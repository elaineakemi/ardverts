import oj from"@babel/runtime/helpers/createSuper";function iF(t,e){for(var n=0;n<e.length;n++){const r=e[n];if(typeof r!="string"&&!Array.isArray(r)){for(const i in r)if(i!=="default"&&!(i in t)){const s=Object.getOwnPropertyDescriptor(r,i);s&&Object.defineProperty(t,i,s.get?s:{enumerable:!0,get:()=>r[i]})}}}return Object.freeze(Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}))}(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const i of document.querySelectorAll('link[rel="modulepreload"]'))r(i);new MutationObserver(i=>{for(const s of i)if(s.type==="childList")for(const o of s.addedNodes)o.tagName==="LINK"&&o.rel==="modulepreload"&&r(o)}).observe(document,{childList:!0,subtree:!0});function n(i){const s={};return i.integrity&&(s.integrity=i.integrity),i.referrerPolicy&&(s.referrerPolicy=i.referrerPolicy),i.crossOrigin==="use-credentials"?s.credentials="include":i.crossOrigin==="anonymous"?s.credentials="omit":s.credentials="same-origin",s}function r(i){if(i.ep)return;i.ep=!0;const s=n(i);fetch(i.href,s)}})();var Pc=typeof globalThis<"u"?globalThis:typeof window<"u"?window:typeof global<"u"?global:typeof self<"u"?self:{};function Ed(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}function Cl(t){if(t.__esModule)return t;var e=t.default;if(typeof e=="function"){var n=function r(){return this instanceof r?Reflect.construct(e,arguments,this.constructor):e.apply(this,arguments)};n.prototype=e.prototype}else n={};return Object.defineProperty(n,"__esModule",{value:!0}),Object.keys(t).forEach(function(r){var i=Object.getOwnPropertyDescriptor(t,r);Object.defineProperty(n,r,i.get?i:{enumerable:!0,get:function(){return t[r]}})}),n}var sF={exports:{}},cb={},oF={exports:{}},Xt={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var c0=Symbol.for("react.element"),aj=Symbol.for("react.portal"),lj=Symbol.for("react.fragment"),cj=Symbol.for("react.strict_mode"),uj=Symbol.for("react.profiler"),dj=Symbol.for("react.provider"),fj=Symbol.for("react.context"),hj=Symbol.for("react.forward_ref"),pj=Symbol.for("react.suspense"),mj=Symbol.for("react.memo"),gj=Symbol.for("react.lazy"),z3=Symbol.iterator;function yj(t){return t===null||typeof t!="object"?null:(t=z3&&t[z3]||t["@@iterator"],typeof t=="function"?t:null)}var aF={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},lF=Object.assign,cF={};function op(t,e,n){this.props=t,this.context=e,this.refs=cF,this.updater=n||aF}op.prototype.isReactComponent={};op.prototype.setState=function(t,e){if(typeof t!="object"&&typeof t!="function"&&t!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,t,e,"setState")};op.prototype.forceUpdate=function(t){this.updater.enqueueForceUpdate(this,t,"forceUpdate")};function uF(){}uF.prototype=op.prototype;function $T(t,e,n){this.props=t,this.context=e,this.refs=cF,this.updater=n||aF}var UT=$T.prototype=new uF;UT.constructor=$T;lF(UT,op.prototype);UT.isPureReactComponent=!0;var G3=Array.isArray,dF=Object.prototype.hasOwnProperty,zT={current:null},fF={key:!0,ref:!0,__self:!0,__source:!0};function hF(t,e,n){var r,i={},s=null,o=null;if(e!=null)for(r in e.ref!==void 0&&(o=e.ref),e.key!==void 0&&(s=""+e.key),e)dF.call(e,r)&&!fF.hasOwnProperty(r)&&(i[r]=e[r]);var a=arguments.length-2;if(a===1)i.children=n;else if(1<a){for(var l=Array(a),c=0;c<a;c++)l[c]=arguments[c+2];i.children=l}if(t&&t.defaultProps)for(r in a=t.defaultProps,a)i[r]===void 0&&(i[r]=a[r]);return{$$typeof:c0,type:t,key:s,ref:o,props:i,_owner:zT.current}}function vj(t,e){return{$$typeof:c0,type:t.type,key:e,ref:t.ref,props:t.props,_owner:t._owner}}function GT(t){return typeof t=="object"&&t!==null&&t.$$typeof===c0}function xj(t){var e={"=":"=0",":":"=2"};return"$"+t.replace(/[=:]/g,function(n){return e[n]})}var H3=/\/+/g;function Tw(t,e){return typeof t=="object"&&t!==null&&t.key!=null?xj(""+t.key):e.toString(36)}function Mx(t,e,n,r,i){var s=typeof t;(s==="undefined"||s==="boolean")&&(t=null);var o=!1;if(t===null)o=!0;else switch(s){case"string":case"number":o=!0;break;case"object":switch(t.$$typeof){case c0:case aj:o=!0}}if(o)return o=t,i=i(o),t=r===""?"."+Tw(o,0):r,G3(i)?(n="",t!=null&&(n=t.replace(H3,"$&/")+"/"),Mx(i,e,n,"",function(c){return c})):i!=null&&(GT(i)&&(i=vj(i,n+(!i.key||o&&o.key===i.key?"":(""+i.key).replace(H3,"$&/")+"/")+t)),e.push(i)),1;if(o=0,r=r===""?".":r+":",G3(t))for(var a=0;a<t.length;a++){s=t[a];var l=r+Tw(s,a);o+=Mx(s,e,n,l,i)}else if(l=yj(t),typeof l=="function")for(t=l.call(t),a=0;!(s=t.next()).done;)s=s.value,l=r+Tw(s,a++),o+=Mx(s,e,n,l,i);else if(s==="object")throw e=String(t),Error("Objects are not valid as a React child (found: "+(e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e)+"). If you meant to render a collection of children, use an array instead.");return o}function Ky(t,e,n){if(t==null)return t;var r=[],i=0;return Mx(t,r,"","",function(s){return e.call(n,s,i++)}),r}function bj(t){if(t._status===-1){var e=t._result;e=e(),e.then(function(n){(t._status===0||t._status===-1)&&(t._status=1,t._result=n)},function(n){(t._status===0||t._status===-1)&&(t._status=2,t._result=n)}),t._status===-1&&(t._status=0,t._result=e)}if(t._status===1)return t._result.default;throw t._result}var $i={current:null},Rx={transition:null},Sj={ReactCurrentDispatcher:$i,ReactCurrentBatchConfig:Rx,ReactCurrentOwner:zT};Xt.Children={map:Ky,forEach:function(t,e,n){Ky(t,function(){e.apply(this,arguments)},n)},count:function(t){var e=0;return Ky(t,function(){e++}),e},toArray:function(t){return Ky(t,function(e){return e})||[]},only:function(t){if(!GT(t))throw Error("React.Children.only expected to receive a single React element child.");return t}};Xt.Component=op;Xt.Fragment=lj;Xt.Profiler=uj;Xt.PureComponent=$T;Xt.StrictMode=cj;Xt.Suspense=pj;Xt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=Sj;Xt.cloneElement=function(t,e,n){if(t==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+t+".");var r=lF({},t.props),i=t.key,s=t.ref,o=t._owner;if(e!=null){if(e.ref!==void 0&&(s=e.ref,o=zT.current),e.key!==void 0&&(i=""+e.key),t.type&&t.type.defaultProps)var a=t.type.defaultProps;for(l in e)dF.call(e,l)&&!fF.hasOwnProperty(l)&&(r[l]=e[l]===void 0&&a!==void 0?a[l]:e[l])}var l=arguments.length-2;if(l===1)r.children=n;else if(1<l){a=Array(l);for(var c=0;c<l;c++)a[c]=arguments[c+2];r.children=a}return{$$typeof:c0,type:t.type,key:i,ref:s,props:r,_owner:o}};Xt.createContext=function(t){return t={$$typeof:fj,_currentValue:t,_currentValue2:t,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},t.Provider={$$typeof:dj,_context:t},t.Consumer=t};Xt.createElement=hF;Xt.createFactory=function(t){var e=hF.bind(null,t);return e.type=t,e};Xt.createRef=function(){return{current:null}};Xt.forwardRef=function(t){return{$$typeof:hj,render:t}};Xt.isValidElement=GT;Xt.lazy=function(t){return{$$typeof:gj,_payload:{_status:-1,_result:t},_init:bj}};Xt.memo=function(t,e){return{$$typeof:mj,type:t,compare:e===void 0?null:e}};Xt.startTransition=function(t){var e=Rx.transition;Rx.transition={};try{t()}finally{Rx.transition=e}};Xt.unstable_act=function(){throw Error("act(...) is not supported in production builds of React.")};Xt.useCallback=function(t,e){return $i.current.useCallback(t,e)};Xt.useContext=function(t){return $i.current.useContext(t)};Xt.useDebugValue=function(){};Xt.useDeferredValue=function(t){return $i.current.useDeferredValue(t)};Xt.useEffect=function(t,e){return $i.current.useEffect(t,e)};Xt.useId=function(){return $i.current.useId()};Xt.useImperativeHandle=function(t,e,n){return $i.current.useImperativeHandle(t,e,n)};Xt.useInsertionEffect=function(t,e){return $i.current.useInsertionEffect(t,e)};Xt.useLayoutEffect=function(t,e){return $i.current.useLayoutEffect(t,e)};Xt.useMemo=function(t,e){return $i.current.useMemo(t,e)};Xt.useReducer=function(t,e,n){return $i.current.useReducer(t,e,n)};Xt.useRef=function(t){return $i.current.useRef(t)};Xt.useState=function(t){return $i.current.useState(t)};Xt.useSyncExternalStore=function(t,e,n){return $i.current.useSyncExternalStore(t,e,n)};Xt.useTransition=function(){return $i.current.useTransition()};Xt.version="18.2.0";oF.exports=Xt;var L=oF.exports;const Go=Ed(L),o1=iF({__proto__:null,default:Go},[L]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var _j=L,wj=Symbol.for("react.element"),Cj=Symbol.for("react.fragment"),Ej=Object.prototype.hasOwnProperty,Aj=_j.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,Tj={key:!0,ref:!0,__self:!0,__source:!0};function pF(t,e,n){var r,i={},s=null,o=null;n!==void 0&&(s=""+n),e.key!==void 0&&(s=""+e.key),e.ref!==void 0&&(o=e.ref);for(r in e)Ej.call(e,r)&&!Tj.hasOwnProperty(r)&&(i[r]=e[r]);if(t&&t.defaultProps)for(r in e=t.defaultProps,e)i[r]===void 0&&(i[r]=e[r]);return{$$typeof:wj,type:t,key:s,ref:o,props:i,_owner:Aj.current}}cb.Fragment=Cj;cb.jsx=pF;cb.jsxs=pF;sF.exports=cb;var H=sF.exports,jE={},mF={exports:{}},Ps={},gF={exports:{}},yF={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(t){function e(O,G){var q=O.length;O.push(G);e:for(;0<q;){var se=q-1>>>1,he=O[se];if(0<i(he,G))O[se]=G,O[q]=he,q=se;else break e}}function n(O){return O.length===0?null:O[0]}function r(O){if(O.length===0)return null;var G=O[0],q=O.pop();if(q!==G){O[0]=q;e:for(var se=0,he=O.length,ke=he>>>1;se<ke;){var re=2*(se+1)-1,pe=O[re],fe=re+1,Ee=O[fe];if(0>i(pe,q))fe<he&&0>i(Ee,pe)?(O[se]=Ee,O[fe]=q,se=fe):(O[se]=pe,O[re]=q,se=re);else if(fe<he&&0>i(Ee,q))O[se]=Ee,O[fe]=q,se=fe;else break e}}return G}function i(O,G){var q=O.sortIndex-G.sortIndex;return q!==0?q:O.id-G.id}if(typeof performance=="object"&&typeof performance.now=="function"){var s=performance;t.unstable_now=function(){return s.now()}}else{var o=Date,a=o.now();t.unstable_now=function(){return o.now()-a}}var l=[],c=[],u=1,d=null,f=3,h=!1,p=!1,x=!1,v=typeof setTimeout=="function"?setTimeout:null,y=typeof clearTimeout=="function"?clearTimeout:null,b=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function S(O){for(var G=n(c);G!==null;){if(G.callback===null)r(c);else if(G.startTime<=O)r(c),G.sortIndex=G.expirationTime,e(l,G);else break;G=n(c)}}function w(O){if(x=!1,S(O),!p)if(n(l)!==null)p=!0,Z(E);else{var G=n(c);G!==null&&ne(w,G.startTime-O)}}function E(O,G){p=!1,x&&(x=!1,y(I),I=-1),h=!0;var q=f;try{for(S(G),d=n(l);d!==null&&(!(d.expirationTime>G)||O&&!P());){var se=d.callback;if(typeof se=="function"){d.callback=null,f=d.priorityLevel;var he=se(d.expirationTime<=G);G=t.unstable_now(),typeof he=="function"?d.callback=he:d===n(l)&&r(l),S(G)}else r(l);d=n(l)}if(d!==null)var ke=!0;else{var re=n(c);re!==null&&ne(w,re.startTime-G),ke=!1}return ke}finally{d=null,f=q,h=!1}}var A=!1,T=null,I=-1,N=5,M=-1;function P(){return!(t.unstable_now()-M<N)}function B(){if(T!==null){var O=t.unstable_now();M=O;var G=!0;try{G=T(!0,O)}finally{G?F():(A=!1,T=null)}}else A=!1}var F;if(typeof b=="function")F=function(){b(B)};else if(typeof MessageChannel<"u"){var U=new MessageChannel,j=U.port2;U.port1.onmessage=B,F=function(){j.postMessage(null)}}else F=function(){v(B,0)};function Z(O){T=O,A||(A=!0,F())}function ne(O,G){I=v(function(){O(t.unstable_now())},G)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(O){O.callback=null},t.unstable_continueExecution=function(){p||h||(p=!0,Z(E))},t.unstable_forceFrameRate=function(O){0>O||125<O?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):N=0<O?Math.floor(1e3/O):5},t.unstable_getCurrentPriorityLevel=function(){return f},t.unstable_getFirstCallbackNode=function(){return n(l)},t.unstable_next=function(O){switch(f){case 1:case 2:case 3:var G=3;break;default:G=f}var q=f;f=G;try{return O()}finally{f=q}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(O,G){switch(O){case 1:case 2:case 3:case 4:case 5:break;default:O=3}var q=f;f=O;try{return G()}finally{f=q}},t.unstable_scheduleCallback=function(O,G,q){var se=t.unstable_now();switch(typeof q=="object"&&q!==null?(q=q.delay,q=typeof q=="number"&&0<q?se+q:se):q=se,O){case 1:var he=-1;break;case 2:he=250;break;case 5:he=1073741823;break;case 4:he=1e4;break;default:he=5e3}return he=q+he,O={id:u++,callback:G,priorityLevel:O,startTime:q,expirationTime:he,sortIndex:-1},q>se?(O.sortIndex=q,e(c,O),n(l)===null&&O===n(c)&&(x?(y(I),I=-1):x=!0,ne(w,q-se))):(O.sortIndex=he,e(l,O),p||h||(p=!0,Z(E))),O},t.unstable_shouldYield=P,t.unstable_wrapCallback=function(O){var G=f;return function(){var q=f;f=G;try{return O.apply(this,arguments)}finally{f=q}}}})(yF);gF.exports=yF;var Mj=gF.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var vF=L,Rs=Mj;function ze(t){for(var e="https://reactjs.org/docs/error-decoder.html?invariant="+t,n=1;n<arguments.length;n++)e+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+t+"; visit "+e+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var xF=new Set,ug={};function Ad(t,e){Mh(t,e),Mh(t+"Capture",e)}function Mh(t,e){for(ug[t]=e,t=0;t<e.length;t++)xF.add(e[t])}var ml=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),XE=Object.prototype.hasOwnProperty,Rj=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,V3={},W3={};function Ij(t){return XE.call(W3,t)?!0:XE.call(V3,t)?!1:Rj.test(t)?W3[t]=!0:(V3[t]=!0,!1)}function Nj(t,e,n,r){if(n!==null&&n.type===0)return!1;switch(typeof e){case"function":case"symbol":return!0;case"boolean":return r?!1:n!==null?!n.acceptsBooleans:(t=t.toLowerCase().slice(0,5),t!=="data-"&&t!=="aria-");default:return!1}}function Pj(t,e,n,r){if(e===null||typeof e>"u"||Nj(t,e,n,r))return!0;if(r)return!1;if(n!==null)switch(n.type){case 3:return!e;case 4:return e===!1;case 5:return isNaN(e);case 6:return isNaN(e)||1>e}return!1}function Ui(t,e,n,r,i,s,o){this.acceptsBooleans=e===2||e===3||e===4,this.attributeName=r,this.attributeNamespace=i,this.mustUseProperty=n,this.propertyName=t,this.type=e,this.sanitizeURL=s,this.removeEmptyString=o}var ei={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t){ei[t]=new Ui(t,0,!1,t,null,!1,!1)});[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(t){var e=t[0];ei[e]=new Ui(e,1,!1,t[1],null,!1,!1)});["contentEditable","draggable","spellCheck","value"].forEach(function(t){ei[t]=new Ui(t,2,!1,t.toLowerCase(),null,!1,!1)});["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(t){ei[t]=new Ui(t,2,!1,t,null,!1,!1)});"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t){ei[t]=new Ui(t,3,!1,t.toLowerCase(),null,!1,!1)});["checked","multiple","muted","selected"].forEach(function(t){ei[t]=new Ui(t,3,!0,t,null,!1,!1)});["capture","download"].forEach(function(t){ei[t]=new Ui(t,4,!1,t,null,!1,!1)});["cols","rows","size","span"].forEach(function(t){ei[t]=new Ui(t,6,!1,t,null,!1,!1)});["rowSpan","start"].forEach(function(t){ei[t]=new Ui(t,5,!1,t.toLowerCase(),null,!1,!1)});var HT=/[\-:]([a-z])/g;function VT(t){return t[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t){var e=t.replace(HT,VT);ei[e]=new Ui(e,1,!1,t,null,!1,!1)});"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t){var e=t.replace(HT,VT);ei[e]=new Ui(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)});["xml:base","xml:lang","xml:space"].forEach(function(t){var e=t.replace(HT,VT);ei[e]=new Ui(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)});["tabIndex","crossOrigin"].forEach(function(t){ei[t]=new Ui(t,1,!1,t.toLowerCase(),null,!1,!1)});ei.xlinkHref=new Ui("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);["src","href","action","formAction"].forEach(function(t){ei[t]=new Ui(t,1,!1,t.toLowerCase(),null,!0,!0)});function WT(t,e,n,r){var i=ei.hasOwnProperty(e)?ei[e]:null;(i!==null?i.type!==0:r||!(2<e.length)||e[0]!=="o"&&e[0]!=="O"||e[1]!=="n"&&e[1]!=="N")&&(Pj(e,n,i,r)&&(n=null),r||i===null?Ij(e)&&(n===null?t.removeAttribute(e):t.setAttribute(e,""+n)):i.mustUseProperty?t[i.propertyName]=n===null?i.type===3?!1:"":n:(e=i.attributeName,r=i.attributeNamespace,n===null?t.removeAttribute(e):(i=i.type,n=i===3||i===4&&n===!0?"":""+n,r?t.setAttributeNS(r,e,n):t.setAttribute(e,n))))}var El=vF.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,qy=Symbol.for("react.element"),jf=Symbol.for("react.portal"),Xf=Symbol.for("react.fragment"),jT=Symbol.for("react.strict_mode"),KE=Symbol.for("react.profiler"),bF=Symbol.for("react.provider"),SF=Symbol.for("react.context"),XT=Symbol.for("react.forward_ref"),qE=Symbol.for("react.suspense"),JE=Symbol.for("react.suspense_list"),KT=Symbol.for("react.memo"),ec=Symbol.for("react.lazy"),_F=Symbol.for("react.offscreen"),j3=Symbol.iterator;function Qp(t){return t===null||typeof t!="object"?null:(t=j3&&t[j3]||t["@@iterator"],typeof t=="function"?t:null)}var Jn=Object.assign,Mw;function Dm(t){if(Mw===void 0)try{throw Error()}catch(n){var e=n.stack.trim().match(/\n( *(at )?)/);Mw=e&&e[1]||""}return`
`+Mw+t}var Rw=!1;function Iw(t,e){if(!t||Rw)return"";Rw=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(e)if(e=function(){throw Error()},Object.defineProperty(e.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(e,[])}catch(c){var r=c}Reflect.construct(t,[],e)}else{try{e.call()}catch(c){r=c}t.call(e.prototype)}else{try{throw Error()}catch(c){r=c}t()}}catch(c){if(c&&r&&typeof c.stack=="string"){for(var i=c.stack.split(`
`),s=r.stack.split(`
`),o=i.length-1,a=s.length-1;1<=o&&0<=a&&i[o]!==s[a];)a--;for(;1<=o&&0<=a;o--,a--)if(i[o]!==s[a]){if(o!==1||a!==1)do if(o--,a--,0>a||i[o]!==s[a]){var l=`
`+i[o].replace(" at new "," at ");return t.displayName&&l.includes("<anonymous>")&&(l=l.replace("<anonymous>",t.displayName)),l}while(1<=o&&0<=a);break}}}finally{Rw=!1,Error.prepareStackTrace=n}return(t=t?t.displayName||t.name:"")?Dm(t):""}function kj(t){switch(t.tag){case 5:return Dm(t.type);case 16:return Dm("Lazy");case 13:return Dm("Suspense");case 19:return Dm("SuspenseList");case 0:case 2:case 15:return t=Iw(t.type,!1),t;case 11:return t=Iw(t.type.render,!1),t;case 1:return t=Iw(t.type,!0),t;default:return""}}function YE(t){if(t==null)return null;if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t;switch(t){case Xf:return"Fragment";case jf:return"Portal";case KE:return"Profiler";case jT:return"StrictMode";case qE:return"Suspense";case JE:return"SuspenseList"}if(typeof t=="object")switch(t.$$typeof){case SF:return(t.displayName||"Context")+".Consumer";case bF:return(t._context.displayName||"Context")+".Provider";case XT:var e=t.render;return t=t.displayName,t||(t=e.displayName||e.name||"",t=t!==""?"ForwardRef("+t+")":"ForwardRef"),t;case KT:return e=t.displayName||null,e!==null?e:YE(t.type)||"Memo";case ec:e=t._payload,t=t._init;try{return YE(t(e))}catch{}}return null}function Dj(t){var e=t.type;switch(t.tag){case 24:return"Cache";case 9:return(e.displayName||"Context")+".Consumer";case 10:return(e._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return t=e.render,t=t.displayName||t.name||"",e.displayName||(t!==""?"ForwardRef("+t+")":"ForwardRef");case 7:return"Fragment";case 5:return e;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return YE(e);case 8:return e===jT?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e}return null}function wc(t){switch(typeof t){case"boolean":case"number":case"string":case"undefined":return t;case"object":return t;default:return""}}function wF(t){var e=t.type;return(t=t.nodeName)&&t.toLowerCase()==="input"&&(e==="checkbox"||e==="radio")}function Oj(t){var e=wF(t)?"checked":"value",n=Object.getOwnPropertyDescriptor(t.constructor.prototype,e),r=""+t[e];if(!t.hasOwnProperty(e)&&typeof n<"u"&&typeof n.get=="function"&&typeof n.set=="function"){var i=n.get,s=n.set;return Object.defineProperty(t,e,{configurable:!0,get:function(){return i.call(this)},set:function(o){r=""+o,s.call(this,o)}}),Object.defineProperty(t,e,{enumerable:n.enumerable}),{getValue:function(){return r},setValue:function(o){r=""+o},stopTracking:function(){t._valueTracker=null,delete t[e]}}}}function Jy(t){t._valueTracker||(t._valueTracker=Oj(t))}function CF(t){if(!t)return!1;var e=t._valueTracker;if(!e)return!0;var n=e.getValue(),r="";return t&&(r=wF(t)?t.checked?"true":"false":t.value),t=r,t!==n?(e.setValue(t),!0):!1}function a1(t){if(t=t||(typeof document<"u"?document:void 0),typeof t>"u")return null;try{return t.activeElement||t.body}catch{return t.body}}function QE(t,e){var n=e.checked;return Jn({},e,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:n??t._wrapperState.initialChecked})}function X3(t,e){var n=e.defaultValue==null?"":e.defaultValue,r=e.checked!=null?e.checked:e.defaultChecked;n=wc(e.value!=null?e.value:n),t._wrapperState={initialChecked:r,initialValue:n,controlled:e.type==="checkbox"||e.type==="radio"?e.checked!=null:e.value!=null}}function EF(t,e){e=e.checked,e!=null&&WT(t,"checked",e,!1)}function ZE(t,e){EF(t,e);var n=wc(e.value),r=e.type;if(n!=null)r==="number"?(n===0&&t.value===""||t.value!=n)&&(t.value=""+n):t.value!==""+n&&(t.value=""+n);else if(r==="submit"||r==="reset"){t.removeAttribute("value");return}e.hasOwnProperty("value")?eA(t,e.type,n):e.hasOwnProperty("defaultValue")&&eA(t,e.type,wc(e.defaultValue)),e.checked==null&&e.defaultChecked!=null&&(t.defaultChecked=!!e.defaultChecked)}function K3(t,e,n){if(e.hasOwnProperty("value")||e.hasOwnProperty("defaultValue")){var r=e.type;if(!(r!=="submit"&&r!=="reset"||e.value!==void 0&&e.value!==null))return;e=""+t._wrapperState.initialValue,n||e===t.value||(t.value=e),t.defaultValue=e}n=t.name,n!==""&&(t.name=""),t.defaultChecked=!!t._wrapperState.initialChecked,n!==""&&(t.name=n)}function eA(t,e,n){(e!=="number"||a1(t.ownerDocument)!==t)&&(n==null?t.defaultValue=""+t._wrapperState.initialValue:t.defaultValue!==""+n&&(t.defaultValue=""+n))}var Om=Array.isArray;function dh(t,e,n,r){if(t=t.options,e){e={};for(var i=0;i<n.length;i++)e["$"+n[i]]=!0;for(n=0;n<t.length;n++)i=e.hasOwnProperty("$"+t[n].value),t[n].selected!==i&&(t[n].selected=i),i&&r&&(t[n].defaultSelected=!0)}else{for(n=""+wc(n),e=null,i=0;i<t.length;i++){if(t[i].value===n){t[i].selected=!0,r&&(t[i].defaultSelected=!0);return}e!==null||t[i].disabled||(e=t[i])}e!==null&&(e.selected=!0)}}function tA(t,e){if(e.dangerouslySetInnerHTML!=null)throw Error(ze(91));return Jn({},e,{value:void 0,defaultValue:void 0,children:""+t._wrapperState.initialValue})}function q3(t,e){var n=e.value;if(n==null){if(n=e.children,e=e.defaultValue,n!=null){if(e!=null)throw Error(ze(92));if(Om(n)){if(1<n.length)throw Error(ze(93));n=n[0]}e=n}e==null&&(e=""),n=e}t._wrapperState={initialValue:wc(n)}}function AF(t,e){var n=wc(e.value),r=wc(e.defaultValue);n!=null&&(n=""+n,n!==t.value&&(t.value=n),e.defaultValue==null&&t.defaultValue!==n&&(t.defaultValue=n)),r!=null&&(t.defaultValue=""+r)}function J3(t){var e=t.textContent;e===t._wrapperState.initialValue&&e!==""&&e!==null&&(t.value=e)}function TF(t){switch(t){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function nA(t,e){return t==null||t==="http://www.w3.org/1999/xhtml"?TF(e):t==="http://www.w3.org/2000/svg"&&e==="foreignObject"?"http://www.w3.org/1999/xhtml":t}var Yy,MF=function(t){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(e,n,r,i){MSApp.execUnsafeLocalFunction(function(){return t(e,n,r,i)})}:t}(function(t,e){if(t.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in t)t.innerHTML=e;else{for(Yy=Yy||document.createElement("div"),Yy.innerHTML="<svg>"+e.valueOf().toString()+"</svg>",e=Yy.firstChild;t.firstChild;)t.removeChild(t.firstChild);for(;e.firstChild;)t.appendChild(e.firstChild)}});function dg(t,e){if(e){var n=t.firstChild;if(n&&n===t.lastChild&&n.nodeType===3){n.nodeValue=e;return}}t.textContent=e}var jm={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},Lj=["Webkit","ms","Moz","O"];Object.keys(jm).forEach(function(t){Lj.forEach(function(e){e=e+t.charAt(0).toUpperCase()+t.substring(1),jm[e]=jm[t]})});function RF(t,e,n){return e==null||typeof e=="boolean"||e===""?"":n||typeof e!="number"||e===0||jm.hasOwnProperty(t)&&jm[t]?(""+e).trim():e+"px"}function IF(t,e){t=t.style;for(var n in e)if(e.hasOwnProperty(n)){var r=n.indexOf("--")===0,i=RF(n,e[n],r);n==="float"&&(n="cssFloat"),r?t.setProperty(n,i):t[n]=i}}var Bj=Jn({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function rA(t,e){if(e){if(Bj[t]&&(e.children!=null||e.dangerouslySetInnerHTML!=null))throw Error(ze(137,t));if(e.dangerouslySetInnerHTML!=null){if(e.children!=null)throw Error(ze(60));if(typeof e.dangerouslySetInnerHTML!="object"||!("__html"in e.dangerouslySetInnerHTML))throw Error(ze(61))}if(e.style!=null&&typeof e.style!="object")throw Error(ze(62))}}function iA(t,e){if(t.indexOf("-")===-1)return typeof e.is=="string";switch(t){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var sA=null;function qT(t){return t=t.target||t.srcElement||window,t.correspondingUseElement&&(t=t.correspondingUseElement),t.nodeType===3?t.parentNode:t}var oA=null,fh=null,hh=null;function Y3(t){if(t=f0(t)){if(typeof oA!="function")throw Error(ze(280));var e=t.stateNode;e&&(e=pb(e),oA(t.stateNode,t.type,e))}}function NF(t){fh?hh?hh.push(t):hh=[t]:fh=t}function PF(){if(fh){var t=fh,e=hh;if(hh=fh=null,Y3(t),e)for(t=0;t<e.length;t++)Y3(e[t])}}function kF(t,e){return t(e)}function DF(){}var Nw=!1;function OF(t,e,n){if(Nw)return t(e,n);Nw=!0;try{return kF(t,e,n)}finally{Nw=!1,(fh!==null||hh!==null)&&(DF(),PF())}}function fg(t,e){var n=t.stateNode;if(n===null)return null;var r=pb(n);if(r===null)return null;n=r[e];e:switch(e){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(r=!r.disabled)||(t=t.type,r=!(t==="button"||t==="input"||t==="select"||t==="textarea")),t=!r;break e;default:t=!1}if(t)return null;if(n&&typeof n!="function")throw Error(ze(231,e,typeof n));return n}var aA=!1;if(ml)try{var Zp={};Object.defineProperty(Zp,"passive",{get:function(){aA=!0}}),window.addEventListener("test",Zp,Zp),window.removeEventListener("test",Zp,Zp)}catch{aA=!1}function Fj(t,e,n,r,i,s,o,a,l){var c=Array.prototype.slice.call(arguments,3);try{e.apply(n,c)}catch(u){this.onError(u)}}var Xm=!1,l1=null,c1=!1,lA=null,$j={onError:function(t){Xm=!0,l1=t}};function Uj(t,e,n,r,i,s,o,a,l){Xm=!1,l1=null,Fj.apply($j,arguments)}function zj(t,e,n,r,i,s,o,a,l){if(Uj.apply(this,arguments),Xm){if(Xm){var c=l1;Xm=!1,l1=null}else throw Error(ze(198));c1||(c1=!0,lA=c)}}function Td(t){var e=t,n=t;if(t.alternate)for(;e.return;)e=e.return;else{t=e;do e=t,e.flags&4098&&(n=e.return),t=e.return;while(t)}return e.tag===3?n:null}function LF(t){if(t.tag===13){var e=t.memoizedState;if(e===null&&(t=t.alternate,t!==null&&(e=t.memoizedState)),e!==null)return e.dehydrated}return null}function Q3(t){if(Td(t)!==t)throw Error(ze(188))}function Gj(t){var e=t.alternate;if(!e){if(e=Td(t),e===null)throw Error(ze(188));return e!==t?null:t}for(var n=t,r=e;;){var i=n.return;if(i===null)break;var s=i.alternate;if(s===null){if(r=i.return,r!==null){n=r;continue}break}if(i.child===s.child){for(s=i.child;s;){if(s===n)return Q3(i),t;if(s===r)return Q3(i),e;s=s.sibling}throw Error(ze(188))}if(n.return!==r.return)n=i,r=s;else{for(var o=!1,a=i.child;a;){if(a===n){o=!0,n=i,r=s;break}if(a===r){o=!0,r=i,n=s;break}a=a.sibling}if(!o){for(a=s.child;a;){if(a===n){o=!0,n=s,r=i;break}if(a===r){o=!0,r=s,n=i;break}a=a.sibling}if(!o)throw Error(ze(189))}}if(n.alternate!==r)throw Error(ze(190))}if(n.tag!==3)throw Error(ze(188));return n.stateNode.current===n?t:e}function BF(t){return t=Gj(t),t!==null?FF(t):null}function FF(t){if(t.tag===5||t.tag===6)return t;for(t=t.child;t!==null;){var e=FF(t);if(e!==null)return e;t=t.sibling}return null}var $F=Rs.unstable_scheduleCallback,Z3=Rs.unstable_cancelCallback,Hj=Rs.unstable_shouldYield,Vj=Rs.unstable_requestPaint,fr=Rs.unstable_now,Wj=Rs.unstable_getCurrentPriorityLevel,JT=Rs.unstable_ImmediatePriority,UF=Rs.unstable_UserBlockingPriority,u1=Rs.unstable_NormalPriority,jj=Rs.unstable_LowPriority,zF=Rs.unstable_IdlePriority,ub=null,Sa=null;function Xj(t){if(Sa&&typeof Sa.onCommitFiberRoot=="function")try{Sa.onCommitFiberRoot(ub,t,void 0,(t.current.flags&128)===128)}catch{}}var Vo=Math.clz32?Math.clz32:Jj,Kj=Math.log,qj=Math.LN2;function Jj(t){return t>>>=0,t===0?32:31-(Kj(t)/qj|0)|0}var Qy=64,Zy=4194304;function Lm(t){switch(t&-t){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return t&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return t}}function d1(t,e){var n=t.pendingLanes;if(n===0)return 0;var r=0,i=t.suspendedLanes,s=t.pingedLanes,o=n&268435455;if(o!==0){var a=o&~i;a!==0?r=Lm(a):(s&=o,s!==0&&(r=Lm(s)))}else o=n&~i,o!==0?r=Lm(o):s!==0&&(r=Lm(s));if(r===0)return 0;if(e!==0&&e!==r&&!(e&i)&&(i=r&-r,s=e&-e,i>=s||i===16&&(s&4194240)!==0))return e;if(r&4&&(r|=n&16),e=t.entangledLanes,e!==0)for(t=t.entanglements,e&=r;0<e;)n=31-Vo(e),i=1<<n,r|=t[n],e&=~i;return r}function Yj(t,e){switch(t){case 1:case 2:case 4:return e+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Qj(t,e){for(var n=t.suspendedLanes,r=t.pingedLanes,i=t.expirationTimes,s=t.pendingLanes;0<s;){var o=31-Vo(s),a=1<<o,l=i[o];l===-1?(!(a&n)||a&r)&&(i[o]=Yj(a,e)):l<=e&&(t.expiredLanes|=a),s&=~a}}function cA(t){return t=t.pendingLanes&-1073741825,t!==0?t:t&1073741824?1073741824:0}function GF(){var t=Qy;return Qy<<=1,!(Qy&4194240)&&(Qy=64),t}function Pw(t){for(var e=[],n=0;31>n;n++)e.push(t);return e}function u0(t,e,n){t.pendingLanes|=e,e!==536870912&&(t.suspendedLanes=0,t.pingedLanes=0),t=t.eventTimes,e=31-Vo(e),t[e]=n}function Zj(t,e){var n=t.pendingLanes&~e;t.pendingLanes=e,t.suspendedLanes=0,t.pingedLanes=0,t.expiredLanes&=e,t.mutableReadLanes&=e,t.entangledLanes&=e,e=t.entanglements;var r=t.eventTimes;for(t=t.expirationTimes;0<n;){var i=31-Vo(n),s=1<<i;e[i]=0,r[i]=-1,t[i]=-1,n&=~s}}function YT(t,e){var n=t.entangledLanes|=e;for(t=t.entanglements;n;){var r=31-Vo(n),i=1<<r;i&e|t[r]&e&&(t[r]|=e),n&=~i}}var xn=0;function HF(t){return t&=-t,1<t?4<t?t&268435455?16:536870912:4:1}var VF,QT,WF,jF,XF,uA=!1,ev=[],dc=null,fc=null,hc=null,hg=new Map,pg=new Map,rc=[],eX="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function eP(t,e){switch(t){case"focusin":case"focusout":dc=null;break;case"dragenter":case"dragleave":fc=null;break;case"mouseover":case"mouseout":hc=null;break;case"pointerover":case"pointerout":hg.delete(e.pointerId);break;case"gotpointercapture":case"lostpointercapture":pg.delete(e.pointerId)}}function em(t,e,n,r,i,s){return t===null||t.nativeEvent!==s?(t={blockedOn:e,domEventName:n,eventSystemFlags:r,nativeEvent:s,targetContainers:[i]},e!==null&&(e=f0(e),e!==null&&QT(e)),t):(t.eventSystemFlags|=r,e=t.targetContainers,i!==null&&e.indexOf(i)===-1&&e.push(i),t)}function tX(t,e,n,r,i){switch(e){case"focusin":return dc=em(dc,t,e,n,r,i),!0;case"dragenter":return fc=em(fc,t,e,n,r,i),!0;case"mouseover":return hc=em(hc,t,e,n,r,i),!0;case"pointerover":var s=i.pointerId;return hg.set(s,em(hg.get(s)||null,t,e,n,r,i)),!0;case"gotpointercapture":return s=i.pointerId,pg.set(s,em(pg.get(s)||null,t,e,n,r,i)),!0}return!1}function KF(t){var e=Ru(t.target);if(e!==null){var n=Td(e);if(n!==null){if(e=n.tag,e===13){if(e=LF(n),e!==null){t.blockedOn=e,XF(t.priority,function(){WF(n)});return}}else if(e===3&&n.stateNode.current.memoizedState.isDehydrated){t.blockedOn=n.tag===3?n.stateNode.containerInfo:null;return}}}t.blockedOn=null}function Ix(t){if(t.blockedOn!==null)return!1;for(var e=t.targetContainers;0<e.length;){var n=dA(t.domEventName,t.eventSystemFlags,e[0],t.nativeEvent);if(n===null){n=t.nativeEvent;var r=new n.constructor(n.type,n);sA=r,n.target.dispatchEvent(r),sA=null}else return e=f0(n),e!==null&&QT(e),t.blockedOn=n,!1;e.shift()}return!0}function tP(t,e,n){Ix(t)&&n.delete(e)}function nX(){uA=!1,dc!==null&&Ix(dc)&&(dc=null),fc!==null&&Ix(fc)&&(fc=null),hc!==null&&Ix(hc)&&(hc=null),hg.forEach(tP),pg.forEach(tP)}function tm(t,e){t.blockedOn===e&&(t.blockedOn=null,uA||(uA=!0,Rs.unstable_scheduleCallback(Rs.unstable_NormalPriority,nX)))}function mg(t){function e(i){return tm(i,t)}if(0<ev.length){tm(ev[0],t);for(var n=1;n<ev.length;n++){var r=ev[n];r.blockedOn===t&&(r.blockedOn=null)}}for(dc!==null&&tm(dc,t),fc!==null&&tm(fc,t),hc!==null&&tm(hc,t),hg.forEach(e),pg.forEach(e),n=0;n<rc.length;n++)r=rc[n],r.blockedOn===t&&(r.blockedOn=null);for(;0<rc.length&&(n=rc[0],n.blockedOn===null);)KF(n),n.blockedOn===null&&rc.shift()}var ph=El.ReactCurrentBatchConfig,f1=!0;function rX(t,e,n,r){var i=xn,s=ph.transition;ph.transition=null;try{xn=1,ZT(t,e,n,r)}finally{xn=i,ph.transition=s}}function iX(t,e,n,r){var i=xn,s=ph.transition;ph.transition=null;try{xn=4,ZT(t,e,n,r)}finally{xn=i,ph.transition=s}}function ZT(t,e,n,r){if(f1){var i=dA(t,e,n,r);if(i===null)Gw(t,e,r,h1,n),eP(t,r);else if(tX(i,t,e,n,r))r.stopPropagation();else if(eP(t,r),e&4&&-1<eX.indexOf(t)){for(;i!==null;){var s=f0(i);if(s!==null&&VF(s),s=dA(t,e,n,r),s===null&&Gw(t,e,r,h1,n),s===i)break;i=s}i!==null&&r.stopPropagation()}else Gw(t,e,r,null,n)}}var h1=null;function dA(t,e,n,r){if(h1=null,t=qT(r),t=Ru(t),t!==null)if(e=Td(t),e===null)t=null;else if(n=e.tag,n===13){if(t=LF(e),t!==null)return t;t=null}else if(n===3){if(e.stateNode.current.memoizedState.isDehydrated)return e.tag===3?e.stateNode.containerInfo:null;t=null}else e!==t&&(t=null);return h1=t,null}function qF(t){switch(t){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Wj()){case JT:return 1;case UF:return 4;case u1:case jj:return 16;case zF:return 536870912;default:return 16}default:return 16}}var oc=null,eM=null,Nx=null;function JF(){if(Nx)return Nx;var t,e=eM,n=e.length,r,i="value"in oc?oc.value:oc.textContent,s=i.length;for(t=0;t<n&&e[t]===i[t];t++);var o=n-t;for(r=1;r<=o&&e[n-r]===i[s-r];r++);return Nx=i.slice(t,1<r?1-r:void 0)}function Px(t){var e=t.keyCode;return"charCode"in t?(t=t.charCode,t===0&&e===13&&(t=13)):t=e,t===10&&(t=13),32<=t||t===13?t:0}function tv(){return!0}function nP(){return!1}function ks(t){function e(n,r,i,s,o){this._reactName=n,this._targetInst=i,this.type=r,this.nativeEvent=s,this.target=o,this.currentTarget=null;for(var a in t)t.hasOwnProperty(a)&&(n=t[a],this[a]=n?n(s):s[a]);return this.isDefaultPrevented=(s.defaultPrevented!=null?s.defaultPrevented:s.returnValue===!1)?tv:nP,this.isPropagationStopped=nP,this}return Jn(e.prototype,{preventDefault:function(){this.defaultPrevented=!0;var n=this.nativeEvent;n&&(n.preventDefault?n.preventDefault():typeof n.returnValue!="unknown"&&(n.returnValue=!1),this.isDefaultPrevented=tv)},stopPropagation:function(){var n=this.nativeEvent;n&&(n.stopPropagation?n.stopPropagation():typeof n.cancelBubble!="unknown"&&(n.cancelBubble=!0),this.isPropagationStopped=tv)},persist:function(){},isPersistent:tv}),e}var ap={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(t){return t.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},tM=ks(ap),d0=Jn({},ap,{view:0,detail:0}),sX=ks(d0),kw,Dw,nm,db=Jn({},d0,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:nM,button:0,buttons:0,relatedTarget:function(t){return t.relatedTarget===void 0?t.fromElement===t.srcElement?t.toElement:t.fromElement:t.relatedTarget},movementX:function(t){return"movementX"in t?t.movementX:(t!==nm&&(nm&&t.type==="mousemove"?(kw=t.screenX-nm.screenX,Dw=t.screenY-nm.screenY):Dw=kw=0,nm=t),kw)},movementY:function(t){return"movementY"in t?t.movementY:Dw}}),rP=ks(db),oX=Jn({},db,{dataTransfer:0}),aX=ks(oX),lX=Jn({},d0,{relatedTarget:0}),Ow=ks(lX),cX=Jn({},ap,{animationName:0,elapsedTime:0,pseudoElement:0}),uX=ks(cX),dX=Jn({},ap,{clipboardData:function(t){return"clipboardData"in t?t.clipboardData:window.clipboardData}}),fX=ks(dX),hX=Jn({},ap,{data:0}),iP=ks(hX),pX={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},mX={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},gX={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function yX(t){var e=this.nativeEvent;return e.getModifierState?e.getModifierState(t):(t=gX[t])?!!e[t]:!1}function nM(){return yX}var vX=Jn({},d0,{key:function(t){if(t.key){var e=pX[t.key]||t.key;if(e!=="Unidentified")return e}return t.type==="keypress"?(t=Px(t),t===13?"Enter":String.fromCharCode(t)):t.type==="keydown"||t.type==="keyup"?mX[t.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:nM,charCode:function(t){return t.type==="keypress"?Px(t):0},keyCode:function(t){return t.type==="keydown"||t.type==="keyup"?t.keyCode:0},which:function(t){return t.type==="keypress"?Px(t):t.type==="keydown"||t.type==="keyup"?t.keyCode:0}}),xX=ks(vX),bX=Jn({},db,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),sP=ks(bX),SX=Jn({},d0,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:nM}),_X=ks(SX),wX=Jn({},ap,{propertyName:0,elapsedTime:0,pseudoElement:0}),CX=ks(wX),EX=Jn({},db,{deltaX:function(t){return"deltaX"in t?t.deltaX:"wheelDeltaX"in t?-t.wheelDeltaX:0},deltaY:function(t){return"deltaY"in t?t.deltaY:"wheelDeltaY"in t?-t.wheelDeltaY:"wheelDelta"in t?-t.wheelDelta:0},deltaZ:0,deltaMode:0}),AX=ks(EX),TX=[9,13,27,32],rM=ml&&"CompositionEvent"in window,Km=null;ml&&"documentMode"in document&&(Km=document.documentMode);var MX=ml&&"TextEvent"in window&&!Km,YF=ml&&(!rM||Km&&8<Km&&11>=Km),oP=" ",aP=!1;function QF(t,e){switch(t){case"keyup":return TX.indexOf(e.keyCode)!==-1;case"keydown":return e.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function ZF(t){return t=t.detail,typeof t=="object"&&"data"in t?t.data:null}var Kf=!1;function RX(t,e){switch(t){case"compositionend":return ZF(e);case"keypress":return e.which!==32?null:(aP=!0,oP);case"textInput":return t=e.data,t===oP&&aP?null:t;default:return null}}function IX(t,e){if(Kf)return t==="compositionend"||!rM&&QF(t,e)?(t=JF(),Nx=eM=oc=null,Kf=!1,t):null;switch(t){case"paste":return null;case"keypress":if(!(e.ctrlKey||e.altKey||e.metaKey)||e.ctrlKey&&e.altKey){if(e.char&&1<e.char.length)return e.char;if(e.which)return String.fromCharCode(e.which)}return null;case"compositionend":return YF&&e.locale!=="ko"?null:e.data;default:return null}}var NX={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function lP(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e==="input"?!!NX[t.type]:e==="textarea"}function e4(t,e,n,r){NF(r),e=p1(e,"onChange"),0<e.length&&(n=new tM("onChange","change",null,n,r),t.push({event:n,listeners:e}))}var qm=null,gg=null;function PX(t){d4(t,0)}function fb(t){var e=Yf(t);if(CF(e))return t}function kX(t,e){if(t==="change")return e}var t4=!1;if(ml){var Lw;if(ml){var Bw="oninput"in document;if(!Bw){var cP=document.createElement("div");cP.setAttribute("oninput","return;"),Bw=typeof cP.oninput=="function"}Lw=Bw}else Lw=!1;t4=Lw&&(!document.documentMode||9<document.documentMode)}function uP(){qm&&(qm.detachEvent("onpropertychange",n4),gg=qm=null)}function n4(t){if(t.propertyName==="value"&&fb(gg)){var e=[];e4(e,gg,t,qT(t)),OF(PX,e)}}function DX(t,e,n){t==="focusin"?(uP(),qm=e,gg=n,qm.attachEvent("onpropertychange",n4)):t==="focusout"&&uP()}function OX(t){if(t==="selectionchange"||t==="keyup"||t==="keydown")return fb(gg)}function LX(t,e){if(t==="click")return fb(e)}function BX(t,e){if(t==="input"||t==="change")return fb(e)}function FX(t,e){return t===e&&(t!==0||1/t===1/e)||t!==t&&e!==e}var jo=typeof Object.is=="function"?Object.is:FX;function yg(t,e){if(jo(t,e))return!0;if(typeof t!="object"||t===null||typeof e!="object"||e===null)return!1;var n=Object.keys(t),r=Object.keys(e);if(n.length!==r.length)return!1;for(r=0;r<n.length;r++){var i=n[r];if(!XE.call(e,i)||!jo(t[i],e[i]))return!1}return!0}function dP(t){for(;t&&t.firstChild;)t=t.firstChild;return t}function fP(t,e){var n=dP(t);t=0;for(var r;n;){if(n.nodeType===3){if(r=t+n.textContent.length,t<=e&&r>=e)return{node:n,offset:e-t};t=r}e:{for(;n;){if(n.nextSibling){n=n.nextSibling;break e}n=n.parentNode}n=void 0}n=dP(n)}}function r4(t,e){return t&&e?t===e?!0:t&&t.nodeType===3?!1:e&&e.nodeType===3?r4(t,e.parentNode):"contains"in t?t.contains(e):t.compareDocumentPosition?!!(t.compareDocumentPosition(e)&16):!1:!1}function i4(){for(var t=window,e=a1();e instanceof t.HTMLIFrameElement;){try{var n=typeof e.contentWindow.location.href=="string"}catch{n=!1}if(n)t=e.contentWindow;else break;e=a1(t.document)}return e}function iM(t){var e=t&&t.nodeName&&t.nodeName.toLowerCase();return e&&(e==="input"&&(t.type==="text"||t.type==="search"||t.type==="tel"||t.type==="url"||t.type==="password")||e==="textarea"||t.contentEditable==="true")}function $X(t){var e=i4(),n=t.focusedElem,r=t.selectionRange;if(e!==n&&n&&n.ownerDocument&&r4(n.ownerDocument.documentElement,n)){if(r!==null&&iM(n)){if(e=r.start,t=r.end,t===void 0&&(t=e),"selectionStart"in n)n.selectionStart=e,n.selectionEnd=Math.min(t,n.value.length);else if(t=(e=n.ownerDocument||document)&&e.defaultView||window,t.getSelection){t=t.getSelection();var i=n.textContent.length,s=Math.min(r.start,i);r=r.end===void 0?s:Math.min(r.end,i),!t.extend&&s>r&&(i=r,r=s,s=i),i=fP(n,s);var o=fP(n,r);i&&o&&(t.rangeCount!==1||t.anchorNode!==i.node||t.anchorOffset!==i.offset||t.focusNode!==o.node||t.focusOffset!==o.offset)&&(e=e.createRange(),e.setStart(i.node,i.offset),t.removeAllRanges(),s>r?(t.addRange(e),t.extend(o.node,o.offset)):(e.setEnd(o.node,o.offset),t.addRange(e)))}}for(e=[],t=n;t=t.parentNode;)t.nodeType===1&&e.push({element:t,left:t.scrollLeft,top:t.scrollTop});for(typeof n.focus=="function"&&n.focus(),n=0;n<e.length;n++)t=e[n],t.element.scrollLeft=t.left,t.element.scrollTop=t.top}}var UX=ml&&"documentMode"in document&&11>=document.documentMode,qf=null,fA=null,Jm=null,hA=!1;function hP(t,e,n){var r=n.window===n?n.document:n.nodeType===9?n:n.ownerDocument;hA||qf==null||qf!==a1(r)||(r=qf,"selectionStart"in r&&iM(r)?r={start:r.selectionStart,end:r.selectionEnd}:(r=(r.ownerDocument&&r.ownerDocument.defaultView||window).getSelection(),r={anchorNode:r.anchorNode,anchorOffset:r.anchorOffset,focusNode:r.focusNode,focusOffset:r.focusOffset}),Jm&&yg(Jm,r)||(Jm=r,r=p1(fA,"onSelect"),0<r.length&&(e=new tM("onSelect","select",null,e,n),t.push({event:e,listeners:r}),e.target=qf)))}function nv(t,e){var n={};return n[t.toLowerCase()]=e.toLowerCase(),n["Webkit"+t]="webkit"+e,n["Moz"+t]="moz"+e,n}var Jf={animationend:nv("Animation","AnimationEnd"),animationiteration:nv("Animation","AnimationIteration"),animationstart:nv("Animation","AnimationStart"),transitionend:nv("Transition","TransitionEnd")},Fw={},s4={};ml&&(s4=document.createElement("div").style,"AnimationEvent"in window||(delete Jf.animationend.animation,delete Jf.animationiteration.animation,delete Jf.animationstart.animation),"TransitionEvent"in window||delete Jf.transitionend.transition);function hb(t){if(Fw[t])return Fw[t];if(!Jf[t])return t;var e=Jf[t],n;for(n in e)if(e.hasOwnProperty(n)&&n in s4)return Fw[t]=e[n];return t}var o4=hb("animationend"),a4=hb("animationiteration"),l4=hb("animationstart"),c4=hb("transitionend"),u4=new Map,pP="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function kc(t,e){u4.set(t,e),Ad(e,[t])}for(var $w=0;$w<pP.length;$w++){var Uw=pP[$w],zX=Uw.toLowerCase(),GX=Uw[0].toUpperCase()+Uw.slice(1);kc(zX,"on"+GX)}kc(o4,"onAnimationEnd");kc(a4,"onAnimationIteration");kc(l4,"onAnimationStart");kc("dblclick","onDoubleClick");kc("focusin","onFocus");kc("focusout","onBlur");kc(c4,"onTransitionEnd");Mh("onMouseEnter",["mouseout","mouseover"]);Mh("onMouseLeave",["mouseout","mouseover"]);Mh("onPointerEnter",["pointerout","pointerover"]);Mh("onPointerLeave",["pointerout","pointerover"]);Ad("onChange","change click focusin focusout input keydown keyup selectionchange".split(" "));Ad("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));Ad("onBeforeInput",["compositionend","keypress","textInput","paste"]);Ad("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" "));Ad("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" "));Ad("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Bm="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),HX=new Set("cancel close invalid load scroll toggle".split(" ").concat(Bm));function mP(t,e,n){var r=t.type||"unknown-event";t.currentTarget=n,zj(r,e,void 0,t),t.currentTarget=null}function d4(t,e){e=(e&4)!==0;for(var n=0;n<t.length;n++){var r=t[n],i=r.event;r=r.listeners;e:{var s=void 0;if(e)for(var o=r.length-1;0<=o;o--){var a=r[o],l=a.instance,c=a.currentTarget;if(a=a.listener,l!==s&&i.isPropagationStopped())break e;mP(i,a,c),s=l}else for(o=0;o<r.length;o++){if(a=r[o],l=a.instance,c=a.currentTarget,a=a.listener,l!==s&&i.isPropagationStopped())break e;mP(i,a,c),s=l}}}if(c1)throw t=lA,c1=!1,lA=null,t}function Dn(t,e){var n=e[vA];n===void 0&&(n=e[vA]=new Set);var r=t+"__bubble";n.has(r)||(f4(e,t,2,!1),n.add(r))}function zw(t,e,n){var r=0;e&&(r|=4),f4(n,t,r,e)}var rv="_reactListening"+Math.random().toString(36).slice(2);function vg(t){if(!t[rv]){t[rv]=!0,xF.forEach(function(n){n!=="selectionchange"&&(HX.has(n)||zw(n,!1,t),zw(n,!0,t))});var e=t.nodeType===9?t:t.ownerDocument;e===null||e[rv]||(e[rv]=!0,zw("selectionchange",!1,e))}}function f4(t,e,n,r){switch(qF(e)){case 1:var i=rX;break;case 4:i=iX;break;default:i=ZT}n=i.bind(null,e,n,t),i=void 0,!aA||e!=="touchstart"&&e!=="touchmove"&&e!=="wheel"||(i=!0),r?i!==void 0?t.addEventListener(e,n,{capture:!0,passive:i}):t.addEventListener(e,n,!0):i!==void 0?t.addEventListener(e,n,{passive:i}):t.addEventListener(e,n,!1)}function Gw(t,e,n,r,i){var s=r;if(!(e&1)&&!(e&2)&&r!==null)e:for(;;){if(r===null)return;var o=r.tag;if(o===3||o===4){var a=r.stateNode.containerInfo;if(a===i||a.nodeType===8&&a.parentNode===i)break;if(o===4)for(o=r.return;o!==null;){var l=o.tag;if((l===3||l===4)&&(l=o.stateNode.containerInfo,l===i||l.nodeType===8&&l.parentNode===i))return;o=o.return}for(;a!==null;){if(o=Ru(a),o===null)return;if(l=o.tag,l===5||l===6){r=s=o;continue e}a=a.parentNode}}r=r.return}OF(function(){var c=s,u=qT(n),d=[];e:{var f=u4.get(t);if(f!==void 0){var h=tM,p=t;switch(t){case"keypress":if(Px(n)===0)break e;case"keydown":case"keyup":h=xX;break;case"focusin":p="focus",h=Ow;break;case"focusout":p="blur",h=Ow;break;case"beforeblur":case"afterblur":h=Ow;break;case"click":if(n.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":h=rP;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":h=aX;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":h=_X;break;case o4:case a4:case l4:h=uX;break;case c4:h=CX;break;case"scroll":h=sX;break;case"wheel":h=AX;break;case"copy":case"cut":case"paste":h=fX;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":h=sP}var x=(e&4)!==0,v=!x&&t==="scroll",y=x?f!==null?f+"Capture":null:f;x=[];for(var b=c,S;b!==null;){S=b;var w=S.stateNode;if(S.tag===5&&w!==null&&(S=w,y!==null&&(w=fg(b,y),w!=null&&x.push(xg(b,w,S)))),v)break;b=b.return}0<x.length&&(f=new h(f,p,null,n,u),d.push({event:f,listeners:x}))}}if(!(e&7)){e:{if(f=t==="mouseover"||t==="pointerover",h=t==="mouseout"||t==="pointerout",f&&n!==sA&&(p=n.relatedTarget||n.fromElement)&&(Ru(p)||p[gl]))break e;if((h||f)&&(f=u.window===u?u:(f=u.ownerDocument)?f.defaultView||f.parentWindow:window,h?(p=n.relatedTarget||n.toElement,h=c,p=p?Ru(p):null,p!==null&&(v=Td(p),p!==v||p.tag!==5&&p.tag!==6)&&(p=null)):(h=null,p=c),h!==p)){if(x=rP,w="onMouseLeave",y="onMouseEnter",b="mouse",(t==="pointerout"||t==="pointerover")&&(x=sP,w="onPointerLeave",y="onPointerEnter",b="pointer"),v=h==null?f:Yf(h),S=p==null?f:Yf(p),f=new x(w,b+"leave",h,n,u),f.target=v,f.relatedTarget=S,w=null,Ru(u)===c&&(x=new x(y,b+"enter",p,n,u),x.target=S,x.relatedTarget=v,w=x),v=w,h&&p)t:{for(x=h,y=p,b=0,S=x;S;S=rf(S))b++;for(S=0,w=y;w;w=rf(w))S++;for(;0<b-S;)x=rf(x),b--;for(;0<S-b;)y=rf(y),S--;for(;b--;){if(x===y||y!==null&&x===y.alternate)break t;x=rf(x),y=rf(y)}x=null}else x=null;h!==null&&gP(d,f,h,x,!1),p!==null&&v!==null&&gP(d,v,p,x,!0)}}e:{if(f=c?Yf(c):window,h=f.nodeName&&f.nodeName.toLowerCase(),h==="select"||h==="input"&&f.type==="file")var E=kX;else if(lP(f))if(t4)E=BX;else{E=OX;var A=DX}else(h=f.nodeName)&&h.toLowerCase()==="input"&&(f.type==="checkbox"||f.type==="radio")&&(E=LX);if(E&&(E=E(t,c))){e4(d,E,n,u);break e}A&&A(t,f,c),t==="focusout"&&(A=f._wrapperState)&&A.controlled&&f.type==="number"&&eA(f,"number",f.value)}switch(A=c?Yf(c):window,t){case"focusin":(lP(A)||A.contentEditable==="true")&&(qf=A,fA=c,Jm=null);break;case"focusout":Jm=fA=qf=null;break;case"mousedown":hA=!0;break;case"contextmenu":case"mouseup":case"dragend":hA=!1,hP(d,n,u);break;case"selectionchange":if(UX)break;case"keydown":case"keyup":hP(d,n,u)}var T;if(rM)e:{switch(t){case"compositionstart":var I="onCompositionStart";break e;case"compositionend":I="onCompositionEnd";break e;case"compositionupdate":I="onCompositionUpdate";break e}I=void 0}else Kf?QF(t,n)&&(I="onCompositionEnd"):t==="keydown"&&n.keyCode===229&&(I="onCompositionStart");I&&(YF&&n.locale!=="ko"&&(Kf||I!=="onCompositionStart"?I==="onCompositionEnd"&&Kf&&(T=JF()):(oc=u,eM="value"in oc?oc.value:oc.textContent,Kf=!0)),A=p1(c,I),0<A.length&&(I=new iP(I,t,null,n,u),d.push({event:I,listeners:A}),T?I.data=T:(T=ZF(n),T!==null&&(I.data=T)))),(T=MX?RX(t,n):IX(t,n))&&(c=p1(c,"onBeforeInput"),0<c.length&&(u=new iP("onBeforeInput","beforeinput",null,n,u),d.push({event:u,listeners:c}),u.data=T))}d4(d,e)})}function xg(t,e,n){return{instance:t,listener:e,currentTarget:n}}function p1(t,e){for(var n=e+"Capture",r=[];t!==null;){var i=t,s=i.stateNode;i.tag===5&&s!==null&&(i=s,s=fg(t,n),s!=null&&r.unshift(xg(t,s,i)),s=fg(t,e),s!=null&&r.push(xg(t,s,i))),t=t.return}return r}function rf(t){if(t===null)return null;do t=t.return;while(t&&t.tag!==5);return t||null}function gP(t,e,n,r,i){for(var s=e._reactName,o=[];n!==null&&n!==r;){var a=n,l=a.alternate,c=a.stateNode;if(l!==null&&l===r)break;a.tag===5&&c!==null&&(a=c,i?(l=fg(n,s),l!=null&&o.unshift(xg(n,l,a))):i||(l=fg(n,s),l!=null&&o.push(xg(n,l,a)))),n=n.return}o.length!==0&&t.push({event:e,listeners:o})}var VX=/\r\n?/g,WX=/\u0000|\uFFFD/g;function yP(t){return(typeof t=="string"?t:""+t).replace(VX,`
`).replace(WX,"")}function iv(t,e,n){if(e=yP(e),yP(t)!==e&&n)throw Error(ze(425))}function m1(){}var pA=null,mA=null;function gA(t,e){return t==="textarea"||t==="noscript"||typeof e.children=="string"||typeof e.children=="number"||typeof e.dangerouslySetInnerHTML=="object"&&e.dangerouslySetInnerHTML!==null&&e.dangerouslySetInnerHTML.__html!=null}var yA=typeof setTimeout=="function"?setTimeout:void 0,jX=typeof clearTimeout=="function"?clearTimeout:void 0,vP=typeof Promise=="function"?Promise:void 0,XX=typeof queueMicrotask=="function"?queueMicrotask:typeof vP<"u"?function(t){return vP.resolve(null).then(t).catch(KX)}:yA;function KX(t){setTimeout(function(){throw t})}function Hw(t,e){var n=e,r=0;do{var i=n.nextSibling;if(t.removeChild(n),i&&i.nodeType===8)if(n=i.data,n==="/$"){if(r===0){t.removeChild(i),mg(e);return}r--}else n!=="$"&&n!=="$?"&&n!=="$!"||r++;n=i}while(n);mg(e)}function pc(t){for(;t!=null;t=t.nextSibling){var e=t.nodeType;if(e===1||e===3)break;if(e===8){if(e=t.data,e==="$"||e==="$!"||e==="$?")break;if(e==="/$")return null}}return t}function xP(t){t=t.previousSibling;for(var e=0;t;){if(t.nodeType===8){var n=t.data;if(n==="$"||n==="$!"||n==="$?"){if(e===0)return t;e--}else n==="/$"&&e++}t=t.previousSibling}return null}var lp=Math.random().toString(36).slice(2),ya="__reactFiber$"+lp,bg="__reactProps$"+lp,gl="__reactContainer$"+lp,vA="__reactEvents$"+lp,qX="__reactListeners$"+lp,JX="__reactHandles$"+lp;function Ru(t){var e=t[ya];if(e)return e;for(var n=t.parentNode;n;){if(e=n[gl]||n[ya]){if(n=e.alternate,e.child!==null||n!==null&&n.child!==null)for(t=xP(t);t!==null;){if(n=t[ya])return n;t=xP(t)}return e}t=n,n=t.parentNode}return null}function f0(t){return t=t[ya]||t[gl],!t||t.tag!==5&&t.tag!==6&&t.tag!==13&&t.tag!==3?null:t}function Yf(t){if(t.tag===5||t.tag===6)return t.stateNode;throw Error(ze(33))}function pb(t){return t[bg]||null}var xA=[],Qf=-1;function Dc(t){return{current:t}}function Ln(t){0>Qf||(t.current=xA[Qf],xA[Qf]=null,Qf--)}function In(t,e){Qf++,xA[Qf]=t.current,t.current=e}var Cc={},xi=Dc(Cc),es=Dc(!1),id=Cc;function Rh(t,e){var n=t.type.contextTypes;if(!n)return Cc;var r=t.stateNode;if(r&&r.__reactInternalMemoizedUnmaskedChildContext===e)return r.__reactInternalMemoizedMaskedChildContext;var i={},s;for(s in n)i[s]=e[s];return r&&(t=t.stateNode,t.__reactInternalMemoizedUnmaskedChildContext=e,t.__reactInternalMemoizedMaskedChildContext=i),i}function ts(t){return t=t.childContextTypes,t!=null}function g1(){Ln(es),Ln(xi)}function bP(t,e,n){if(xi.current!==Cc)throw Error(ze(168));In(xi,e),In(es,n)}function h4(t,e,n){var r=t.stateNode;if(e=e.childContextTypes,typeof r.getChildContext!="function")return n;r=r.getChildContext();for(var i in r)if(!(i in e))throw Error(ze(108,Dj(t)||"Unknown",i));return Jn({},n,r)}function y1(t){return t=(t=t.stateNode)&&t.__reactInternalMemoizedMergedChildContext||Cc,id=xi.current,In(xi,t),In(es,es.current),!0}function SP(t,e,n){var r=t.stateNode;if(!r)throw Error(ze(169));n?(t=h4(t,e,id),r.__reactInternalMemoizedMergedChildContext=t,Ln(es),Ln(xi),In(xi,t)):Ln(es),In(es,n)}var Ja=null,mb=!1,Vw=!1;function p4(t){Ja===null?Ja=[t]:Ja.push(t)}function YX(t){mb=!0,p4(t)}function Oc(){if(!Vw&&Ja!==null){Vw=!0;var t=0,e=xn;try{var n=Ja;for(xn=1;t<n.length;t++){var r=n[t];do r=r(!0);while(r!==null)}Ja=null,mb=!1}catch(i){throw Ja!==null&&(Ja=Ja.slice(t+1)),$F(JT,Oc),i}finally{xn=e,Vw=!1}}return null}var Zf=[],eh=0,v1=null,x1=0,no=[],ro=0,sd=null,il=1,sl="";function gu(t,e){Zf[eh++]=x1,Zf[eh++]=v1,v1=t,x1=e}function m4(t,e,n){no[ro++]=il,no[ro++]=sl,no[ro++]=sd,sd=t;var r=il;t=sl;var i=32-Vo(r)-1;r&=~(1<<i),n+=1;var s=32-Vo(e)+i;if(30<s){var o=i-i%5;s=(r&(1<<o)-1).toString(32),r>>=o,i-=o,il=1<<32-Vo(e)+i|n<<i|r,sl=s+t}else il=1<<s|n<<i|r,sl=t}function sM(t){t.return!==null&&(gu(t,1),m4(t,1,0))}function oM(t){for(;t===v1;)v1=Zf[--eh],Zf[eh]=null,x1=Zf[--eh],Zf[eh]=null;for(;t===sd;)sd=no[--ro],no[ro]=null,sl=no[--ro],no[ro]=null,il=no[--ro],no[ro]=null}var Es=null,_s=null,Gn=!1,Lo=null;function g4(t,e){var n=oo(5,null,null,0);n.elementType="DELETED",n.stateNode=e,n.return=t,e=t.deletions,e===null?(t.deletions=[n],t.flags|=16):e.push(n)}function _P(t,e){switch(t.tag){case 5:var n=t.type;return e=e.nodeType!==1||n.toLowerCase()!==e.nodeName.toLowerCase()?null:e,e!==null?(t.stateNode=e,Es=t,_s=pc(e.firstChild),!0):!1;case 6:return e=t.pendingProps===""||e.nodeType!==3?null:e,e!==null?(t.stateNode=e,Es=t,_s=null,!0):!1;case 13:return e=e.nodeType!==8?null:e,e!==null?(n=sd!==null?{id:il,overflow:sl}:null,t.memoizedState={dehydrated:e,treeContext:n,retryLane:1073741824},n=oo(18,null,null,0),n.stateNode=e,n.return=t,t.child=n,Es=t,_s=null,!0):!1;default:return!1}}function bA(t){return(t.mode&1)!==0&&(t.flags&128)===0}function SA(t){if(Gn){var e=_s;if(e){var n=e;if(!_P(t,e)){if(bA(t))throw Error(ze(418));e=pc(n.nextSibling);var r=Es;e&&_P(t,e)?g4(r,n):(t.flags=t.flags&-4097|2,Gn=!1,Es=t)}}else{if(bA(t))throw Error(ze(418));t.flags=t.flags&-4097|2,Gn=!1,Es=t}}}function wP(t){for(t=t.return;t!==null&&t.tag!==5&&t.tag!==3&&t.tag!==13;)t=t.return;Es=t}function sv(t){if(t!==Es)return!1;if(!Gn)return wP(t),Gn=!0,!1;var e;if((e=t.tag!==3)&&!(e=t.tag!==5)&&(e=t.type,e=e!=="head"&&e!=="body"&&!gA(t.type,t.memoizedProps)),e&&(e=_s)){if(bA(t))throw y4(),Error(ze(418));for(;e;)g4(t,e),e=pc(e.nextSibling)}if(wP(t),t.tag===13){if(t=t.memoizedState,t=t!==null?t.dehydrated:null,!t)throw Error(ze(317));e:{for(t=t.nextSibling,e=0;t;){if(t.nodeType===8){var n=t.data;if(n==="/$"){if(e===0){_s=pc(t.nextSibling);break e}e--}else n!=="$"&&n!=="$!"&&n!=="$?"||e++}t=t.nextSibling}_s=null}}else _s=Es?pc(t.stateNode.nextSibling):null;return!0}function y4(){for(var t=_s;t;)t=pc(t.nextSibling)}function Ih(){_s=Es=null,Gn=!1}function aM(t){Lo===null?Lo=[t]:Lo.push(t)}var QX=El.ReactCurrentBatchConfig;function Po(t,e){if(t&&t.defaultProps){e=Jn({},e),t=t.defaultProps;for(var n in t)e[n]===void 0&&(e[n]=t[n]);return e}return e}var b1=Dc(null),S1=null,th=null,lM=null;function cM(){lM=th=S1=null}function uM(t){var e=b1.current;Ln(b1),t._currentValue=e}function _A(t,e,n){for(;t!==null;){var r=t.alternate;if((t.childLanes&e)!==e?(t.childLanes|=e,r!==null&&(r.childLanes|=e)):r!==null&&(r.childLanes&e)!==e&&(r.childLanes|=e),t===n)break;t=t.return}}function mh(t,e){S1=t,lM=th=null,t=t.dependencies,t!==null&&t.firstContext!==null&&(t.lanes&e&&(Ji=!0),t.firstContext=null)}function mo(t){var e=t._currentValue;if(lM!==t)if(t={context:t,memoizedValue:e,next:null},th===null){if(S1===null)throw Error(ze(308));th=t,S1.dependencies={lanes:0,firstContext:t}}else th=th.next=t;return e}var Iu=null;function dM(t){Iu===null?Iu=[t]:Iu.push(t)}function v4(t,e,n,r){var i=e.interleaved;return i===null?(n.next=n,dM(e)):(n.next=i.next,i.next=n),e.interleaved=n,yl(t,r)}function yl(t,e){t.lanes|=e;var n=t.alternate;for(n!==null&&(n.lanes|=e),n=t,t=t.return;t!==null;)t.childLanes|=e,n=t.alternate,n!==null&&(n.childLanes|=e),n=t,t=t.return;return n.tag===3?n.stateNode:null}var tc=!1;function fM(t){t.updateQueue={baseState:t.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function x4(t,e){t=t.updateQueue,e.updateQueue===t&&(e.updateQueue={baseState:t.baseState,firstBaseUpdate:t.firstBaseUpdate,lastBaseUpdate:t.lastBaseUpdate,shared:t.shared,effects:t.effects})}function ll(t,e){return{eventTime:t,lane:e,tag:0,payload:null,callback:null,next:null}}function mc(t,e,n){var r=t.updateQueue;if(r===null)return null;if(r=r.shared,nn&2){var i=r.pending;return i===null?e.next=e:(e.next=i.next,i.next=e),r.pending=e,yl(t,n)}return i=r.interleaved,i===null?(e.next=e,dM(r)):(e.next=i.next,i.next=e),r.interleaved=e,yl(t,n)}function kx(t,e,n){if(e=e.updateQueue,e!==null&&(e=e.shared,(n&4194240)!==0)){var r=e.lanes;r&=t.pendingLanes,n|=r,e.lanes=n,YT(t,n)}}function CP(t,e){var n=t.updateQueue,r=t.alternate;if(r!==null&&(r=r.updateQueue,n===r)){var i=null,s=null;if(n=n.firstBaseUpdate,n!==null){do{var o={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};s===null?i=s=o:s=s.next=o,n=n.next}while(n!==null);s===null?i=s=e:s=s.next=e}else i=s=e;n={baseState:r.baseState,firstBaseUpdate:i,lastBaseUpdate:s,shared:r.shared,effects:r.effects},t.updateQueue=n;return}t=n.lastBaseUpdate,t===null?n.firstBaseUpdate=e:t.next=e,n.lastBaseUpdate=e}function _1(t,e,n,r){var i=t.updateQueue;tc=!1;var s=i.firstBaseUpdate,o=i.lastBaseUpdate,a=i.shared.pending;if(a!==null){i.shared.pending=null;var l=a,c=l.next;l.next=null,o===null?s=c:o.next=c,o=l;var u=t.alternate;u!==null&&(u=u.updateQueue,a=u.lastBaseUpdate,a!==o&&(a===null?u.firstBaseUpdate=c:a.next=c,u.lastBaseUpdate=l))}if(s!==null){var d=i.baseState;o=0,u=c=l=null,a=s;do{var f=a.lane,h=a.eventTime;if((r&f)===f){u!==null&&(u=u.next={eventTime:h,lane:0,tag:a.tag,payload:a.payload,callback:a.callback,next:null});e:{var p=t,x=a;switch(f=e,h=n,x.tag){case 1:if(p=x.payload,typeof p=="function"){d=p.call(h,d,f);break e}d=p;break e;case 3:p.flags=p.flags&-65537|128;case 0:if(p=x.payload,f=typeof p=="function"?p.call(h,d,f):p,f==null)break e;d=Jn({},d,f);break e;case 2:tc=!0}}a.callback!==null&&a.lane!==0&&(t.flags|=64,f=i.effects,f===null?i.effects=[a]:f.push(a))}else h={eventTime:h,lane:f,tag:a.tag,payload:a.payload,callback:a.callback,next:null},u===null?(c=u=h,l=d):u=u.next=h,o|=f;if(a=a.next,a===null){if(a=i.shared.pending,a===null)break;f=a,a=f.next,f.next=null,i.lastBaseUpdate=f,i.shared.pending=null}}while(!0);if(u===null&&(l=d),i.baseState=l,i.firstBaseUpdate=c,i.lastBaseUpdate=u,e=i.shared.interleaved,e!==null){i=e;do o|=i.lane,i=i.next;while(i!==e)}else s===null&&(i.shared.lanes=0);ad|=o,t.lanes=o,t.memoizedState=d}}function EP(t,e,n){if(t=e.effects,e.effects=null,t!==null)for(e=0;e<t.length;e++){var r=t[e],i=r.callback;if(i!==null){if(r.callback=null,r=n,typeof i!="function")throw Error(ze(191,i));i.call(r)}}}var b4=new vF.Component().refs;function wA(t,e,n,r){e=t.memoizedState,n=n(r,e),n=n==null?e:Jn({},e,n),t.memoizedState=n,t.lanes===0&&(t.updateQueue.baseState=n)}var gb={isMounted:function(t){return(t=t._reactInternals)?Td(t)===t:!1},enqueueSetState:function(t,e,n){t=t._reactInternals;var r=Li(),i=yc(t),s=ll(r,i);s.payload=e,n!=null&&(s.callback=n),e=mc(t,s,i),e!==null&&(Wo(e,t,i,r),kx(e,t,i))},enqueueReplaceState:function(t,e,n){t=t._reactInternals;var r=Li(),i=yc(t),s=ll(r,i);s.tag=1,s.payload=e,n!=null&&(s.callback=n),e=mc(t,s,i),e!==null&&(Wo(e,t,i,r),kx(e,t,i))},enqueueForceUpdate:function(t,e){t=t._reactInternals;var n=Li(),r=yc(t),i=ll(n,r);i.tag=2,e!=null&&(i.callback=e),e=mc(t,i,r),e!==null&&(Wo(e,t,r,n),kx(e,t,r))}};function AP(t,e,n,r,i,s,o){return t=t.stateNode,typeof t.shouldComponentUpdate=="function"?t.shouldComponentUpdate(r,s,o):e.prototype&&e.prototype.isPureReactComponent?!yg(n,r)||!yg(i,s):!0}function S4(t,e,n){var r=!1,i=Cc,s=e.contextType;return typeof s=="object"&&s!==null?s=mo(s):(i=ts(e)?id:xi.current,r=e.contextTypes,s=(r=r!=null)?Rh(t,i):Cc),e=new e(n,s),t.memoizedState=e.state!==null&&e.state!==void 0?e.state:null,e.updater=gb,t.stateNode=e,e._reactInternals=t,r&&(t=t.stateNode,t.__reactInternalMemoizedUnmaskedChildContext=i,t.__reactInternalMemoizedMaskedChildContext=s),e}function TP(t,e,n,r){t=e.state,typeof e.componentWillReceiveProps=="function"&&e.componentWillReceiveProps(n,r),typeof e.UNSAFE_componentWillReceiveProps=="function"&&e.UNSAFE_componentWillReceiveProps(n,r),e.state!==t&&gb.enqueueReplaceState(e,e.state,null)}function CA(t,e,n,r){var i=t.stateNode;i.props=n,i.state=t.memoizedState,i.refs=b4,fM(t);var s=e.contextType;typeof s=="object"&&s!==null?i.context=mo(s):(s=ts(e)?id:xi.current,i.context=Rh(t,s)),i.state=t.memoizedState,s=e.getDerivedStateFromProps,typeof s=="function"&&(wA(t,e,s,n),i.state=t.memoizedState),typeof e.getDerivedStateFromProps=="function"||typeof i.getSnapshotBeforeUpdate=="function"||typeof i.UNSAFE_componentWillMount!="function"&&typeof i.componentWillMount!="function"||(e=i.state,typeof i.componentWillMount=="function"&&i.componentWillMount(),typeof i.UNSAFE_componentWillMount=="function"&&i.UNSAFE_componentWillMount(),e!==i.state&&gb.enqueueReplaceState(i,i.state,null),_1(t,n,i,r),i.state=t.memoizedState),typeof i.componentDidMount=="function"&&(t.flags|=4194308)}function rm(t,e,n){if(t=n.ref,t!==null&&typeof t!="function"&&typeof t!="object"){if(n._owner){if(n=n._owner,n){if(n.tag!==1)throw Error(ze(309));var r=n.stateNode}if(!r)throw Error(ze(147,t));var i=r,s=""+t;return e!==null&&e.ref!==null&&typeof e.ref=="function"&&e.ref._stringRef===s?e.ref:(e=function(o){var a=i.refs;a===b4&&(a=i.refs={}),o===null?delete a[s]:a[s]=o},e._stringRef=s,e)}if(typeof t!="string")throw Error(ze(284));if(!n._owner)throw Error(ze(290,t))}return t}function ov(t,e){throw t=Object.prototype.toString.call(e),Error(ze(31,t==="[object Object]"?"object with keys {"+Object.keys(e).join(", ")+"}":t))}function MP(t){var e=t._init;return e(t._payload)}function _4(t){function e(y,b){if(t){var S=y.deletions;S===null?(y.deletions=[b],y.flags|=16):S.push(b)}}function n(y,b){if(!t)return null;for(;b!==null;)e(y,b),b=b.sibling;return null}function r(y,b){for(y=new Map;b!==null;)b.key!==null?y.set(b.key,b):y.set(b.index,b),b=b.sibling;return y}function i(y,b){return y=vc(y,b),y.index=0,y.sibling=null,y}function s(y,b,S){return y.index=S,t?(S=y.alternate,S!==null?(S=S.index,S<b?(y.flags|=2,b):S):(y.flags|=2,b)):(y.flags|=1048576,b)}function o(y){return t&&y.alternate===null&&(y.flags|=2),y}function a(y,b,S,w){return b===null||b.tag!==6?(b=Yw(S,y.mode,w),b.return=y,b):(b=i(b,S),b.return=y,b)}function l(y,b,S,w){var E=S.type;return E===Xf?u(y,b,S.props.children,w,S.key):b!==null&&(b.elementType===E||typeof E=="object"&&E!==null&&E.$$typeof===ec&&MP(E)===b.type)?(w=i(b,S.props),w.ref=rm(y,b,S),w.return=y,w):(w=$x(S.type,S.key,S.props,null,y.mode,w),w.ref=rm(y,b,S),w.return=y,w)}function c(y,b,S,w){return b===null||b.tag!==4||b.stateNode.containerInfo!==S.containerInfo||b.stateNode.implementation!==S.implementation?(b=Qw(S,y.mode,w),b.return=y,b):(b=i(b,S.children||[]),b.return=y,b)}function u(y,b,S,w,E){return b===null||b.tag!==7?(b=Xu(S,y.mode,w,E),b.return=y,b):(b=i(b,S),b.return=y,b)}function d(y,b,S){if(typeof b=="string"&&b!==""||typeof b=="number")return b=Yw(""+b,y.mode,S),b.return=y,b;if(typeof b=="object"&&b!==null){switch(b.$$typeof){case qy:return S=$x(b.type,b.key,b.props,null,y.mode,S),S.ref=rm(y,null,b),S.return=y,S;case jf:return b=Qw(b,y.mode,S),b.return=y,b;case ec:var w=b._init;return d(y,w(b._payload),S)}if(Om(b)||Qp(b))return b=Xu(b,y.mode,S,null),b.return=y,b;ov(y,b)}return null}function f(y,b,S,w){var E=b!==null?b.key:null;if(typeof S=="string"&&S!==""||typeof S=="number")return E!==null?null:a(y,b,""+S,w);if(typeof S=="object"&&S!==null){switch(S.$$typeof){case qy:return S.key===E?l(y,b,S,w):null;case jf:return S.key===E?c(y,b,S,w):null;case ec:return E=S._init,f(y,b,E(S._payload),w)}if(Om(S)||Qp(S))return E!==null?null:u(y,b,S,w,null);ov(y,S)}return null}function h(y,b,S,w,E){if(typeof w=="string"&&w!==""||typeof w=="number")return y=y.get(S)||null,a(b,y,""+w,E);if(typeof w=="object"&&w!==null){switch(w.$$typeof){case qy:return y=y.get(w.key===null?S:w.key)||null,l(b,y,w,E);case jf:return y=y.get(w.key===null?S:w.key)||null,c(b,y,w,E);case ec:var A=w._init;return h(y,b,S,A(w._payload),E)}if(Om(w)||Qp(w))return y=y.get(S)||null,u(b,y,w,E,null);ov(b,w)}return null}function p(y,b,S,w){for(var E=null,A=null,T=b,I=b=0,N=null;T!==null&&I<S.length;I++){T.index>I?(N=T,T=null):N=T.sibling;var M=f(y,T,S[I],w);if(M===null){T===null&&(T=N);break}t&&T&&M.alternate===null&&e(y,T),b=s(M,b,I),A===null?E=M:A.sibling=M,A=M,T=N}if(I===S.length)return n(y,T),Gn&&gu(y,I),E;if(T===null){for(;I<S.length;I++)T=d(y,S[I],w),T!==null&&(b=s(T,b,I),A===null?E=T:A.sibling=T,A=T);return Gn&&gu(y,I),E}for(T=r(y,T);I<S.length;I++)N=h(T,y,I,S[I],w),N!==null&&(t&&N.alternate!==null&&T.delete(N.key===null?I:N.key),b=s(N,b,I),A===null?E=N:A.sibling=N,A=N);return t&&T.forEach(function(P){return e(y,P)}),Gn&&gu(y,I),E}function x(y,b,S,w){var E=Qp(S);if(typeof E!="function")throw Error(ze(150));if(S=E.call(S),S==null)throw Error(ze(151));for(var A=E=null,T=b,I=b=0,N=null,M=S.next();T!==null&&!M.done;I++,M=S.next()){T.index>I?(N=T,T=null):N=T.sibling;var P=f(y,T,M.value,w);if(P===null){T===null&&(T=N);break}t&&T&&P.alternate===null&&e(y,T),b=s(P,b,I),A===null?E=P:A.sibling=P,A=P,T=N}if(M.done)return n(y,T),Gn&&gu(y,I),E;if(T===null){for(;!M.done;I++,M=S.next())M=d(y,M.value,w),M!==null&&(b=s(M,b,I),A===null?E=M:A.sibling=M,A=M);return Gn&&gu(y,I),E}for(T=r(y,T);!M.done;I++,M=S.next())M=h(T,y,I,M.value,w),M!==null&&(t&&M.alternate!==null&&T.delete(M.key===null?I:M.key),b=s(M,b,I),A===null?E=M:A.sibling=M,A=M);return t&&T.forEach(function(B){return e(y,B)}),Gn&&gu(y,I),E}function v(y,b,S,w){if(typeof S=="object"&&S!==null&&S.type===Xf&&S.key===null&&(S=S.props.children),typeof S=="object"&&S!==null){switch(S.$$typeof){case qy:e:{for(var E=S.key,A=b;A!==null;){if(A.key===E){if(E=S.type,E===Xf){if(A.tag===7){n(y,A.sibling),b=i(A,S.props.children),b.return=y,y=b;break e}}else if(A.elementType===E||typeof E=="object"&&E!==null&&E.$$typeof===ec&&MP(E)===A.type){n(y,A.sibling),b=i(A,S.props),b.ref=rm(y,A,S),b.return=y,y=b;break e}n(y,A);break}else e(y,A);A=A.sibling}S.type===Xf?(b=Xu(S.props.children,y.mode,w,S.key),b.return=y,y=b):(w=$x(S.type,S.key,S.props,null,y.mode,w),w.ref=rm(y,b,S),w.return=y,y=w)}return o(y);case jf:e:{for(A=S.key;b!==null;){if(b.key===A)if(b.tag===4&&b.stateNode.containerInfo===S.containerInfo&&b.stateNode.implementation===S.implementation){n(y,b.sibling),b=i(b,S.children||[]),b.return=y,y=b;break e}else{n(y,b);break}else e(y,b);b=b.sibling}b=Qw(S,y.mode,w),b.return=y,y=b}return o(y);case ec:return A=S._init,v(y,b,A(S._payload),w)}if(Om(S))return p(y,b,S,w);if(Qp(S))return x(y,b,S,w);ov(y,S)}return typeof S=="string"&&S!==""||typeof S=="number"?(S=""+S,b!==null&&b.tag===6?(n(y,b.sibling),b=i(b,S),b.return=y,y=b):(n(y,b),b=Yw(S,y.mode,w),b.return=y,y=b),o(y)):n(y,b)}return v}var Nh=_4(!0),w4=_4(!1),h0={},_a=Dc(h0),Sg=Dc(h0),_g=Dc(h0);function Nu(t){if(t===h0)throw Error(ze(174));return t}function hM(t,e){switch(In(_g,e),In(Sg,t),In(_a,h0),t=e.nodeType,t){case 9:case 11:e=(e=e.documentElement)?e.namespaceURI:nA(null,"");break;default:t=t===8?e.parentNode:e,e=t.namespaceURI||null,t=t.tagName,e=nA(e,t)}Ln(_a),In(_a,e)}function Ph(){Ln(_a),Ln(Sg),Ln(_g)}function C4(t){Nu(_g.current);var e=Nu(_a.current),n=nA(e,t.type);e!==n&&(In(Sg,t),In(_a,n))}function pM(t){Sg.current===t&&(Ln(_a),Ln(Sg))}var jn=Dc(0);function w1(t){for(var e=t;e!==null;){if(e.tag===13){var n=e.memoizedState;if(n!==null&&(n=n.dehydrated,n===null||n.data==="$?"||n.data==="$!"))return e}else if(e.tag===19&&e.memoizedProps.revealOrder!==void 0){if(e.flags&128)return e}else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break;for(;e.sibling===null;){if(e.return===null||e.return===t)return null;e=e.return}e.sibling.return=e.return,e=e.sibling}return null}var Ww=[];function mM(){for(var t=0;t<Ww.length;t++)Ww[t]._workInProgressVersionPrimary=null;Ww.length=0}var Dx=El.ReactCurrentDispatcher,jw=El.ReactCurrentBatchConfig,od=0,Kn=null,Mr=null,$r=null,C1=!1,Ym=!1,wg=0,ZX=0;function ai(){throw Error(ze(321))}function gM(t,e){if(e===null)return!1;for(var n=0;n<e.length&&n<t.length;n++)if(!jo(t[n],e[n]))return!1;return!0}function yM(t,e,n,r,i,s){if(od=s,Kn=e,e.memoizedState=null,e.updateQueue=null,e.lanes=0,Dx.current=t===null||t.memoizedState===null?rK:iK,t=n(r,i),Ym){s=0;do{if(Ym=!1,wg=0,25<=s)throw Error(ze(301));s+=1,$r=Mr=null,e.updateQueue=null,Dx.current=sK,t=n(r,i)}while(Ym)}if(Dx.current=E1,e=Mr!==null&&Mr.next!==null,od=0,$r=Mr=Kn=null,C1=!1,e)throw Error(ze(300));return t}function vM(){var t=wg!==0;return wg=0,t}function fa(){var t={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return $r===null?Kn.memoizedState=$r=t:$r=$r.next=t,$r}function go(){if(Mr===null){var t=Kn.alternate;t=t!==null?t.memoizedState:null}else t=Mr.next;var e=$r===null?Kn.memoizedState:$r.next;if(e!==null)$r=e,Mr=t;else{if(t===null)throw Error(ze(310));Mr=t,t={memoizedState:Mr.memoizedState,baseState:Mr.baseState,baseQueue:Mr.baseQueue,queue:Mr.queue,next:null},$r===null?Kn.memoizedState=$r=t:$r=$r.next=t}return $r}function Cg(t,e){return typeof e=="function"?e(t):e}function Xw(t){var e=go(),n=e.queue;if(n===null)throw Error(ze(311));n.lastRenderedReducer=t;var r=Mr,i=r.baseQueue,s=n.pending;if(s!==null){if(i!==null){var o=i.next;i.next=s.next,s.next=o}r.baseQueue=i=s,n.pending=null}if(i!==null){s=i.next,r=r.baseState;var a=o=null,l=null,c=s;do{var u=c.lane;if((od&u)===u)l!==null&&(l=l.next={lane:0,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null}),r=c.hasEagerState?c.eagerState:t(r,c.action);else{var d={lane:u,action:c.action,hasEagerState:c.hasEagerState,eagerState:c.eagerState,next:null};l===null?(a=l=d,o=r):l=l.next=d,Kn.lanes|=u,ad|=u}c=c.next}while(c!==null&&c!==s);l===null?o=r:l.next=a,jo(r,e.memoizedState)||(Ji=!0),e.memoizedState=r,e.baseState=o,e.baseQueue=l,n.lastRenderedState=r}if(t=n.interleaved,t!==null){i=t;do s=i.lane,Kn.lanes|=s,ad|=s,i=i.next;while(i!==t)}else i===null&&(n.lanes=0);return[e.memoizedState,n.dispatch]}function Kw(t){var e=go(),n=e.queue;if(n===null)throw Error(ze(311));n.lastRenderedReducer=t;var r=n.dispatch,i=n.pending,s=e.memoizedState;if(i!==null){n.pending=null;var o=i=i.next;do s=t(s,o.action),o=o.next;while(o!==i);jo(s,e.memoizedState)||(Ji=!0),e.memoizedState=s,e.baseQueue===null&&(e.baseState=s),n.lastRenderedState=s}return[s,r]}function E4(){}function A4(t,e){var n=Kn,r=go(),i=e(),s=!jo(r.memoizedState,i);if(s&&(r.memoizedState=i,Ji=!0),r=r.queue,xM(R4.bind(null,n,r,t),[t]),r.getSnapshot!==e||s||$r!==null&&$r.memoizedState.tag&1){if(n.flags|=2048,Eg(9,M4.bind(null,n,r,i,e),void 0,null),Gr===null)throw Error(ze(349));od&30||T4(n,e,i)}return i}function T4(t,e,n){t.flags|=16384,t={getSnapshot:e,value:n},e=Kn.updateQueue,e===null?(e={lastEffect:null,stores:null},Kn.updateQueue=e,e.stores=[t]):(n=e.stores,n===null?e.stores=[t]:n.push(t))}function M4(t,e,n,r){e.value=n,e.getSnapshot=r,I4(e)&&N4(t)}function R4(t,e,n){return n(function(){I4(e)&&N4(t)})}function I4(t){var e=t.getSnapshot;t=t.value;try{var n=e();return!jo(t,n)}catch{return!0}}function N4(t){var e=yl(t,1);e!==null&&Wo(e,t,1,-1)}function RP(t){var e=fa();return typeof t=="function"&&(t=t()),e.memoizedState=e.baseState=t,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Cg,lastRenderedState:t},e.queue=t,t=t.dispatch=nK.bind(null,Kn,t),[e.memoizedState,t]}function Eg(t,e,n,r){return t={tag:t,create:e,destroy:n,deps:r,next:null},e=Kn.updateQueue,e===null?(e={lastEffect:null,stores:null},Kn.updateQueue=e,e.lastEffect=t.next=t):(n=e.lastEffect,n===null?e.lastEffect=t.next=t:(r=n.next,n.next=t,t.next=r,e.lastEffect=t)),t}function P4(){return go().memoizedState}function Ox(t,e,n,r){var i=fa();Kn.flags|=t,i.memoizedState=Eg(1|e,n,void 0,r===void 0?null:r)}function yb(t,e,n,r){var i=go();r=r===void 0?null:r;var s=void 0;if(Mr!==null){var o=Mr.memoizedState;if(s=o.destroy,r!==null&&gM(r,o.deps)){i.memoizedState=Eg(e,n,s,r);return}}Kn.flags|=t,i.memoizedState=Eg(1|e,n,s,r)}function IP(t,e){return Ox(8390656,8,t,e)}function xM(t,e){return yb(2048,8,t,e)}function k4(t,e){return yb(4,2,t,e)}function D4(t,e){return yb(4,4,t,e)}function O4(t,e){if(typeof e=="function")return t=t(),e(t),function(){e(null)};if(e!=null)return t=t(),e.current=t,function(){e.current=null}}function L4(t,e,n){return n=n!=null?n.concat([t]):null,yb(4,4,O4.bind(null,e,t),n)}function bM(){}function B4(t,e){var n=go();e=e===void 0?null:e;var r=n.memoizedState;return r!==null&&e!==null&&gM(e,r[1])?r[0]:(n.memoizedState=[t,e],t)}function F4(t,e){var n=go();e=e===void 0?null:e;var r=n.memoizedState;return r!==null&&e!==null&&gM(e,r[1])?r[0]:(t=t(),n.memoizedState=[t,e],t)}function $4(t,e,n){return od&21?(jo(n,e)||(n=GF(),Kn.lanes|=n,ad|=n,t.baseState=!0),e):(t.baseState&&(t.baseState=!1,Ji=!0),t.memoizedState=n)}function eK(t,e){var n=xn;xn=n!==0&&4>n?n:4,t(!0);var r=jw.transition;jw.transition={};try{t(!1),e()}finally{xn=n,jw.transition=r}}function U4(){return go().memoizedState}function tK(t,e,n){var r=yc(t);if(n={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null},z4(t))G4(e,n);else if(n=v4(t,e,n,r),n!==null){var i=Li();Wo(n,t,r,i),H4(n,e,r)}}function nK(t,e,n){var r=yc(t),i={lane:r,action:n,hasEagerState:!1,eagerState:null,next:null};if(z4(t))G4(e,i);else{var s=t.alternate;if(t.lanes===0&&(s===null||s.lanes===0)&&(s=e.lastRenderedReducer,s!==null))try{var o=e.lastRenderedState,a=s(o,n);if(i.hasEagerState=!0,i.eagerState=a,jo(a,o)){var l=e.interleaved;l===null?(i.next=i,dM(e)):(i.next=l.next,l.next=i),e.interleaved=i;return}}catch{}finally{}n=v4(t,e,i,r),n!==null&&(i=Li(),Wo(n,t,r,i),H4(n,e,r))}}function z4(t){var e=t.alternate;return t===Kn||e!==null&&e===Kn}function G4(t,e){Ym=C1=!0;var n=t.pending;n===null?e.next=e:(e.next=n.next,n.next=e),t.pending=e}function H4(t,e,n){if(n&4194240){var r=e.lanes;r&=t.pendingLanes,n|=r,e.lanes=n,YT(t,n)}}var E1={readContext:mo,useCallback:ai,useContext:ai,useEffect:ai,useImperativeHandle:ai,useInsertionEffect:ai,useLayoutEffect:ai,useMemo:ai,useReducer:ai,useRef:ai,useState:ai,useDebugValue:ai,useDeferredValue:ai,useTransition:ai,useMutableSource:ai,useSyncExternalStore:ai,useId:ai,unstable_isNewReconciler:!1},rK={readContext:mo,useCallback:function(t,e){return fa().memoizedState=[t,e===void 0?null:e],t},useContext:mo,useEffect:IP,useImperativeHandle:function(t,e,n){return n=n!=null?n.concat([t]):null,Ox(4194308,4,O4.bind(null,e,t),n)},useLayoutEffect:function(t,e){return Ox(4194308,4,t,e)},useInsertionEffect:function(t,e){return Ox(4,2,t,e)},useMemo:function(t,e){var n=fa();return e=e===void 0?null:e,t=t(),n.memoizedState=[t,e],t},useReducer:function(t,e,n){var r=fa();return e=n!==void 0?n(e):e,r.memoizedState=r.baseState=e,t={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:t,lastRenderedState:e},r.queue=t,t=t.dispatch=tK.bind(null,Kn,t),[r.memoizedState,t]},useRef:function(t){var e=fa();return t={current:t},e.memoizedState=t},useState:RP,useDebugValue:bM,useDeferredValue:function(t){return fa().memoizedState=t},useTransition:function(){var t=RP(!1),e=t[0];return t=eK.bind(null,t[1]),fa().memoizedState=t,[e,t]},useMutableSource:function(){},useSyncExternalStore:function(t,e,n){var r=Kn,i=fa();if(Gn){if(n===void 0)throw Error(ze(407));n=n()}else{if(n=e(),Gr===null)throw Error(ze(349));od&30||T4(r,e,n)}i.memoizedState=n;var s={value:n,getSnapshot:e};return i.queue=s,IP(R4.bind(null,r,s,t),[t]),r.flags|=2048,Eg(9,M4.bind(null,r,s,n,e),void 0,null),n},useId:function(){var t=fa(),e=Gr.identifierPrefix;if(Gn){var n=sl,r=il;n=(r&~(1<<32-Vo(r)-1)).toString(32)+n,e=":"+e+"R"+n,n=wg++,0<n&&(e+="H"+n.toString(32)),e+=":"}else n=ZX++,e=":"+e+"r"+n.toString(32)+":";return t.memoizedState=e},unstable_isNewReconciler:!1},iK={readContext:mo,useCallback:B4,useContext:mo,useEffect:xM,useImperativeHandle:L4,useInsertionEffect:k4,useLayoutEffect:D4,useMemo:F4,useReducer:Xw,useRef:P4,useState:function(){return Xw(Cg)},useDebugValue:bM,useDeferredValue:function(t){var e=go();return $4(e,Mr.memoizedState,t)},useTransition:function(){var t=Xw(Cg)[0],e=go().memoizedState;return[t,e]},useMutableSource:E4,useSyncExternalStore:A4,useId:U4,unstable_isNewReconciler:!1},sK={readContext:mo,useCallback:B4,useContext:mo,useEffect:xM,useImperativeHandle:L4,useInsertionEffect:k4,useLayoutEffect:D4,useMemo:F4,useReducer:Kw,useRef:P4,useState:function(){return Kw(Cg)},useDebugValue:bM,useDeferredValue:function(t){var e=go();return Mr===null?e.memoizedState=t:$4(e,Mr.memoizedState,t)},useTransition:function(){var t=Kw(Cg)[0],e=go().memoizedState;return[t,e]},useMutableSource:E4,useSyncExternalStore:A4,useId:U4,unstable_isNewReconciler:!1};function kh(t,e){try{var n="",r=e;do n+=kj(r),r=r.return;while(r);var i=n}catch(s){i=`
Error generating stack: `+s.message+`
`+s.stack}return{value:t,source:e,stack:i,digest:null}}function qw(t,e,n){return{value:t,source:null,stack:n??null,digest:e??null}}function EA(t,e){try{console.error(e.value)}catch(n){setTimeout(function(){throw n})}}var oK=typeof WeakMap=="function"?WeakMap:Map;function V4(t,e,n){n=ll(-1,n),n.tag=3,n.payload={element:null};var r=e.value;return n.callback=function(){T1||(T1=!0,OA=r),EA(t,e)},n}function W4(t,e,n){n=ll(-1,n),n.tag=3;var r=t.type.getDerivedStateFromError;if(typeof r=="function"){var i=e.value;n.payload=function(){return r(i)},n.callback=function(){EA(t,e)}}var s=t.stateNode;return s!==null&&typeof s.componentDidCatch=="function"&&(n.callback=function(){EA(t,e),typeof r!="function"&&(gc===null?gc=new Set([this]):gc.add(this));var o=e.stack;this.componentDidCatch(e.value,{componentStack:o!==null?o:""})}),n}function NP(t,e,n){var r=t.pingCache;if(r===null){r=t.pingCache=new oK;var i=new Set;r.set(e,i)}else i=r.get(e),i===void 0&&(i=new Set,r.set(e,i));i.has(n)||(i.add(n),t=bK.bind(null,t,e,n),e.then(t,t))}function PP(t){do{var e;if((e=t.tag===13)&&(e=t.memoizedState,e=e!==null?e.dehydrated!==null:!0),e)return t;t=t.return}while(t!==null);return null}function kP(t,e,n,r,i){return t.mode&1?(t.flags|=65536,t.lanes=i,t):(t===e?t.flags|=65536:(t.flags|=128,n.flags|=131072,n.flags&=-52805,n.tag===1&&(n.alternate===null?n.tag=17:(e=ll(-1,1),e.tag=2,mc(n,e,1))),n.lanes|=1),t)}var aK=El.ReactCurrentOwner,Ji=!1;function Ni(t,e,n,r){e.child=t===null?w4(e,null,n,r):Nh(e,t.child,n,r)}function DP(t,e,n,r,i){n=n.render;var s=e.ref;return mh(e,i),r=yM(t,e,n,r,s,i),n=vM(),t!==null&&!Ji?(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~i,vl(t,e,i)):(Gn&&n&&sM(e),e.flags|=1,Ni(t,e,r,i),e.child)}function OP(t,e,n,r,i){if(t===null){var s=n.type;return typeof s=="function"&&!MM(s)&&s.defaultProps===void 0&&n.compare===null&&n.defaultProps===void 0?(e.tag=15,e.type=s,j4(t,e,s,r,i)):(t=$x(n.type,null,r,e,e.mode,i),t.ref=e.ref,t.return=e,e.child=t)}if(s=t.child,!(t.lanes&i)){var o=s.memoizedProps;if(n=n.compare,n=n!==null?n:yg,n(o,r)&&t.ref===e.ref)return vl(t,e,i)}return e.flags|=1,t=vc(s,r),t.ref=e.ref,t.return=e,e.child=t}function j4(t,e,n,r,i){if(t!==null){var s=t.memoizedProps;if(yg(s,r)&&t.ref===e.ref)if(Ji=!1,e.pendingProps=r=s,(t.lanes&i)!==0)t.flags&131072&&(Ji=!0);else return e.lanes=t.lanes,vl(t,e,i)}return AA(t,e,n,r,i)}function X4(t,e,n){var r=e.pendingProps,i=r.children,s=t!==null?t.memoizedState:null;if(r.mode==="hidden")if(!(e.mode&1))e.memoizedState={baseLanes:0,cachePool:null,transitions:null},In(rh,vs),vs|=n;else{if(!(n&1073741824))return t=s!==null?s.baseLanes|n:n,e.lanes=e.childLanes=1073741824,e.memoizedState={baseLanes:t,cachePool:null,transitions:null},e.updateQueue=null,In(rh,vs),vs|=t,null;e.memoizedState={baseLanes:0,cachePool:null,transitions:null},r=s!==null?s.baseLanes:n,In(rh,vs),vs|=r}else s!==null?(r=s.baseLanes|n,e.memoizedState=null):r=n,In(rh,vs),vs|=r;return Ni(t,e,i,n),e.child}function K4(t,e){var n=e.ref;(t===null&&n!==null||t!==null&&t.ref!==n)&&(e.flags|=512,e.flags|=2097152)}function AA(t,e,n,r,i){var s=ts(n)?id:xi.current;return s=Rh(e,s),mh(e,i),n=yM(t,e,n,r,s,i),r=vM(),t!==null&&!Ji?(e.updateQueue=t.updateQueue,e.flags&=-2053,t.lanes&=~i,vl(t,e,i)):(Gn&&r&&sM(e),e.flags|=1,Ni(t,e,n,i),e.child)}function LP(t,e,n,r,i){if(ts(n)){var s=!0;y1(e)}else s=!1;if(mh(e,i),e.stateNode===null)Lx(t,e),S4(e,n,r),CA(e,n,r,i),r=!0;else if(t===null){var o=e.stateNode,a=e.memoizedProps;o.props=a;var l=o.context,c=n.contextType;typeof c=="object"&&c!==null?c=mo(c):(c=ts(n)?id:xi.current,c=Rh(e,c));var u=n.getDerivedStateFromProps,d=typeof u=="function"||typeof o.getSnapshotBeforeUpdate=="function";d||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(a!==r||l!==c)&&TP(e,o,r,c),tc=!1;var f=e.memoizedState;o.state=f,_1(e,r,o,i),l=e.memoizedState,a!==r||f!==l||es.current||tc?(typeof u=="function"&&(wA(e,n,u,r),l=e.memoizedState),(a=tc||AP(e,n,a,r,f,l,c))?(d||typeof o.UNSAFE_componentWillMount!="function"&&typeof o.componentWillMount!="function"||(typeof o.componentWillMount=="function"&&o.componentWillMount(),typeof o.UNSAFE_componentWillMount=="function"&&o.UNSAFE_componentWillMount()),typeof o.componentDidMount=="function"&&(e.flags|=4194308)):(typeof o.componentDidMount=="function"&&(e.flags|=4194308),e.memoizedProps=r,e.memoizedState=l),o.props=r,o.state=l,o.context=c,r=a):(typeof o.componentDidMount=="function"&&(e.flags|=4194308),r=!1)}else{o=e.stateNode,x4(t,e),a=e.memoizedProps,c=e.type===e.elementType?a:Po(e.type,a),o.props=c,d=e.pendingProps,f=o.context,l=n.contextType,typeof l=="object"&&l!==null?l=mo(l):(l=ts(n)?id:xi.current,l=Rh(e,l));var h=n.getDerivedStateFromProps;(u=typeof h=="function"||typeof o.getSnapshotBeforeUpdate=="function")||typeof o.UNSAFE_componentWillReceiveProps!="function"&&typeof o.componentWillReceiveProps!="function"||(a!==d||f!==l)&&TP(e,o,r,l),tc=!1,f=e.memoizedState,o.state=f,_1(e,r,o,i);var p=e.memoizedState;a!==d||f!==p||es.current||tc?(typeof h=="function"&&(wA(e,n,h,r),p=e.memoizedState),(c=tc||AP(e,n,c,r,f,p,l)||!1)?(u||typeof o.UNSAFE_componentWillUpdate!="function"&&typeof o.componentWillUpdate!="function"||(typeof o.componentWillUpdate=="function"&&o.componentWillUpdate(r,p,l),typeof o.UNSAFE_componentWillUpdate=="function"&&o.UNSAFE_componentWillUpdate(r,p,l)),typeof o.componentDidUpdate=="function"&&(e.flags|=4),typeof o.getSnapshotBeforeUpdate=="function"&&(e.flags|=1024)):(typeof o.componentDidUpdate!="function"||a===t.memoizedProps&&f===t.memoizedState||(e.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||a===t.memoizedProps&&f===t.memoizedState||(e.flags|=1024),e.memoizedProps=r,e.memoizedState=p),o.props=r,o.state=p,o.context=l,r=c):(typeof o.componentDidUpdate!="function"||a===t.memoizedProps&&f===t.memoizedState||(e.flags|=4),typeof o.getSnapshotBeforeUpdate!="function"||a===t.memoizedProps&&f===t.memoizedState||(e.flags|=1024),r=!1)}return TA(t,e,n,r,s,i)}function TA(t,e,n,r,i,s){K4(t,e);var o=(e.flags&128)!==0;if(!r&&!o)return i&&SP(e,n,!1),vl(t,e,s);r=e.stateNode,aK.current=e;var a=o&&typeof n.getDerivedStateFromError!="function"?null:r.render();return e.flags|=1,t!==null&&o?(e.child=Nh(e,t.child,null,s),e.child=Nh(e,null,a,s)):Ni(t,e,a,s),e.memoizedState=r.state,i&&SP(e,n,!0),e.child}function q4(t){var e=t.stateNode;e.pendingContext?bP(t,e.pendingContext,e.pendingContext!==e.context):e.context&&bP(t,e.context,!1),hM(t,e.containerInfo)}function BP(t,e,n,r,i){return Ih(),aM(i),e.flags|=256,Ni(t,e,n,r),e.child}var MA={dehydrated:null,treeContext:null,retryLane:0};function RA(t){return{baseLanes:t,cachePool:null,transitions:null}}function J4(t,e,n){var r=e.pendingProps,i=jn.current,s=!1,o=(e.flags&128)!==0,a;if((a=o)||(a=t!==null&&t.memoizedState===null?!1:(i&2)!==0),a?(s=!0,e.flags&=-129):(t===null||t.memoizedState!==null)&&(i|=1),In(jn,i&1),t===null)return SA(e),t=e.memoizedState,t!==null&&(t=t.dehydrated,t!==null)?(e.mode&1?t.data==="$!"?e.lanes=8:e.lanes=1073741824:e.lanes=1,null):(o=r.children,t=r.fallback,s?(r=e.mode,s=e.child,o={mode:"hidden",children:o},!(r&1)&&s!==null?(s.childLanes=0,s.pendingProps=o):s=bb(o,r,0,null),t=Xu(t,r,n,null),s.return=e,t.return=e,s.sibling=t,e.child=s,e.child.memoizedState=RA(n),e.memoizedState=MA,t):SM(e,o));if(i=t.memoizedState,i!==null&&(a=i.dehydrated,a!==null))return lK(t,e,o,r,a,i,n);if(s){s=r.fallback,o=e.mode,i=t.child,a=i.sibling;var l={mode:"hidden",children:r.children};return!(o&1)&&e.child!==i?(r=e.child,r.childLanes=0,r.pendingProps=l,e.deletions=null):(r=vc(i,l),r.subtreeFlags=i.subtreeFlags&14680064),a!==null?s=vc(a,s):(s=Xu(s,o,n,null),s.flags|=2),s.return=e,r.return=e,r.sibling=s,e.child=r,r=s,s=e.child,o=t.child.memoizedState,o=o===null?RA(n):{baseLanes:o.baseLanes|n,cachePool:null,transitions:o.transitions},s.memoizedState=o,s.childLanes=t.childLanes&~n,e.memoizedState=MA,r}return s=t.child,t=s.sibling,r=vc(s,{mode:"visible",children:r.children}),!(e.mode&1)&&(r.lanes=n),r.return=e,r.sibling=null,t!==null&&(n=e.deletions,n===null?(e.deletions=[t],e.flags|=16):n.push(t)),e.child=r,e.memoizedState=null,r}function SM(t,e){return e=bb({mode:"visible",children:e},t.mode,0,null),e.return=t,t.child=e}function av(t,e,n,r){return r!==null&&aM(r),Nh(e,t.child,null,n),t=SM(e,e.pendingProps.children),t.flags|=2,e.memoizedState=null,t}function lK(t,e,n,r,i,s,o){if(n)return e.flags&256?(e.flags&=-257,r=qw(Error(ze(422))),av(t,e,o,r)):e.memoizedState!==null?(e.child=t.child,e.flags|=128,null):(s=r.fallback,i=e.mode,r=bb({mode:"visible",children:r.children},i,0,null),s=Xu(s,i,o,null),s.flags|=2,r.return=e,s.return=e,r.sibling=s,e.child=r,e.mode&1&&Nh(e,t.child,null,o),e.child.memoizedState=RA(o),e.memoizedState=MA,s);if(!(e.mode&1))return av(t,e,o,null);if(i.data==="$!"){if(r=i.nextSibling&&i.nextSibling.dataset,r)var a=r.dgst;return r=a,s=Error(ze(419)),r=qw(s,r,void 0),av(t,e,o,r)}if(a=(o&t.childLanes)!==0,Ji||a){if(r=Gr,r!==null){switch(o&-o){case 4:i=2;break;case 16:i=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:i=32;break;case 536870912:i=268435456;break;default:i=0}i=i&(r.suspendedLanes|o)?0:i,i!==0&&i!==s.retryLane&&(s.retryLane=i,yl(t,i),Wo(r,t,i,-1))}return TM(),r=qw(Error(ze(421))),av(t,e,o,r)}return i.data==="$?"?(e.flags|=128,e.child=t.child,e=SK.bind(null,t),i._reactRetry=e,null):(t=s.treeContext,_s=pc(i.nextSibling),Es=e,Gn=!0,Lo=null,t!==null&&(no[ro++]=il,no[ro++]=sl,no[ro++]=sd,il=t.id,sl=t.overflow,sd=e),e=SM(e,r.children),e.flags|=4096,e)}function FP(t,e,n){t.lanes|=e;var r=t.alternate;r!==null&&(r.lanes|=e),_A(t.return,e,n)}function Jw(t,e,n,r,i){var s=t.memoizedState;s===null?t.memoizedState={isBackwards:e,rendering:null,renderingStartTime:0,last:r,tail:n,tailMode:i}:(s.isBackwards=e,s.rendering=null,s.renderingStartTime=0,s.last=r,s.tail=n,s.tailMode=i)}function Y4(t,e,n){var r=e.pendingProps,i=r.revealOrder,s=r.tail;if(Ni(t,e,r.children,n),r=jn.current,r&2)r=r&1|2,e.flags|=128;else{if(t!==null&&t.flags&128)e:for(t=e.child;t!==null;){if(t.tag===13)t.memoizedState!==null&&FP(t,n,e);else if(t.tag===19)FP(t,n,e);else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break e;for(;t.sibling===null;){if(t.return===null||t.return===e)break e;t=t.return}t.sibling.return=t.return,t=t.sibling}r&=1}if(In(jn,r),!(e.mode&1))e.memoizedState=null;else switch(i){case"forwards":for(n=e.child,i=null;n!==null;)t=n.alternate,t!==null&&w1(t)===null&&(i=n),n=n.sibling;n=i,n===null?(i=e.child,e.child=null):(i=n.sibling,n.sibling=null),Jw(e,!1,i,n,s);break;case"backwards":for(n=null,i=e.child,e.child=null;i!==null;){if(t=i.alternate,t!==null&&w1(t)===null){e.child=i;break}t=i.sibling,i.sibling=n,n=i,i=t}Jw(e,!0,n,null,s);break;case"together":Jw(e,!1,null,null,void 0);break;default:e.memoizedState=null}return e.child}function Lx(t,e){!(e.mode&1)&&t!==null&&(t.alternate=null,e.alternate=null,e.flags|=2)}function vl(t,e,n){if(t!==null&&(e.dependencies=t.dependencies),ad|=e.lanes,!(n&e.childLanes))return null;if(t!==null&&e.child!==t.child)throw Error(ze(153));if(e.child!==null){for(t=e.child,n=vc(t,t.pendingProps),e.child=n,n.return=e;t.sibling!==null;)t=t.sibling,n=n.sibling=vc(t,t.pendingProps),n.return=e;n.sibling=null}return e.child}function cK(t,e,n){switch(e.tag){case 3:q4(e),Ih();break;case 5:C4(e);break;case 1:ts(e.type)&&y1(e);break;case 4:hM(e,e.stateNode.containerInfo);break;case 10:var r=e.type._context,i=e.memoizedProps.value;In(b1,r._currentValue),r._currentValue=i;break;case 13:if(r=e.memoizedState,r!==null)return r.dehydrated!==null?(In(jn,jn.current&1),e.flags|=128,null):n&e.child.childLanes?J4(t,e,n):(In(jn,jn.current&1),t=vl(t,e,n),t!==null?t.sibling:null);In(jn,jn.current&1);break;case 19:if(r=(n&e.childLanes)!==0,t.flags&128){if(r)return Y4(t,e,n);e.flags|=128}if(i=e.memoizedState,i!==null&&(i.rendering=null,i.tail=null,i.lastEffect=null),In(jn,jn.current),r)break;return null;case 22:case 23:return e.lanes=0,X4(t,e,n)}return vl(t,e,n)}var Q4,IA,Z4,e$;Q4=function(t,e){for(var n=e.child;n!==null;){if(n.tag===5||n.tag===6)t.appendChild(n.stateNode);else if(n.tag!==4&&n.child!==null){n.child.return=n,n=n.child;continue}if(n===e)break;for(;n.sibling===null;){if(n.return===null||n.return===e)return;n=n.return}n.sibling.return=n.return,n=n.sibling}};IA=function(){};Z4=function(t,e,n,r){var i=t.memoizedProps;if(i!==r){t=e.stateNode,Nu(_a.current);var s=null;switch(n){case"input":i=QE(t,i),r=QE(t,r),s=[];break;case"select":i=Jn({},i,{value:void 0}),r=Jn({},r,{value:void 0}),s=[];break;case"textarea":i=tA(t,i),r=tA(t,r),s=[];break;default:typeof i.onClick!="function"&&typeof r.onClick=="function"&&(t.onclick=m1)}rA(n,r);var o;n=null;for(c in i)if(!r.hasOwnProperty(c)&&i.hasOwnProperty(c)&&i[c]!=null)if(c==="style"){var a=i[c];for(o in a)a.hasOwnProperty(o)&&(n||(n={}),n[o]="")}else c!=="dangerouslySetInnerHTML"&&c!=="children"&&c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&c!=="autoFocus"&&(ug.hasOwnProperty(c)?s||(s=[]):(s=s||[]).push(c,null));for(c in r){var l=r[c];if(a=i!=null?i[c]:void 0,r.hasOwnProperty(c)&&l!==a&&(l!=null||a!=null))if(c==="style")if(a){for(o in a)!a.hasOwnProperty(o)||l&&l.hasOwnProperty(o)||(n||(n={}),n[o]="");for(o in l)l.hasOwnProperty(o)&&a[o]!==l[o]&&(n||(n={}),n[o]=l[o])}else n||(s||(s=[]),s.push(c,n)),n=l;else c==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,a=a?a.__html:void 0,l!=null&&a!==l&&(s=s||[]).push(c,l)):c==="children"?typeof l!="string"&&typeof l!="number"||(s=s||[]).push(c,""+l):c!=="suppressContentEditableWarning"&&c!=="suppressHydrationWarning"&&(ug.hasOwnProperty(c)?(l!=null&&c==="onScroll"&&Dn("scroll",t),s||a===l||(s=[])):(s=s||[]).push(c,l))}n&&(s=s||[]).push("style",n);var c=s;(e.updateQueue=c)&&(e.flags|=4)}};e$=function(t,e,n,r){n!==r&&(e.flags|=4)};function im(t,e){if(!Gn)switch(t.tailMode){case"hidden":e=t.tail;for(var n=null;e!==null;)e.alternate!==null&&(n=e),e=e.sibling;n===null?t.tail=null:n.sibling=null;break;case"collapsed":n=t.tail;for(var r=null;n!==null;)n.alternate!==null&&(r=n),n=n.sibling;r===null?e||t.tail===null?t.tail=null:t.tail.sibling=null:r.sibling=null}}function li(t){var e=t.alternate!==null&&t.alternate.child===t.child,n=0,r=0;if(e)for(var i=t.child;i!==null;)n|=i.lanes|i.childLanes,r|=i.subtreeFlags&14680064,r|=i.flags&14680064,i.return=t,i=i.sibling;else for(i=t.child;i!==null;)n|=i.lanes|i.childLanes,r|=i.subtreeFlags,r|=i.flags,i.return=t,i=i.sibling;return t.subtreeFlags|=r,t.childLanes=n,e}function uK(t,e,n){var r=e.pendingProps;switch(oM(e),e.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return li(e),null;case 1:return ts(e.type)&&g1(),li(e),null;case 3:return r=e.stateNode,Ph(),Ln(es),Ln(xi),mM(),r.pendingContext&&(r.context=r.pendingContext,r.pendingContext=null),(t===null||t.child===null)&&(sv(e)?e.flags|=4:t===null||t.memoizedState.isDehydrated&&!(e.flags&256)||(e.flags|=1024,Lo!==null&&(FA(Lo),Lo=null))),IA(t,e),li(e),null;case 5:pM(e);var i=Nu(_g.current);if(n=e.type,t!==null&&e.stateNode!=null)Z4(t,e,n,r,i),t.ref!==e.ref&&(e.flags|=512,e.flags|=2097152);else{if(!r){if(e.stateNode===null)throw Error(ze(166));return li(e),null}if(t=Nu(_a.current),sv(e)){r=e.stateNode,n=e.type;var s=e.memoizedProps;switch(r[ya]=e,r[bg]=s,t=(e.mode&1)!==0,n){case"dialog":Dn("cancel",r),Dn("close",r);break;case"iframe":case"object":case"embed":Dn("load",r);break;case"video":case"audio":for(i=0;i<Bm.length;i++)Dn(Bm[i],r);break;case"source":Dn("error",r);break;case"img":case"image":case"link":Dn("error",r),Dn("load",r);break;case"details":Dn("toggle",r);break;case"input":X3(r,s),Dn("invalid",r);break;case"select":r._wrapperState={wasMultiple:!!s.multiple},Dn("invalid",r);break;case"textarea":q3(r,s),Dn("invalid",r)}rA(n,s),i=null;for(var o in s)if(s.hasOwnProperty(o)){var a=s[o];o==="children"?typeof a=="string"?r.textContent!==a&&(s.suppressHydrationWarning!==!0&&iv(r.textContent,a,t),i=["children",a]):typeof a=="number"&&r.textContent!==""+a&&(s.suppressHydrationWarning!==!0&&iv(r.textContent,a,t),i=["children",""+a]):ug.hasOwnProperty(o)&&a!=null&&o==="onScroll"&&Dn("scroll",r)}switch(n){case"input":Jy(r),K3(r,s,!0);break;case"textarea":Jy(r),J3(r);break;case"select":case"option":break;default:typeof s.onClick=="function"&&(r.onclick=m1)}r=i,e.updateQueue=r,r!==null&&(e.flags|=4)}else{o=i.nodeType===9?i:i.ownerDocument,t==="http://www.w3.org/1999/xhtml"&&(t=TF(n)),t==="http://www.w3.org/1999/xhtml"?n==="script"?(t=o.createElement("div"),t.innerHTML="<script><\/script>",t=t.removeChild(t.firstChild)):typeof r.is=="string"?t=o.createElement(n,{is:r.is}):(t=o.createElement(n),n==="select"&&(o=t,r.multiple?o.multiple=!0:r.size&&(o.size=r.size))):t=o.createElementNS(t,n),t[ya]=e,t[bg]=r,Q4(t,e,!1,!1),e.stateNode=t;e:{switch(o=iA(n,r),n){case"dialog":Dn("cancel",t),Dn("close",t),i=r;break;case"iframe":case"object":case"embed":Dn("load",t),i=r;break;case"video":case"audio":for(i=0;i<Bm.length;i++)Dn(Bm[i],t);i=r;break;case"source":Dn("error",t),i=r;break;case"img":case"image":case"link":Dn("error",t),Dn("load",t),i=r;break;case"details":Dn("toggle",t),i=r;break;case"input":X3(t,r),i=QE(t,r),Dn("invalid",t);break;case"option":i=r;break;case"select":t._wrapperState={wasMultiple:!!r.multiple},i=Jn({},r,{value:void 0}),Dn("invalid",t);break;case"textarea":q3(t,r),i=tA(t,r),Dn("invalid",t);break;default:i=r}rA(n,i),a=i;for(s in a)if(a.hasOwnProperty(s)){var l=a[s];s==="style"?IF(t,l):s==="dangerouslySetInnerHTML"?(l=l?l.__html:void 0,l!=null&&MF(t,l)):s==="children"?typeof l=="string"?(n!=="textarea"||l!=="")&&dg(t,l):typeof l=="number"&&dg(t,""+l):s!=="suppressContentEditableWarning"&&s!=="suppressHydrationWarning"&&s!=="autoFocus"&&(ug.hasOwnProperty(s)?l!=null&&s==="onScroll"&&Dn("scroll",t):l!=null&&WT(t,s,l,o))}switch(n){case"input":Jy(t),K3(t,r,!1);break;case"textarea":Jy(t),J3(t);break;case"option":r.value!=null&&t.setAttribute("value",""+wc(r.value));break;case"select":t.multiple=!!r.multiple,s=r.value,s!=null?dh(t,!!r.multiple,s,!1):r.defaultValue!=null&&dh(t,!!r.multiple,r.defaultValue,!0);break;default:typeof i.onClick=="function"&&(t.onclick=m1)}switch(n){case"button":case"input":case"select":case"textarea":r=!!r.autoFocus;break e;case"img":r=!0;break e;default:r=!1}}r&&(e.flags|=4)}e.ref!==null&&(e.flags|=512,e.flags|=2097152)}return li(e),null;case 6:if(t&&e.stateNode!=null)e$(t,e,t.memoizedProps,r);else{if(typeof r!="string"&&e.stateNode===null)throw Error(ze(166));if(n=Nu(_g.current),Nu(_a.current),sv(e)){if(r=e.stateNode,n=e.memoizedProps,r[ya]=e,(s=r.nodeValue!==n)&&(t=Es,t!==null))switch(t.tag){case 3:iv(r.nodeValue,n,(t.mode&1)!==0);break;case 5:t.memoizedProps.suppressHydrationWarning!==!0&&iv(r.nodeValue,n,(t.mode&1)!==0)}s&&(e.flags|=4)}else r=(n.nodeType===9?n:n.ownerDocument).createTextNode(r),r[ya]=e,e.stateNode=r}return li(e),null;case 13:if(Ln(jn),r=e.memoizedState,t===null||t.memoizedState!==null&&t.memoizedState.dehydrated!==null){if(Gn&&_s!==null&&e.mode&1&&!(e.flags&128))y4(),Ih(),e.flags|=98560,s=!1;else if(s=sv(e),r!==null&&r.dehydrated!==null){if(t===null){if(!s)throw Error(ze(318));if(s=e.memoizedState,s=s!==null?s.dehydrated:null,!s)throw Error(ze(317));s[ya]=e}else Ih(),!(e.flags&128)&&(e.memoizedState=null),e.flags|=4;li(e),s=!1}else Lo!==null&&(FA(Lo),Lo=null),s=!0;if(!s)return e.flags&65536?e:null}return e.flags&128?(e.lanes=n,e):(r=r!==null,r!==(t!==null&&t.memoizedState!==null)&&r&&(e.child.flags|=8192,e.mode&1&&(t===null||jn.current&1?Ir===0&&(Ir=3):TM())),e.updateQueue!==null&&(e.flags|=4),li(e),null);case 4:return Ph(),IA(t,e),t===null&&vg(e.stateNode.containerInfo),li(e),null;case 10:return uM(e.type._context),li(e),null;case 17:return ts(e.type)&&g1(),li(e),null;case 19:if(Ln(jn),s=e.memoizedState,s===null)return li(e),null;if(r=(e.flags&128)!==0,o=s.rendering,o===null)if(r)im(s,!1);else{if(Ir!==0||t!==null&&t.flags&128)for(t=e.child;t!==null;){if(o=w1(t),o!==null){for(e.flags|=128,im(s,!1),r=o.updateQueue,r!==null&&(e.updateQueue=r,e.flags|=4),e.subtreeFlags=0,r=n,n=e.child;n!==null;)s=n,t=r,s.flags&=14680066,o=s.alternate,o===null?(s.childLanes=0,s.lanes=t,s.child=null,s.subtreeFlags=0,s.memoizedProps=null,s.memoizedState=null,s.updateQueue=null,s.dependencies=null,s.stateNode=null):(s.childLanes=o.childLanes,s.lanes=o.lanes,s.child=o.child,s.subtreeFlags=0,s.deletions=null,s.memoizedProps=o.memoizedProps,s.memoizedState=o.memoizedState,s.updateQueue=o.updateQueue,s.type=o.type,t=o.dependencies,s.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext}),n=n.sibling;return In(jn,jn.current&1|2),e.child}t=t.sibling}s.tail!==null&&fr()>Dh&&(e.flags|=128,r=!0,im(s,!1),e.lanes=4194304)}else{if(!r)if(t=w1(o),t!==null){if(e.flags|=128,r=!0,n=t.updateQueue,n!==null&&(e.updateQueue=n,e.flags|=4),im(s,!0),s.tail===null&&s.tailMode==="hidden"&&!o.alternate&&!Gn)return li(e),null}else 2*fr()-s.renderingStartTime>Dh&&n!==1073741824&&(e.flags|=128,r=!0,im(s,!1),e.lanes=4194304);s.isBackwards?(o.sibling=e.child,e.child=o):(n=s.last,n!==null?n.sibling=o:e.child=o,s.last=o)}return s.tail!==null?(e=s.tail,s.rendering=e,s.tail=e.sibling,s.renderingStartTime=fr(),e.sibling=null,n=jn.current,In(jn,r?n&1|2:n&1),e):(li(e),null);case 22:case 23:return AM(),r=e.memoizedState!==null,t!==null&&t.memoizedState!==null!==r&&(e.flags|=8192),r&&e.mode&1?vs&1073741824&&(li(e),e.subtreeFlags&6&&(e.flags|=8192)):li(e),null;case 24:return null;case 25:return null}throw Error(ze(156,e.tag))}function dK(t,e){switch(oM(e),e.tag){case 1:return ts(e.type)&&g1(),t=e.flags,t&65536?(e.flags=t&-65537|128,e):null;case 3:return Ph(),Ln(es),Ln(xi),mM(),t=e.flags,t&65536&&!(t&128)?(e.flags=t&-65537|128,e):null;case 5:return pM(e),null;case 13:if(Ln(jn),t=e.memoizedState,t!==null&&t.dehydrated!==null){if(e.alternate===null)throw Error(ze(340));Ih()}return t=e.flags,t&65536?(e.flags=t&-65537|128,e):null;case 19:return Ln(jn),null;case 4:return Ph(),null;case 10:return uM(e.type._context),null;case 22:case 23:return AM(),null;case 24:return null;default:return null}}var lv=!1,pi=!1,fK=typeof WeakSet=="function"?WeakSet:Set,lt=null;function nh(t,e){var n=t.ref;if(n!==null)if(typeof n=="function")try{n(null)}catch(r){ir(t,e,r)}else n.current=null}function NA(t,e,n){try{n()}catch(r){ir(t,e,r)}}var $P=!1;function hK(t,e){if(pA=f1,t=i4(),iM(t)){if("selectionStart"in t)var n={start:t.selectionStart,end:t.selectionEnd};else e:{n=(n=t.ownerDocument)&&n.defaultView||window;var r=n.getSelection&&n.getSelection();if(r&&r.rangeCount!==0){n=r.anchorNode;var i=r.anchorOffset,s=r.focusNode;r=r.focusOffset;try{n.nodeType,s.nodeType}catch{n=null;break e}var o=0,a=-1,l=-1,c=0,u=0,d=t,f=null;t:for(;;){for(var h;d!==n||i!==0&&d.nodeType!==3||(a=o+i),d!==s||r!==0&&d.nodeType!==3||(l=o+r),d.nodeType===3&&(o+=d.nodeValue.length),(h=d.firstChild)!==null;)f=d,d=h;for(;;){if(d===t)break t;if(f===n&&++c===i&&(a=o),f===s&&++u===r&&(l=o),(h=d.nextSibling)!==null)break;d=f,f=d.parentNode}d=h}n=a===-1||l===-1?null:{start:a,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(mA={focusedElem:t,selectionRange:n},f1=!1,lt=e;lt!==null;)if(e=lt,t=e.child,(e.subtreeFlags&1028)!==0&&t!==null)t.return=e,lt=t;else for(;lt!==null;){e=lt;try{var p=e.alternate;if(e.flags&1024)switch(e.tag){case 0:case 11:case 15:break;case 1:if(p!==null){var x=p.memoizedProps,v=p.memoizedState,y=e.stateNode,b=y.getSnapshotBeforeUpdate(e.elementType===e.type?x:Po(e.type,x),v);y.__reactInternalSnapshotBeforeUpdate=b}break;case 3:var S=e.stateNode.containerInfo;S.nodeType===1?S.textContent="":S.nodeType===9&&S.documentElement&&S.removeChild(S.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(ze(163))}}catch(w){ir(e,e.return,w)}if(t=e.sibling,t!==null){t.return=e.return,lt=t;break}lt=e.return}return p=$P,$P=!1,p}function Qm(t,e,n){var r=e.updateQueue;if(r=r!==null?r.lastEffect:null,r!==null){var i=r=r.next;do{if((i.tag&t)===t){var s=i.destroy;i.destroy=void 0,s!==void 0&&NA(e,n,s)}i=i.next}while(i!==r)}}function vb(t,e){if(e=e.updateQueue,e=e!==null?e.lastEffect:null,e!==null){var n=e=e.next;do{if((n.tag&t)===t){var r=n.create;n.destroy=r()}n=n.next}while(n!==e)}}function PA(t){var e=t.ref;if(e!==null){var n=t.stateNode;switch(t.tag){case 5:t=n;break;default:t=n}typeof e=="function"?e(t):e.current=t}}function t$(t){var e=t.alternate;e!==null&&(t.alternate=null,t$(e)),t.child=null,t.deletions=null,t.sibling=null,t.tag===5&&(e=t.stateNode,e!==null&&(delete e[ya],delete e[bg],delete e[vA],delete e[qX],delete e[JX])),t.stateNode=null,t.return=null,t.dependencies=null,t.memoizedProps=null,t.memoizedState=null,t.pendingProps=null,t.stateNode=null,t.updateQueue=null}function n$(t){return t.tag===5||t.tag===3||t.tag===4}function UP(t){e:for(;;){for(;t.sibling===null;){if(t.return===null||n$(t.return))return null;t=t.return}for(t.sibling.return=t.return,t=t.sibling;t.tag!==5&&t.tag!==6&&t.tag!==18;){if(t.flags&2||t.child===null||t.tag===4)continue e;t.child.return=t,t=t.child}if(!(t.flags&2))return t.stateNode}}function kA(t,e,n){var r=t.tag;if(r===5||r===6)t=t.stateNode,e?n.nodeType===8?n.parentNode.insertBefore(t,e):n.insertBefore(t,e):(n.nodeType===8?(e=n.parentNode,e.insertBefore(t,n)):(e=n,e.appendChild(t)),n=n._reactRootContainer,n!=null||e.onclick!==null||(e.onclick=m1));else if(r!==4&&(t=t.child,t!==null))for(kA(t,e,n),t=t.sibling;t!==null;)kA(t,e,n),t=t.sibling}function DA(t,e,n){var r=t.tag;if(r===5||r===6)t=t.stateNode,e?n.insertBefore(t,e):n.appendChild(t);else if(r!==4&&(t=t.child,t!==null))for(DA(t,e,n),t=t.sibling;t!==null;)DA(t,e,n),t=t.sibling}var Jr=null,Do=!1;function Gl(t,e,n){for(n=n.child;n!==null;)r$(t,e,n),n=n.sibling}function r$(t,e,n){if(Sa&&typeof Sa.onCommitFiberUnmount=="function")try{Sa.onCommitFiberUnmount(ub,n)}catch{}switch(n.tag){case 5:pi||nh(n,e);case 6:var r=Jr,i=Do;Jr=null,Gl(t,e,n),Jr=r,Do=i,Jr!==null&&(Do?(t=Jr,n=n.stateNode,t.nodeType===8?t.parentNode.removeChild(n):t.removeChild(n)):Jr.removeChild(n.stateNode));break;case 18:Jr!==null&&(Do?(t=Jr,n=n.stateNode,t.nodeType===8?Hw(t.parentNode,n):t.nodeType===1&&Hw(t,n),mg(t)):Hw(Jr,n.stateNode));break;case 4:r=Jr,i=Do,Jr=n.stateNode.containerInfo,Do=!0,Gl(t,e,n),Jr=r,Do=i;break;case 0:case 11:case 14:case 15:if(!pi&&(r=n.updateQueue,r!==null&&(r=r.lastEffect,r!==null))){i=r=r.next;do{var s=i,o=s.destroy;s=s.tag,o!==void 0&&(s&2||s&4)&&NA(n,e,o),i=i.next}while(i!==r)}Gl(t,e,n);break;case 1:if(!pi&&(nh(n,e),r=n.stateNode,typeof r.componentWillUnmount=="function"))try{r.props=n.memoizedProps,r.state=n.memoizedState,r.componentWillUnmount()}catch(a){ir(n,e,a)}Gl(t,e,n);break;case 21:Gl(t,e,n);break;case 22:n.mode&1?(pi=(r=pi)||n.memoizedState!==null,Gl(t,e,n),pi=r):Gl(t,e,n);break;default:Gl(t,e,n)}}function zP(t){var e=t.updateQueue;if(e!==null){t.updateQueue=null;var n=t.stateNode;n===null&&(n=t.stateNode=new fK),e.forEach(function(r){var i=_K.bind(null,t,r);n.has(r)||(n.add(r),r.then(i,i))})}}function To(t,e){var n=e.deletions;if(n!==null)for(var r=0;r<n.length;r++){var i=n[r];try{var s=t,o=e,a=o;e:for(;a!==null;){switch(a.tag){case 5:Jr=a.stateNode,Do=!1;break e;case 3:Jr=a.stateNode.containerInfo,Do=!0;break e;case 4:Jr=a.stateNode.containerInfo,Do=!0;break e}a=a.return}if(Jr===null)throw Error(ze(160));r$(s,o,i),Jr=null,Do=!1;var l=i.alternate;l!==null&&(l.return=null),i.return=null}catch(c){ir(i,e,c)}}if(e.subtreeFlags&12854)for(e=e.child;e!==null;)i$(e,t),e=e.sibling}function i$(t,e){var n=t.alternate,r=t.flags;switch(t.tag){case 0:case 11:case 14:case 15:if(To(e,t),da(t),r&4){try{Qm(3,t,t.return),vb(3,t)}catch(x){ir(t,t.return,x)}try{Qm(5,t,t.return)}catch(x){ir(t,t.return,x)}}break;case 1:To(e,t),da(t),r&512&&n!==null&&nh(n,n.return);break;case 5:if(To(e,t),da(t),r&512&&n!==null&&nh(n,n.return),t.flags&32){var i=t.stateNode;try{dg(i,"")}catch(x){ir(t,t.return,x)}}if(r&4&&(i=t.stateNode,i!=null)){var s=t.memoizedProps,o=n!==null?n.memoizedProps:s,a=t.type,l=t.updateQueue;if(t.updateQueue=null,l!==null)try{a==="input"&&s.type==="radio"&&s.name!=null&&EF(i,s),iA(a,o);var c=iA(a,s);for(o=0;o<l.length;o+=2){var u=l[o],d=l[o+1];u==="style"?IF(i,d):u==="dangerouslySetInnerHTML"?MF(i,d):u==="children"?dg(i,d):WT(i,u,d,c)}switch(a){case"input":ZE(i,s);break;case"textarea":AF(i,s);break;case"select":var f=i._wrapperState.wasMultiple;i._wrapperState.wasMultiple=!!s.multiple;var h=s.value;h!=null?dh(i,!!s.multiple,h,!1):f!==!!s.multiple&&(s.defaultValue!=null?dh(i,!!s.multiple,s.defaultValue,!0):dh(i,!!s.multiple,s.multiple?[]:"",!1))}i[bg]=s}catch(x){ir(t,t.return,x)}}break;case 6:if(To(e,t),da(t),r&4){if(t.stateNode===null)throw Error(ze(162));i=t.stateNode,s=t.memoizedProps;try{i.nodeValue=s}catch(x){ir(t,t.return,x)}}break;case 3:if(To(e,t),da(t),r&4&&n!==null&&n.memoizedState.isDehydrated)try{mg(e.containerInfo)}catch(x){ir(t,t.return,x)}break;case 4:To(e,t),da(t);break;case 13:To(e,t),da(t),i=t.child,i.flags&8192&&(s=i.memoizedState!==null,i.stateNode.isHidden=s,!s||i.alternate!==null&&i.alternate.memoizedState!==null||(CM=fr())),r&4&&zP(t);break;case 22:if(u=n!==null&&n.memoizedState!==null,t.mode&1?(pi=(c=pi)||u,To(e,t),pi=c):To(e,t),da(t),r&8192){if(c=t.memoizedState!==null,(t.stateNode.isHidden=c)&&!u&&t.mode&1)for(lt=t,u=t.child;u!==null;){for(d=lt=u;lt!==null;){switch(f=lt,h=f.child,f.tag){case 0:case 11:case 14:case 15:Qm(4,f,f.return);break;case 1:nh(f,f.return);var p=f.stateNode;if(typeof p.componentWillUnmount=="function"){r=f,n=f.return;try{e=r,p.props=e.memoizedProps,p.state=e.memoizedState,p.componentWillUnmount()}catch(x){ir(r,n,x)}}break;case 5:nh(f,f.return);break;case 22:if(f.memoizedState!==null){HP(d);continue}}h!==null?(h.return=f,lt=h):HP(d)}u=u.sibling}e:for(u=null,d=t;;){if(d.tag===5){if(u===null){u=d;try{i=d.stateNode,c?(s=i.style,typeof s.setProperty=="function"?s.setProperty("display","none","important"):s.display="none"):(a=d.stateNode,l=d.memoizedProps.style,o=l!=null&&l.hasOwnProperty("display")?l.display:null,a.style.display=RF("display",o))}catch(x){ir(t,t.return,x)}}}else if(d.tag===6){if(u===null)try{d.stateNode.nodeValue=c?"":d.memoizedProps}catch(x){ir(t,t.return,x)}}else if((d.tag!==22&&d.tag!==23||d.memoizedState===null||d===t)&&d.child!==null){d.child.return=d,d=d.child;continue}if(d===t)break e;for(;d.sibling===null;){if(d.return===null||d.return===t)break e;u===d&&(u=null),d=d.return}u===d&&(u=null),d.sibling.return=d.return,d=d.sibling}}break;case 19:To(e,t),da(t),r&4&&zP(t);break;case 21:break;default:To(e,t),da(t)}}function da(t){var e=t.flags;if(e&2){try{e:{for(var n=t.return;n!==null;){if(n$(n)){var r=n;break e}n=n.return}throw Error(ze(160))}switch(r.tag){case 5:var i=r.stateNode;r.flags&32&&(dg(i,""),r.flags&=-33);var s=UP(t);DA(t,s,i);break;case 3:case 4:var o=r.stateNode.containerInfo,a=UP(t);kA(t,a,o);break;default:throw Error(ze(161))}}catch(l){ir(t,t.return,l)}t.flags&=-3}e&4096&&(t.flags&=-4097)}function pK(t,e,n){lt=t,s$(t)}function s$(t,e,n){for(var r=(t.mode&1)!==0;lt!==null;){var i=lt,s=i.child;if(i.tag===22&&r){var o=i.memoizedState!==null||lv;if(!o){var a=i.alternate,l=a!==null&&a.memoizedState!==null||pi;a=lv;var c=pi;if(lv=o,(pi=l)&&!c)for(lt=i;lt!==null;)o=lt,l=o.child,o.tag===22&&o.memoizedState!==null?VP(i):l!==null?(l.return=o,lt=l):VP(i);for(;s!==null;)lt=s,s$(s),s=s.sibling;lt=i,lv=a,pi=c}GP(t)}else i.subtreeFlags&8772&&s!==null?(s.return=i,lt=s):GP(t)}}function GP(t){for(;lt!==null;){var e=lt;if(e.flags&8772){var n=e.alternate;try{if(e.flags&8772)switch(e.tag){case 0:case 11:case 15:pi||vb(5,e);break;case 1:var r=e.stateNode;if(e.flags&4&&!pi)if(n===null)r.componentDidMount();else{var i=e.elementType===e.type?n.memoizedProps:Po(e.type,n.memoizedProps);r.componentDidUpdate(i,n.memoizedState,r.__reactInternalSnapshotBeforeUpdate)}var s=e.updateQueue;s!==null&&EP(e,s,r);break;case 3:var o=e.updateQueue;if(o!==null){if(n=null,e.child!==null)switch(e.child.tag){case 5:n=e.child.stateNode;break;case 1:n=e.child.stateNode}EP(e,o,n)}break;case 5:var a=e.stateNode;if(n===null&&e.flags&4){n=a;var l=e.memoizedProps;switch(e.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(e.memoizedState===null){var c=e.alternate;if(c!==null){var u=c.memoizedState;if(u!==null){var d=u.dehydrated;d!==null&&mg(d)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(ze(163))}pi||e.flags&512&&PA(e)}catch(f){ir(e,e.return,f)}}if(e===t){lt=null;break}if(n=e.sibling,n!==null){n.return=e.return,lt=n;break}lt=e.return}}function HP(t){for(;lt!==null;){var e=lt;if(e===t){lt=null;break}var n=e.sibling;if(n!==null){n.return=e.return,lt=n;break}lt=e.return}}function VP(t){for(;lt!==null;){var e=lt;try{switch(e.tag){case 0:case 11:case 15:var n=e.return;try{vb(4,e)}catch(l){ir(e,n,l)}break;case 1:var r=e.stateNode;if(typeof r.componentDidMount=="function"){var i=e.return;try{r.componentDidMount()}catch(l){ir(e,i,l)}}var s=e.return;try{PA(e)}catch(l){ir(e,s,l)}break;case 5:var o=e.return;try{PA(e)}catch(l){ir(e,o,l)}}}catch(l){ir(e,e.return,l)}if(e===t){lt=null;break}var a=e.sibling;if(a!==null){a.return=e.return,lt=a;break}lt=e.return}}var mK=Math.ceil,A1=El.ReactCurrentDispatcher,_M=El.ReactCurrentOwner,po=El.ReactCurrentBatchConfig,nn=0,Gr=null,Sr=null,Qr=0,vs=0,rh=Dc(0),Ir=0,Ag=null,ad=0,xb=0,wM=0,Zm=null,qi=null,CM=0,Dh=1/0,qa=null,T1=!1,OA=null,gc=null,cv=!1,ac=null,M1=0,eg=0,LA=null,Bx=-1,Fx=0;function Li(){return nn&6?fr():Bx!==-1?Bx:Bx=fr()}function yc(t){return t.mode&1?nn&2&&Qr!==0?Qr&-Qr:QX.transition!==null?(Fx===0&&(Fx=GF()),Fx):(t=xn,t!==0||(t=window.event,t=t===void 0?16:qF(t.type)),t):1}function Wo(t,e,n,r){if(50<eg)throw eg=0,LA=null,Error(ze(185));u0(t,n,r),(!(nn&2)||t!==Gr)&&(t===Gr&&(!(nn&2)&&(xb|=n),Ir===4&&ic(t,Qr)),ns(t,r),n===1&&nn===0&&!(e.mode&1)&&(Dh=fr()+500,mb&&Oc()))}function ns(t,e){var n=t.callbackNode;Qj(t,e);var r=d1(t,t===Gr?Qr:0);if(r===0)n!==null&&Z3(n),t.callbackNode=null,t.callbackPriority=0;else if(e=r&-r,t.callbackPriority!==e){if(n!=null&&Z3(n),e===1)t.tag===0?YX(WP.bind(null,t)):p4(WP.bind(null,t)),XX(function(){!(nn&6)&&Oc()}),n=null;else{switch(HF(r)){case 1:n=JT;break;case 4:n=UF;break;case 16:n=u1;break;case 536870912:n=zF;break;default:n=u1}n=h$(n,o$.bind(null,t))}t.callbackPriority=e,t.callbackNode=n}}function o$(t,e){if(Bx=-1,Fx=0,nn&6)throw Error(ze(327));var n=t.callbackNode;if(gh()&&t.callbackNode!==n)return null;var r=d1(t,t===Gr?Qr:0);if(r===0)return null;if(r&30||r&t.expiredLanes||e)e=R1(t,r);else{e=r;var i=nn;nn|=2;var s=l$();(Gr!==t||Qr!==e)&&(qa=null,Dh=fr()+500,ju(t,e));do try{vK();break}catch(a){a$(t,a)}while(!0);cM(),A1.current=s,nn=i,Sr!==null?e=0:(Gr=null,Qr=0,e=Ir)}if(e!==0){if(e===2&&(i=cA(t),i!==0&&(r=i,e=BA(t,i))),e===1)throw n=Ag,ju(t,0),ic(t,r),ns(t,fr()),n;if(e===6)ic(t,r);else{if(i=t.current.alternate,!(r&30)&&!gK(i)&&(e=R1(t,r),e===2&&(s=cA(t),s!==0&&(r=s,e=BA(t,s))),e===1))throw n=Ag,ju(t,0),ic(t,r),ns(t,fr()),n;switch(t.finishedWork=i,t.finishedLanes=r,e){case 0:case 1:throw Error(ze(345));case 2:yu(t,qi,qa);break;case 3:if(ic(t,r),(r&130023424)===r&&(e=CM+500-fr(),10<e)){if(d1(t,0)!==0)break;if(i=t.suspendedLanes,(i&r)!==r){Li(),t.pingedLanes|=t.suspendedLanes&i;break}t.timeoutHandle=yA(yu.bind(null,t,qi,qa),e);break}yu(t,qi,qa);break;case 4:if(ic(t,r),(r&4194240)===r)break;for(e=t.eventTimes,i=-1;0<r;){var o=31-Vo(r);s=1<<o,o=e[o],o>i&&(i=o),r&=~s}if(r=i,r=fr()-r,r=(120>r?120:480>r?480:1080>r?1080:1920>r?1920:3e3>r?3e3:4320>r?4320:1960*mK(r/1960))-r,10<r){t.timeoutHandle=yA(yu.bind(null,t,qi,qa),r);break}yu(t,qi,qa);break;case 5:yu(t,qi,qa);break;default:throw Error(ze(329))}}}return ns(t,fr()),t.callbackNode===n?o$.bind(null,t):null}function BA(t,e){var n=Zm;return t.current.memoizedState.isDehydrated&&(ju(t,e).flags|=256),t=R1(t,e),t!==2&&(e=qi,qi=n,e!==null&&FA(e)),t}function FA(t){qi===null?qi=t:qi.push.apply(qi,t)}function gK(t){for(var e=t;;){if(e.flags&16384){var n=e.updateQueue;if(n!==null&&(n=n.stores,n!==null))for(var r=0;r<n.length;r++){var i=n[r],s=i.getSnapshot;i=i.value;try{if(!jo(s(),i))return!1}catch{return!1}}}if(n=e.child,e.subtreeFlags&16384&&n!==null)n.return=e,e=n;else{if(e===t)break;for(;e.sibling===null;){if(e.return===null||e.return===t)return!0;e=e.return}e.sibling.return=e.return,e=e.sibling}}return!0}function ic(t,e){for(e&=~wM,e&=~xb,t.suspendedLanes|=e,t.pingedLanes&=~e,t=t.expirationTimes;0<e;){var n=31-Vo(e),r=1<<n;t[n]=-1,e&=~r}}function WP(t){if(nn&6)throw Error(ze(327));gh();var e=d1(t,0);if(!(e&1))return ns(t,fr()),null;var n=R1(t,e);if(t.tag!==0&&n===2){var r=cA(t);r!==0&&(e=r,n=BA(t,r))}if(n===1)throw n=Ag,ju(t,0),ic(t,e),ns(t,fr()),n;if(n===6)throw Error(ze(345));return t.finishedWork=t.current.alternate,t.finishedLanes=e,yu(t,qi,qa),ns(t,fr()),null}function EM(t,e){var n=nn;nn|=1;try{return t(e)}finally{nn=n,nn===0&&(Dh=fr()+500,mb&&Oc())}}function ld(t){ac!==null&&ac.tag===0&&!(nn&6)&&gh();var e=nn;nn|=1;var n=po.transition,r=xn;try{if(po.transition=null,xn=1,t)return t()}finally{xn=r,po.transition=n,nn=e,!(nn&6)&&Oc()}}function AM(){vs=rh.current,Ln(rh)}function ju(t,e){t.finishedWork=null,t.finishedLanes=0;var n=t.timeoutHandle;if(n!==-1&&(t.timeoutHandle=-1,jX(n)),Sr!==null)for(n=Sr.return;n!==null;){var r=n;switch(oM(r),r.tag){case 1:r=r.type.childContextTypes,r!=null&&g1();break;case 3:Ph(),Ln(es),Ln(xi),mM();break;case 5:pM(r);break;case 4:Ph();break;case 13:Ln(jn);break;case 19:Ln(jn);break;case 10:uM(r.type._context);break;case 22:case 23:AM()}n=n.return}if(Gr=t,Sr=t=vc(t.current,null),Qr=vs=e,Ir=0,Ag=null,wM=xb=ad=0,qi=Zm=null,Iu!==null){for(e=0;e<Iu.length;e++)if(n=Iu[e],r=n.interleaved,r!==null){n.interleaved=null;var i=r.next,s=n.pending;if(s!==null){var o=s.next;s.next=i,r.next=o}n.pending=r}Iu=null}return t}function a$(t,e){do{var n=Sr;try{if(cM(),Dx.current=E1,C1){for(var r=Kn.memoizedState;r!==null;){var i=r.queue;i!==null&&(i.pending=null),r=r.next}C1=!1}if(od=0,$r=Mr=Kn=null,Ym=!1,wg=0,_M.current=null,n===null||n.return===null){Ir=1,Ag=e,Sr=null;break}e:{var s=t,o=n.return,a=n,l=e;if(e=Qr,a.flags|=32768,l!==null&&typeof l=="object"&&typeof l.then=="function"){var c=l,u=a,d=u.tag;if(!(u.mode&1)&&(d===0||d===11||d===15)){var f=u.alternate;f?(u.updateQueue=f.updateQueue,u.memoizedState=f.memoizedState,u.lanes=f.lanes):(u.updateQueue=null,u.memoizedState=null)}var h=PP(o);if(h!==null){h.flags&=-257,kP(h,o,a,s,e),h.mode&1&&NP(s,c,e),e=h,l=c;var p=e.updateQueue;if(p===null){var x=new Set;x.add(l),e.updateQueue=x}else p.add(l);break e}else{if(!(e&1)){NP(s,c,e),TM();break e}l=Error(ze(426))}}else if(Gn&&a.mode&1){var v=PP(o);if(v!==null){!(v.flags&65536)&&(v.flags|=256),kP(v,o,a,s,e),aM(kh(l,a));break e}}s=l=kh(l,a),Ir!==4&&(Ir=2),Zm===null?Zm=[s]:Zm.push(s),s=o;do{switch(s.tag){case 3:s.flags|=65536,e&=-e,s.lanes|=e;var y=V4(s,l,e);CP(s,y);break e;case 1:a=l;var b=s.type,S=s.stateNode;if(!(s.flags&128)&&(typeof b.getDerivedStateFromError=="function"||S!==null&&typeof S.componentDidCatch=="function"&&(gc===null||!gc.has(S)))){s.flags|=65536,e&=-e,s.lanes|=e;var w=W4(s,a,e);CP(s,w);break e}}s=s.return}while(s!==null)}u$(n)}catch(E){e=E,Sr===n&&n!==null&&(Sr=n=n.return);continue}break}while(!0)}function l$(){var t=A1.current;return A1.current=E1,t===null?E1:t}function TM(){(Ir===0||Ir===3||Ir===2)&&(Ir=4),Gr===null||!(ad&268435455)&&!(xb&268435455)||ic(Gr,Qr)}function R1(t,e){var n=nn;nn|=2;var r=l$();(Gr!==t||Qr!==e)&&(qa=null,ju(t,e));do try{yK();break}catch(i){a$(t,i)}while(!0);if(cM(),nn=n,A1.current=r,Sr!==null)throw Error(ze(261));return Gr=null,Qr=0,Ir}function yK(){for(;Sr!==null;)c$(Sr)}function vK(){for(;Sr!==null&&!Hj();)c$(Sr)}function c$(t){var e=f$(t.alternate,t,vs);t.memoizedProps=t.pendingProps,e===null?u$(t):Sr=e,_M.current=null}function u$(t){var e=t;do{var n=e.alternate;if(t=e.return,e.flags&32768){if(n=dK(n,e),n!==null){n.flags&=32767,Sr=n;return}if(t!==null)t.flags|=32768,t.subtreeFlags=0,t.deletions=null;else{Ir=6,Sr=null;return}}else if(n=uK(n,e,vs),n!==null){Sr=n;return}if(e=e.sibling,e!==null){Sr=e;return}Sr=e=t}while(e!==null);Ir===0&&(Ir=5)}function yu(t,e,n){var r=xn,i=po.transition;try{po.transition=null,xn=1,xK(t,e,n,r)}finally{po.transition=i,xn=r}return null}function xK(t,e,n,r){do gh();while(ac!==null);if(nn&6)throw Error(ze(327));n=t.finishedWork;var i=t.finishedLanes;if(n===null)return null;if(t.finishedWork=null,t.finishedLanes=0,n===t.current)throw Error(ze(177));t.callbackNode=null,t.callbackPriority=0;var s=n.lanes|n.childLanes;if(Zj(t,s),t===Gr&&(Sr=Gr=null,Qr=0),!(n.subtreeFlags&2064)&&!(n.flags&2064)||cv||(cv=!0,h$(u1,function(){return gh(),null})),s=(n.flags&15990)!==0,n.subtreeFlags&15990||s){s=po.transition,po.transition=null;var o=xn;xn=1;var a=nn;nn|=4,_M.current=null,hK(t,n),i$(n,t),$X(mA),f1=!!pA,mA=pA=null,t.current=n,pK(n),Vj(),nn=a,xn=o,po.transition=s}else t.current=n;if(cv&&(cv=!1,ac=t,M1=i),s=t.pendingLanes,s===0&&(gc=null),Xj(n.stateNode),ns(t,fr()),e!==null)for(r=t.onRecoverableError,n=0;n<e.length;n++)i=e[n],r(i.value,{componentStack:i.stack,digest:i.digest});if(T1)throw T1=!1,t=OA,OA=null,t;return M1&1&&t.tag!==0&&gh(),s=t.pendingLanes,s&1?t===LA?eg++:(eg=0,LA=t):eg=0,Oc(),null}function gh(){if(ac!==null){var t=HF(M1),e=po.transition,n=xn;try{if(po.transition=null,xn=16>t?16:t,ac===null)var r=!1;else{if(t=ac,ac=null,M1=0,nn&6)throw Error(ze(331));var i=nn;for(nn|=4,lt=t.current;lt!==null;){var s=lt,o=s.child;if(lt.flags&16){var a=s.deletions;if(a!==null){for(var l=0;l<a.length;l++){var c=a[l];for(lt=c;lt!==null;){var u=lt;switch(u.tag){case 0:case 11:case 15:Qm(8,u,s)}var d=u.child;if(d!==null)d.return=u,lt=d;else for(;lt!==null;){u=lt;var f=u.sibling,h=u.return;if(t$(u),u===c){lt=null;break}if(f!==null){f.return=h,lt=f;break}lt=h}}}var p=s.alternate;if(p!==null){var x=p.child;if(x!==null){p.child=null;do{var v=x.sibling;x.sibling=null,x=v}while(x!==null)}}lt=s}}if(s.subtreeFlags&2064&&o!==null)o.return=s,lt=o;else e:for(;lt!==null;){if(s=lt,s.flags&2048)switch(s.tag){case 0:case 11:case 15:Qm(9,s,s.return)}var y=s.sibling;if(y!==null){y.return=s.return,lt=y;break e}lt=s.return}}var b=t.current;for(lt=b;lt!==null;){o=lt;var S=o.child;if(o.subtreeFlags&2064&&S!==null)S.return=o,lt=S;else e:for(o=b;lt!==null;){if(a=lt,a.flags&2048)try{switch(a.tag){case 0:case 11:case 15:vb(9,a)}}catch(E){ir(a,a.return,E)}if(a===o){lt=null;break e}var w=a.sibling;if(w!==null){w.return=a.return,lt=w;break e}lt=a.return}}if(nn=i,Oc(),Sa&&typeof Sa.onPostCommitFiberRoot=="function")try{Sa.onPostCommitFiberRoot(ub,t)}catch{}r=!0}return r}finally{xn=n,po.transition=e}}return!1}function jP(t,e,n){e=kh(n,e),e=V4(t,e,1),t=mc(t,e,1),e=Li(),t!==null&&(u0(t,1,e),ns(t,e))}function ir(t,e,n){if(t.tag===3)jP(t,t,n);else for(;e!==null;){if(e.tag===3){jP(e,t,n);break}else if(e.tag===1){var r=e.stateNode;if(typeof e.type.getDerivedStateFromError=="function"||typeof r.componentDidCatch=="function"&&(gc===null||!gc.has(r))){t=kh(n,t),t=W4(e,t,1),e=mc(e,t,1),t=Li(),e!==null&&(u0(e,1,t),ns(e,t));break}}e=e.return}}function bK(t,e,n){var r=t.pingCache;r!==null&&r.delete(e),e=Li(),t.pingedLanes|=t.suspendedLanes&n,Gr===t&&(Qr&n)===n&&(Ir===4||Ir===3&&(Qr&130023424)===Qr&&500>fr()-CM?ju(t,0):wM|=n),ns(t,e)}function d$(t,e){e===0&&(t.mode&1?(e=Zy,Zy<<=1,!(Zy&130023424)&&(Zy=4194304)):e=1);var n=Li();t=yl(t,e),t!==null&&(u0(t,e,n),ns(t,n))}function SK(t){var e=t.memoizedState,n=0;e!==null&&(n=e.retryLane),d$(t,n)}function _K(t,e){var n=0;switch(t.tag){case 13:var r=t.stateNode,i=t.memoizedState;i!==null&&(n=i.retryLane);break;case 19:r=t.stateNode;break;default:throw Error(ze(314))}r!==null&&r.delete(e),d$(t,n)}var f$;f$=function(t,e,n){if(t!==null)if(t.memoizedProps!==e.pendingProps||es.current)Ji=!0;else{if(!(t.lanes&n)&&!(e.flags&128))return Ji=!1,cK(t,e,n);Ji=!!(t.flags&131072)}else Ji=!1,Gn&&e.flags&1048576&&m4(e,x1,e.index);switch(e.lanes=0,e.tag){case 2:var r=e.type;Lx(t,e),t=e.pendingProps;var i=Rh(e,xi.current);mh(e,n),i=yM(null,e,r,t,i,n);var s=vM();return e.flags|=1,typeof i=="object"&&i!==null&&typeof i.render=="function"&&i.$$typeof===void 0?(e.tag=1,e.memoizedState=null,e.updateQueue=null,ts(r)?(s=!0,y1(e)):s=!1,e.memoizedState=i.state!==null&&i.state!==void 0?i.state:null,fM(e),i.updater=gb,e.stateNode=i,i._reactInternals=e,CA(e,r,t,n),e=TA(null,e,r,!0,s,n)):(e.tag=0,Gn&&s&&sM(e),Ni(null,e,i,n),e=e.child),e;case 16:r=e.elementType;e:{switch(Lx(t,e),t=e.pendingProps,i=r._init,r=i(r._payload),e.type=r,i=e.tag=CK(r),t=Po(r,t),i){case 0:e=AA(null,e,r,t,n);break e;case 1:e=LP(null,e,r,t,n);break e;case 11:e=DP(null,e,r,t,n);break e;case 14:e=OP(null,e,r,Po(r.type,t),n);break e}throw Error(ze(306,r,""))}return e;case 0:return r=e.type,i=e.pendingProps,i=e.elementType===r?i:Po(r,i),AA(t,e,r,i,n);case 1:return r=e.type,i=e.pendingProps,i=e.elementType===r?i:Po(r,i),LP(t,e,r,i,n);case 3:e:{if(q4(e),t===null)throw Error(ze(387));r=e.pendingProps,s=e.memoizedState,i=s.element,x4(t,e),_1(e,r,null,n);var o=e.memoizedState;if(r=o.element,s.isDehydrated)if(s={element:r,isDehydrated:!1,cache:o.cache,pendingSuspenseBoundaries:o.pendingSuspenseBoundaries,transitions:o.transitions},e.updateQueue.baseState=s,e.memoizedState=s,e.flags&256){i=kh(Error(ze(423)),e),e=BP(t,e,r,n,i);break e}else if(r!==i){i=kh(Error(ze(424)),e),e=BP(t,e,r,n,i);break e}else for(_s=pc(e.stateNode.containerInfo.firstChild),Es=e,Gn=!0,Lo=null,n=w4(e,null,r,n),e.child=n;n;)n.flags=n.flags&-3|4096,n=n.sibling;else{if(Ih(),r===i){e=vl(t,e,n);break e}Ni(t,e,r,n)}e=e.child}return e;case 5:return C4(e),t===null&&SA(e),r=e.type,i=e.pendingProps,s=t!==null?t.memoizedProps:null,o=i.children,gA(r,i)?o=null:s!==null&&gA(r,s)&&(e.flags|=32),K4(t,e),Ni(t,e,o,n),e.child;case 6:return t===null&&SA(e),null;case 13:return J4(t,e,n);case 4:return hM(e,e.stateNode.containerInfo),r=e.pendingProps,t===null?e.child=Nh(e,null,r,n):Ni(t,e,r,n),e.child;case 11:return r=e.type,i=e.pendingProps,i=e.elementType===r?i:Po(r,i),DP(t,e,r,i,n);case 7:return Ni(t,e,e.pendingProps,n),e.child;case 8:return Ni(t,e,e.pendingProps.children,n),e.child;case 12:return Ni(t,e,e.pendingProps.children,n),e.child;case 10:e:{if(r=e.type._context,i=e.pendingProps,s=e.memoizedProps,o=i.value,In(b1,r._currentValue),r._currentValue=o,s!==null)if(jo(s.value,o)){if(s.children===i.children&&!es.current){e=vl(t,e,n);break e}}else for(s=e.child,s!==null&&(s.return=e);s!==null;){var a=s.dependencies;if(a!==null){o=s.child;for(var l=a.firstContext;l!==null;){if(l.context===r){if(s.tag===1){l=ll(-1,n&-n),l.tag=2;var c=s.updateQueue;if(c!==null){c=c.shared;var u=c.pending;u===null?l.next=l:(l.next=u.next,u.next=l),c.pending=l}}s.lanes|=n,l=s.alternate,l!==null&&(l.lanes|=n),_A(s.return,n,e),a.lanes|=n;break}l=l.next}}else if(s.tag===10)o=s.type===e.type?null:s.child;else if(s.tag===18){if(o=s.return,o===null)throw Error(ze(341));o.lanes|=n,a=o.alternate,a!==null&&(a.lanes|=n),_A(o,n,e),o=s.sibling}else o=s.child;if(o!==null)o.return=s;else for(o=s;o!==null;){if(o===e){o=null;break}if(s=o.sibling,s!==null){s.return=o.return,o=s;break}o=o.return}s=o}Ni(t,e,i.children,n),e=e.child}return e;case 9:return i=e.type,r=e.pendingProps.children,mh(e,n),i=mo(i),r=r(i),e.flags|=1,Ni(t,e,r,n),e.child;case 14:return r=e.type,i=Po(r,e.pendingProps),i=Po(r.type,i),OP(t,e,r,i,n);case 15:return j4(t,e,e.type,e.pendingProps,n);case 17:return r=e.type,i=e.pendingProps,i=e.elementType===r?i:Po(r,i),Lx(t,e),e.tag=1,ts(r)?(t=!0,y1(e)):t=!1,mh(e,n),S4(e,r,i),CA(e,r,i,n),TA(null,e,r,!0,t,n);case 19:return Y4(t,e,n);case 22:return X4(t,e,n)}throw Error(ze(156,e.tag))};function h$(t,e){return $F(t,e)}function wK(t,e,n,r){this.tag=t,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=e,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=r,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function oo(t,e,n,r){return new wK(t,e,n,r)}function MM(t){return t=t.prototype,!(!t||!t.isReactComponent)}function CK(t){if(typeof t=="function")return MM(t)?1:0;if(t!=null){if(t=t.$$typeof,t===XT)return 11;if(t===KT)return 14}return 2}function vc(t,e){var n=t.alternate;return n===null?(n=oo(t.tag,e,t.key,t.mode),n.elementType=t.elementType,n.type=t.type,n.stateNode=t.stateNode,n.alternate=t,t.alternate=n):(n.pendingProps=e,n.type=t.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=t.flags&14680064,n.childLanes=t.childLanes,n.lanes=t.lanes,n.child=t.child,n.memoizedProps=t.memoizedProps,n.memoizedState=t.memoizedState,n.updateQueue=t.updateQueue,e=t.dependencies,n.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext},n.sibling=t.sibling,n.index=t.index,n.ref=t.ref,n}function $x(t,e,n,r,i,s){var o=2;if(r=t,typeof t=="function")MM(t)&&(o=1);else if(typeof t=="string")o=5;else e:switch(t){case Xf:return Xu(n.children,i,s,e);case jT:o=8,i|=8;break;case KE:return t=oo(12,n,e,i|2),t.elementType=KE,t.lanes=s,t;case qE:return t=oo(13,n,e,i),t.elementType=qE,t.lanes=s,t;case JE:return t=oo(19,n,e,i),t.elementType=JE,t.lanes=s,t;case _F:return bb(n,i,s,e);default:if(typeof t=="object"&&t!==null)switch(t.$$typeof){case bF:o=10;break e;case SF:o=9;break e;case XT:o=11;break e;case KT:o=14;break e;case ec:o=16,r=null;break e}throw Error(ze(130,t==null?t:typeof t,""))}return e=oo(o,n,e,i),e.elementType=t,e.type=r,e.lanes=s,e}function Xu(t,e,n,r){return t=oo(7,t,r,e),t.lanes=n,t}function bb(t,e,n,r){return t=oo(22,t,r,e),t.elementType=_F,t.lanes=n,t.stateNode={isHidden:!1},t}function Yw(t,e,n){return t=oo(6,t,null,e),t.lanes=n,t}function Qw(t,e,n){return e=oo(4,t.children!==null?t.children:[],t.key,e),e.lanes=n,e.stateNode={containerInfo:t.containerInfo,pendingChildren:null,implementation:t.implementation},e}function EK(t,e,n,r,i){this.tag=e,this.containerInfo=t,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=Pw(0),this.expirationTimes=Pw(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=Pw(0),this.identifierPrefix=r,this.onRecoverableError=i,this.mutableSourceEagerHydrationData=null}function RM(t,e,n,r,i,s,o,a,l){return t=new EK(t,e,n,a,l),e===1?(e=1,s===!0&&(e|=8)):e=0,s=oo(3,null,null,e),t.current=s,s.stateNode=t,s.memoizedState={element:r,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},fM(s),t}function AK(t,e,n){var r=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:jf,key:r==null?null:""+r,children:t,containerInfo:e,implementation:n}}function p$(t){if(!t)return Cc;t=t._reactInternals;e:{if(Td(t)!==t||t.tag!==1)throw Error(ze(170));var e=t;do{switch(e.tag){case 3:e=e.stateNode.context;break e;case 1:if(ts(e.type)){e=e.stateNode.__reactInternalMemoizedMergedChildContext;break e}}e=e.return}while(e!==null);throw Error(ze(171))}if(t.tag===1){var n=t.type;if(ts(n))return h4(t,n,e)}return e}function m$(t,e,n,r,i,s,o,a,l){return t=RM(n,r,!0,t,i,s,o,a,l),t.context=p$(null),n=t.current,r=Li(),i=yc(n),s=ll(r,i),s.callback=e??null,mc(n,s,i),t.current.lanes=i,u0(t,i,r),ns(t,r),t}function Sb(t,e,n,r){var i=e.current,s=Li(),o=yc(i);return n=p$(n),e.context===null?e.context=n:e.pendingContext=n,e=ll(s,o),e.payload={element:t},r=r===void 0?null:r,r!==null&&(e.callback=r),t=mc(i,e,o),t!==null&&(Wo(t,i,o,s),kx(t,i,o)),o}function I1(t){if(t=t.current,!t.child)return null;switch(t.child.tag){case 5:return t.child.stateNode;default:return t.child.stateNode}}function XP(t,e){if(t=t.memoizedState,t!==null&&t.dehydrated!==null){var n=t.retryLane;t.retryLane=n!==0&&n<e?n:e}}function IM(t,e){XP(t,e),(t=t.alternate)&&XP(t,e)}function TK(){return null}var g$=typeof reportError=="function"?reportError:function(t){console.error(t)};function NM(t){this._internalRoot=t}_b.prototype.render=NM.prototype.render=function(t){var e=this._internalRoot;if(e===null)throw Error(ze(409));Sb(t,e,null,null)};_b.prototype.unmount=NM.prototype.unmount=function(){var t=this._internalRoot;if(t!==null){this._internalRoot=null;var e=t.containerInfo;ld(function(){Sb(null,t,null,null)}),e[gl]=null}};function _b(t){this._internalRoot=t}_b.prototype.unstable_scheduleHydration=function(t){if(t){var e=jF();t={blockedOn:null,target:t,priority:e};for(var n=0;n<rc.length&&e!==0&&e<rc[n].priority;n++);rc.splice(n,0,t),n===0&&KF(t)}};function PM(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11)}function wb(t){return!(!t||t.nodeType!==1&&t.nodeType!==9&&t.nodeType!==11&&(t.nodeType!==8||t.nodeValue!==" react-mount-point-unstable "))}function KP(){}function MK(t,e,n,r,i){if(i){if(typeof r=="function"){var s=r;r=function(){var c=I1(o);s.call(c)}}var o=m$(e,r,t,0,null,!1,!1,"",KP);return t._reactRootContainer=o,t[gl]=o.current,vg(t.nodeType===8?t.parentNode:t),ld(),o}for(;i=t.lastChild;)t.removeChild(i);if(typeof r=="function"){var a=r;r=function(){var c=I1(l);a.call(c)}}var l=RM(t,0,!1,null,null,!1,!1,"",KP);return t._reactRootContainer=l,t[gl]=l.current,vg(t.nodeType===8?t.parentNode:t),ld(function(){Sb(e,l,n,r)}),l}function Cb(t,e,n,r,i){var s=n._reactRootContainer;if(s){var o=s;if(typeof i=="function"){var a=i;i=function(){var l=I1(o);a.call(l)}}Sb(e,o,t,i)}else o=MK(n,e,t,i,r);return I1(o)}VF=function(t){switch(t.tag){case 3:var e=t.stateNode;if(e.current.memoizedState.isDehydrated){var n=Lm(e.pendingLanes);n!==0&&(YT(e,n|1),ns(e,fr()),!(nn&6)&&(Dh=fr()+500,Oc()))}break;case 13:ld(function(){var r=yl(t,1);if(r!==null){var i=Li();Wo(r,t,1,i)}}),IM(t,1)}};QT=function(t){if(t.tag===13){var e=yl(t,134217728);if(e!==null){var n=Li();Wo(e,t,134217728,n)}IM(t,134217728)}};WF=function(t){if(t.tag===13){var e=yc(t),n=yl(t,e);if(n!==null){var r=Li();Wo(n,t,e,r)}IM(t,e)}};jF=function(){return xn};XF=function(t,e){var n=xn;try{return xn=t,e()}finally{xn=n}};oA=function(t,e,n){switch(e){case"input":if(ZE(t,n),e=n.name,n.type==="radio"&&e!=null){for(n=t;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+e)+'][type="radio"]'),e=0;e<n.length;e++){var r=n[e];if(r!==t&&r.form===t.form){var i=pb(r);if(!i)throw Error(ze(90));CF(r),ZE(r,i)}}}break;case"textarea":AF(t,n);break;case"select":e=n.value,e!=null&&dh(t,!!n.multiple,e,!1)}};kF=EM;DF=ld;var RK={usingClientEntryPoint:!1,Events:[f0,Yf,pb,NF,PF,EM]},sm={findFiberByHostInstance:Ru,bundleType:0,version:"18.2.0",rendererPackageName:"react-dom"},IK={bundleType:sm.bundleType,version:sm.version,rendererPackageName:sm.rendererPackageName,rendererConfig:sm.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:El.ReactCurrentDispatcher,findHostInstanceByFiber:function(t){return t=BF(t),t===null?null:t.stateNode},findFiberByHostInstance:sm.findFiberByHostInstance||TK,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.2.0-next-9e3b772b8-20220608"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var uv=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!uv.isDisabled&&uv.supportsFiber)try{ub=uv.inject(IK),Sa=uv}catch{}}Ps.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=RK;Ps.createPortal=function(t,e){var n=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!PM(e))throw Error(ze(200));return AK(t,e,null,n)};Ps.createRoot=function(t,e){if(!PM(t))throw Error(ze(299));var n=!1,r="",i=g$;return e!=null&&(e.unstable_strictMode===!0&&(n=!0),e.identifierPrefix!==void 0&&(r=e.identifierPrefix),e.onRecoverableError!==void 0&&(i=e.onRecoverableError)),e=RM(t,1,!1,null,null,n,!1,r,i),t[gl]=e.current,vg(t.nodeType===8?t.parentNode:t),new NM(e)};Ps.findDOMNode=function(t){if(t==null)return null;if(t.nodeType===1)return t;var e=t._reactInternals;if(e===void 0)throw typeof t.render=="function"?Error(ze(188)):(t=Object.keys(t).join(","),Error(ze(268,t)));return t=BF(e),t=t===null?null:t.stateNode,t};Ps.flushSync=function(t){return ld(t)};Ps.hydrate=function(t,e,n){if(!wb(e))throw Error(ze(200));return Cb(null,t,e,!0,n)};Ps.hydrateRoot=function(t,e,n){if(!PM(t))throw Error(ze(405));var r=n!=null&&n.hydratedSources||null,i=!1,s="",o=g$;if(n!=null&&(n.unstable_strictMode===!0&&(i=!0),n.identifierPrefix!==void 0&&(s=n.identifierPrefix),n.onRecoverableError!==void 0&&(o=n.onRecoverableError)),e=m$(e,null,t,1,n??null,i,!1,s,o),t[gl]=e.current,vg(t),r)for(t=0;t<r.length;t++)n=r[t],i=n._getVersion,i=i(n._source),e.mutableSourceEagerHydrationData==null?e.mutableSourceEagerHydrationData=[n,i]:e.mutableSourceEagerHydrationData.push(n,i);return new _b(e)};Ps.render=function(t,e,n){if(!wb(e))throw Error(ze(200));return Cb(null,t,e,!1,n)};Ps.unmountComponentAtNode=function(t){if(!wb(t))throw Error(ze(40));return t._reactRootContainer?(ld(function(){Cb(null,null,t,!1,function(){t._reactRootContainer=null,t[gl]=null})}),!0):!1};Ps.unstable_batchedUpdates=EM;Ps.unstable_renderSubtreeIntoContainer=function(t,e,n,r){if(!wb(n))throw Error(ze(200));if(t==null||t._reactInternals===void 0)throw Error(ze(38));return Cb(t,e,n,!1,r)};Ps.version="18.2.0-next-9e3b772b8-20220608";function y$(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(y$)}catch(t){console.error(t)}}y$(),mF.exports=Ps;var kM=mF.exports;const dv=Ed(kM);var qP=kM;jE.createRoot=qP.createRoot,jE.hydrateRoot=qP.hydrateRoot;/**
 * @remix-run/router v1.16.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Tg(){return Tg=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},Tg.apply(this,arguments)}var lc;(function(t){t.Pop="POP",t.Push="PUSH",t.Replace="REPLACE"})(lc||(lc={}));const JP="popstate";function NK(t){t===void 0&&(t={});function e(r,i){let{pathname:s,search:o,hash:a}=r.location;return $A("",{pathname:s,search:o,hash:a},i.state&&i.state.usr||null,i.state&&i.state.key||"default")}function n(r,i){return typeof i=="string"?i:N1(i)}return kK(e,n,null,t)}function _r(t,e){if(t===!1||t===null||typeof t>"u")throw new Error(e)}function v$(t,e){if(!t){typeof console<"u"&&console.warn(e);try{throw new Error(e)}catch{}}}function PK(){return Math.random().toString(36).substr(2,8)}function YP(t,e){return{usr:t.state,key:t.key,idx:e}}function $A(t,e,n,r){return n===void 0&&(n=null),Tg({pathname:typeof t=="string"?t:t.pathname,search:"",hash:""},typeof e=="string"?cp(e):e,{state:n,key:e&&e.key||r||PK()})}function N1(t){let{pathname:e="/",search:n="",hash:r=""}=t;return n&&n!=="?"&&(e+=n.charAt(0)==="?"?n:"?"+n),r&&r!=="#"&&(e+=r.charAt(0)==="#"?r:"#"+r),e}function cp(t){let e={};if(t){let n=t.indexOf("#");n>=0&&(e.hash=t.substr(n),t=t.substr(0,n));let r=t.indexOf("?");r>=0&&(e.search=t.substr(r),t=t.substr(0,r)),t&&(e.pathname=t)}return e}function kK(t,e,n,r){r===void 0&&(r={});let{window:i=document.defaultView,v5Compat:s=!1}=r,o=i.history,a=lc.Pop,l=null,c=u();c==null&&(c=0,o.replaceState(Tg({},o.state,{idx:c}),""));function u(){return(o.state||{idx:null}).idx}function d(){a=lc.Pop;let v=u(),y=v==null?null:v-c;c=v,l&&l({action:a,location:x.location,delta:y})}function f(v,y){a=lc.Push;let b=$A(x.location,v,y);n&&n(b,v),c=u()+1;let S=YP(b,c),w=x.createHref(b);try{o.pushState(S,"",w)}catch(E){if(E instanceof DOMException&&E.name==="DataCloneError")throw E;i.location.assign(w)}s&&l&&l({action:a,location:x.location,delta:1})}function h(v,y){a=lc.Replace;let b=$A(x.location,v,y);n&&n(b,v),c=u();let S=YP(b,c),w=x.createHref(b);o.replaceState(S,"",w),s&&l&&l({action:a,location:x.location,delta:0})}function p(v){let y=i.location.origin!=="null"?i.location.origin:i.location.href,b=typeof v=="string"?v:N1(v);return b=b.replace(/ $/,"%20"),_r(y,"No window.location.(origin|href) available to create URL for href: "+b),new URL(b,y)}let x={get action(){return a},get location(){return t(i,o)},listen(v){if(l)throw new Error("A history only accepts one active listener");return i.addEventListener(JP,d),l=v,()=>{i.removeEventListener(JP,d),l=null}},createHref(v){return e(i,v)},createURL:p,encodeLocation(v){let y=p(v);return{pathname:y.pathname,search:y.search,hash:y.hash}},push:f,replace:h,go(v){return o.go(v)}};return x}var QP;(function(t){t.data="data",t.deferred="deferred",t.redirect="redirect",t.error="error"})(QP||(QP={}));function DK(t,e,n){n===void 0&&(n="/");let r=typeof e=="string"?cp(e):e,i=DM(r.pathname||"/",n);if(i==null)return null;let s=x$(t);OK(s);let o=null;for(let a=0;o==null&&a<s.length;++a){let l=XK(i);o=VK(s[a],l)}return o}function x$(t,e,n,r){e===void 0&&(e=[]),n===void 0&&(n=[]),r===void 0&&(r="");let i=(s,o,a)=>{let l={relativePath:a===void 0?s.path||"":a,caseSensitive:s.caseSensitive===!0,childrenIndex:o,route:s};l.relativePath.startsWith("/")&&(_r(l.relativePath.startsWith(r),'Absolute route path "'+l.relativePath+'" nested under path '+('"'+r+'" is not valid. An absolute child route path ')+"must start with the combined path of all its parent routes."),l.relativePath=l.relativePath.slice(r.length));let c=xc([r,l.relativePath]),u=n.concat(l);s.children&&s.children.length>0&&(_r(s.index!==!0,"Index routes must not have child routes. Please remove "+('all child routes from route path "'+c+'".')),x$(s.children,e,u,c)),!(s.path==null&&!s.index)&&e.push({path:c,score:GK(c,s.index),routesMeta:u})};return t.forEach((s,o)=>{var a;if(s.path===""||!((a=s.path)!=null&&a.includes("?")))i(s,o);else for(let l of b$(s.path))i(s,o,l)}),e}function b$(t){let e=t.split("/");if(e.length===0)return[];let[n,...r]=e,i=n.endsWith("?"),s=n.replace(/\?$/,"");if(r.length===0)return i?[s,""]:[s];let o=b$(r.join("/")),a=[];return a.push(...o.map(l=>l===""?s:[s,l].join("/"))),i&&a.push(...o),a.map(l=>t.startsWith("/")&&l===""?"/":l)}function OK(t){t.sort((e,n)=>e.score!==n.score?n.score-e.score:HK(e.routesMeta.map(r=>r.childrenIndex),n.routesMeta.map(r=>r.childrenIndex)))}const LK=/^:[\w-]+$/,BK=3,FK=2,$K=1,UK=10,zK=-2,ZP=t=>t==="*";function GK(t,e){let n=t.split("/"),r=n.length;return n.some(ZP)&&(r+=zK),e&&(r+=FK),n.filter(i=>!ZP(i)).reduce((i,s)=>i+(LK.test(s)?BK:s===""?$K:UK),r)}function HK(t,e){return t.length===e.length&&t.slice(0,-1).every((r,i)=>r===e[i])?t[t.length-1]-e[e.length-1]:0}function VK(t,e){let{routesMeta:n}=t,r={},i="/",s=[];for(let o=0;o<n.length;++o){let a=n[o],l=o===n.length-1,c=i==="/"?e:e.slice(i.length)||"/",u=WK({path:a.relativePath,caseSensitive:a.caseSensitive,end:l},c);if(!u)return null;Object.assign(r,u.params);let d=a.route;s.push({params:r,pathname:xc([i,u.pathname]),pathnameBase:YK(xc([i,u.pathnameBase])),route:d}),u.pathnameBase!=="/"&&(i=xc([i,u.pathnameBase]))}return s}function WK(t,e){typeof t=="string"&&(t={path:t,caseSensitive:!1,end:!0});let[n,r]=jK(t.path,t.caseSensitive,t.end),i=e.match(n);if(!i)return null;let s=i[0],o=s.replace(/(.)\/+$/,"$1"),a=i.slice(1);return{params:r.reduce((c,u,d)=>{let{paramName:f,isOptional:h}=u;if(f==="*"){let x=a[d]||"";o=s.slice(0,s.length-x.length).replace(/(.)\/+$/,"$1")}const p=a[d];return h&&!p?c[f]=void 0:c[f]=(p||"").replace(/%2F/g,"/"),c},{}),pathname:s,pathnameBase:o,pattern:t}}function jK(t,e,n){e===void 0&&(e=!1),n===void 0&&(n=!0),v$(t==="*"||!t.endsWith("*")||t.endsWith("/*"),'Route path "'+t+'" will be treated as if it were '+('"'+t.replace(/\*$/,"/*")+'" because the `*` character must ')+"always follow a `/` in the pattern. To get rid of this warning, "+('please change the route path to "'+t.replace(/\*$/,"/*")+'".'));let r=[],i="^"+t.replace(/\/*\*?$/,"").replace(/^\/*/,"/").replace(/[\\.*+^${}|()[\]]/g,"\\$&").replace(/\/:([\w-]+)(\?)?/g,(o,a,l)=>(r.push({paramName:a,isOptional:l!=null}),l?"/?([^\\/]+)?":"/([^\\/]+)"));return t.endsWith("*")?(r.push({paramName:"*"}),i+=t==="*"||t==="/*"?"(.*)$":"(?:\\/(.+)|\\/*)$"):n?i+="\\/*$":t!==""&&t!=="/"&&(i+="(?:(?=\\/|$))"),[new RegExp(i,e?void 0:"i"),r]}function XK(t){try{return t.split("/").map(e=>decodeURIComponent(e).replace(/\//g,"%2F")).join("/")}catch(e){return v$(!1,'The URL path "'+t+'" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent '+("encoding ("+e+").")),t}}function DM(t,e){if(e==="/")return t;if(!t.toLowerCase().startsWith(e.toLowerCase()))return null;let n=e.endsWith("/")?e.length-1:e.length,r=t.charAt(n);return r&&r!=="/"?null:t.slice(n)||"/"}function KK(t,e){e===void 0&&(e="/");let{pathname:n,search:r="",hash:i=""}=typeof t=="string"?cp(t):t;return{pathname:n?n.startsWith("/")?n:qK(n,e):e,search:QK(r),hash:ZK(i)}}function qK(t,e){let n=e.replace(/\/+$/,"").split("/");return t.split("/").forEach(i=>{i===".."?n.length>1&&n.pop():i!=="."&&n.push(i)}),n.length>1?n.join("/"):"/"}function Zw(t,e,n,r){return"Cannot include a '"+t+"' character in a manually specified "+("`to."+e+"` field ["+JSON.stringify(r)+"].  Please separate it out to the ")+("`to."+n+"` field. Alternatively you may provide the full path as ")+'a string in <Link to="..."> and the router will parse it for you.'}function JK(t){return t.filter((e,n)=>n===0||e.route.path&&e.route.path.length>0)}function S$(t,e){let n=JK(t);return e?n.map((r,i)=>i===t.length-1?r.pathname:r.pathnameBase):n.map(r=>r.pathnameBase)}function _$(t,e,n,r){r===void 0&&(r=!1);let i;typeof t=="string"?i=cp(t):(i=Tg({},t),_r(!i.pathname||!i.pathname.includes("?"),Zw("?","pathname","search",i)),_r(!i.pathname||!i.pathname.includes("#"),Zw("#","pathname","hash",i)),_r(!i.search||!i.search.includes("#"),Zw("#","search","hash",i)));let s=t===""||i.pathname==="",o=s?"/":i.pathname,a;if(o==null)a=n;else{let d=e.length-1;if(!r&&o.startsWith("..")){let f=o.split("/");for(;f[0]==="..";)f.shift(),d-=1;i.pathname=f.join("/")}a=d>=0?e[d]:"/"}let l=KK(i,a),c=o&&o!=="/"&&o.endsWith("/"),u=(s||o===".")&&n.endsWith("/");return!l.pathname.endsWith("/")&&(c||u)&&(l.pathname+="/"),l}const xc=t=>t.join("/").replace(/\/\/+/g,"/"),YK=t=>t.replace(/\/+$/,"").replace(/^\/*/,"/"),QK=t=>!t||t==="?"?"":t.startsWith("?")?t:"?"+t,ZK=t=>!t||t==="#"?"":t.startsWith("#")?t:"#"+t;function eq(t){return t!=null&&typeof t.status=="number"&&typeof t.statusText=="string"&&typeof t.internal=="boolean"&&"data"in t}const w$=["post","put","patch","delete"];new Set(w$);const tq=["get",...w$];new Set(tq);/**
 * React Router v6.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Mg(){return Mg=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},Mg.apply(this,arguments)}const OM=L.createContext(null),nq=L.createContext(null),Md=L.createContext(null),Eb=L.createContext(null),Lc=L.createContext({outlet:null,matches:[],isDataRoute:!1}),C$=L.createContext(null);function rq(t,e){let{relative:n}=e===void 0?{}:e;p0()||_r(!1);let{basename:r,navigator:i}=L.useContext(Md),{hash:s,pathname:o,search:a}=T$(t,{relative:n}),l=o;return r!=="/"&&(l=o==="/"?r:xc([r,o])),i.createHref({pathname:l,search:a,hash:s})}function p0(){return L.useContext(Eb)!=null}function Ab(){return p0()||_r(!1),L.useContext(Eb).location}function E$(t){L.useContext(Md).static||L.useLayoutEffect(t)}function m0(){let{isDataRoute:t}=L.useContext(Lc);return t?gq():iq()}function iq(){p0()||_r(!1);let t=L.useContext(OM),{basename:e,future:n,navigator:r}=L.useContext(Md),{matches:i}=L.useContext(Lc),{pathname:s}=Ab(),o=JSON.stringify(S$(i,n.v7_relativeSplatPath)),a=L.useRef(!1);return E$(()=>{a.current=!0}),L.useCallback(function(c,u){if(u===void 0&&(u={}),!a.current)return;if(typeof c=="number"){r.go(c);return}let d=_$(c,JSON.parse(o),s,u.relative==="path");t==null&&e!=="/"&&(d.pathname=d.pathname==="/"?e:xc([e,d.pathname])),(u.replace?r.replace:r.push)(d,u.state,u)},[e,r,o,s,t])}function A$(){let{matches:t}=L.useContext(Lc),e=t[t.length-1];return e?e.params:{}}function T$(t,e){let{relative:n}=e===void 0?{}:e,{future:r}=L.useContext(Md),{matches:i}=L.useContext(Lc),{pathname:s}=Ab(),o=JSON.stringify(S$(i,r.v7_relativeSplatPath));return L.useMemo(()=>_$(t,JSON.parse(o),s,n==="path"),[t,o,s,n])}function sq(t,e){return oq(t,e)}function oq(t,e,n,r){p0()||_r(!1);let{navigator:i}=L.useContext(Md),{matches:s}=L.useContext(Lc),o=s[s.length-1],a=o?o.params:{};o&&o.pathname;let l=o?o.pathnameBase:"/";o&&o.route;let c=Ab(),u;if(e){var d;let v=typeof e=="string"?cp(e):e;l==="/"||(d=v.pathname)!=null&&d.startsWith(l)||_r(!1),u=v}else u=c;let f=u.pathname||"/",h=f;if(l!=="/"){let v=l.replace(/^\//,"").split("/");h="/"+f.replace(/^\//,"").split("/").slice(v.length).join("/")}let p=DK(t,{pathname:h}),x=dq(p&&p.map(v=>Object.assign({},v,{params:Object.assign({},a,v.params),pathname:xc([l,i.encodeLocation?i.encodeLocation(v.pathname).pathname:v.pathname]),pathnameBase:v.pathnameBase==="/"?l:xc([l,i.encodeLocation?i.encodeLocation(v.pathnameBase).pathname:v.pathnameBase])})),s,n,r);return e&&x?L.createElement(Eb.Provider,{value:{location:Mg({pathname:"/",search:"",hash:"",state:null,key:"default"},u),navigationType:lc.Pop}},x):x}function aq(){let t=mq(),e=eq(t)?t.status+" "+t.statusText:t instanceof Error?t.message:JSON.stringify(t),n=t instanceof Error?t.stack:null,i={padding:"0.5rem",backgroundColor:"rgba(200,200,200, 0.5)"};return L.createElement(L.Fragment,null,L.createElement("h2",null,"Unexpected Application Error!"),L.createElement("h3",{style:{fontStyle:"italic"}},e),n?L.createElement("pre",{style:i},n):null,null)}const lq=L.createElement(aq,null);class cq extends L.Component{constructor(e){super(e),this.state={location:e.location,revalidation:e.revalidation,error:e.error}}static getDerivedStateFromError(e){return{error:e}}static getDerivedStateFromProps(e,n){return n.location!==e.location||n.revalidation!=="idle"&&e.revalidation==="idle"?{error:e.error,location:e.location,revalidation:e.revalidation}:{error:e.error!==void 0?e.error:n.error,location:n.location,revalidation:e.revalidation||n.revalidation}}componentDidCatch(e,n){console.error("React Router caught the following error during render",e,n)}render(){return this.state.error!==void 0?L.createElement(Lc.Provider,{value:this.props.routeContext},L.createElement(C$.Provider,{value:this.state.error,children:this.props.component})):this.props.children}}function uq(t){let{routeContext:e,match:n,children:r}=t,i=L.useContext(OM);return i&&i.static&&i.staticContext&&(n.route.errorElement||n.route.ErrorBoundary)&&(i.staticContext._deepestRenderedBoundaryId=n.route.id),L.createElement(Lc.Provider,{value:e},r)}function dq(t,e,n,r){var i;if(e===void 0&&(e=[]),n===void 0&&(n=null),r===void 0&&(r=null),t==null){var s;if((s=n)!=null&&s.errors)t=n.matches;else return null}let o=t,a=(i=n)==null?void 0:i.errors;if(a!=null){let u=o.findIndex(d=>d.route.id&&(a==null?void 0:a[d.route.id])!==void 0);u>=0||_r(!1),o=o.slice(0,Math.min(o.length,u+1))}let l=!1,c=-1;if(n&&r&&r.v7_partialHydration)for(let u=0;u<o.length;u++){let d=o[u];if((d.route.HydrateFallback||d.route.hydrateFallbackElement)&&(c=u),d.route.id){let{loaderData:f,errors:h}=n,p=d.route.loader&&f[d.route.id]===void 0&&(!h||h[d.route.id]===void 0);if(d.route.lazy||p){l=!0,c>=0?o=o.slice(0,c+1):o=[o[0]];break}}}return o.reduceRight((u,d,f)=>{let h,p=!1,x=null,v=null;n&&(h=a&&d.route.id?a[d.route.id]:void 0,x=d.route.errorElement||lq,l&&(c<0&&f===0?(yq("route-fallback",!1),p=!0,v=null):c===f&&(p=!0,v=d.route.hydrateFallbackElement||null)));let y=e.concat(o.slice(0,f+1)),b=()=>{let S;return h?S=x:p?S=v:d.route.Component?S=L.createElement(d.route.Component,null):d.route.element?S=d.route.element:S=u,L.createElement(uq,{match:d,routeContext:{outlet:u,matches:y,isDataRoute:n!=null},children:S})};return n&&(d.route.ErrorBoundary||d.route.errorElement||f===0)?L.createElement(cq,{location:n.location,revalidation:n.revalidation,component:x,error:h,children:b(),routeContext:{outlet:null,matches:y,isDataRoute:!0}}):b()},null)}var M$=function(t){return t.UseBlocker="useBlocker",t.UseRevalidator="useRevalidator",t.UseNavigateStable="useNavigate",t}(M$||{}),P1=function(t){return t.UseBlocker="useBlocker",t.UseLoaderData="useLoaderData",t.UseActionData="useActionData",t.UseRouteError="useRouteError",t.UseNavigation="useNavigation",t.UseRouteLoaderData="useRouteLoaderData",t.UseMatches="useMatches",t.UseRevalidator="useRevalidator",t.UseNavigateStable="useNavigate",t.UseRouteId="useRouteId",t}(P1||{});function fq(t){let e=L.useContext(OM);return e||_r(!1),e}function hq(t){let e=L.useContext(nq);return e||_r(!1),e}function pq(t){let e=L.useContext(Lc);return e||_r(!1),e}function R$(t){let e=pq(),n=e.matches[e.matches.length-1];return n.route.id||_r(!1),n.route.id}function mq(){var t;let e=L.useContext(C$),n=hq(P1.UseRouteError),r=R$(P1.UseRouteError);return e!==void 0?e:(t=n.errors)==null?void 0:t[r]}function gq(){let{router:t}=fq(M$.UseNavigateStable),e=R$(P1.UseNavigateStable),n=L.useRef(!1);return E$(()=>{n.current=!0}),L.useCallback(function(i,s){s===void 0&&(s={}),n.current&&(typeof i=="number"?t.navigate(i):t.navigate(i,Mg({fromRouteId:e},s)))},[t,e])}const ek={};function yq(t,e,n){!e&&!ek[t]&&(ek[t]=!0)}function Fm(t){_r(!1)}function vq(t){let{basename:e="/",children:n=null,location:r,navigationType:i=lc.Pop,navigator:s,static:o=!1,future:a}=t;p0()&&_r(!1);let l=e.replace(/^\/*/,"/"),c=L.useMemo(()=>({basename:l,navigator:s,static:o,future:Mg({v7_relativeSplatPath:!1},a)}),[l,a,s,o]);typeof r=="string"&&(r=cp(r));let{pathname:u="/",search:d="",hash:f="",state:h=null,key:p="default"}=r,x=L.useMemo(()=>{let v=DM(u,l);return v==null?null:{location:{pathname:v,search:d,hash:f,state:h,key:p},navigationType:i}},[l,u,d,f,h,p,i]);return x==null?null:L.createElement(Md.Provider,{value:c},L.createElement(Eb.Provider,{children:n,value:x}))}function xq(t){let{children:e,location:n}=t;return sq(UA(e),n)}new Promise(()=>{});function UA(t,e){e===void 0&&(e=[]);let n=[];return L.Children.forEach(t,(r,i)=>{if(!L.isValidElement(r))return;let s=[...e,i];if(r.type===L.Fragment){n.push.apply(n,UA(r.props.children,s));return}r.type!==Fm&&_r(!1),!r.props.index||!r.props.children||_r(!1);let o={id:r.props.id||s.join("-"),caseSensitive:r.props.caseSensitive,element:r.props.element,Component:r.props.Component,index:r.props.index,path:r.props.path,loader:r.props.loader,action:r.props.action,errorElement:r.props.errorElement,ErrorBoundary:r.props.ErrorBoundary,hasErrorBoundary:r.props.ErrorBoundary!=null||r.props.errorElement!=null,shouldRevalidate:r.props.shouldRevalidate,handle:r.props.handle,lazy:r.props.lazy};r.props.children&&(o.children=UA(r.props.children,s)),n.push(o)}),n}/**
 * React Router DOM v6.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function zA(){return zA=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},zA.apply(this,arguments)}function bq(t,e){if(t==null)return{};var n={},r=Object.keys(t),i,s;for(s=0;s<r.length;s++)i=r[s],!(e.indexOf(i)>=0)&&(n[i]=t[i]);return n}function Sq(t){return!!(t.metaKey||t.altKey||t.ctrlKey||t.shiftKey)}function _q(t,e){return t.button===0&&(!e||e==="_self")&&!Sq(t)}const wq=["onClick","relative","reloadDocument","replace","state","target","to","preventScrollReset","unstable_viewTransition"],Cq="6";try{window.__reactRouterVersion=Cq}catch{}const Eq="startTransition",tk=o1[Eq];function Aq(t){let{basename:e,children:n,future:r,window:i}=t,s=L.useRef();s.current==null&&(s.current=NK({window:i,v5Compat:!0}));let o=s.current,[a,l]=L.useState({action:o.action,location:o.location}),{v7_startTransition:c}=r||{},u=L.useCallback(d=>{c&&tk?tk(()=>l(d)):l(d)},[l,c]);return L.useLayoutEffect(()=>o.listen(u),[o,u]),L.createElement(vq,{basename:e,children:n,location:a.location,navigationType:a.action,navigator:o,future:r})}const Tq=typeof window<"u"&&typeof window.document<"u"&&typeof window.document.createElement<"u",Mq=/^(?:[a-z][a-z0-9+.-]*:|\/\/)/i,Rq=L.forwardRef(function(e,n){let{onClick:r,relative:i,reloadDocument:s,replace:o,state:a,target:l,to:c,preventScrollReset:u,unstable_viewTransition:d}=e,f=bq(e,wq),{basename:h}=L.useContext(Md),p,x=!1;if(typeof c=="string"&&Mq.test(c)&&(p=c,Tq))try{let S=new URL(window.location.href),w=c.startsWith("//")?new URL(S.protocol+c):new URL(c),E=DM(w.pathname,h);w.origin===S.origin&&E!=null?c=E+w.search+w.hash:x=!0}catch{}let v=rq(c,{relative:i}),y=Iq(c,{replace:o,state:a,target:l,preventScrollReset:u,relative:i,unstable_viewTransition:d});function b(S){r&&r(S),S.defaultPrevented||y(S)}return L.createElement("a",zA({},f,{href:p||v,onClick:x||s?r:b,ref:n,target:l}))});var nk;(function(t){t.UseScrollRestoration="useScrollRestoration",t.UseSubmit="useSubmit",t.UseSubmitFetcher="useSubmitFetcher",t.UseFetcher="useFetcher",t.useViewTransitionState="useViewTransitionState"})(nk||(nk={}));var rk;(function(t){t.UseFetcher="useFetcher",t.UseFetchers="useFetchers",t.UseScrollRestoration="useScrollRestoration"})(rk||(rk={}));function Iq(t,e){let{target:n,replace:r,state:i,preventScrollReset:s,relative:o,unstable_viewTransition:a}=e===void 0?{}:e,l=m0(),c=Ab(),u=T$(t,{relative:o});return L.useCallback(d=>{if(_q(d,n)){d.preventDefault();let f=r!==void 0?r:N1(c)===N1(u);l(t,{replace:f,state:i,preventScrollReset:s,relative:o,unstable_viewTransition:a})}},[c,l,u,r,i,n,t,s,o,a])}const Nq={black:"#000",white:"#fff"},Rg=Nq,Pq={50:"#ffebee",100:"#ffcdd2",200:"#ef9a9a",300:"#e57373",400:"#ef5350",500:"#f44336",600:"#e53935",700:"#d32f2f",800:"#c62828",900:"#b71c1c",A100:"#ff8a80",A200:"#ff5252",A400:"#ff1744",A700:"#d50000"},sf=Pq,kq={50:"#f3e5f5",100:"#e1bee7",200:"#ce93d8",300:"#ba68c8",400:"#ab47bc",500:"#9c27b0",600:"#8e24aa",700:"#7b1fa2",800:"#6a1b9a",900:"#4a148c",A100:"#ea80fc",A200:"#e040fb",A400:"#d500f9",A700:"#aa00ff"},of=kq,Dq={50:"#e3f2fd",100:"#bbdefb",200:"#90caf9",300:"#64b5f6",400:"#42a5f5",500:"#2196f3",600:"#1e88e5",700:"#1976d2",800:"#1565c0",900:"#0d47a1",A100:"#82b1ff",A200:"#448aff",A400:"#2979ff",A700:"#2962ff"},af=Dq,Oq={50:"#e1f5fe",100:"#b3e5fc",200:"#81d4fa",300:"#4fc3f7",400:"#29b6f6",500:"#03a9f4",600:"#039be5",700:"#0288d1",800:"#0277bd",900:"#01579b",A100:"#80d8ff",A200:"#40c4ff",A400:"#00b0ff",A700:"#0091ea"},lf=Oq,Lq={50:"#e8f5e9",100:"#c8e6c9",200:"#a5d6a7",300:"#81c784",400:"#66bb6a",500:"#4caf50",600:"#43a047",700:"#388e3c",800:"#2e7d32",900:"#1b5e20",A100:"#b9f6ca",A200:"#69f0ae",A400:"#00e676",A700:"#00c853"},cf=Lq,Bq={50:"#fff3e0",100:"#ffe0b2",200:"#ffcc80",300:"#ffb74d",400:"#ffa726",500:"#ff9800",600:"#fb8c00",700:"#f57c00",800:"#ef6c00",900:"#e65100",A100:"#ffd180",A200:"#ffab40",A400:"#ff9100",A700:"#ff6d00"},om=Bq,Fq={50:"#fafafa",100:"#f5f5f5",200:"#eeeeee",300:"#e0e0e0",400:"#bdbdbd",500:"#9e9e9e",600:"#757575",700:"#616161",800:"#424242",900:"#212121",A100:"#f5f5f5",A200:"#eeeeee",A400:"#bdbdbd",A700:"#616161"},$q=Fq;function cd(t){let e="https://mui.com/production-error/?code="+t;for(let n=1;n<arguments.length;n+=1)e+="&args[]="+encodeURIComponent(arguments[n]);return"Minified MUI error #"+t+"; visit "+e+" for the full message."}const Uq=Object.freeze(Object.defineProperty({__proto__:null,default:cd},Symbol.toStringTag,{value:"Module"})),g0="$$material";function X(){return X=Object.assign?Object.assign.bind():function(t){for(var e=1;e<arguments.length;e++){var n=arguments[e];for(var r in n)Object.prototype.hasOwnProperty.call(n,r)&&(t[r]=n[r])}return t},X.apply(this,arguments)}function it(t,e){if(t==null)return{};var n={},r=Object.keys(t),i,s;for(s=0;s<r.length;s++)i=r[s],!(e.indexOf(i)>=0)&&(n[i]=t[i]);return n}function I$(t){var e=Object.create(null);return function(n){return e[n]===void 0&&(e[n]=t(n)),e[n]}}var zq=/^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/,Gq=I$(function(t){return zq.test(t)||t.charCodeAt(0)===111&&t.charCodeAt(1)===110&&t.charCodeAt(2)<91});function Hq(t){if(t.sheet)return t.sheet;for(var e=0;e<document.styleSheets.length;e++)if(document.styleSheets[e].ownerNode===t)return document.styleSheets[e]}function Vq(t){var e=document.createElement("style");return e.setAttribute("data-emotion",t.key),t.nonce!==void 0&&e.setAttribute("nonce",t.nonce),e.appendChild(document.createTextNode("")),e.setAttribute("data-s",""),e}var Wq=function(){function t(n){var r=this;this._insertTag=function(i){var s;r.tags.length===0?r.insertionPoint?s=r.insertionPoint.nextSibling:r.prepend?s=r.container.firstChild:s=r.before:s=r.tags[r.tags.length-1].nextSibling,r.container.insertBefore(i,s),r.tags.push(i)},this.isSpeedy=n.speedy===void 0?!0:n.speedy,this.tags=[],this.ctr=0,this.nonce=n.nonce,this.key=n.key,this.container=n.container,this.prepend=n.prepend,this.insertionPoint=n.insertionPoint,this.before=null}var e=t.prototype;return e.hydrate=function(r){r.forEach(this._insertTag)},e.insert=function(r){this.ctr%(this.isSpeedy?65e3:1)===0&&this._insertTag(Vq(this));var i=this.tags[this.tags.length-1];if(this.isSpeedy){var s=Hq(i);try{s.insertRule(r,s.cssRules.length)}catch{}}else i.appendChild(document.createTextNode(r));this.ctr++},e.flush=function(){this.tags.forEach(function(r){return r.parentNode&&r.parentNode.removeChild(r)}),this.tags=[],this.ctr=0},t}(),fi="-ms-",k1="-moz-",un="-webkit-",N$="comm",LM="rule",BM="decl",jq="@import",P$="@keyframes",Xq="@layer",Kq=Math.abs,Tb=String.fromCharCode,qq=Object.assign;function Jq(t,e){return Yr(t,0)^45?(((e<<2^Yr(t,0))<<2^Yr(t,1))<<2^Yr(t,2))<<2^Yr(t,3):0}function k$(t){return t.trim()}function Yq(t,e){return(t=e.exec(t))?t[0]:t}function dn(t,e,n){return t.replace(e,n)}function GA(t,e){return t.indexOf(e)}function Yr(t,e){return t.charCodeAt(e)|0}function Ig(t,e,n){return t.slice(e,n)}function pa(t){return t.length}function FM(t){return t.length}function fv(t,e){return e.push(t),t}function Qq(t,e){return t.map(e).join("")}var Mb=1,Oh=1,D$=0,rs=0,br=0,up="";function Rb(t,e,n,r,i,s,o){return{value:t,root:e,parent:n,type:r,props:i,children:s,line:Mb,column:Oh,length:o,return:""}}function am(t,e){return qq(Rb("",null,null,"",null,null,0),t,{length:-t.length},e)}function Zq(){return br}function eJ(){return br=rs>0?Yr(up,--rs):0,Oh--,br===10&&(Oh=1,Mb--),br}function As(){return br=rs<D$?Yr(up,rs++):0,Oh++,br===10&&(Oh=1,Mb++),br}function wa(){return Yr(up,rs)}function Ux(){return rs}function y0(t,e){return Ig(up,t,e)}function Ng(t){switch(t){case 0:case 9:case 10:case 13:case 32:return 5;case 33:case 43:case 44:case 47:case 62:case 64:case 126:case 59:case 123:case 125:return 4;case 58:return 3;case 34:case 39:case 40:case 91:return 2;case 41:case 93:return 1}return 0}function O$(t){return Mb=Oh=1,D$=pa(up=t),rs=0,[]}function L$(t){return up="",t}function zx(t){return k$(y0(rs-1,HA(t===91?t+2:t===40?t+1:t)))}function tJ(t){for(;(br=wa())&&br<33;)As();return Ng(t)>2||Ng(br)>3?"":" "}function nJ(t,e){for(;--e&&As()&&!(br<48||br>102||br>57&&br<65||br>70&&br<97););return y0(t,Ux()+(e<6&&wa()==32&&As()==32))}function HA(t){for(;As();)switch(br){case t:return rs;case 34:case 39:t!==34&&t!==39&&HA(br);break;case 40:t===41&&HA(t);break;case 92:As();break}return rs}function rJ(t,e){for(;As()&&t+br!==57;)if(t+br===84&&wa()===47)break;return"/*"+y0(e,rs-1)+"*"+Tb(t===47?t:As())}function iJ(t){for(;!Ng(wa());)As();return y0(t,rs)}function sJ(t){return L$(Gx("",null,null,null,[""],t=O$(t),0,[0],t))}function Gx(t,e,n,r,i,s,o,a,l){for(var c=0,u=0,d=o,f=0,h=0,p=0,x=1,v=1,y=1,b=0,S="",w=i,E=s,A=r,T=S;v;)switch(p=b,b=As()){case 40:if(p!=108&&Yr(T,d-1)==58){GA(T+=dn(zx(b),"&","&\f"),"&\f")!=-1&&(y=-1);break}case 34:case 39:case 91:T+=zx(b);break;case 9:case 10:case 13:case 32:T+=tJ(p);break;case 92:T+=nJ(Ux()-1,7);continue;case 47:switch(wa()){case 42:case 47:fv(oJ(rJ(As(),Ux()),e,n),l);break;default:T+="/"}break;case 123*x:a[c++]=pa(T)*y;case 125*x:case 59:case 0:switch(b){case 0:case 125:v=0;case 59+u:y==-1&&(T=dn(T,/\f/g,"")),h>0&&pa(T)-d&&fv(h>32?sk(T+";",r,n,d-1):sk(dn(T," ","")+";",r,n,d-2),l);break;case 59:T+=";";default:if(fv(A=ik(T,e,n,c,u,i,a,S,w=[],E=[],d),s),b===123)if(u===0)Gx(T,e,A,A,w,s,d,a,E);else switch(f===99&&Yr(T,3)===110?100:f){case 100:case 108:case 109:case 115:Gx(t,A,A,r&&fv(ik(t,A,A,0,0,i,a,S,i,w=[],d),E),i,E,d,a,r?w:E);break;default:Gx(T,A,A,A,[""],E,0,a,E)}}c=u=h=0,x=y=1,S=T="",d=o;break;case 58:d=1+pa(T),h=p;default:if(x<1){if(b==123)--x;else if(b==125&&x++==0&&eJ()==125)continue}switch(T+=Tb(b),b*x){case 38:y=u>0?1:(T+="\f",-1);break;case 44:a[c++]=(pa(T)-1)*y,y=1;break;case 64:wa()===45&&(T+=zx(As())),f=wa(),u=d=pa(S=T+=iJ(Ux())),b++;break;case 45:p===45&&pa(T)==2&&(x=0)}}return s}function ik(t,e,n,r,i,s,o,a,l,c,u){for(var d=i-1,f=i===0?s:[""],h=FM(f),p=0,x=0,v=0;p<r;++p)for(var y=0,b=Ig(t,d+1,d=Kq(x=o[p])),S=t;y<h;++y)(S=k$(x>0?f[y]+" "+b:dn(b,/&\f/g,f[y])))&&(l[v++]=S);return Rb(t,e,n,i===0?LM:a,l,c,u)}function oJ(t,e,n){return Rb(t,e,n,N$,Tb(Zq()),Ig(t,2,-2),0)}function sk(t,e,n,r){return Rb(t,e,n,BM,Ig(t,0,r),Ig(t,r+1,-1),r)}function yh(t,e){for(var n="",r=FM(t),i=0;i<r;i++)n+=e(t[i],i,t,e)||"";return n}function aJ(t,e,n,r){switch(t.type){case Xq:if(t.children.length)break;case jq:case BM:return t.return=t.return||t.value;case N$:return"";case P$:return t.return=t.value+"{"+yh(t.children,r)+"}";case LM:t.value=t.props.join(",")}return pa(n=yh(t.children,r))?t.return=t.value+"{"+n+"}":""}function lJ(t){var e=FM(t);return function(n,r,i,s){for(var o="",a=0;a<e;a++)o+=t[a](n,r,i,s)||"";return o}}function cJ(t){return function(e){e.root||(e=e.return)&&t(e)}}var uJ=function(e,n,r){for(var i=0,s=0;i=s,s=wa(),i===38&&s===12&&(n[r]=1),!Ng(s);)As();return y0(e,rs)},dJ=function(e,n){var r=-1,i=44;do switch(Ng(i)){case 0:i===38&&wa()===12&&(n[r]=1),e[r]+=uJ(rs-1,n,r);break;case 2:e[r]+=zx(i);break;case 4:if(i===44){e[++r]=wa()===58?"&\f":"",n[r]=e[r].length;break}default:e[r]+=Tb(i)}while(i=As());return e},fJ=function(e,n){return L$(dJ(O$(e),n))},ok=new WeakMap,hJ=function(e){if(!(e.type!=="rule"||!e.parent||e.length<1)){for(var n=e.value,r=e.parent,i=e.column===r.column&&e.line===r.line;r.type!=="rule";)if(r=r.parent,!r)return;if(!(e.props.length===1&&n.charCodeAt(0)!==58&&!ok.get(r))&&!i){ok.set(e,!0);for(var s=[],o=fJ(n,s),a=r.props,l=0,c=0;l<o.length;l++)for(var u=0;u<a.length;u++,c++)e.props[c]=s[l]?o[l].replace(/&\f/g,a[u]):a[u]+" "+o[l]}}},pJ=function(e){if(e.type==="decl"){var n=e.value;n.charCodeAt(0)===108&&n.charCodeAt(2)===98&&(e.return="",e.value="")}};function B$(t,e){switch(Jq(t,e)){case 5103:return un+"print-"+t+t;case 5737:case 4201:case 3177:case 3433:case 1641:case 4457:case 2921:case 5572:case 6356:case 5844:case 3191:case 6645:case 3005:case 6391:case 5879:case 5623:case 6135:case 4599:case 4855:case 4215:case 6389:case 5109:case 5365:case 5621:case 3829:return un+t+t;case 5349:case 4246:case 4810:case 6968:case 2756:return un+t+k1+t+fi+t+t;case 6828:case 4268:return un+t+fi+t+t;case 6165:return un+t+fi+"flex-"+t+t;case 5187:return un+t+dn(t,/(\w+).+(:[^]+)/,un+"box-$1$2"+fi+"flex-$1$2")+t;case 5443:return un+t+fi+"flex-item-"+dn(t,/flex-|-self/,"")+t;case 4675:return un+t+fi+"flex-line-pack"+dn(t,/align-content|flex-|-self/,"")+t;case 5548:return un+t+fi+dn(t,"shrink","negative")+t;case 5292:return un+t+fi+dn(t,"basis","preferred-size")+t;case 6060:return un+"box-"+dn(t,"-grow","")+un+t+fi+dn(t,"grow","positive")+t;case 4554:return un+dn(t,/([^-])(transform)/g,"$1"+un+"$2")+t;case 6187:return dn(dn(dn(t,/(zoom-|grab)/,un+"$1"),/(image-set)/,un+"$1"),t,"")+t;case 5495:case 3959:return dn(t,/(image-set\([^]*)/,un+"$1$`$1");case 4968:return dn(dn(t,/(.+:)(flex-)?(.*)/,un+"box-pack:$3"+fi+"flex-pack:$3"),/s.+-b[^;]+/,"justify")+un+t+t;case 4095:case 3583:case 4068:case 2532:return dn(t,/(.+)-inline(.+)/,un+"$1$2")+t;case 8116:case 7059:case 5753:case 5535:case 5445:case 5701:case 4933:case 4677:case 5533:case 5789:case 5021:case 4765:if(pa(t)-1-e>6)switch(Yr(t,e+1)){case 109:if(Yr(t,e+4)!==45)break;case 102:return dn(t,/(.+:)(.+)-([^]+)/,"$1"+un+"$2-$3$1"+k1+(Yr(t,e+3)==108?"$3":"$2-$3"))+t;case 115:return~GA(t,"stretch")?B$(dn(t,"stretch","fill-available"),e)+t:t}break;case 4949:if(Yr(t,e+1)!==115)break;case 6444:switch(Yr(t,pa(t)-3-(~GA(t,"!important")&&10))){case 107:return dn(t,":",":"+un)+t;case 101:return dn(t,/(.+:)([^;!]+)(;|!.+)?/,"$1"+un+(Yr(t,14)===45?"inline-":"")+"box$3$1"+un+"$2$3$1"+fi+"$2box$3")+t}break;case 5936:switch(Yr(t,e+11)){case 114:return un+t+fi+dn(t,/[svh]\w+-[tblr]{2}/,"tb")+t;case 108:return un+t+fi+dn(t,/[svh]\w+-[tblr]{2}/,"tb-rl")+t;case 45:return un+t+fi+dn(t,/[svh]\w+-[tblr]{2}/,"lr")+t}return un+t+fi+t+t}return t}var mJ=function(e,n,r,i){if(e.length>-1&&!e.return)switch(e.type){case BM:e.return=B$(e.value,e.length);break;case P$:return yh([am(e,{value:dn(e.value,"@","@"+un)})],i);case LM:if(e.length)return Qq(e.props,function(s){switch(Yq(s,/(::plac\w+|:read-\w+)/)){case":read-only":case":read-write":return yh([am(e,{props:[dn(s,/:(read-\w+)/,":"+k1+"$1")]})],i);case"::placeholder":return yh([am(e,{props:[dn(s,/:(plac\w+)/,":"+un+"input-$1")]}),am(e,{props:[dn(s,/:(plac\w+)/,":"+k1+"$1")]}),am(e,{props:[dn(s,/:(plac\w+)/,fi+"input-$1")]})],i)}return""})}},gJ=[mJ],F$=function(e){var n=e.key;if(n==="css"){var r=document.querySelectorAll("style[data-emotion]:not([data-s])");Array.prototype.forEach.call(r,function(x){var v=x.getAttribute("data-emotion");v.indexOf(" ")!==-1&&(document.head.appendChild(x),x.setAttribute("data-s",""))})}var i=e.stylisPlugins||gJ,s={},o,a=[];o=e.container||document.head,Array.prototype.forEach.call(document.querySelectorAll('style[data-emotion^="'+n+' "]'),function(x){for(var v=x.getAttribute("data-emotion").split(" "),y=1;y<v.length;y++)s[v[y]]=!0;a.push(x)});var l,c=[hJ,pJ];{var u,d=[aJ,cJ(function(x){u.insert(x)})],f=lJ(c.concat(i,d)),h=function(v){return yh(sJ(v),f)};l=function(v,y,b,S){u=b,h(v?v+"{"+y.styles+"}":y.styles),S&&(p.inserted[y.name]=!0)}}var p={key:n,sheet:new Wq({key:n,container:o,nonce:e.nonce,speedy:e.speedy,prepend:e.prepend,insertionPoint:e.insertionPoint}),nonce:e.nonce,inserted:s,registered:{},insert:l};return p.sheet.hydrate(a),p},$$={exports:{}},bn={};/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var jr=typeof Symbol=="function"&&Symbol.for,$M=jr?Symbol.for("react.element"):60103,UM=jr?Symbol.for("react.portal"):60106,Ib=jr?Symbol.for("react.fragment"):60107,Nb=jr?Symbol.for("react.strict_mode"):60108,Pb=jr?Symbol.for("react.profiler"):60114,kb=jr?Symbol.for("react.provider"):60109,Db=jr?Symbol.for("react.context"):60110,zM=jr?Symbol.for("react.async_mode"):60111,Ob=jr?Symbol.for("react.concurrent_mode"):60111,Lb=jr?Symbol.for("react.forward_ref"):60112,Bb=jr?Symbol.for("react.suspense"):60113,yJ=jr?Symbol.for("react.suspense_list"):60120,Fb=jr?Symbol.for("react.memo"):60115,$b=jr?Symbol.for("react.lazy"):60116,vJ=jr?Symbol.for("react.block"):60121,xJ=jr?Symbol.for("react.fundamental"):60117,bJ=jr?Symbol.for("react.responder"):60118,SJ=jr?Symbol.for("react.scope"):60119;function Ds(t){if(typeof t=="object"&&t!==null){var e=t.$$typeof;switch(e){case $M:switch(t=t.type,t){case zM:case Ob:case Ib:case Pb:case Nb:case Bb:return t;default:switch(t=t&&t.$$typeof,t){case Db:case Lb:case $b:case Fb:case kb:return t;default:return e}}case UM:return e}}}function U$(t){return Ds(t)===Ob}bn.AsyncMode=zM;bn.ConcurrentMode=Ob;bn.ContextConsumer=Db;bn.ContextProvider=kb;bn.Element=$M;bn.ForwardRef=Lb;bn.Fragment=Ib;bn.Lazy=$b;bn.Memo=Fb;bn.Portal=UM;bn.Profiler=Pb;bn.StrictMode=Nb;bn.Suspense=Bb;bn.isAsyncMode=function(t){return U$(t)||Ds(t)===zM};bn.isConcurrentMode=U$;bn.isContextConsumer=function(t){return Ds(t)===Db};bn.isContextProvider=function(t){return Ds(t)===kb};bn.isElement=function(t){return typeof t=="object"&&t!==null&&t.$$typeof===$M};bn.isForwardRef=function(t){return Ds(t)===Lb};bn.isFragment=function(t){return Ds(t)===Ib};bn.isLazy=function(t){return Ds(t)===$b};bn.isMemo=function(t){return Ds(t)===Fb};bn.isPortal=function(t){return Ds(t)===UM};bn.isProfiler=function(t){return Ds(t)===Pb};bn.isStrictMode=function(t){return Ds(t)===Nb};bn.isSuspense=function(t){return Ds(t)===Bb};bn.isValidElementType=function(t){return typeof t=="string"||typeof t=="function"||t===Ib||t===Ob||t===Pb||t===Nb||t===Bb||t===yJ||typeof t=="object"&&t!==null&&(t.$$typeof===$b||t.$$typeof===Fb||t.$$typeof===kb||t.$$typeof===Db||t.$$typeof===Lb||t.$$typeof===xJ||t.$$typeof===bJ||t.$$typeof===SJ||t.$$typeof===vJ)};bn.typeOf=Ds;$$.exports=bn;var _J=$$.exports,z$=_J,wJ={$$typeof:!0,render:!0,defaultProps:!0,displayName:!0,propTypes:!0},CJ={$$typeof:!0,compare:!0,defaultProps:!0,displayName:!0,propTypes:!0,type:!0},G$={};G$[z$.ForwardRef]=wJ;G$[z$.Memo]=CJ;var EJ=!0;function AJ(t,e,n){var r="";return n.split(" ").forEach(function(i){t[i]!==void 0?e.push(t[i]+";"):r+=i+" "}),r}var H$=function(e,n,r){var i=e.key+"-"+n.name;(r===!1||EJ===!1)&&e.registered[i]===void 0&&(e.registered[i]=n.styles)},V$=function(e,n,r){H$(e,n,r);var i=e.key+"-"+n.name;if(e.inserted[n.name]===void 0){var s=n;do e.insert(n===s?"."+i:"",s,e.sheet,!0),s=s.next;while(s!==void 0)}};function TJ(t){for(var e=0,n,r=0,i=t.length;i>=4;++r,i-=4)n=t.charCodeAt(r)&255|(t.charCodeAt(++r)&255)<<8|(t.charCodeAt(++r)&255)<<16|(t.charCodeAt(++r)&255)<<24,n=(n&65535)*1540483477+((n>>>16)*59797<<16),n^=n>>>24,e=(n&65535)*1540483477+((n>>>16)*59797<<16)^(e&65535)*1540483477+((e>>>16)*59797<<16);switch(i){case 3:e^=(t.charCodeAt(r+2)&255)<<16;case 2:e^=(t.charCodeAt(r+1)&255)<<8;case 1:e^=t.charCodeAt(r)&255,e=(e&65535)*1540483477+((e>>>16)*59797<<16)}return e^=e>>>13,e=(e&65535)*1540483477+((e>>>16)*59797<<16),((e^e>>>15)>>>0).toString(36)}var MJ={animationIterationCount:1,aspectRatio:1,borderImageOutset:1,borderImageSlice:1,borderImageWidth:1,boxFlex:1,boxFlexGroup:1,boxOrdinalGroup:1,columnCount:1,columns:1,flex:1,flexGrow:1,flexPositive:1,flexShrink:1,flexNegative:1,flexOrder:1,gridRow:1,gridRowEnd:1,gridRowSpan:1,gridRowStart:1,gridColumn:1,gridColumnEnd:1,gridColumnSpan:1,gridColumnStart:1,msGridRow:1,msGridRowSpan:1,msGridColumn:1,msGridColumnSpan:1,fontWeight:1,lineHeight:1,opacity:1,order:1,orphans:1,tabSize:1,widows:1,zIndex:1,zoom:1,WebkitLineClamp:1,fillOpacity:1,floodOpacity:1,stopOpacity:1,strokeDasharray:1,strokeDashoffset:1,strokeMiterlimit:1,strokeOpacity:1,strokeWidth:1},RJ=/[A-Z]|^ms/g,IJ=/_EMO_([^_]+?)_([^]*?)_EMO_/g,W$=function(e){return e.charCodeAt(1)===45},ak=function(e){return e!=null&&typeof e!="boolean"},eC=I$(function(t){return W$(t)?t:t.replace(RJ,"-$&").toLowerCase()}),lk=function(e,n){switch(e){case"animation":case"animationName":if(typeof n=="string")return n.replace(IJ,function(r,i,s){return ma={name:i,styles:s,next:ma},i})}return MJ[e]!==1&&!W$(e)&&typeof n=="number"&&n!==0?n+"px":n};function Pg(t,e,n){if(n==null)return"";if(n.__emotion_styles!==void 0)return n;switch(typeof n){case"boolean":return"";case"object":{if(n.anim===1)return ma={name:n.name,styles:n.styles,next:ma},n.name;if(n.styles!==void 0){var r=n.next;if(r!==void 0)for(;r!==void 0;)ma={name:r.name,styles:r.styles,next:ma},r=r.next;var i=n.styles+";";return i}return NJ(t,e,n)}case"function":{if(t!==void 0){var s=ma,o=n(t);return ma=s,Pg(t,e,o)}break}}if(e==null)return n;var a=e[n];return a!==void 0?a:n}function NJ(t,e,n){var r="";if(Array.isArray(n))for(var i=0;i<n.length;i++)r+=Pg(t,e,n[i])+";";else for(var s in n){var o=n[s];if(typeof o!="object")e!=null&&e[o]!==void 0?r+=s+"{"+e[o]+"}":ak(o)&&(r+=eC(s)+":"+lk(s,o)+";");else if(Array.isArray(o)&&typeof o[0]=="string"&&(e==null||e[o[0]]===void 0))for(var a=0;a<o.length;a++)ak(o[a])&&(r+=eC(s)+":"+lk(s,o[a])+";");else{var l=Pg(t,e,o);switch(s){case"animation":case"animationName":{r+=eC(s)+":"+l+";";break}default:r+=s+"{"+l+"}"}}}return r}var ck=/label:\s*([^\s;\n{]+)\s*(;|$)/g,ma,GM=function(e,n,r){if(e.length===1&&typeof e[0]=="object"&&e[0]!==null&&e[0].styles!==void 0)return e[0];var i=!0,s="";ma=void 0;var o=e[0];o==null||o.raw===void 0?(i=!1,s+=Pg(r,n,o)):s+=o[0];for(var a=1;a<e.length;a++)s+=Pg(r,n,e[a]),i&&(s+=o[a]);ck.lastIndex=0;for(var l="",c;(c=ck.exec(s))!==null;)l+="-"+c[1];var u=TJ(s)+l;return{name:u,styles:s,next:ma}},PJ=function(e){return e()},j$=o1.useInsertionEffect?o1.useInsertionEffect:!1,kJ=j$||PJ,uk=j$||L.useLayoutEffect,X$=L.createContext(typeof HTMLElement<"u"?F$({key:"css"}):null),DJ=X$.Provider,K$=function(e){return L.forwardRef(function(n,r){var i=L.useContext(X$);return e(n,i,r)})},Ub=L.createContext({}),tC={exports:{}},dk;function q$(){return dk||(dk=1,function(t){function e(){return t.exports=e=Object.assign?Object.assign.bind():function(n){for(var r=1;r<arguments.length;r++){var i=arguments[r];for(var s in i)Object.prototype.hasOwnProperty.call(i,s)&&(n[s]=i[s])}return n},t.exports.__esModule=!0,t.exports.default=t.exports,e.apply(this,arguments)}t.exports=e,t.exports.__esModule=!0,t.exports.default=t.exports}(tC)),tC.exports}q$();var OJ=K$(function(t,e){var n=t.styles,r=GM([n],void 0,L.useContext(Ub)),i=L.useRef();return uk(function(){var s=e.key+"-global",o=new e.sheet.constructor({key:s,nonce:e.sheet.nonce,container:e.sheet.container,speedy:e.sheet.isSpeedy}),a=!1,l=document.querySelector('style[data-emotion="'+s+" "+r.name+'"]');return e.sheet.tags.length&&(o.before=e.sheet.tags[0]),l!==null&&(a=!0,l.setAttribute("data-emotion",s),o.hydrate([l])),i.current=[o,a],function(){o.flush()}},[e]),uk(function(){var s=i.current,o=s[0],a=s[1];if(a){s[1]=!1;return}if(r.next!==void 0&&V$(e,r.next,!0),o.tags.length){var l=o.tags[o.tags.length-1].nextElementSibling;o.before=l,o.flush()}e.insert("",r,o,!1)},[e,r.name]),null});function v0(){for(var t=arguments.length,e=new Array(t),n=0;n<t;n++)e[n]=arguments[n];return GM(e)}var Rd=function(){var e=v0.apply(void 0,arguments),n="animation-"+e.name;return{name:n,styles:"@keyframes "+n+"{"+e.styles+"}",anim:1,toString:function(){return"_EMO_"+this.name+"_"+this.styles+"_EMO_"}}},LJ=Gq,BJ=function(e){return e!=="theme"},fk=function(e){return typeof e=="string"&&e.charCodeAt(0)>96?LJ:BJ},hk=function(e,n,r){var i;if(n){var s=n.shouldForwardProp;i=e.__emotion_forwardProp&&s?function(o){return e.__emotion_forwardProp(o)&&s(o)}:s}return typeof i!="function"&&r&&(i=e.__emotion_forwardProp),i},FJ=function(e){var n=e.cache,r=e.serialized,i=e.isStringTag;return H$(n,r,i),kJ(function(){return V$(n,r,i)}),null},$J=function t(e,n){var r=e.__emotion_real===e,i=r&&e.__emotion_base||e,s,o;n!==void 0&&(s=n.label,o=n.target);var a=hk(e,n,r),l=a||fk(i),c=!l("as");return function(){var u=arguments,d=r&&e.__emotion_styles!==void 0?e.__emotion_styles.slice(0):[];if(s!==void 0&&d.push("label:"+s+";"),u[0]==null||u[0].raw===void 0)d.push.apply(d,u);else{d.push(u[0][0]);for(var f=u.length,h=1;h<f;h++)d.push(u[h],u[0][h])}var p=K$(function(x,v,y){var b=c&&x.as||i,S="",w=[],E=x;if(x.theme==null){E={};for(var A in x)E[A]=x[A];E.theme=L.useContext(Ub)}typeof x.className=="string"?S=AJ(v.registered,w,x.className):x.className!=null&&(S=x.className+" ");var T=GM(d.concat(w),v.registered,E);S+=v.key+"-"+T.name,o!==void 0&&(S+=" "+o);var I=c&&a===void 0?fk(b):l,N={};for(var M in x)c&&M==="as"||I(M)&&(N[M]=x[M]);return N.className=S,N.ref=y,L.createElement(L.Fragment,null,L.createElement(FJ,{cache:v,serialized:T,isStringTag:typeof b=="string"}),L.createElement(b,N))});return p.displayName=s!==void 0?s:"Styled("+(typeof i=="string"?i:i.displayName||i.name||"Component")+")",p.defaultProps=e.defaultProps,p.__emotion_real=p,p.__emotion_base=i,p.__emotion_styles=d,p.__emotion_forwardProp=a,Object.defineProperty(p,"toString",{value:function(){return"."+o}}),p.withComponent=function(x,v){return t(x,X({},n,v,{shouldForwardProp:hk(p,v,!0)})).apply(void 0,d)},p}},UJ=["a","abbr","address","area","article","aside","audio","b","base","bdi","bdo","big","blockquote","body","br","button","canvas","caption","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","div","dl","dt","em","embed","fieldset","figcaption","figure","footer","form","h1","h2","h3","h4","h5","h6","head","header","hgroup","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","marquee","menu","menuitem","meta","meter","nav","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strong","style","sub","summary","sup","table","tbody","td","textarea","tfoot","th","thead","time","title","tr","track","u","ul","var","video","wbr","circle","clipPath","defs","ellipse","foreignObject","g","image","line","linearGradient","mask","path","pattern","polygon","polyline","radialGradient","rect","stop","svg","text","tspan"],VA=$J.bind();UJ.forEach(function(t){VA[t]=VA(t)});var J$={exports:{}},zJ="SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED",GJ=zJ,HJ=GJ;function Y$(){}function Q$(){}Q$.resetWarningCache=Y$;var VJ=function(){function t(r,i,s,o,a,l){if(l!==HJ){var c=new Error("Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types");throw c.name="Invariant Violation",c}}t.isRequired=t;function e(){return t}var n={array:t,bigint:t,bool:t,func:t,number:t,object:t,string:t,symbol:t,any:t,arrayOf:e,element:t,elementType:t,instanceOf:e,node:t,objectOf:e,oneOf:e,oneOfType:e,shape:e,exact:e,checkPropTypes:Q$,resetWarningCache:Y$};return n.PropTypes=n,n};J$.exports=VJ();var WJ=J$.exports;let WA;typeof document=="object"&&(WA=F$({key:"css",prepend:!0}));function jJ(t){const{injectFirst:e,children:n}=t;return e&&WA?H.jsx(DJ,{value:WA,children:n}):n}function XJ(t){return t==null||Object.keys(t).length===0}function Z$(t){const{styles:e,defaultTheme:n={}}=t,r=typeof e=="function"?i=>e(XJ(i)?n:i):e;return H.jsx(OJ,{styles:r})}function HM(t,e){return VA(t,e)}const eU=(t,e)=>{Array.isArray(t.__emotion_styles)&&(t.__emotion_styles=e(t.__emotion_styles))},KJ=Object.freeze(Object.defineProperty({__proto__:null,GlobalStyles:Z$,StyledEngineProvider:jJ,ThemeContext:Ub,css:v0,default:HM,internal_processStyles:eU,keyframes:Rd},Symbol.toStringTag,{value:"Module"}));function el(t){if(typeof t!="object"||t===null)return!1;const e=Object.getPrototypeOf(t);return(e===null||e===Object.prototype||Object.getPrototypeOf(e)===null)&&!(Symbol.toStringTag in t)&&!(Symbol.iterator in t)}function tU(t){if(!el(t))return t;const e={};return Object.keys(t).forEach(n=>{e[n]=tU(t[n])}),e}function Bi(t,e,n={clone:!0}){const r=n.clone?X({},t):t;return el(t)&&el(e)&&Object.keys(e).forEach(i=>{i!=="__proto__"&&(el(e[i])&&i in t&&el(t[i])?r[i]=Bi(t[i],e[i],n):n.clone?r[i]=el(e[i])?tU(e[i]):e[i]:r[i]=e[i])}),r}const qJ=Object.freeze(Object.defineProperty({__proto__:null,default:Bi,isPlainObject:el},Symbol.toStringTag,{value:"Module"})),JJ=["values","unit","step"],YJ=t=>{const e=Object.keys(t).map(n=>({key:n,val:t[n]}))||[];return e.sort((n,r)=>n.val-r.val),e.reduce((n,r)=>X({},n,{[r.key]:r.val}),{})};function nU(t){const{values:e={xs:0,sm:600,md:900,lg:1200,xl:1536},unit:n="px",step:r=5}=t,i=it(t,JJ),s=YJ(e),o=Object.keys(s);function a(f){return`@media (min-width:${typeof e[f]=="number"?e[f]:f}${n})`}function l(f){return`@media (max-width:${(typeof e[f]=="number"?e[f]:f)-r/100}${n})`}function c(f,h){const p=o.indexOf(h);return`@media (min-width:${typeof e[f]=="number"?e[f]:f}${n}) and (max-width:${(p!==-1&&typeof e[o[p]]=="number"?e[o[p]]:h)-r/100}${n})`}function u(f){return o.indexOf(f)+1<o.length?c(f,o[o.indexOf(f)+1]):a(f)}function d(f){const h=o.indexOf(f);return h===0?a(o[1]):h===o.length-1?l(o[h]):c(f,o[o.indexOf(f)+1]).replace("@media","@media not all and")}return X({keys:o,values:s,up:a,down:l,between:c,only:u,not:d,unit:n},i)}const QJ={borderRadius:4},ZJ=QJ;function tg(t,e){return e?Bi(t,e,{clone:!1}):t}const VM={xs:0,sm:600,md:900,lg:1200,xl:1536},pk={keys:["xs","sm","md","lg","xl"],up:t=>`@media (min-width:${VM[t]}px)`};function is(t,e,n){const r=t.theme||{};if(Array.isArray(e)){const s=r.breakpoints||pk;return e.reduce((o,a,l)=>(o[s.up(s.keys[l])]=n(e[l]),o),{})}if(typeof e=="object"){const s=r.breakpoints||pk;return Object.keys(e).reduce((o,a)=>{if(Object.keys(s.values||VM).indexOf(a)!==-1){const l=s.up(a);o[l]=n(e[a],a)}else{const l=a;o[l]=e[l]}return o},{})}return n(e)}function rU(t={}){var e;return((e=t.keys)==null?void 0:e.reduce((r,i)=>{const s=t.up(i);return r[s]={},r},{}))||{}}function iU(t,e){return t.reduce((n,r)=>{const i=n[r];return(!i||Object.keys(i).length===0)&&delete n[r],n},e)}function eY(t,...e){const n=rU(t),r=[n,...e].reduce((i,s)=>Bi(i,s),{});return iU(Object.keys(n),r)}function tY(t,e){if(typeof t!="object")return{};const n={},r=Object.keys(e);return Array.isArray(t)?r.forEach((i,s)=>{s<t.length&&(n[i]=!0)}):r.forEach(i=>{t[i]!=null&&(n[i]=!0)}),n}function Ku({values:t,breakpoints:e,base:n}){const r=n||tY(t,e),i=Object.keys(r);if(i.length===0)return t;let s;return i.reduce((o,a,l)=>(Array.isArray(t)?(o[a]=t[l]!=null?t[l]:t[s],s=l):typeof t=="object"?(o[a]=t[a]!=null?t[a]:t[s],s=a):o[a]=t,o),{})}function Le(t){if(typeof t!="string")throw new Error(cd(7));return t.charAt(0).toUpperCase()+t.slice(1)}const nY=Object.freeze(Object.defineProperty({__proto__:null,default:Le},Symbol.toStringTag,{value:"Module"}));function Lh(t,e,n=!0){if(!e||typeof e!="string")return null;if(t&&t.vars&&n){const r=`vars.${e}`.split(".").reduce((i,s)=>i&&i[s]?i[s]:null,t);if(r!=null)return r}return e.split(".").reduce((r,i)=>r&&r[i]!=null?r[i]:null,t)}function D1(t,e,n,r=n){let i;return typeof t=="function"?i=t(n):Array.isArray(t)?i=t[n]||r:i=Lh(t,n)||r,e&&(i=e(i,r,t)),i}function mr(t){const{prop:e,cssProperty:n=t.prop,themeKey:r,transform:i}=t,s=o=>{if(o[e]==null)return null;const a=o[e],l=o.theme,c=Lh(l,r)||{};return is(o,a,d=>{let f=D1(c,i,d);return d===f&&typeof d=="string"&&(f=D1(c,i,`${e}${d==="default"?"":Le(d)}`,d)),n===!1?f:{[n]:f}})};return s.propTypes={},s.filterProps=[e],s}function rY(t){const e={};return n=>(e[n]===void 0&&(e[n]=t(n)),e[n])}const iY={m:"margin",p:"padding"},sY={t:"Top",r:"Right",b:"Bottom",l:"Left",x:["Left","Right"],y:["Top","Bottom"]},mk={marginX:"mx",marginY:"my",paddingX:"px",paddingY:"py"},oY=rY(t=>{if(t.length>2)if(mk[t])t=mk[t];else return[t];const[e,n]=t.split(""),r=iY[e],i=sY[n]||"";return Array.isArray(i)?i.map(s=>r+s):[r+i]}),WM=["m","mt","mr","mb","ml","mx","my","margin","marginTop","marginRight","marginBottom","marginLeft","marginX","marginY","marginInline","marginInlineStart","marginInlineEnd","marginBlock","marginBlockStart","marginBlockEnd"],jM=["p","pt","pr","pb","pl","px","py","padding","paddingTop","paddingRight","paddingBottom","paddingLeft","paddingX","paddingY","paddingInline","paddingInlineStart","paddingInlineEnd","paddingBlock","paddingBlockStart","paddingBlockEnd"];[...WM,...jM];function x0(t,e,n,r){var i;const s=(i=Lh(t,e,!1))!=null?i:n;return typeof s=="number"?o=>typeof o=="string"?o:s*o:Array.isArray(s)?o=>typeof o=="string"?o:s[o]:typeof s=="function"?s:()=>{}}function XM(t){return x0(t,"spacing",8)}function ud(t,e){if(typeof e=="string"||e==null)return e;const n=Math.abs(e),r=t(n);return e>=0?r:typeof r=="number"?-r:`-${r}`}function aY(t,e){return n=>t.reduce((r,i)=>(r[i]=ud(e,n),r),{})}function lY(t,e,n,r){if(e.indexOf(n)===-1)return null;const i=oY(n),s=aY(i,r),o=t[n];return is(t,o,s)}function sU(t,e){const n=XM(t.theme);return Object.keys(t).map(r=>lY(t,e,r,n)).reduce(tg,{})}function nr(t){return sU(t,WM)}nr.propTypes={};nr.filterProps=WM;function rr(t){return sU(t,jM)}rr.propTypes={};rr.filterProps=jM;function cY(t=8){if(t.mui)return t;const e=XM({spacing:t}),n=(...r)=>(r.length===0?[1]:r).map(s=>{const o=e(s);return typeof o=="number"?`${o}px`:o}).join(" ");return n.mui=!0,n}function zb(...t){const e=t.reduce((r,i)=>(i.filterProps.forEach(s=>{r[s]=i}),r),{}),n=r=>Object.keys(r).reduce((i,s)=>e[s]?tg(i,e[s](r)):i,{});return n.propTypes={},n.filterProps=t.reduce((r,i)=>r.concat(i.filterProps),[]),n}function io(t){return typeof t!="number"?t:`${t}px solid`}function vo(t,e){return mr({prop:t,themeKey:"borders",transform:e})}const uY=vo("border",io),dY=vo("borderTop",io),fY=vo("borderRight",io),hY=vo("borderBottom",io),pY=vo("borderLeft",io),mY=vo("borderColor"),gY=vo("borderTopColor"),yY=vo("borderRightColor"),vY=vo("borderBottomColor"),xY=vo("borderLeftColor"),bY=vo("outline",io),SY=vo("outlineColor"),Gb=t=>{if(t.borderRadius!==void 0&&t.borderRadius!==null){const e=x0(t.theme,"shape.borderRadius",4),n=r=>({borderRadius:ud(e,r)});return is(t,t.borderRadius,n)}return null};Gb.propTypes={};Gb.filterProps=["borderRadius"];zb(uY,dY,fY,hY,pY,mY,gY,yY,vY,xY,Gb,bY,SY);const Hb=t=>{if(t.gap!==void 0&&t.gap!==null){const e=x0(t.theme,"spacing",8),n=r=>({gap:ud(e,r)});return is(t,t.gap,n)}return null};Hb.propTypes={};Hb.filterProps=["gap"];const Vb=t=>{if(t.columnGap!==void 0&&t.columnGap!==null){const e=x0(t.theme,"spacing",8),n=r=>({columnGap:ud(e,r)});return is(t,t.columnGap,n)}return null};Vb.propTypes={};Vb.filterProps=["columnGap"];const Wb=t=>{if(t.rowGap!==void 0&&t.rowGap!==null){const e=x0(t.theme,"spacing",8),n=r=>({rowGap:ud(e,r)});return is(t,t.rowGap,n)}return null};Wb.propTypes={};Wb.filterProps=["rowGap"];const _Y=mr({prop:"gridColumn"}),wY=mr({prop:"gridRow"}),CY=mr({prop:"gridAutoFlow"}),EY=mr({prop:"gridAutoColumns"}),AY=mr({prop:"gridAutoRows"}),TY=mr({prop:"gridTemplateColumns"}),MY=mr({prop:"gridTemplateRows"}),RY=mr({prop:"gridTemplateAreas"}),IY=mr({prop:"gridArea"});zb(Hb,Vb,Wb,_Y,wY,CY,EY,AY,TY,MY,RY,IY);function vh(t,e){return e==="grey"?e:t}const NY=mr({prop:"color",themeKey:"palette",transform:vh}),PY=mr({prop:"bgcolor",cssProperty:"backgroundColor",themeKey:"palette",transform:vh}),kY=mr({prop:"backgroundColor",themeKey:"palette",transform:vh});zb(NY,PY,kY);function bs(t){return t<=1&&t!==0?`${t*100}%`:t}const DY=mr({prop:"width",transform:bs}),KM=t=>{if(t.maxWidth!==void 0&&t.maxWidth!==null){const e=n=>{var r,i;const s=((r=t.theme)==null||(r=r.breakpoints)==null||(r=r.values)==null?void 0:r[n])||VM[n];return s?((i=t.theme)==null||(i=i.breakpoints)==null?void 0:i.unit)!=="px"?{maxWidth:`${s}${t.theme.breakpoints.unit}`}:{maxWidth:s}:{maxWidth:bs(n)}};return is(t,t.maxWidth,e)}return null};KM.filterProps=["maxWidth"];const OY=mr({prop:"minWidth",transform:bs}),LY=mr({prop:"height",transform:bs}),BY=mr({prop:"maxHeight",transform:bs}),FY=mr({prop:"minHeight",transform:bs});mr({prop:"size",cssProperty:"width",transform:bs});mr({prop:"size",cssProperty:"height",transform:bs});const $Y=mr({prop:"boxSizing"});zb(DY,KM,OY,LY,BY,FY,$Y);const UY={border:{themeKey:"borders",transform:io},borderTop:{themeKey:"borders",transform:io},borderRight:{themeKey:"borders",transform:io},borderBottom:{themeKey:"borders",transform:io},borderLeft:{themeKey:"borders",transform:io},borderColor:{themeKey:"palette"},borderTopColor:{themeKey:"palette"},borderRightColor:{themeKey:"palette"},borderBottomColor:{themeKey:"palette"},borderLeftColor:{themeKey:"palette"},outline:{themeKey:"borders",transform:io},outlineColor:{themeKey:"palette"},borderRadius:{themeKey:"shape.borderRadius",style:Gb},color:{themeKey:"palette",transform:vh},bgcolor:{themeKey:"palette",cssProperty:"backgroundColor",transform:vh},backgroundColor:{themeKey:"palette",transform:vh},p:{style:rr},pt:{style:rr},pr:{style:rr},pb:{style:rr},pl:{style:rr},px:{style:rr},py:{style:rr},padding:{style:rr},paddingTop:{style:rr},paddingRight:{style:rr},paddingBottom:{style:rr},paddingLeft:{style:rr},paddingX:{style:rr},paddingY:{style:rr},paddingInline:{style:rr},paddingInlineStart:{style:rr},paddingInlineEnd:{style:rr},paddingBlock:{style:rr},paddingBlockStart:{style:rr},paddingBlockEnd:{style:rr},m:{style:nr},mt:{style:nr},mr:{style:nr},mb:{style:nr},ml:{style:nr},mx:{style:nr},my:{style:nr},margin:{style:nr},marginTop:{style:nr},marginRight:{style:nr},marginBottom:{style:nr},marginLeft:{style:nr},marginX:{style:nr},marginY:{style:nr},marginInline:{style:nr},marginInlineStart:{style:nr},marginInlineEnd:{style:nr},marginBlock:{style:nr},marginBlockStart:{style:nr},marginBlockEnd:{style:nr},displayPrint:{cssProperty:!1,transform:t=>({"@media print":{display:t}})},display:{},overflow:{},textOverflow:{},visibility:{},whiteSpace:{},flexBasis:{},flexDirection:{},flexWrap:{},justifyContent:{},alignItems:{},alignContent:{},order:{},flex:{},flexGrow:{},flexShrink:{},alignSelf:{},justifyItems:{},justifySelf:{},gap:{style:Hb},rowGap:{style:Wb},columnGap:{style:Vb},gridColumn:{},gridRow:{},gridAutoFlow:{},gridAutoColumns:{},gridAutoRows:{},gridTemplateColumns:{},gridTemplateRows:{},gridTemplateAreas:{},gridArea:{},position:{},zIndex:{themeKey:"zIndex"},top:{},right:{},bottom:{},left:{},boxShadow:{themeKey:"shadows"},width:{transform:bs},maxWidth:{style:KM},minWidth:{transform:bs},height:{transform:bs},maxHeight:{transform:bs},minHeight:{transform:bs},boxSizing:{},fontFamily:{themeKey:"typography"},fontSize:{themeKey:"typography"},fontStyle:{themeKey:"typography"},fontWeight:{themeKey:"typography"},letterSpacing:{},textTransform:{},lineHeight:{},textAlign:{},typography:{cssProperty:!1,themeKey:"typography"}},b0=UY;function zY(...t){const e=t.reduce((r,i)=>r.concat(Object.keys(i)),[]),n=new Set(e);return t.every(r=>n.size===Object.keys(r).length)}function GY(t,e){return typeof t=="function"?t(e):t}function oU(){function t(n,r,i,s){const o={[n]:r,theme:i},a=s[n];if(!a)return{[n]:r};const{cssProperty:l=n,themeKey:c,transform:u,style:d}=a;if(r==null)return null;if(c==="typography"&&r==="inherit")return{[n]:r};const f=Lh(i,c)||{};return d?d(o):is(o,r,p=>{let x=D1(f,u,p);return p===x&&typeof p=="string"&&(x=D1(f,u,`${n}${p==="default"?"":Le(p)}`,p)),l===!1?x:{[l]:x}})}function e(n){var r;const{sx:i,theme:s={}}=n||{};if(!i)return null;const o=(r=s.unstable_sxConfig)!=null?r:b0;function a(l){let c=l;if(typeof l=="function")c=l(s);else if(typeof l!="object")return l;if(!c)return null;const u=rU(s.breakpoints),d=Object.keys(u);let f=u;return Object.keys(c).forEach(h=>{const p=GY(c[h],s);if(p!=null)if(typeof p=="object")if(o[h])f=tg(f,t(h,p,s,o));else{const x=is({theme:s},p,v=>({[h]:v}));zY(x,p)?f[h]=e({sx:p,theme:s}):f=tg(f,x)}else f=tg(f,t(h,p,s,o))}),iU(d,f)}return Array.isArray(i)?i.map(a):a(i)}return e}const dp=oU();dp.filterProps=["sx"];function aU(t,e){const n=this;return n.vars&&typeof n.getColorSchemeSelector=="function"?{[n.getColorSchemeSelector(t).replace(/(\[[^\]]+\])/,"*:where($1)")]:e}:n.palette.mode===t?e:{}}const HY=["breakpoints","palette","spacing","shape"];function fp(t={},...e){const{breakpoints:n={},palette:r={},spacing:i,shape:s={}}=t,o=it(t,HY),a=nU(n),l=cY(i);let c=Bi({breakpoints:a,direction:"ltr",components:{},palette:X({mode:"light"},r),spacing:l,shape:X({},ZJ,s)},o);return c.applyStyles=aU,c=e.reduce((u,d)=>Bi(u,d),c),c.unstable_sxConfig=X({},b0,o==null?void 0:o.unstable_sxConfig),c.unstable_sx=function(d){return dp({sx:d,theme:this})},c}const VY=Object.freeze(Object.defineProperty({__proto__:null,default:fp,private_createBreakpoints:nU,unstable_applyStyles:aU},Symbol.toStringTag,{value:"Module"}));function WY(t){return Object.keys(t).length===0}function jY(t=null){const e=L.useContext(Ub);return!e||WY(e)?t:e}const XY=fp();function jb(t=XY){return jY(t)}function KY({styles:t,themeId:e,defaultTheme:n={}}){const r=jb(n),i=typeof t=="function"?t(e&&r[e]||r):t;return H.jsx(Z$,{styles:i})}const qY=["sx"],JY=t=>{var e,n;const r={systemProps:{},otherProps:{}},i=(e=t==null||(n=t.theme)==null?void 0:n.unstable_sxConfig)!=null?e:b0;return Object.keys(t).forEach(s=>{i[s]?r.systemProps[s]=t[s]:r.otherProps[s]=t[s]}),r};function S0(t){const{sx:e}=t,n=it(t,qY),{systemProps:r,otherProps:i}=JY(n);let s;return Array.isArray(e)?s=[r,...e]:typeof e=="function"?s=(...o)=>{const a=e(...o);return el(a)?X({},r,a):r}:s=X({},r,e),X({},i,{sx:s})}const YY=Object.freeze(Object.defineProperty({__proto__:null,default:dp,extendSxProp:S0,unstable_createStyleFunctionSx:oU,unstable_defaultSxConfig:b0},Symbol.toStringTag,{value:"Module"})),gk=t=>t,QY=()=>{let t=gk;return{configure(e){t=e},generate(e){return t(e)},reset(){t=gk}}},lU=QY();function cU(t){var e,n,r="";if(typeof t=="string"||typeof t=="number")r+=t;else if(typeof t=="object")if(Array.isArray(t)){var i=t.length;for(e=0;e<i;e++)t[e]&&(n=cU(t[e]))&&(r&&(r+=" "),r+=n)}else for(n in t)t[n]&&(r&&(r+=" "),r+=n);return r}function ct(){for(var t,e,n=0,r="",i=arguments.length;n<i;n++)(t=arguments[n])&&(e=cU(t))&&(r&&(r+=" "),r+=e);return r}const ZY=["className","component"];function eQ(t={}){const{themeId:e,defaultTheme:n,defaultClassName:r="MuiBox-root",generateClassName:i}=t,s=HM("div",{shouldForwardProp:a=>a!=="theme"&&a!=="sx"&&a!=="as"})(dp);return L.forwardRef(function(l,c){const u=jb(n),d=S0(l),{className:f,component:h="div"}=d,p=it(d,ZY);return H.jsx(s,X({as:h,ref:c,className:ct(f,i?i(r):r),theme:e&&u[e]||u},p))})}const tQ={active:"active",checked:"checked",completed:"completed",disabled:"disabled",error:"error",expanded:"expanded",focused:"focused",focusVisible:"focusVisible",open:"open",readOnly:"readOnly",required:"required",selected:"selected"};function kt(t,e,n="Mui"){const r=tQ[e];return r?`${n}-${r}`:`${lU.generate(t)}-${e}`}function Bt(t,e,n="Mui"){const r={};return e.forEach(i=>{r[i]=kt(t,i,n)}),r}var uU={exports:{}},Sn={};/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var qM=Symbol.for("react.element"),JM=Symbol.for("react.portal"),Xb=Symbol.for("react.fragment"),Kb=Symbol.for("react.strict_mode"),qb=Symbol.for("react.profiler"),Jb=Symbol.for("react.provider"),Yb=Symbol.for("react.context"),nQ=Symbol.for("react.server_context"),Qb=Symbol.for("react.forward_ref"),Zb=Symbol.for("react.suspense"),eS=Symbol.for("react.suspense_list"),tS=Symbol.for("react.memo"),nS=Symbol.for("react.lazy"),rQ=Symbol.for("react.offscreen"),dU;dU=Symbol.for("react.module.reference");function xo(t){if(typeof t=="object"&&t!==null){var e=t.$$typeof;switch(e){case qM:switch(t=t.type,t){case Xb:case qb:case Kb:case Zb:case eS:return t;default:switch(t=t&&t.$$typeof,t){case nQ:case Yb:case Qb:case nS:case tS:case Jb:return t;default:return e}}case JM:return e}}}Sn.ContextConsumer=Yb;Sn.ContextProvider=Jb;Sn.Element=qM;Sn.ForwardRef=Qb;Sn.Fragment=Xb;Sn.Lazy=nS;Sn.Memo=tS;Sn.Portal=JM;Sn.Profiler=qb;Sn.StrictMode=Kb;Sn.Suspense=Zb;Sn.SuspenseList=eS;Sn.isAsyncMode=function(){return!1};Sn.isConcurrentMode=function(){return!1};Sn.isContextConsumer=function(t){return xo(t)===Yb};Sn.isContextProvider=function(t){return xo(t)===Jb};Sn.isElement=function(t){return typeof t=="object"&&t!==null&&t.$$typeof===qM};Sn.isForwardRef=function(t){return xo(t)===Qb};Sn.isFragment=function(t){return xo(t)===Xb};Sn.isLazy=function(t){return xo(t)===nS};Sn.isMemo=function(t){return xo(t)===tS};Sn.isPortal=function(t){return xo(t)===JM};Sn.isProfiler=function(t){return xo(t)===qb};Sn.isStrictMode=function(t){return xo(t)===Kb};Sn.isSuspense=function(t){return xo(t)===Zb};Sn.isSuspenseList=function(t){return xo(t)===eS};Sn.isValidElementType=function(t){return typeof t=="string"||typeof t=="function"||t===Xb||t===qb||t===Kb||t===Zb||t===eS||t===rQ||typeof t=="object"&&t!==null&&(t.$$typeof===nS||t.$$typeof===tS||t.$$typeof===Jb||t.$$typeof===Yb||t.$$typeof===Qb||t.$$typeof===dU||t.getModuleId!==void 0)};Sn.typeOf=xo;uU.exports=Sn;var yk=uU.exports;const iQ=/^\s*function(?:\s|\s*\/\*.*\*\/\s*)+([^(\s/]*)\s*/;function fU(t){const e=`${t}`.match(iQ);return e&&e[1]||""}function hU(t,e=""){return t.displayName||t.name||fU(t)||e}function vk(t,e,n){const r=hU(e);return t.displayName||(r!==""?`${n}(${r})`:n)}function sQ(t){if(t!=null){if(typeof t=="string")return t;if(typeof t=="function")return hU(t,"Component");if(typeof t=="object")switch(t.$$typeof){case yk.ForwardRef:return vk(t,t.render,"ForwardRef");case yk.Memo:return vk(t,t.type,"memo");default:return}}}const oQ=Object.freeze(Object.defineProperty({__proto__:null,default:sQ,getFunctionName:fU},Symbol.toStringTag,{value:"Module"})),aQ=["ownerState"],lQ=["variants"],cQ=["name","slot","skipVariantsResolver","skipSx","overridesResolver"];function uQ(t){return Object.keys(t).length===0}function dQ(t){return typeof t=="string"&&t.charCodeAt(0)>96}function nC(t){return t!=="ownerState"&&t!=="theme"&&t!=="sx"&&t!=="as"}const fQ=fp(),hQ=t=>t&&t.charAt(0).toLowerCase()+t.slice(1);function hv({defaultTheme:t,theme:e,themeId:n}){return uQ(e)?t:e[n]||e}function pQ(t){return t?(e,n)=>n[t]:null}function Hx(t,e){let{ownerState:n}=e,r=it(e,aQ);const i=typeof t=="function"?t(X({ownerState:n},r)):t;if(Array.isArray(i))return i.flatMap(s=>Hx(s,X({ownerState:n},r)));if(i&&typeof i=="object"&&Array.isArray(i.variants)){const{variants:s=[]}=i;let a=it(i,lQ);return s.forEach(l=>{let c=!0;typeof l.props=="function"?c=l.props(X({ownerState:n},r,n)):Object.keys(l.props).forEach(u=>{(n==null?void 0:n[u])!==l.props[u]&&r[u]!==l.props[u]&&(c=!1)}),c&&(Array.isArray(a)||(a=[a]),a.push(typeof l.style=="function"?l.style(X({ownerState:n},r,n)):l.style))}),a}return i}function mQ(t={}){const{themeId:e,defaultTheme:n=fQ,rootShouldForwardProp:r=nC,slotShouldForwardProp:i=nC}=t,s=o=>dp(X({},o,{theme:hv(X({},o,{defaultTheme:n,themeId:e}))}));return s.__mui_systemSx=!0,(o,a={})=>{eU(o,E=>E.filter(A=>!(A!=null&&A.__mui_systemSx)));const{name:l,slot:c,skipVariantsResolver:u,skipSx:d,overridesResolver:f=pQ(hQ(c))}=a,h=it(a,cQ),p=u!==void 0?u:c&&c!=="Root"&&c!=="root"||!1,x=d||!1;let v,y=nC;c==="Root"||c==="root"?y=r:c?y=i:dQ(o)&&(y=void 0);const b=HM(o,X({shouldForwardProp:y,label:v},h)),S=E=>typeof E=="function"&&E.__emotion_real!==E||el(E)?A=>Hx(E,X({},A,{theme:hv({theme:A.theme,defaultTheme:n,themeId:e})})):E,w=(E,...A)=>{let T=S(E);const I=A?A.map(S):[];l&&f&&I.push(P=>{const B=hv(X({},P,{defaultTheme:n,themeId:e}));if(!B.components||!B.components[l]||!B.components[l].styleOverrides)return null;const F=B.components[l].styleOverrides,U={};return Object.entries(F).forEach(([j,Z])=>{U[j]=Hx(Z,X({},P,{theme:B}))}),f(P,U)}),l&&!p&&I.push(P=>{var B;const F=hv(X({},P,{defaultTheme:n,themeId:e})),U=F==null||(B=F.components)==null||(B=B[l])==null?void 0:B.variants;return Hx({variants:U},X({},P,{theme:F}))}),x||I.push(s);const N=I.length-A.length;if(Array.isArray(E)&&N>0){const P=new Array(N).fill("");T=[...E,...P],T.raw=[...E.raw,...P]}const M=b(T,...I);return o.muiName&&(M.muiName=o.muiName),M};return b.withConfig&&(w.withConfig=b.withConfig),w}}const pU=mQ();function YM(t,e){const n=X({},e);return Object.keys(t).forEach(r=>{if(r.toString().match(/^(components|slots)$/))n[r]=X({},t[r],n[r]);else if(r.toString().match(/^(componentsProps|slotProps)$/)){const i=t[r]||{},s=e[r];n[r]={},!s||!Object.keys(s)?n[r]=i:!i||!Object.keys(i)?n[r]=s:(n[r]=X({},s),Object.keys(i).forEach(o=>{n[r][o]=YM(i[o],s[o])}))}else n[r]===void 0&&(n[r]=t[r])}),n}function gQ(t){const{theme:e,name:n,props:r}=t;return!e||!e.components||!e.components[n]||!e.components[n].defaultProps?r:YM(e.components[n].defaultProps,r)}function QM({props:t,name:e,defaultTheme:n,themeId:r}){let i=jb(n);return r&&(i=i[r]||i),gQ({theme:i,name:e,props:t})}const dd=typeof window<"u"?L.useLayoutEffect:L.useEffect;function yQ(t,e=Number.MIN_SAFE_INTEGER,n=Number.MAX_SAFE_INTEGER){return Math.max(e,Math.min(t,n))}const vQ=Object.freeze(Object.defineProperty({__proto__:null,default:yQ},Symbol.toStringTag,{value:"Module"}));function xk(...t){return t.reduce((e,n)=>n==null?e:function(...i){e.apply(this,i),n.apply(this,i)},()=>{})}function mU(t,e=166){let n;function r(...i){const s=()=>{t.apply(this,i)};clearTimeout(n),n=setTimeout(s,e)}return r.clear=()=>{clearTimeout(n)},r}function rC(t,e){var n,r;return L.isValidElement(t)&&e.indexOf((n=t.type.muiName)!=null?n:(r=t.type)==null||(r=r._payload)==null||(r=r.value)==null?void 0:r.muiName)!==-1}function Ts(t){return t&&t.ownerDocument||document}function fd(t){return Ts(t).defaultView||window}function jA(t,e){typeof t=="function"?t(e):t&&(t.current=e)}let bk=0;function xQ(t){const[e,n]=L.useState(t),r=t||e;return L.useEffect(()=>{e==null&&(bk+=1,n(`mui-${bk}`))},[e]),r}const Sk=o1.useId;function gU(t){if(Sk!==void 0){const e=Sk();return t??e}return xQ(t)}function XA({controlled:t,default:e,name:n,state:r="value"}){const{current:i}=L.useRef(t!==void 0),[s,o]=L.useState(e),a=i?t:s,l=L.useCallback(c=>{i||o(c)},[]);return[a,l]}function ih(t){const e=L.useRef(t);return dd(()=>{e.current=t}),L.useRef((...n)=>(0,e.current)(...n)).current}function Wr(...t){return L.useMemo(()=>t.every(e=>e==null)?null:e=>{t.forEach(n=>{jA(n,e)})},t)}const _k={};function bQ(t,e){const n=L.useRef(_k);return n.current===_k&&(n.current=t(e)),n}const SQ=[];function _Q(t){L.useEffect(t,SQ)}class rS{constructor(){this.currentId=null,this.clear=()=>{this.currentId!==null&&(clearTimeout(this.currentId),this.currentId=null)},this.disposeEffect=()=>this.clear}static create(){return new rS}start(e,n){this.clear(),this.currentId=setTimeout(()=>{this.currentId=null,n()},e)}}function ZM(){const t=bQ(rS.create).current;return _Q(t.disposeEffect),t}let iS=!0,KA=!1;const wQ=new rS,CQ={text:!0,search:!0,url:!0,tel:!0,email:!0,password:!0,number:!0,date:!0,month:!0,week:!0,time:!0,datetime:!0,"datetime-local":!0};function EQ(t){const{type:e,tagName:n}=t;return!!(n==="INPUT"&&CQ[e]&&!t.readOnly||n==="TEXTAREA"&&!t.readOnly||t.isContentEditable)}function AQ(t){t.metaKey||t.altKey||t.ctrlKey||(iS=!0)}function iC(){iS=!1}function TQ(){this.visibilityState==="hidden"&&KA&&(iS=!0)}function MQ(t){t.addEventListener("keydown",AQ,!0),t.addEventListener("mousedown",iC,!0),t.addEventListener("pointerdown",iC,!0),t.addEventListener("touchstart",iC,!0),t.addEventListener("visibilitychange",TQ,!0)}function RQ(t){const{target:e}=t;try{return e.matches(":focus-visible")}catch{}return iS||EQ(e)}function yU(){const t=L.useCallback(i=>{i!=null&&MQ(i.ownerDocument)},[]),e=L.useRef(!1);function n(){return e.current?(KA=!0,wQ.start(100,()=>{KA=!1}),e.current=!1,!0):!1}function r(i){return RQ(i)?(e.current=!0,!0):!1}return{isFocusVisibleRef:e,onFocus:r,onBlur:n,ref:t}}function vU(t){const e=t.documentElement.clientWidth;return Math.abs(window.innerWidth-e)}const xU=t=>{const e=L.useRef({});return L.useEffect(()=>{e.current=t}),e.current};function Ft(t,e,n=void 0){const r={};return Object.keys(t).forEach(i=>{r[i]=t[i].reduce((s,o)=>{if(o){const a=e(o);a!==""&&s.push(a),n&&n[o]&&s.push(n[o])}return s},[]).join(" ")}),r}const IQ=L.createContext(),bU=()=>{const t=L.useContext(IQ);return t??!1},NQ=["className","component","disableGutters","fixed","maxWidth","classes"],PQ=fp(),kQ=pU("div",{name:"MuiContainer",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,e[`maxWidth${Le(String(n.maxWidth))}`],n.fixed&&e.fixed,n.disableGutters&&e.disableGutters]}}),DQ=t=>QM({props:t,name:"MuiContainer",defaultTheme:PQ}),OQ=(t,e)=>{const n=l=>kt(e,l),{classes:r,fixed:i,disableGutters:s,maxWidth:o}=t,a={root:["root",o&&`maxWidth${Le(String(o))}`,i&&"fixed",s&&"disableGutters"]};return Ft(a,n,r)};function LQ(t={}){const{createStyledComponent:e=kQ,useThemeProps:n=DQ,componentName:r="MuiContainer"}=t,i=e(({theme:o,ownerState:a})=>X({width:"100%",marginLeft:"auto",boxSizing:"border-box",marginRight:"auto",display:"block"},!a.disableGutters&&{paddingLeft:o.spacing(2),paddingRight:o.spacing(2),[o.breakpoints.up("sm")]:{paddingLeft:o.spacing(3),paddingRight:o.spacing(3)}}),({theme:o,ownerState:a})=>a.fixed&&Object.keys(o.breakpoints.values).reduce((l,c)=>{const u=c,d=o.breakpoints.values[u];return d!==0&&(l[o.breakpoints.up(u)]={maxWidth:`${d}${o.breakpoints.unit}`}),l},{}),({theme:o,ownerState:a})=>X({},a.maxWidth==="xs"&&{[o.breakpoints.up("xs")]:{maxWidth:Math.max(o.breakpoints.values.xs,444)}},a.maxWidth&&a.maxWidth!=="xs"&&{[o.breakpoints.up(a.maxWidth)]:{maxWidth:`${o.breakpoints.values[a.maxWidth]}${o.breakpoints.unit}`}}));return L.forwardRef(function(a,l){const c=n(a),{className:u,component:d="div",disableGutters:f=!1,fixed:h=!1,maxWidth:p="lg"}=c,x=it(c,NQ),v=X({},c,{component:d,disableGutters:f,fixed:h,maxWidth:p}),y=OQ(v,r);return H.jsx(i,X({as:d,ownerState:v,className:ct(y.root,u),ref:l},x))})}const BQ=["component","direction","spacing","divider","children","className","useFlexGap"],FQ=fp(),$Q=pU("div",{name:"MuiStack",slot:"Root",overridesResolver:(t,e)=>e.root});function UQ(t){return QM({props:t,name:"MuiStack",defaultTheme:FQ})}function zQ(t,e){const n=L.Children.toArray(t).filter(Boolean);return n.reduce((r,i,s)=>(r.push(i),s<n.length-1&&r.push(L.cloneElement(e,{key:`separator-${s}`})),r),[])}const GQ=t=>({row:"Left","row-reverse":"Right",column:"Top","column-reverse":"Bottom"})[t],HQ=({ownerState:t,theme:e})=>{let n=X({display:"flex",flexDirection:"column"},is({theme:e},Ku({values:t.direction,breakpoints:e.breakpoints.values}),r=>({flexDirection:r})));if(t.spacing){const r=XM(e),i=Object.keys(e.breakpoints.values).reduce((l,c)=>((typeof t.spacing=="object"&&t.spacing[c]!=null||typeof t.direction=="object"&&t.direction[c]!=null)&&(l[c]=!0),l),{}),s=Ku({values:t.direction,base:i}),o=Ku({values:t.spacing,base:i});typeof s=="object"&&Object.keys(s).forEach((l,c,u)=>{if(!s[l]){const f=c>0?s[u[c-1]]:"column";s[l]=f}}),n=Bi(n,is({theme:e},o,(l,c)=>t.useFlexGap?{gap:ud(r,l)}:{"& > :not(style):not(style)":{margin:0},"& > :not(style) ~ :not(style)":{[`margin${GQ(c?s[c]:t.direction)}`]:ud(r,l)}}))}return n=eY(e.breakpoints,n),n};function VQ(t={}){const{createStyledComponent:e=$Q,useThemeProps:n=UQ,componentName:r="MuiStack"}=t,i=()=>Ft({root:["root"]},l=>kt(r,l),{}),s=e(HQ);return L.forwardRef(function(l,c){const u=n(l),d=S0(u),{component:f="div",direction:h="column",spacing:p=0,divider:x,children:v,className:y,useFlexGap:b=!1}=d,S=it(d,BQ),w={direction:h,spacing:p,useFlexGap:b},E=i();return H.jsx(s,X({as:f,ownerState:w,ref:c,className:ct(E.root,y)},S,{children:x?zQ(v,x):v}))})}function WQ(t,e){return X({toolbar:{minHeight:56,[t.up("xs")]:{"@media (orientation: landscape)":{minHeight:48}},[t.up("sm")]:{minHeight:64}}},e)}var gr={},SU={exports:{}};(function(t){function e(n){return n&&n.__esModule?n:{default:n}}t.exports=e,t.exports.__esModule=!0,t.exports.default=t.exports})(SU);var _U=SU.exports;const jQ=Cl(Uq),XQ=Cl(vQ);var wU=_U;Object.defineProperty(gr,"__esModule",{value:!0});var Tr=gr.alpha=RU;gr.blend=iZ;gr.colorChannel=void 0;var CU=gr.darken=tR;gr.decomposeColor=yo;gr.emphasize=IU;var KQ=gr.getContrastRatio=ZQ;gr.getLuminance=O1;gr.hexToRgb=AU;gr.hslToRgb=MU;var EU=gr.lighten=nR;gr.private_safeAlpha=eZ;gr.private_safeColorChannel=void 0;gr.private_safeDarken=tZ;gr.private_safeEmphasize=rZ;gr.private_safeLighten=nZ;gr.recomposeColor=hp;gr.rgbToHex=QQ;var wk=wU(jQ),qQ=wU(XQ);function eR(t,e=0,n=1){return(0,qQ.default)(t,e,n)}function AU(t){t=t.slice(1);const e=new RegExp(`.{1,${t.length>=6?2:1}}`,"g");let n=t.match(e);return n&&n[0].length===1&&(n=n.map(r=>r+r)),n?`rgb${n.length===4?"a":""}(${n.map((r,i)=>i<3?parseInt(r,16):Math.round(parseInt(r,16)/255*1e3)/1e3).join(", ")})`:""}function JQ(t){const e=t.toString(16);return e.length===1?`0${e}`:e}function yo(t){if(t.type)return t;if(t.charAt(0)==="#")return yo(AU(t));const e=t.indexOf("("),n=t.substring(0,e);if(["rgb","rgba","hsl","hsla","color"].indexOf(n)===-1)throw new Error((0,wk.default)(9,t));let r=t.substring(e+1,t.length-1),i;if(n==="color"){if(r=r.split(" "),i=r.shift(),r.length===4&&r[3].charAt(0)==="/"&&(r[3]=r[3].slice(1)),["srgb","display-p3","a98-rgb","prophoto-rgb","rec-2020"].indexOf(i)===-1)throw new Error((0,wk.default)(10,i))}else r=r.split(",");return r=r.map(s=>parseFloat(s)),{type:n,values:r,colorSpace:i}}const TU=t=>{const e=yo(t);return e.values.slice(0,3).map((n,r)=>e.type.indexOf("hsl")!==-1&&r!==0?`${n}%`:n).join(" ")};gr.colorChannel=TU;const YQ=(t,e)=>{try{return TU(t)}catch{return t}};gr.private_safeColorChannel=YQ;function hp(t){const{type:e,colorSpace:n}=t;let{values:r}=t;return e.indexOf("rgb")!==-1?r=r.map((i,s)=>s<3?parseInt(i,10):i):e.indexOf("hsl")!==-1&&(r[1]=`${r[1]}%`,r[2]=`${r[2]}%`),e.indexOf("color")!==-1?r=`${n} ${r.join(" ")}`:r=`${r.join(", ")}`,`${e}(${r})`}function QQ(t){if(t.indexOf("#")===0)return t;const{values:e}=yo(t);return`#${e.map((n,r)=>JQ(r===3?Math.round(255*n):n)).join("")}`}function MU(t){t=yo(t);const{values:e}=t,n=e[0],r=e[1]/100,i=e[2]/100,s=r*Math.min(i,1-i),o=(c,u=(c+n/30)%12)=>i-s*Math.max(Math.min(u-3,9-u,1),-1);let a="rgb";const l=[Math.round(o(0)*255),Math.round(o(8)*255),Math.round(o(4)*255)];return t.type==="hsla"&&(a+="a",l.push(e[3])),hp({type:a,values:l})}function O1(t){t=yo(t);let e=t.type==="hsl"||t.type==="hsla"?yo(MU(t)).values:t.values;return e=e.map(n=>(t.type!=="color"&&(n/=255),n<=.03928?n/12.92:((n+.055)/1.055)**2.4)),Number((.2126*e[0]+.7152*e[1]+.0722*e[2]).toFixed(3))}function ZQ(t,e){const n=O1(t),r=O1(e);return(Math.max(n,r)+.05)/(Math.min(n,r)+.05)}function RU(t,e){return t=yo(t),e=eR(e),(t.type==="rgb"||t.type==="hsl")&&(t.type+="a"),t.type==="color"?t.values[3]=`/${e}`:t.values[3]=e,hp(t)}function eZ(t,e,n){try{return RU(t,e)}catch{return t}}function tR(t,e){if(t=yo(t),e=eR(e),t.type.indexOf("hsl")!==-1)t.values[2]*=1-e;else if(t.type.indexOf("rgb")!==-1||t.type.indexOf("color")!==-1)for(let n=0;n<3;n+=1)t.values[n]*=1-e;return hp(t)}function tZ(t,e,n){try{return tR(t,e)}catch{return t}}function nR(t,e){if(t=yo(t),e=eR(e),t.type.indexOf("hsl")!==-1)t.values[2]+=(100-t.values[2])*e;else if(t.type.indexOf("rgb")!==-1)for(let n=0;n<3;n+=1)t.values[n]+=(255-t.values[n])*e;else if(t.type.indexOf("color")!==-1)for(let n=0;n<3;n+=1)t.values[n]+=(1-t.values[n])*e;return hp(t)}function nZ(t,e,n){try{return nR(t,e)}catch{return t}}function IU(t,e=.15){return O1(t)>.5?tR(t,e):nR(t,e)}function rZ(t,e,n){try{return IU(t,e)}catch{return t}}function iZ(t,e,n,r=1){const i=(l,c)=>Math.round((l**(1/r)*(1-n)+c**(1/r)*n)**r),s=yo(t),o=yo(e),a=[i(s.values[0],o.values[0]),i(s.values[1],o.values[1]),i(s.values[2],o.values[2])];return hp({type:"rgb",values:a})}const sZ=["mode","contrastThreshold","tonalOffset"],Ck={text:{primary:"rgba(0, 0, 0, 0.87)",secondary:"rgba(0, 0, 0, 0.6)",disabled:"rgba(0, 0, 0, 0.38)"},divider:"rgba(0, 0, 0, 0.12)",background:{paper:Rg.white,default:Rg.white},action:{active:"rgba(0, 0, 0, 0.54)",hover:"rgba(0, 0, 0, 0.04)",hoverOpacity:.04,selected:"rgba(0, 0, 0, 0.08)",selectedOpacity:.08,disabled:"rgba(0, 0, 0, 0.26)",disabledBackground:"rgba(0, 0, 0, 0.12)",disabledOpacity:.38,focus:"rgba(0, 0, 0, 0.12)",focusOpacity:.12,activatedOpacity:.12}},sC={text:{primary:Rg.white,secondary:"rgba(255, 255, 255, 0.7)",disabled:"rgba(255, 255, 255, 0.5)",icon:"rgba(255, 255, 255, 0.5)"},divider:"rgba(255, 255, 255, 0.12)",background:{paper:"#121212",default:"#121212"},action:{active:Rg.white,hover:"rgba(255, 255, 255, 0.08)",hoverOpacity:.08,selected:"rgba(255, 255, 255, 0.16)",selectedOpacity:.16,disabled:"rgba(255, 255, 255, 0.3)",disabledBackground:"rgba(255, 255, 255, 0.12)",disabledOpacity:.38,focus:"rgba(255, 255, 255, 0.12)",focusOpacity:.12,activatedOpacity:.24}};function Ek(t,e,n,r){const i=r.light||r,s=r.dark||r*1.5;t[e]||(t.hasOwnProperty(n)?t[e]=t[n]:e==="light"?t.light=EU(t.main,i):e==="dark"&&(t.dark=CU(t.main,s)))}function oZ(t="light"){return t==="dark"?{main:af[200],light:af[50],dark:af[400]}:{main:af[700],light:af[400],dark:af[800]}}function aZ(t="light"){return t==="dark"?{main:of[200],light:of[50],dark:of[400]}:{main:of[500],light:of[300],dark:of[700]}}function lZ(t="light"){return t==="dark"?{main:sf[500],light:sf[300],dark:sf[700]}:{main:sf[700],light:sf[400],dark:sf[800]}}function cZ(t="light"){return t==="dark"?{main:lf[400],light:lf[300],dark:lf[700]}:{main:lf[700],light:lf[500],dark:lf[900]}}function uZ(t="light"){return t==="dark"?{main:cf[400],light:cf[300],dark:cf[700]}:{main:cf[800],light:cf[500],dark:cf[900]}}function dZ(t="light"){return t==="dark"?{main:om[400],light:om[300],dark:om[700]}:{main:"#ed6c02",light:om[500],dark:om[900]}}function fZ(t){const{mode:e="light",contrastThreshold:n=3,tonalOffset:r=.2}=t,i=it(t,sZ),s=t.primary||oZ(e),o=t.secondary||aZ(e),a=t.error||lZ(e),l=t.info||cZ(e),c=t.success||uZ(e),u=t.warning||dZ(e);function d(x){return KQ(x,sC.text.primary)>=n?sC.text.primary:Ck.text.primary}const f=({color:x,name:v,mainShade:y=500,lightShade:b=300,darkShade:S=700})=>{if(x=X({},x),!x.main&&x[y]&&(x.main=x[y]),!x.hasOwnProperty("main"))throw new Error(cd(11,v?` (${v})`:"",y));if(typeof x.main!="string")throw new Error(cd(12,v?` (${v})`:"",JSON.stringify(x.main)));return Ek(x,"light",b,r),Ek(x,"dark",S,r),x.contrastText||(x.contrastText=d(x.main)),x},h={dark:sC,light:Ck};return Bi(X({common:X({},Rg),mode:e,primary:f({color:s,name:"primary"}),secondary:f({color:o,name:"secondary",mainShade:"A400",lightShade:"A200",darkShade:"A700"}),error:f({color:a,name:"error"}),warning:f({color:u,name:"warning"}),info:f({color:l,name:"info"}),success:f({color:c,name:"success"}),grey:$q,contrastThreshold:n,getContrastText:d,augmentColor:f,tonalOffset:r},h[e]),i)}const hZ=["fontFamily","fontSize","fontWeightLight","fontWeightRegular","fontWeightMedium","fontWeightBold","htmlFontSize","allVariants","pxToRem"];function pZ(t){return Math.round(t*1e5)/1e5}const Ak={textTransform:"uppercase"},Tk='"Roboto", "Helvetica", "Arial", sans-serif';function mZ(t,e){const n=typeof e=="function"?e(t):e,{fontFamily:r=Tk,fontSize:i=14,fontWeightLight:s=300,fontWeightRegular:o=400,fontWeightMedium:a=500,fontWeightBold:l=700,htmlFontSize:c=16,allVariants:u,pxToRem:d}=n,f=it(n,hZ),h=i/14,p=d||(y=>`${y/c*h}rem`),x=(y,b,S,w,E)=>X({fontFamily:r,fontWeight:y,fontSize:p(b),lineHeight:S},r===Tk?{letterSpacing:`${pZ(w/b)}em`}:{},E,u),v={h1:x(s,96,1.167,-1.5),h2:x(s,60,1.2,-.5),h3:x(o,48,1.167,0),h4:x(o,34,1.235,.25),h5:x(o,24,1.334,0),h6:x(a,20,1.6,.15),subtitle1:x(o,16,1.75,.15),subtitle2:x(a,14,1.57,.1),body1:x(o,16,1.5,.15),body2:x(o,14,1.43,.15),button:x(a,14,1.75,.4,Ak),caption:x(o,12,1.66,.4),overline:x(o,12,2.66,1,Ak),inherit:{fontFamily:"inherit",fontWeight:"inherit",fontSize:"inherit",lineHeight:"inherit",letterSpacing:"inherit"}};return Bi(X({htmlFontSize:c,pxToRem:p,fontFamily:r,fontSize:i,fontWeightLight:s,fontWeightRegular:o,fontWeightMedium:a,fontWeightBold:l},v),f,{clone:!1})}const gZ=.2,yZ=.14,vZ=.12;function Un(...t){return[`${t[0]}px ${t[1]}px ${t[2]}px ${t[3]}px rgba(0,0,0,${gZ})`,`${t[4]}px ${t[5]}px ${t[6]}px ${t[7]}px rgba(0,0,0,${yZ})`,`${t[8]}px ${t[9]}px ${t[10]}px ${t[11]}px rgba(0,0,0,${vZ})`].join(",")}const xZ=["none",Un(0,2,1,-1,0,1,1,0,0,1,3,0),Un(0,3,1,-2,0,2,2,0,0,1,5,0),Un(0,3,3,-2,0,3,4,0,0,1,8,0),Un(0,2,4,-1,0,4,5,0,0,1,10,0),Un(0,3,5,-1,0,5,8,0,0,1,14,0),Un(0,3,5,-1,0,6,10,0,0,1,18,0),Un(0,4,5,-2,0,7,10,1,0,2,16,1),Un(0,5,5,-3,0,8,10,1,0,3,14,2),Un(0,5,6,-3,0,9,12,1,0,3,16,2),Un(0,6,6,-3,0,10,14,1,0,4,18,3),Un(0,6,7,-4,0,11,15,1,0,4,20,3),Un(0,7,8,-4,0,12,17,2,0,5,22,4),Un(0,7,8,-4,0,13,19,2,0,5,24,4),Un(0,7,9,-4,0,14,21,2,0,5,26,4),Un(0,8,9,-5,0,15,22,2,0,6,28,5),Un(0,8,10,-5,0,16,24,2,0,6,30,5),Un(0,8,11,-5,0,17,26,2,0,6,32,5),Un(0,9,11,-5,0,18,28,2,0,7,34,6),Un(0,9,12,-6,0,19,29,2,0,7,36,6),Un(0,10,13,-6,0,20,31,3,0,8,38,7),Un(0,10,13,-6,0,21,33,3,0,8,40,7),Un(0,10,14,-6,0,22,35,3,0,8,42,7),Un(0,11,14,-7,0,23,36,3,0,9,44,8),Un(0,11,15,-7,0,24,38,3,0,9,46,8)],bZ=["duration","easing","delay"],SZ={easeInOut:"cubic-bezier(0.4, 0, 0.2, 1)",easeOut:"cubic-bezier(0.0, 0, 0.2, 1)",easeIn:"cubic-bezier(0.4, 0, 1, 1)",sharp:"cubic-bezier(0.4, 0, 0.6, 1)"},NU={shortest:150,shorter:200,short:250,standard:300,complex:375,enteringScreen:225,leavingScreen:195};function Mk(t){return`${Math.round(t)}ms`}function _Z(t){if(!t)return 0;const e=t/36;return Math.round((4+15*e**.25+e/5)*10)}function wZ(t){const e=X({},SZ,t.easing),n=X({},NU,t.duration);return X({getAutoHeightDuration:_Z,create:(i=["all"],s={})=>{const{duration:o=n.standard,easing:a=e.easeInOut,delay:l=0}=s;return it(s,bZ),(Array.isArray(i)?i:[i]).map(c=>`${c} ${typeof o=="string"?o:Mk(o)} ${a} ${typeof l=="string"?l:Mk(l)}`).join(",")}},t,{easing:e,duration:n})}const CZ={mobileStepper:1e3,fab:1050,speedDial:1050,appBar:1100,drawer:1200,modal:1300,snackbar:1400,tooltip:1500},EZ=CZ,AZ=["breakpoints","mixins","spacing","palette","transitions","typography","shape"];function PU(t={},...e){const{mixins:n={},palette:r={},transitions:i={},typography:s={}}=t,o=it(t,AZ);if(t.vars)throw new Error(cd(18));const a=fZ(r),l=fp(t);let c=Bi(l,{mixins:WQ(l.breakpoints,n),palette:a,shadows:xZ.slice(),typography:mZ(a,s),transitions:wZ(i),zIndex:X({},EZ)});return c=Bi(c,o),c=e.reduce((u,d)=>Bi(u,d),c),c.unstable_sxConfig=X({},b0,o==null?void 0:o.unstable_sxConfig),c.unstable_sx=function(d){return dp({sx:d,theme:this})},c}const TZ=PU(),sS=TZ;function _0(){const t=jb(sS);return t[g0]||t}function Vt({props:t,name:e}){return QM({props:t,name:e,defaultTheme:sS,themeId:g0})}var w0={},oC={exports:{}},Rk;function MZ(){return Rk||(Rk=1,function(t){function e(n,r){if(n==null)return{};var i={},s=Object.keys(n),o,a;for(a=0;a<s.length;a++)o=s[a],!(r.indexOf(o)>=0)&&(i[o]=n[o]);return i}t.exports=e,t.exports.__esModule=!0,t.exports.default=t.exports}(oC)),oC.exports}const RZ=Cl(KJ),IZ=Cl(qJ),NZ=Cl(nY),PZ=Cl(oQ),kZ=Cl(VY),DZ=Cl(YY);var pp=_U;Object.defineProperty(w0,"__esModule",{value:!0});var OZ=w0.default=KZ;w0.shouldForwardProp=Vx;w0.systemDefaultTheme=void 0;var Qs=pp(q$()),qA=pp(MZ()),Ik=GZ(RZ),LZ=IZ;pp(NZ);pp(PZ);var BZ=pp(kZ),FZ=pp(DZ);const $Z=["ownerState"],UZ=["variants"],zZ=["name","slot","skipVariantsResolver","skipSx","overridesResolver"];function kU(t){if(typeof WeakMap!="function")return null;var e=new WeakMap,n=new WeakMap;return(kU=function(r){return r?n:e})(t)}function GZ(t,e){if(!e&&t&&t.__esModule)return t;if(t===null||typeof t!="object"&&typeof t!="function")return{default:t};var n=kU(e);if(n&&n.has(t))return n.get(t);var r={__proto__:null},i=Object.defineProperty&&Object.getOwnPropertyDescriptor;for(var s in t)if(s!=="default"&&Object.prototype.hasOwnProperty.call(t,s)){var o=i?Object.getOwnPropertyDescriptor(t,s):null;o&&(o.get||o.set)?Object.defineProperty(r,s,o):r[s]=t[s]}return r.default=t,n&&n.set(t,r),r}function HZ(t){return Object.keys(t).length===0}function VZ(t){return typeof t=="string"&&t.charCodeAt(0)>96}function Vx(t){return t!=="ownerState"&&t!=="theme"&&t!=="sx"&&t!=="as"}const WZ=w0.systemDefaultTheme=(0,BZ.default)(),jZ=t=>t&&t.charAt(0).toLowerCase()+t.slice(1);function pv({defaultTheme:t,theme:e,themeId:n}){return HZ(e)?t:e[n]||e}function XZ(t){return t?(e,n)=>n[t]:null}function Wx(t,e){let{ownerState:n}=e,r=(0,qA.default)(e,$Z);const i=typeof t=="function"?t((0,Qs.default)({ownerState:n},r)):t;if(Array.isArray(i))return i.flatMap(s=>Wx(s,(0,Qs.default)({ownerState:n},r)));if(i&&typeof i=="object"&&Array.isArray(i.variants)){const{variants:s=[]}=i;let a=(0,qA.default)(i,UZ);return s.forEach(l=>{let c=!0;typeof l.props=="function"?c=l.props((0,Qs.default)({ownerState:n},r,n)):Object.keys(l.props).forEach(u=>{(n==null?void 0:n[u])!==l.props[u]&&r[u]!==l.props[u]&&(c=!1)}),c&&(Array.isArray(a)||(a=[a]),a.push(typeof l.style=="function"?l.style((0,Qs.default)({ownerState:n},r,n)):l.style))}),a}return i}function KZ(t={}){const{themeId:e,defaultTheme:n=WZ,rootShouldForwardProp:r=Vx,slotShouldForwardProp:i=Vx}=t,s=o=>(0,FZ.default)((0,Qs.default)({},o,{theme:pv((0,Qs.default)({},o,{defaultTheme:n,themeId:e}))}));return s.__mui_systemSx=!0,(o,a={})=>{(0,Ik.internal_processStyles)(o,E=>E.filter(A=>!(A!=null&&A.__mui_systemSx)));const{name:l,slot:c,skipVariantsResolver:u,skipSx:d,overridesResolver:f=XZ(jZ(c))}=a,h=(0,qA.default)(a,zZ),p=u!==void 0?u:c&&c!=="Root"&&c!=="root"||!1,x=d||!1;let v,y=Vx;c==="Root"||c==="root"?y=r:c?y=i:VZ(o)&&(y=void 0);const b=(0,Ik.default)(o,(0,Qs.default)({shouldForwardProp:y,label:v},h)),S=E=>typeof E=="function"&&E.__emotion_real!==E||(0,LZ.isPlainObject)(E)?A=>Wx(E,(0,Qs.default)({},A,{theme:pv({theme:A.theme,defaultTheme:n,themeId:e})})):E,w=(E,...A)=>{let T=S(E);const I=A?A.map(S):[];l&&f&&I.push(P=>{const B=pv((0,Qs.default)({},P,{defaultTheme:n,themeId:e}));if(!B.components||!B.components[l]||!B.components[l].styleOverrides)return null;const F=B.components[l].styleOverrides,U={};return Object.entries(F).forEach(([j,Z])=>{U[j]=Wx(Z,(0,Qs.default)({},P,{theme:B}))}),f(P,U)}),l&&!p&&I.push(P=>{var B;const F=pv((0,Qs.default)({},P,{defaultTheme:n,themeId:e})),U=F==null||(B=F.components)==null||(B=B[l])==null?void 0:B.variants;return Wx({variants:U},(0,Qs.default)({},P,{theme:F}))}),x||I.push(s);const N=I.length-A.length;if(Array.isArray(E)&&N>0){const P=new Array(N).fill("");T=[...E,...P],T.raw=[...E.raw,...P]}const M=b(T,...I);return o.muiName&&(M.muiName=o.muiName),M};return b.withConfig&&(w.withConfig=b.withConfig),w}}function rR(t){return t!=="ownerState"&&t!=="theme"&&t!=="sx"&&t!=="as"}const Jo=t=>rR(t)&&t!=="classes",Ke=OZ({themeId:g0,defaultTheme:sS,rootShouldForwardProp:Jo}),Nk=t=>{let e;return t<1?e=5.11916*t**2:e=4.5*Math.log(t+1)+2,(e/100).toFixed(2)};function qZ(t){return kt("MuiSvgIcon",t)}Bt("MuiSvgIcon",["root","colorPrimary","colorSecondary","colorAction","colorError","colorDisabled","fontSizeInherit","fontSizeSmall","fontSizeMedium","fontSizeLarge"]);const JZ=["children","className","color","component","fontSize","htmlColor","inheritViewBox","titleAccess","viewBox"],YZ=t=>{const{color:e,fontSize:n,classes:r}=t,i={root:["root",e!=="inherit"&&`color${Le(e)}`,`fontSize${Le(n)}`]};return Ft(i,qZ,r)},QZ=Ke("svg",{name:"MuiSvgIcon",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,n.color!=="inherit"&&e[`color${Le(n.color)}`],e[`fontSize${Le(n.fontSize)}`]]}})(({theme:t,ownerState:e})=>{var n,r,i,s,o,a,l,c,u,d,f,h,p;return{userSelect:"none",width:"1em",height:"1em",display:"inline-block",fill:e.hasSvgAsChild?void 0:"currentColor",flexShrink:0,transition:(n=t.transitions)==null||(r=n.create)==null?void 0:r.call(n,"fill",{duration:(i=t.transitions)==null||(i=i.duration)==null?void 0:i.shorter}),fontSize:{inherit:"inherit",small:((s=t.typography)==null||(o=s.pxToRem)==null?void 0:o.call(s,20))||"1.25rem",medium:((a=t.typography)==null||(l=a.pxToRem)==null?void 0:l.call(a,24))||"1.5rem",large:((c=t.typography)==null||(u=c.pxToRem)==null?void 0:u.call(c,35))||"2.1875rem"}[e.fontSize],color:(d=(f=(t.vars||t).palette)==null||(f=f[e.color])==null?void 0:f.main)!=null?d:{action:(h=(t.vars||t).palette)==null||(h=h.action)==null?void 0:h.active,disabled:(p=(t.vars||t).palette)==null||(p=p.action)==null?void 0:p.disabled,inherit:void 0}[e.color]}}),JA=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiSvgIcon"}),{children:i,className:s,color:o="inherit",component:a="svg",fontSize:l="medium",htmlColor:c,inheritViewBox:u=!1,titleAccess:d,viewBox:f="0 0 24 24"}=r,h=it(r,JZ),p=L.isValidElement(i)&&i.type==="svg",x=X({},r,{color:o,component:a,fontSize:l,instanceFontSize:e.fontSize,inheritViewBox:u,viewBox:f,hasSvgAsChild:p}),v={};u||(v.viewBox=f);const y=YZ(x);return H.jsxs(QZ,X({as:a,className:ct(y.root,s),focusable:"false",color:c,"aria-hidden":d?void 0:!0,role:d?"img":void 0,ref:n},v,h,p&&i.props,{ownerState:x,children:[p?i.props.children:i,d?H.jsx("title",{children:d}):null]}))});JA.muiName="SvgIcon";function Os(t,e){function n(r,i){return H.jsx(JA,X({"data-testid":`${e}Icon`,ref:i},r,{children:t}))}return n.muiName=JA.muiName,L.memo(L.forwardRef(n))}var wn={};/**
 * @license React
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var iR=Symbol.for("react.element"),sR=Symbol.for("react.portal"),oS=Symbol.for("react.fragment"),aS=Symbol.for("react.strict_mode"),lS=Symbol.for("react.profiler"),cS=Symbol.for("react.provider"),uS=Symbol.for("react.context"),ZZ=Symbol.for("react.server_context"),dS=Symbol.for("react.forward_ref"),fS=Symbol.for("react.suspense"),hS=Symbol.for("react.suspense_list"),pS=Symbol.for("react.memo"),mS=Symbol.for("react.lazy"),eee=Symbol.for("react.offscreen"),DU;DU=Symbol.for("react.module.reference");function bo(t){if(typeof t=="object"&&t!==null){var e=t.$$typeof;switch(e){case iR:switch(t=t.type,t){case oS:case lS:case aS:case fS:case hS:return t;default:switch(t=t&&t.$$typeof,t){case ZZ:case uS:case dS:case mS:case pS:case cS:return t;default:return e}}case sR:return e}}}wn.ContextConsumer=uS;wn.ContextProvider=cS;wn.Element=iR;wn.ForwardRef=dS;wn.Fragment=oS;wn.Lazy=mS;wn.Memo=pS;wn.Portal=sR;wn.Profiler=lS;wn.StrictMode=aS;wn.Suspense=fS;wn.SuspenseList=hS;wn.isAsyncMode=function(){return!1};wn.isConcurrentMode=function(){return!1};wn.isContextConsumer=function(t){return bo(t)===uS};wn.isContextProvider=function(t){return bo(t)===cS};wn.isElement=function(t){return typeof t=="object"&&t!==null&&t.$$typeof===iR};wn.isForwardRef=function(t){return bo(t)===dS};wn.isFragment=function(t){return bo(t)===oS};wn.isLazy=function(t){return bo(t)===mS};wn.isMemo=function(t){return bo(t)===pS};wn.isPortal=function(t){return bo(t)===sR};wn.isProfiler=function(t){return bo(t)===lS};wn.isStrictMode=function(t){return bo(t)===aS};wn.isSuspense=function(t){return bo(t)===fS};wn.isSuspenseList=function(t){return bo(t)===hS};wn.isValidElementType=function(t){return typeof t=="string"||typeof t=="function"||t===oS||t===lS||t===aS||t===fS||t===hS||t===eee||typeof t=="object"&&t!==null&&(t.$$typeof===mS||t.$$typeof===pS||t.$$typeof===cS||t.$$typeof===uS||t.$$typeof===dS||t.$$typeof===DU||t.getModuleId!==void 0)};wn.typeOf=bo;function gS(t){return Vt}function YA(t,e){return YA=Object.setPrototypeOf?Object.setPrototypeOf.bind():function(r,i){return r.__proto__=i,r},YA(t,e)}function OU(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t,YA(t,e)}const Pk={disabled:!1},L1=Go.createContext(null);var tee=function(e){return e.scrollTop},$m="unmounted",vu="exited",xu="entering",$f="entered",QA="exiting",Al=function(t){OU(e,t);function e(r,i){var s;s=t.call(this,r,i)||this;var o=i,a=o&&!o.isMounting?r.enter:r.appear,l;return s.appearStatus=null,r.in?a?(l=vu,s.appearStatus=xu):l=$f:r.unmountOnExit||r.mountOnEnter?l=$m:l=vu,s.state={status:l},s.nextCallback=null,s}e.getDerivedStateFromProps=function(i,s){var o=i.in;return o&&s.status===$m?{status:vu}:null};var n=e.prototype;return n.componentDidMount=function(){this.updateStatus(!0,this.appearStatus)},n.componentDidUpdate=function(i){var s=null;if(i!==this.props){var o=this.state.status;this.props.in?o!==xu&&o!==$f&&(s=xu):(o===xu||o===$f)&&(s=QA)}this.updateStatus(!1,s)},n.componentWillUnmount=function(){this.cancelNextCallback()},n.getTimeouts=function(){var i=this.props.timeout,s,o,a;return s=o=a=i,i!=null&&typeof i!="number"&&(s=i.exit,o=i.enter,a=i.appear!==void 0?i.appear:o),{exit:s,enter:o,appear:a}},n.updateStatus=function(i,s){if(i===void 0&&(i=!1),s!==null)if(this.cancelNextCallback(),s===xu){if(this.props.unmountOnExit||this.props.mountOnEnter){var o=this.props.nodeRef?this.props.nodeRef.current:dv.findDOMNode(this);o&&tee(o)}this.performEnter(i)}else this.performExit();else this.props.unmountOnExit&&this.state.status===vu&&this.setState({status:$m})},n.performEnter=function(i){var s=this,o=this.props.enter,a=this.context?this.context.isMounting:i,l=this.props.nodeRef?[a]:[dv.findDOMNode(this),a],c=l[0],u=l[1],d=this.getTimeouts(),f=a?d.appear:d.enter;if(!i&&!o||Pk.disabled){this.safeSetState({status:$f},function(){s.props.onEntered(c)});return}this.props.onEnter(c,u),this.safeSetState({status:xu},function(){s.props.onEntering(c,u),s.onTransitionEnd(f,function(){s.safeSetState({status:$f},function(){s.props.onEntered(c,u)})})})},n.performExit=function(){var i=this,s=this.props.exit,o=this.getTimeouts(),a=this.props.nodeRef?void 0:dv.findDOMNode(this);if(!s||Pk.disabled){this.safeSetState({status:vu},function(){i.props.onExited(a)});return}this.props.onExit(a),this.safeSetState({status:QA},function(){i.props.onExiting(a),i.onTransitionEnd(o.exit,function(){i.safeSetState({status:vu},function(){i.props.onExited(a)})})})},n.cancelNextCallback=function(){this.nextCallback!==null&&(this.nextCallback.cancel(),this.nextCallback=null)},n.safeSetState=function(i,s){s=this.setNextCallback(s),this.setState(i,s)},n.setNextCallback=function(i){var s=this,o=!0;return this.nextCallback=function(a){o&&(o=!1,s.nextCallback=null,i(a))},this.nextCallback.cancel=function(){o=!1},this.nextCallback},n.onTransitionEnd=function(i,s){this.setNextCallback(s);var o=this.props.nodeRef?this.props.nodeRef.current:dv.findDOMNode(this),a=i==null&&!this.props.addEndListener;if(!o||a){setTimeout(this.nextCallback,0);return}if(this.props.addEndListener){var l=this.props.nodeRef?[this.nextCallback]:[o,this.nextCallback],c=l[0],u=l[1];this.props.addEndListener(c,u)}i!=null&&setTimeout(this.nextCallback,i)},n.render=function(){var i=this.state.status;if(i===$m)return null;var s=this.props,o=s.children;s.in,s.mountOnEnter,s.unmountOnExit,s.appear,s.enter,s.exit,s.timeout,s.addEndListener,s.onEnter,s.onEntering,s.onEntered,s.onExit,s.onExiting,s.onExited,s.nodeRef;var a=it(s,["children","in","mountOnEnter","unmountOnExit","appear","enter","exit","timeout","addEndListener","onEnter","onEntering","onEntered","onExit","onExiting","onExited","nodeRef"]);return Go.createElement(L1.Provider,{value:null},typeof o=="function"?o(i,a):Go.cloneElement(Go.Children.only(o),a))},e}(Go.Component);Al.contextType=L1;Al.propTypes={};function uf(){}Al.defaultProps={in:!1,mountOnEnter:!1,unmountOnExit:!1,appear:!1,enter:!0,exit:!0,onEnter:uf,onEntering:uf,onEntered:uf,onExit:uf,onExiting:uf,onExited:uf};Al.UNMOUNTED=$m;Al.EXITED=vu;Al.ENTERING=xu;Al.ENTERED=$f;Al.EXITING=QA;const oR=Al;function nee(t){if(t===void 0)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return t}function aR(t,e){var n=function(s){return e&&L.isValidElement(s)?e(s):s},r=Object.create(null);return t&&L.Children.map(t,function(i){return i}).forEach(function(i){r[i.key]=n(i)}),r}function ree(t,e){t=t||{},e=e||{};function n(u){return u in e?e[u]:t[u]}var r=Object.create(null),i=[];for(var s in t)s in e?i.length&&(r[s]=i,i=[]):i.push(s);var o,a={};for(var l in e){if(r[l])for(o=0;o<r[l].length;o++){var c=r[l][o];a[r[l][o]]=n(c)}a[l]=n(l)}for(o=0;o<i.length;o++)a[i[o]]=n(i[o]);return a}function Pu(t,e,n){return n[e]!=null?n[e]:t.props[e]}function iee(t,e){return aR(t.children,function(n){return L.cloneElement(n,{onExited:e.bind(null,n),in:!0,appear:Pu(n,"appear",t),enter:Pu(n,"enter",t),exit:Pu(n,"exit",t)})})}function see(t,e,n){var r=aR(t.children),i=ree(e,r);return Object.keys(i).forEach(function(s){var o=i[s];if(L.isValidElement(o)){var a=s in e,l=s in r,c=e[s],u=L.isValidElement(c)&&!c.props.in;l&&(!a||u)?i[s]=L.cloneElement(o,{onExited:n.bind(null,o),in:!0,exit:Pu(o,"exit",t),enter:Pu(o,"enter",t)}):!l&&a&&!u?i[s]=L.cloneElement(o,{in:!1}):l&&a&&L.isValidElement(c)&&(i[s]=L.cloneElement(o,{onExited:n.bind(null,o),in:c.props.in,exit:Pu(o,"exit",t),enter:Pu(o,"enter",t)}))}}),i}var oee=Object.values||function(t){return Object.keys(t).map(function(e){return t[e]})},aee={component:"div",childFactory:function(e){return e}},lR=function(t){OU(e,t);function e(r,i){var s;s=t.call(this,r,i)||this;var o=s.handleExited.bind(nee(s));return s.state={contextValue:{isMounting:!0},handleExited:o,firstRender:!0},s}var n=e.prototype;return n.componentDidMount=function(){this.mounted=!0,this.setState({contextValue:{isMounting:!1}})},n.componentWillUnmount=function(){this.mounted=!1},e.getDerivedStateFromProps=function(i,s){var o=s.children,a=s.handleExited,l=s.firstRender;return{children:l?iee(i,a):see(i,o,a),firstRender:!1}},n.handleExited=function(i,s){var o=aR(this.props.children);i.key in o||(i.props.onExited&&i.props.onExited(s),this.mounted&&this.setState(function(a){var l=X({},a.children);return delete l[i.key],{children:l}}))},n.render=function(){var i=this.props,s=i.component,o=i.childFactory,a=it(i,["component","childFactory"]),l=this.state.contextValue,c=oee(this.state.children).map(o);return delete a.appear,delete a.enter,delete a.exit,s===null?Go.createElement(L1.Provider,{value:l},c):Go.createElement(L1.Provider,{value:l},Go.createElement(s,a,c))},e}(Go.Component);lR.propTypes={};lR.defaultProps=aee;const lee=lR,LU=t=>t.scrollTop;function Bh(t,e){var n,r;const{timeout:i,easing:s,style:o={}}=t;return{duration:(n=o.transitionDuration)!=null?n:typeof i=="number"?i:i[e.mode]||0,easing:(r=o.transitionTimingFunction)!=null?r:typeof s=="object"?s[e.mode]:s,delay:o.transitionDelay}}function cee(t){return kt("MuiCollapse",t)}Bt("MuiCollapse",["root","horizontal","vertical","entered","hidden","wrapper","wrapperInner"]);const uee=["addEndListener","children","className","collapsedSize","component","easing","in","onEnter","onEntered","onEntering","onExit","onExited","onExiting","orientation","style","timeout","TransitionComponent"],dee=t=>{const{orientation:e,classes:n}=t,r={root:["root",`${e}`],entered:["entered"],hidden:["hidden"],wrapper:["wrapper",`${e}`],wrapperInner:["wrapperInner",`${e}`]};return Ft(r,cee,n)},fee=Ke("div",{name:"MuiCollapse",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,e[n.orientation],n.state==="entered"&&e.entered,n.state==="exited"&&!n.in&&n.collapsedSize==="0px"&&e.hidden]}})(({theme:t,ownerState:e})=>X({height:0,overflow:"hidden",transition:t.transitions.create("height")},e.orientation==="horizontal"&&{height:"auto",width:0,transition:t.transitions.create("width")},e.state==="entered"&&X({height:"auto",overflow:"visible"},e.orientation==="horizontal"&&{width:"auto"}),e.state==="exited"&&!e.in&&e.collapsedSize==="0px"&&{visibility:"hidden"})),hee=Ke("div",{name:"MuiCollapse",slot:"Wrapper",overridesResolver:(t,e)=>e.wrapper})(({ownerState:t})=>X({display:"flex",width:"100%"},t.orientation==="horizontal"&&{width:"auto",height:"100%"})),pee=Ke("div",{name:"MuiCollapse",slot:"WrapperInner",overridesResolver:(t,e)=>e.wrapperInner})(({ownerState:t})=>X({width:"100%"},t.orientation==="horizontal"&&{width:"auto",height:"100%"})),BU=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiCollapse"}),{addEndListener:i,children:s,className:o,collapsedSize:a="0px",component:l,easing:c,in:u,onEnter:d,onEntered:f,onEntering:h,onExit:p,onExited:x,onExiting:v,orientation:y="vertical",style:b,timeout:S=NU.standard,TransitionComponent:w=oR}=r,E=it(r,uee),A=X({},r,{orientation:y,collapsedSize:a}),T=dee(A),I=_0(),N=ZM(),M=L.useRef(null),P=L.useRef(),B=typeof a=="number"?`${a}px`:a,F=y==="horizontal",U=F?"width":"height",j=L.useRef(null),Z=Wr(n,j),ne=fe=>Ee=>{if(fe){const We=j.current;Ee===void 0?fe(We):fe(We,Ee)}},O=()=>M.current?M.current[F?"clientWidth":"clientHeight"]:0,G=ne((fe,Ee)=>{M.current&&F&&(M.current.style.position="absolute"),fe.style[U]=B,d&&d(fe,Ee)}),q=ne((fe,Ee)=>{const We=O();M.current&&F&&(M.current.style.position="");const{duration:je,easing:Je}=Bh({style:b,timeout:S,easing:c},{mode:"enter"});if(S==="auto"){const te=I.transitions.getAutoHeightDuration(We);fe.style.transitionDuration=`${te}ms`,P.current=te}else fe.style.transitionDuration=typeof je=="string"?je:`${je}ms`;fe.style[U]=`${We}px`,fe.style.transitionTimingFunction=Je,h&&h(fe,Ee)}),se=ne((fe,Ee)=>{fe.style[U]="auto",f&&f(fe,Ee)}),he=ne(fe=>{fe.style[U]=`${O()}px`,p&&p(fe)}),ke=ne(x),re=ne(fe=>{const Ee=O(),{duration:We,easing:je}=Bh({style:b,timeout:S,easing:c},{mode:"exit"});if(S==="auto"){const Je=I.transitions.getAutoHeightDuration(Ee);fe.style.transitionDuration=`${Je}ms`,P.current=Je}else fe.style.transitionDuration=typeof We=="string"?We:`${We}ms`;fe.style[U]=B,fe.style.transitionTimingFunction=je,v&&v(fe)}),pe=fe=>{S==="auto"&&N.start(P.current||0,fe),i&&i(j.current,fe)};return H.jsx(w,X({in:u,onEnter:G,onEntered:se,onEntering:q,onExit:he,onExited:ke,onExiting:re,addEndListener:pe,nodeRef:j,timeout:S==="auto"?null:S},E,{children:(fe,Ee)=>H.jsx(fee,X({as:l,className:ct(T.root,o,{entered:T.entered,exited:!u&&B==="0px"&&T.hidden}[fe]),style:X({[F?"minWidth":"minHeight"]:B},b),ref:Z},Ee,{ownerState:X({},A,{state:fe}),children:H.jsx(hee,{ownerState:X({},A,{state:fe}),className:T.wrapper,ref:M,children:H.jsx(pee,{ownerState:X({},A,{state:fe}),className:T.wrapperInner,children:s})})}))}))});BU.muiSupportAuto=!0;const mee=BU;function gee(t){return kt("MuiPaper",t)}Bt("MuiPaper",["root","rounded","outlined","elevation","elevation0","elevation1","elevation2","elevation3","elevation4","elevation5","elevation6","elevation7","elevation8","elevation9","elevation10","elevation11","elevation12","elevation13","elevation14","elevation15","elevation16","elevation17","elevation18","elevation19","elevation20","elevation21","elevation22","elevation23","elevation24"]);const yee=["className","component","elevation","square","variant"],vee=t=>{const{square:e,elevation:n,variant:r,classes:i}=t,s={root:["root",r,!e&&"rounded",r==="elevation"&&`elevation${n}`]};return Ft(s,gee,i)},xee=Ke("div",{name:"MuiPaper",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,e[n.variant],!n.square&&e.rounded,n.variant==="elevation"&&e[`elevation${n.elevation}`]]}})(({theme:t,ownerState:e})=>{var n;return X({backgroundColor:(t.vars||t).palette.background.paper,color:(t.vars||t).palette.text.primary,transition:t.transitions.create("box-shadow")},!e.square&&{borderRadius:t.shape.borderRadius},e.variant==="outlined"&&{border:`1px solid ${(t.vars||t).palette.divider}`},e.variant==="elevation"&&X({boxShadow:(t.vars||t).shadows[e.elevation]},!t.vars&&t.palette.mode==="dark"&&{backgroundImage:`linear-gradient(${Tr("#fff",Nk(e.elevation))}, ${Tr("#fff",Nk(e.elevation))})`},t.vars&&{backgroundImage:(n=t.vars.overlays)==null?void 0:n[e.elevation]}))}),bee=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiPaper"}),{className:i,component:s="div",elevation:o=1,square:a=!1,variant:l="elevation"}=r,c=it(r,yee),u=X({},r,{component:s,elevation:o,square:a,variant:l}),d=vee(u);return H.jsx(xee,X({as:s,ownerState:u,className:ct(d.root,i),ref:n},c))}),Tl=bee,FU=L.createContext({});function B1(t){return typeof t=="string"}function $U(t,e,n){return t===void 0||B1(t)?e:X({},e,{ownerState:X({},e.ownerState,n)})}function UU(t,e=[]){if(t===void 0)return{};const n={};return Object.keys(t).filter(r=>r.match(/^on[A-Z]/)&&typeof t[r]=="function"&&!e.includes(r)).forEach(r=>{n[r]=t[r]}),n}function zU(t,e,n){return typeof t=="function"?t(e,n):t}function kk(t){if(t===void 0)return{};const e={};return Object.keys(t).filter(n=>!(n.match(/^on[A-Z]/)&&typeof t[n]=="function")).forEach(n=>{e[n]=t[n]}),e}function GU(t){const{getSlotProps:e,additionalProps:n,externalSlotProps:r,externalForwardedProps:i,className:s}=t;if(!e){const h=ct(n==null?void 0:n.className,s,i==null?void 0:i.className,r==null?void 0:r.className),p=X({},n==null?void 0:n.style,i==null?void 0:i.style,r==null?void 0:r.style),x=X({},n,i,r);return h.length>0&&(x.className=h),Object.keys(p).length>0&&(x.style=p),{props:x,internalRef:void 0}}const o=UU(X({},i,r)),a=kk(r),l=kk(i),c=e(o),u=ct(c==null?void 0:c.className,n==null?void 0:n.className,s,i==null?void 0:i.className,r==null?void 0:r.className),d=X({},c==null?void 0:c.style,n==null?void 0:n.style,i==null?void 0:i.style,r==null?void 0:r.style),f=X({},c,n,l,a);return u.length>0&&(f.className=u),Object.keys(d).length>0&&(f.style=d),{props:f,internalRef:c.ref}}const See=["elementType","externalSlotProps","ownerState","skipResolvingSlotProps"];function Ec(t){var e;const{elementType:n,externalSlotProps:r,ownerState:i,skipResolvingSlotProps:s=!1}=t,o=it(t,See),a=s?{}:zU(r,i),{props:l,internalRef:c}=GU(X({},o,{externalSlotProps:a})),u=Wr(c,a==null?void 0:a.ref,(e=t.additionalProps)==null?void 0:e.ref);return $U(n,X({},l,{ref:u}),i)}const _ee=["className","elementType","ownerState","externalForwardedProps","getSlotOwnerState","internalForwardedProps"],wee=["component","slots","slotProps"],Cee=["component"];function Eee(t,e){const{className:n,elementType:r,ownerState:i,externalForwardedProps:s,getSlotOwnerState:o,internalForwardedProps:a}=e,l=it(e,_ee),{component:c,slots:u={[t]:void 0},slotProps:d={[t]:void 0}}=s,f=it(s,wee),h=u[t]||r,p=zU(d[t],i),x=GU(X({className:n},l,{externalForwardedProps:t==="root"?f:void 0,externalSlotProps:p})),{props:{component:v},internalRef:y}=x,b=it(x.props,Cee),S=Wr(y,p==null?void 0:p.ref,e.ref),w=o?o(b):{},E=X({},i,w),A=t==="root"?v||c:v,T=$U(h,X({},t==="root"&&!c&&!u[t]&&a,t!=="root"&&!u[t]&&a,b,A&&{as:A},{ref:S}),E);return Object.keys(w).forEach(I=>{delete T[I]}),[h,T]}function Aee(t){return kt("MuiAccordion",t)}const Tee=Bt("MuiAccordion",["root","rounded","expanded","disabled","gutters","region"]),mv=Tee,Mee=["children","className","defaultExpanded","disabled","disableGutters","expanded","onChange","square","slots","slotProps","TransitionComponent","TransitionProps"],Ree=gS(),Iee=t=>{const{classes:e,square:n,expanded:r,disabled:i,disableGutters:s}=t;return Ft({root:["root",!n&&"rounded",r&&"expanded",i&&"disabled",!s&&"gutters"],region:["region"]},Aee,e)},Nee=Ke(Tl,{name:"MuiAccordion",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[{[`& .${mv.region}`]:e.region},e.root,!n.square&&e.rounded,!n.disableGutters&&e.gutters]}})(({theme:t})=>{const e={duration:t.transitions.duration.shortest};return{position:"relative",transition:t.transitions.create(["margin"],e),overflowAnchor:"none","&::before":{position:"absolute",left:0,top:-1,right:0,height:1,content:'""',opacity:1,backgroundColor:(t.vars||t).palette.divider,transition:t.transitions.create(["opacity","background-color"],e)},"&:first-of-type":{"&::before":{display:"none"}},[`&.${mv.expanded}`]:{"&::before":{opacity:0},"&:first-of-type":{marginTop:0},"&:last-of-type":{marginBottom:0},"& + &":{"&::before":{display:"none"}}},[`&.${mv.disabled}`]:{backgroundColor:(t.vars||t).palette.action.disabledBackground}}},({theme:t})=>({variants:[{props:e=>!e.square,style:{borderRadius:0,"&:first-of-type":{borderTopLeftRadius:(t.vars||t).shape.borderRadius,borderTopRightRadius:(t.vars||t).shape.borderRadius},"&:last-of-type":{borderBottomLeftRadius:(t.vars||t).shape.borderRadius,borderBottomRightRadius:(t.vars||t).shape.borderRadius,"@supports (-ms-ime-align: auto)":{borderBottomLeftRadius:0,borderBottomRightRadius:0}}}},{props:e=>!e.disableGutters,style:{[`&.${mv.expanded}`]:{margin:"16px 0"}}}]})),Pee=L.forwardRef(function(e,n){const r=Ree({props:e,name:"MuiAccordion"}),{children:i,className:s,defaultExpanded:o=!1,disabled:a=!1,disableGutters:l=!1,expanded:c,onChange:u,square:d=!1,slots:f={},slotProps:h={},TransitionComponent:p,TransitionProps:x}=r,v=it(r,Mee),[y,b]=XA({controlled:c,default:o,name:"Accordion",state:"expanded"}),S=L.useCallback(F=>{b(!y),u&&u(F,!y)},[y,u,b]),[w,...E]=L.Children.toArray(i),A=L.useMemo(()=>({expanded:y,disabled:a,disableGutters:l,toggle:S}),[y,a,l,S]),T=X({},r,{square:d,disabled:a,disableGutters:l,expanded:y}),I=Iee(T),N=X({transition:p},f),M=X({transition:x},h),[P,B]=Eee("transition",{elementType:mee,externalForwardedProps:{slots:N,slotProps:M},ownerState:T});return H.jsxs(Nee,X({className:ct(I.root,s),ref:n,ownerState:T,square:d},v,{children:[H.jsx(FU.Provider,{value:A,children:w}),H.jsx(P,X({in:y,timeout:"auto"},B,{children:H.jsx("div",{"aria-labelledby":w.props.id,id:w.props["aria-controls"],role:"region",className:I.region,children:E})}))]}))}),Dk=Pee;function kee(t){return kt("MuiAccordionDetails",t)}Bt("MuiAccordionDetails",["root"]);const Dee=["className"],Oee=gS(),Lee=t=>{const{classes:e}=t;return Ft({root:["root"]},kee,e)},Bee=Ke("div",{name:"MuiAccordionDetails",slot:"Root",overridesResolver:(t,e)=>e.root})(({theme:t})=>({padding:t.spacing(1,2,2)})),Fee=L.forwardRef(function(e,n){const r=Oee({props:e,name:"MuiAccordionDetails"}),{className:i}=r,s=it(r,Dee),o=r,a=Lee(o);return H.jsx(Bee,X({className:ct(a.root,i),ref:n,ownerState:o},s))}),Ok=Fee;function $ee(t){const{className:e,classes:n,pulsate:r=!1,rippleX:i,rippleY:s,rippleSize:o,in:a,onExited:l,timeout:c}=t,[u,d]=L.useState(!1),f=ct(e,n.ripple,n.rippleVisible,r&&n.ripplePulsate),h={width:o,height:o,top:-(o/2)+s,left:-(o/2)+i},p=ct(n.child,u&&n.childLeaving,r&&n.childPulsate);return!a&&!u&&d(!0),L.useEffect(()=>{if(!a&&l!=null){const x=setTimeout(l,c);return()=>{clearTimeout(x)}}},[l,a,c]),H.jsx("span",{className:f,style:h,children:H.jsx("span",{className:p})})}const to=Bt("MuiTouchRipple",["root","ripple","rippleVisible","ripplePulsate","child","childLeaving","childPulsate"]),Uee=["center","classes","className"];let yS=t=>t,Lk,Bk,Fk,$k;const ZA=550,zee=80,Gee=Rd(Lk||(Lk=yS`
  0% {
    transform: scale(0);
    opacity: 0.1;
  }

  100% {
    transform: scale(1);
    opacity: 0.3;
  }
`)),Hee=Rd(Bk||(Bk=yS`
  0% {
    opacity: 1;
  }

  100% {
    opacity: 0;
  }
`)),Vee=Rd(Fk||(Fk=yS`
  0% {
    transform: scale(1);
  }

  50% {
    transform: scale(0.92);
  }

  100% {
    transform: scale(1);
  }
`)),Wee=Ke("span",{name:"MuiTouchRipple",slot:"Root"})({overflow:"hidden",pointerEvents:"none",position:"absolute",zIndex:0,top:0,right:0,bottom:0,left:0,borderRadius:"inherit"}),jee=Ke($ee,{name:"MuiTouchRipple",slot:"Ripple"})($k||($k=yS`
  opacity: 0;
  position: absolute;

  &.${0} {
    opacity: 0.3;
    transform: scale(1);
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  &.${0} {
    animation-duration: ${0}ms;
  }

  & .${0} {
    opacity: 1;
    display: block;
    width: 100%;
    height: 100%;
    border-radius: 50%;
    background-color: currentColor;
  }

  & .${0} {
    opacity: 0;
    animation-name: ${0};
    animation-duration: ${0}ms;
    animation-timing-function: ${0};
  }

  & .${0} {
    position: absolute;
    /* @noflip */
    left: 0px;
    top: 0;
    animation-name: ${0};
    animation-duration: 2500ms;
    animation-timing-function: ${0};
    animation-iteration-count: infinite;
    animation-delay: 200ms;
  }
`),to.rippleVisible,Gee,ZA,({theme:t})=>t.transitions.easing.easeInOut,to.ripplePulsate,({theme:t})=>t.transitions.duration.shorter,to.child,to.childLeaving,Hee,ZA,({theme:t})=>t.transitions.easing.easeInOut,to.childPulsate,Vee,({theme:t})=>t.transitions.easing.easeInOut),Xee=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiTouchRipple"}),{center:i=!1,classes:s={},className:o}=r,a=it(r,Uee),[l,c]=L.useState([]),u=L.useRef(0),d=L.useRef(null);L.useEffect(()=>{d.current&&(d.current(),d.current=null)},[l]);const f=L.useRef(!1),h=ZM(),p=L.useRef(null),x=L.useRef(null),v=L.useCallback(w=>{const{pulsate:E,rippleX:A,rippleY:T,rippleSize:I,cb:N}=w;c(M=>[...M,H.jsx(jee,{classes:{ripple:ct(s.ripple,to.ripple),rippleVisible:ct(s.rippleVisible,to.rippleVisible),ripplePulsate:ct(s.ripplePulsate,to.ripplePulsate),child:ct(s.child,to.child),childLeaving:ct(s.childLeaving,to.childLeaving),childPulsate:ct(s.childPulsate,to.childPulsate)},timeout:ZA,pulsate:E,rippleX:A,rippleY:T,rippleSize:I},u.current)]),u.current+=1,d.current=N},[s]),y=L.useCallback((w={},E={},A=()=>{})=>{const{pulsate:T=!1,center:I=i||E.pulsate,fakeElement:N=!1}=E;if((w==null?void 0:w.type)==="mousedown"&&f.current){f.current=!1;return}(w==null?void 0:w.type)==="touchstart"&&(f.current=!0);const M=N?null:x.current,P=M?M.getBoundingClientRect():{width:0,height:0,left:0,top:0};let B,F,U;if(I||w===void 0||w.clientX===0&&w.clientY===0||!w.clientX&&!w.touches)B=Math.round(P.width/2),F=Math.round(P.height/2);else{const{clientX:j,clientY:Z}=w.touches&&w.touches.length>0?w.touches[0]:w;B=Math.round(j-P.left),F=Math.round(Z-P.top)}if(I)U=Math.sqrt((2*P.width**2+P.height**2)/3),U%2===0&&(U+=1);else{const j=Math.max(Math.abs((M?M.clientWidth:0)-B),B)*2+2,Z=Math.max(Math.abs((M?M.clientHeight:0)-F),F)*2+2;U=Math.sqrt(j**2+Z**2)}w!=null&&w.touches?p.current===null&&(p.current=()=>{v({pulsate:T,rippleX:B,rippleY:F,rippleSize:U,cb:A})},h.start(zee,()=>{p.current&&(p.current(),p.current=null)})):v({pulsate:T,rippleX:B,rippleY:F,rippleSize:U,cb:A})},[i,v,h]),b=L.useCallback(()=>{y({},{pulsate:!0})},[y]),S=L.useCallback((w,E)=>{if(h.clear(),(w==null?void 0:w.type)==="touchend"&&p.current){p.current(),p.current=null,h.start(0,()=>{S(w,E)});return}p.current=null,c(A=>A.length>0?A.slice(1):A),d.current=E},[h]);return L.useImperativeHandle(n,()=>({pulsate:b,start:y,stop:S}),[b,y,S]),H.jsx(Wee,X({className:ct(to.root,s.root,o),ref:x},a,{children:H.jsx(lee,{component:null,exit:!0,children:l})}))}),Kee=Xee;function qee(t){return kt("MuiButtonBase",t)}const Jee=Bt("MuiButtonBase",["root","disabled","focusVisible"]),Yee=["action","centerRipple","children","className","component","disabled","disableRipple","disableTouchRipple","focusRipple","focusVisibleClassName","LinkComponent","onBlur","onClick","onContextMenu","onDragLeave","onFocus","onFocusVisible","onKeyDown","onKeyUp","onMouseDown","onMouseLeave","onMouseUp","onTouchEnd","onTouchMove","onTouchStart","tabIndex","TouchRippleProps","touchRippleRef","type"],Qee=t=>{const{disabled:e,focusVisible:n,focusVisibleClassName:r,classes:i}=t,o=Ft({root:["root",e&&"disabled",n&&"focusVisible"]},qee,i);return n&&r&&(o.root+=` ${r}`),o},Zee=Ke("button",{name:"MuiButtonBase",slot:"Root",overridesResolver:(t,e)=>e.root})({display:"inline-flex",alignItems:"center",justifyContent:"center",position:"relative",boxSizing:"border-box",WebkitTapHighlightColor:"transparent",backgroundColor:"transparent",outline:0,border:0,margin:0,borderRadius:0,padding:0,cursor:"pointer",userSelect:"none",verticalAlign:"middle",MozAppearance:"none",WebkitAppearance:"none",textDecoration:"none",color:"inherit","&::-moz-focus-inner":{borderStyle:"none"},[`&.${Jee.disabled}`]:{pointerEvents:"none",cursor:"default"},"@media print":{colorAdjust:"exact"}}),ete=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiButtonBase"}),{action:i,centerRipple:s=!1,children:o,className:a,component:l="button",disabled:c=!1,disableRipple:u=!1,disableTouchRipple:d=!1,focusRipple:f=!1,LinkComponent:h="a",onBlur:p,onClick:x,onContextMenu:v,onDragLeave:y,onFocus:b,onFocusVisible:S,onKeyDown:w,onKeyUp:E,onMouseDown:A,onMouseLeave:T,onMouseUp:I,onTouchEnd:N,onTouchMove:M,onTouchStart:P,tabIndex:B=0,TouchRippleProps:F,touchRippleRef:U,type:j}=r,Z=it(r,Yee),ne=L.useRef(null),O=L.useRef(null),G=Wr(O,U),{isFocusVisibleRef:q,onFocus:se,onBlur:he,ref:ke}=yU(),[re,pe]=L.useState(!1);c&&re&&pe(!1),L.useImperativeHandle(i,()=>({focusVisible:()=>{pe(!0),ne.current.focus()}}),[]);const[fe,Ee]=L.useState(!1);L.useEffect(()=>{Ee(!0)},[]);const We=fe&&!u&&!c;L.useEffect(()=>{re&&f&&!u&&fe&&O.current.pulsate()},[u,f,re,fe]);function je($e,Ze,ot=d){return ih(Pt=>(Ze&&Ze(Pt),!ot&&O.current&&O.current[$e](Pt),!0))}const Je=je("start",A),te=je("stop",v),be=je("stop",y),ce=je("stop",I),Me=je("stop",$e=>{re&&$e.preventDefault(),T&&T($e)}),Ie=je("start",P),Oe=je("stop",N),V=je("stop",M),$=je("stop",$e=>{he($e),q.current===!1&&pe(!1),p&&p($e)},!1),ue=ih($e=>{ne.current||(ne.current=$e.currentTarget),se($e),q.current===!0&&(pe(!0),S&&S($e)),b&&b($e)}),ye=()=>{const $e=ne.current;return l&&l!=="button"&&!($e.tagName==="A"&&$e.href)},ve=L.useRef(!1),Ne=ih($e=>{f&&!ve.current&&re&&O.current&&$e.key===" "&&(ve.current=!0,O.current.stop($e,()=>{O.current.start($e)})),$e.target===$e.currentTarget&&ye()&&$e.key===" "&&$e.preventDefault(),w&&w($e),$e.target===$e.currentTarget&&ye()&&$e.key==="Enter"&&!c&&($e.preventDefault(),x&&x($e))}),nt=ih($e=>{f&&$e.key===" "&&O.current&&re&&!$e.defaultPrevented&&(ve.current=!1,O.current.stop($e,()=>{O.current.pulsate($e)})),E&&E($e),x&&$e.target===$e.currentTarget&&ye()&&$e.key===" "&&!$e.defaultPrevented&&x($e)});let Ae=l;Ae==="button"&&(Z.href||Z.to)&&(Ae=h);const st={};Ae==="button"?(st.type=j===void 0?"button":j,st.disabled=c):(!Z.href&&!Z.to&&(st.role="button"),c&&(st["aria-disabled"]=c));const ht=Wr(n,ke,ne),Ue=X({},r,{centerRipple:s,component:l,disabled:c,disableRipple:u,disableTouchRipple:d,focusRipple:f,tabIndex:B,focusVisible:re}),Fe=Qee(Ue);return H.jsxs(Zee,X({as:Ae,className:ct(Fe.root,a),ownerState:Ue,onBlur:$,onClick:x,onContextMenu:te,onFocus:ue,onKeyDown:Ne,onKeyUp:nt,onMouseDown:Je,onMouseLeave:Me,onMouseUp:ce,onDragLeave:be,onTouchEnd:Oe,onTouchMove:V,onTouchStart:Ie,ref:ht,tabIndex:c?-1:B,type:j},st,Z,{children:[o,We?H.jsx(Kee,X({ref:G,center:s},F)):null]}))}),hd=ete;function tte(t){return kt("MuiAccordionSummary",t)}const nte=Bt("MuiAccordionSummary",["root","expanded","focusVisible","disabled","gutters","contentGutters","content","expandIconWrapper"]),sh=nte,rte=["children","className","expandIcon","focusVisibleClassName","onClick"],ite=gS(),ste=t=>{const{classes:e,expanded:n,disabled:r,disableGutters:i}=t;return Ft({root:["root",n&&"expanded",r&&"disabled",!i&&"gutters"],focusVisible:["focusVisible"],content:["content",n&&"expanded",!i&&"contentGutters"],expandIconWrapper:["expandIconWrapper",n&&"expanded"]},tte,e)},ote=Ke(hd,{name:"MuiAccordionSummary",slot:"Root",overridesResolver:(t,e)=>e.root})(({theme:t})=>{const e={duration:t.transitions.duration.shortest};return{display:"flex",minHeight:48,padding:t.spacing(0,2),transition:t.transitions.create(["min-height","background-color"],e),[`&.${sh.focusVisible}`]:{backgroundColor:(t.vars||t).palette.action.focus},[`&.${sh.disabled}`]:{opacity:(t.vars||t).palette.action.disabledOpacity},[`&:hover:not(.${sh.disabled})`]:{cursor:"pointer"},variants:[{props:n=>!n.disableGutters,style:{[`&.${sh.expanded}`]:{minHeight:64}}}]}}),ate=Ke("div",{name:"MuiAccordionSummary",slot:"Content",overridesResolver:(t,e)=>e.content})(({theme:t})=>({display:"flex",flexGrow:1,margin:"12px 0",variants:[{props:e=>!e.disableGutters,style:{transition:t.transitions.create(["margin"],{duration:t.transitions.duration.shortest}),[`&.${sh.expanded}`]:{margin:"20px 0"}}}]})),lte=Ke("div",{name:"MuiAccordionSummary",slot:"ExpandIconWrapper",overridesResolver:(t,e)=>e.expandIconWrapper})(({theme:t})=>({display:"flex",color:(t.vars||t).palette.action.active,transform:"rotate(0deg)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shortest}),[`&.${sh.expanded}`]:{transform:"rotate(180deg)"}})),cte=L.forwardRef(function(e,n){const r=ite({props:e,name:"MuiAccordionSummary"}),{children:i,className:s,expandIcon:o,focusVisibleClassName:a,onClick:l}=r,c=it(r,rte),{disabled:u=!1,disableGutters:d,expanded:f,toggle:h}=L.useContext(FU),p=y=>{h&&h(y),l&&l(y)},x=X({},r,{expanded:f,disabled:u,disableGutters:d}),v=ste(x);return H.jsxs(ote,X({focusRipple:!1,disableRipple:!0,disabled:u,component:"div","aria-expanded":f,className:ct(v.root,s),focusVisibleClassName:ct(v.focusVisible,a),onClick:p,ref:n,ownerState:x},c,{children:[H.jsx(ate,{className:v.content,ownerState:x,children:i}),o&&H.jsx(lte,{className:v.expandIconWrapper,ownerState:x,children:o})]}))}),Uk=cte;function ute(t){return kt("MuiIconButton",t)}const dte=Bt("MuiIconButton",["root","disabled","colorInherit","colorPrimary","colorSecondary","colorError","colorInfo","colorSuccess","colorWarning","edgeStart","edgeEnd","sizeSmall","sizeMedium","sizeLarge"]),fte=["edge","children","className","color","disabled","disableFocusRipple","size"],hte=t=>{const{classes:e,disabled:n,color:r,edge:i,size:s}=t,o={root:["root",n&&"disabled",r!=="default"&&`color${Le(r)}`,i&&`edge${Le(i)}`,`size${Le(s)}`]};return Ft(o,ute,e)},pte=Ke(hd,{name:"MuiIconButton",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,n.color!=="default"&&e[`color${Le(n.color)}`],n.edge&&e[`edge${Le(n.edge)}`],e[`size${Le(n.size)}`]]}})(({theme:t,ownerState:e})=>X({textAlign:"center",flex:"0 0 auto",fontSize:t.typography.pxToRem(24),padding:8,borderRadius:"50%",overflow:"visible",color:(t.vars||t).palette.action.active,transition:t.transitions.create("background-color",{duration:t.transitions.duration.shortest})},!e.disableRipple&&{"&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.activeChannel} / ${t.vars.palette.action.hoverOpacity})`:Tr(t.palette.action.active,t.palette.action.hoverOpacity),"@media (hover: none)":{backgroundColor:"transparent"}}},e.edge==="start"&&{marginLeft:e.size==="small"?-3:-12},e.edge==="end"&&{marginRight:e.size==="small"?-3:-12}),({theme:t,ownerState:e})=>{var n;const r=(n=(t.vars||t).palette)==null?void 0:n[e.color];return X({},e.color==="inherit"&&{color:"inherit"},e.color!=="inherit"&&e.color!=="default"&&X({color:r==null?void 0:r.main},!e.disableRipple&&{"&:hover":X({},r&&{backgroundColor:t.vars?`rgba(${r.mainChannel} / ${t.vars.palette.action.hoverOpacity})`:Tr(r.main,t.palette.action.hoverOpacity)},{"@media (hover: none)":{backgroundColor:"transparent"}})}),e.size==="small"&&{padding:5,fontSize:t.typography.pxToRem(18)},e.size==="large"&&{padding:12,fontSize:t.typography.pxToRem(28)},{[`&.${dte.disabled}`]:{backgroundColor:"transparent",color:(t.vars||t).palette.action.disabled}})}),mte=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiIconButton"}),{edge:i=!1,children:s,className:o,color:a="default",disabled:l=!1,disableFocusRipple:c=!1,size:u="medium"}=r,d=it(r,fte),f=X({},r,{edge:i,color:a,disabled:l,disableFocusRipple:c,size:u}),h=hte(f);return H.jsx(pte,X({className:ct(h.root,o),centerRipple:!0,focusRipple:!c,disabled:l,ref:n},d,{ownerState:f,children:s}))}),cR=mte;function gte(t){return kt("MuiTypography",t)}Bt("MuiTypography",["root","h1","h2","h3","h4","h5","h6","subtitle1","subtitle2","body1","body2","inherit","button","caption","overline","alignLeft","alignRight","alignCenter","alignJustify","noWrap","gutterBottom","paragraph"]);const yte=["align","className","component","gutterBottom","noWrap","paragraph","variant","variantMapping"],vte=t=>{const{align:e,gutterBottom:n,noWrap:r,paragraph:i,variant:s,classes:o}=t,a={root:["root",s,t.align!=="inherit"&&`align${Le(e)}`,n&&"gutterBottom",r&&"noWrap",i&&"paragraph"]};return Ft(a,gte,o)},xte=Ke("span",{name:"MuiTypography",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,n.variant&&e[n.variant],n.align!=="inherit"&&e[`align${Le(n.align)}`],n.noWrap&&e.noWrap,n.gutterBottom&&e.gutterBottom,n.paragraph&&e.paragraph]}})(({theme:t,ownerState:e})=>X({margin:0},e.variant==="inherit"&&{font:"inherit"},e.variant!=="inherit"&&t.typography[e.variant],e.align!=="inherit"&&{textAlign:e.align},e.noWrap&&{overflow:"hidden",textOverflow:"ellipsis",whiteSpace:"nowrap"},e.gutterBottom&&{marginBottom:"0.35em"},e.paragraph&&{marginBottom:16})),zk={h1:"h1",h2:"h2",h3:"h3",h4:"h4",h5:"h5",h6:"h6",subtitle1:"h6",subtitle2:"h6",body1:"p",body2:"p",inherit:"p"},bte={primary:"primary.main",textPrimary:"text.primary",secondary:"secondary.main",textSecondary:"text.secondary",error:"error.main"},Ste=t=>bte[t]||t,_te=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiTypography"}),i=Ste(r.color),s=S0(X({},r,{color:i})),{align:o="inherit",className:a,component:l,gutterBottom:c=!1,noWrap:u=!1,paragraph:d=!1,variant:f="body1",variantMapping:h=zk}=s,p=it(s,yte),x=X({},s,{align:o,color:i,className:a,component:l,gutterBottom:c,noWrap:u,paragraph:d,variant:f,variantMapping:h}),v=l||(d?"p":h[f]||zk[f])||"span",y=vte(x);return H.jsx(xte,X({as:v,ref:n,ownerState:x,className:ct(y.root,a)},p))}),va=_te;function wte(t){return kt("MuiAppBar",t)}Bt("MuiAppBar",["root","positionFixed","positionAbsolute","positionSticky","positionStatic","positionRelative","colorDefault","colorPrimary","colorSecondary","colorInherit","colorTransparent","colorError","colorInfo","colorSuccess","colorWarning"]);const Cte=["className","color","enableColorOnDark","position"],Ete=t=>{const{color:e,position:n,classes:r}=t,i={root:["root",`color${Le(e)}`,`position${Le(n)}`]};return Ft(i,wte,r)},gv=(t,e)=>t?`${t==null?void 0:t.replace(")","")}, ${e})`:e,Ate=Ke(Tl,{name:"MuiAppBar",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,e[`position${Le(n.position)}`],e[`color${Le(n.color)}`]]}})(({theme:t,ownerState:e})=>{const n=t.palette.mode==="light"?t.palette.grey[100]:t.palette.grey[900];return X({display:"flex",flexDirection:"column",width:"100%",boxSizing:"border-box",flexShrink:0},e.position==="fixed"&&{position:"fixed",zIndex:(t.vars||t).zIndex.appBar,top:0,left:"auto",right:0,"@media print":{position:"absolute"}},e.position==="absolute"&&{position:"absolute",zIndex:(t.vars||t).zIndex.appBar,top:0,left:"auto",right:0},e.position==="sticky"&&{position:"sticky",zIndex:(t.vars||t).zIndex.appBar,top:0,left:"auto",right:0},e.position==="static"&&{position:"static"},e.position==="relative"&&{position:"relative"},!t.vars&&X({},e.color==="default"&&{backgroundColor:n,color:t.palette.getContrastText(n)},e.color&&e.color!=="default"&&e.color!=="inherit"&&e.color!=="transparent"&&{backgroundColor:t.palette[e.color].main,color:t.palette[e.color].contrastText},e.color==="inherit"&&{color:"inherit"},t.palette.mode==="dark"&&!e.enableColorOnDark&&{backgroundColor:null,color:null},e.color==="transparent"&&X({backgroundColor:"transparent",color:"inherit"},t.palette.mode==="dark"&&{backgroundImage:"none"})),t.vars&&X({},e.color==="default"&&{"--AppBar-background":e.enableColorOnDark?t.vars.palette.AppBar.defaultBg:gv(t.vars.palette.AppBar.darkBg,t.vars.palette.AppBar.defaultBg),"--AppBar-color":e.enableColorOnDark?t.vars.palette.text.primary:gv(t.vars.palette.AppBar.darkColor,t.vars.palette.text.primary)},e.color&&!e.color.match(/^(default|inherit|transparent)$/)&&{"--AppBar-background":e.enableColorOnDark?t.vars.palette[e.color].main:gv(t.vars.palette.AppBar.darkBg,t.vars.palette[e.color].main),"--AppBar-color":e.enableColorOnDark?t.vars.palette[e.color].contrastText:gv(t.vars.palette.AppBar.darkColor,t.vars.palette[e.color].contrastText)},{backgroundColor:"var(--AppBar-background)",color:e.color==="inherit"?"inherit":"var(--AppBar-color)"},e.color==="transparent"&&{backgroundImage:"none",backgroundColor:"transparent",color:"inherit"}))}),Tte=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiAppBar"}),{className:i,color:s="primary",enableColorOnDark:o=!1,position:a="fixed"}=r,l=it(r,Cte),c=X({},r,{color:s,position:a,enableColorOnDark:o}),u=Ete(c);return H.jsx(Ate,X({square:!0,component:"header",ownerState:c,elevation:4,className:ct(u.root,i,a==="fixed"&&"mui-fixed"),ref:n},l))}),Mte=Tte;function Rte(t){const{badgeContent:e,invisible:n=!1,max:r=99,showZero:i=!1}=t,s=xU({badgeContent:e,max:r});let o=n;n===!1&&e===0&&!i&&(o=!0);const{badgeContent:a,max:l=r}=o?s:t,c=a&&Number(a)>l?`${l}+`:a;return{badgeContent:a,invisible:o,max:l,displayValue:c}}const Ite=["input","select","textarea","a[href]","button","[tabindex]","audio[controls]","video[controls]",'[contenteditable]:not([contenteditable="false"])'].join(",");function Nte(t){const e=parseInt(t.getAttribute("tabindex")||"",10);return Number.isNaN(e)?t.contentEditable==="true"||(t.nodeName==="AUDIO"||t.nodeName==="VIDEO"||t.nodeName==="DETAILS")&&t.getAttribute("tabindex")===null?0:t.tabIndex:e}function Pte(t){if(t.tagName!=="INPUT"||t.type!=="radio"||!t.name)return!1;const e=r=>t.ownerDocument.querySelector(`input[type="radio"]${r}`);let n=e(`[name="${t.name}"]:checked`);return n||(n=e(`[name="${t.name}"]`)),n!==t}function kte(t){return!(t.disabled||t.tagName==="INPUT"&&t.type==="hidden"||Pte(t))}function Dte(t){const e=[],n=[];return Array.from(t.querySelectorAll(Ite)).forEach((r,i)=>{const s=Nte(r);s===-1||!kte(r)||(s===0?e.push(r):n.push({documentOrder:i,tabIndex:s,node:r}))}),n.sort((r,i)=>r.tabIndex===i.tabIndex?r.documentOrder-i.documentOrder:r.tabIndex-i.tabIndex).map(r=>r.node).concat(e)}function Ote(){return!0}function Lte(t){const{children:e,disableAutoFocus:n=!1,disableEnforceFocus:r=!1,disableRestoreFocus:i=!1,getTabbable:s=Dte,isEnabled:o=Ote,open:a}=t,l=L.useRef(!1),c=L.useRef(null),u=L.useRef(null),d=L.useRef(null),f=L.useRef(null),h=L.useRef(!1),p=L.useRef(null),x=Wr(e.ref,p),v=L.useRef(null);L.useEffect(()=>{!a||!p.current||(h.current=!n)},[n,a]),L.useEffect(()=>{if(!a||!p.current)return;const S=Ts(p.current);return p.current.contains(S.activeElement)||(p.current.hasAttribute("tabIndex")||p.current.setAttribute("tabIndex","-1"),h.current&&p.current.focus()),()=>{i||(d.current&&d.current.focus&&(l.current=!0,d.current.focus()),d.current=null)}},[a]),L.useEffect(()=>{if(!a||!p.current)return;const S=Ts(p.current),w=T=>{v.current=T,!(r||!o()||T.key!=="Tab")&&S.activeElement===p.current&&T.shiftKey&&(l.current=!0,u.current&&u.current.focus())},E=()=>{const T=p.current;if(T===null)return;if(!S.hasFocus()||!o()||l.current){l.current=!1;return}if(T.contains(S.activeElement)||r&&S.activeElement!==c.current&&S.activeElement!==u.current)return;if(S.activeElement!==f.current)f.current=null;else if(f.current!==null)return;if(!h.current)return;let I=[];if((S.activeElement===c.current||S.activeElement===u.current)&&(I=s(p.current)),I.length>0){var N,M;const P=!!((N=v.current)!=null&&N.shiftKey&&((M=v.current)==null?void 0:M.key)==="Tab"),B=I[0],F=I[I.length-1];typeof B!="string"&&typeof F!="string"&&(P?F.focus():B.focus())}else T.focus()};S.addEventListener("focusin",E),S.addEventListener("keydown",w,!0);const A=setInterval(()=>{S.activeElement&&S.activeElement.tagName==="BODY"&&E()},50);return()=>{clearInterval(A),S.removeEventListener("focusin",E),S.removeEventListener("keydown",w,!0)}},[n,r,i,o,a,s]);const y=S=>{d.current===null&&(d.current=S.relatedTarget),h.current=!0,f.current=S.target;const w=e.props.onFocus;w&&w(S)},b=S=>{d.current===null&&(d.current=S.relatedTarget),h.current=!0};return H.jsxs(L.Fragment,{children:[H.jsx("div",{tabIndex:a?0:-1,onFocus:b,ref:c,"data-testid":"sentinelStart"}),L.cloneElement(e,{ref:x,onFocus:y}),H.jsx("div",{tabIndex:a?0:-1,onFocus:b,ref:u,"data-testid":"sentinelEnd"})]})}function Bte(t){return typeof t=="function"?t():t}const Fte=L.forwardRef(function(e,n){const{children:r,container:i,disablePortal:s=!1}=e,[o,a]=L.useState(null),l=Wr(L.isValidElement(r)?r.ref:null,n);if(dd(()=>{s||a(Bte(i)||document.body)},[i,s]),dd(()=>{if(o&&!s)return jA(n,o),()=>{jA(n,null)}},[n,o,s]),s){if(L.isValidElement(r)){const c={ref:l};return L.cloneElement(r,c)}return H.jsx(L.Fragment,{children:r})}return H.jsx(L.Fragment,{children:o&&kM.createPortal(r,o)})});function $te(t){const e=Ts(t);return e.body===t?fd(t).innerWidth>e.documentElement.clientWidth:t.scrollHeight>t.clientHeight}function ng(t,e){e?t.setAttribute("aria-hidden","true"):t.removeAttribute("aria-hidden")}function Gk(t){return parseInt(fd(t).getComputedStyle(t).paddingRight,10)||0}function Ute(t){const n=["TEMPLATE","SCRIPT","STYLE","LINK","MAP","META","NOSCRIPT","PICTURE","COL","COLGROUP","PARAM","SLOT","SOURCE","TRACK"].indexOf(t.tagName)!==-1,r=t.tagName==="INPUT"&&t.getAttribute("type")==="hidden";return n||r}function Hk(t,e,n,r,i){const s=[e,n,...r];[].forEach.call(t.children,o=>{const a=s.indexOf(o)===-1,l=!Ute(o);a&&l&&ng(o,i)})}function aC(t,e){let n=-1;return t.some((r,i)=>e(r)?(n=i,!0):!1),n}function zte(t,e){const n=[],r=t.container;if(!e.disableScrollLock){if($te(r)){const o=vU(Ts(r));n.push({value:r.style.paddingRight,property:"padding-right",el:r}),r.style.paddingRight=`${Gk(r)+o}px`;const a=Ts(r).querySelectorAll(".mui-fixed");[].forEach.call(a,l=>{n.push({value:l.style.paddingRight,property:"padding-right",el:l}),l.style.paddingRight=`${Gk(l)+o}px`})}let s;if(r.parentNode instanceof DocumentFragment)s=Ts(r).body;else{const o=r.parentElement,a=fd(r);s=(o==null?void 0:o.nodeName)==="HTML"&&a.getComputedStyle(o).overflowY==="scroll"?o:r}n.push({value:s.style.overflow,property:"overflow",el:s},{value:s.style.overflowX,property:"overflow-x",el:s},{value:s.style.overflowY,property:"overflow-y",el:s}),s.style.overflow="hidden"}return()=>{n.forEach(({value:s,el:o,property:a})=>{s?o.style.setProperty(a,s):o.style.removeProperty(a)})}}function Gte(t){const e=[];return[].forEach.call(t.children,n=>{n.getAttribute("aria-hidden")==="true"&&e.push(n)}),e}class Hte{constructor(){this.containers=void 0,this.modals=void 0,this.modals=[],this.containers=[]}add(e,n){let r=this.modals.indexOf(e);if(r!==-1)return r;r=this.modals.length,this.modals.push(e),e.modalRef&&ng(e.modalRef,!1);const i=Gte(n);Hk(n,e.mount,e.modalRef,i,!0);const s=aC(this.containers,o=>o.container===n);return s!==-1?(this.containers[s].modals.push(e),r):(this.containers.push({modals:[e],container:n,restore:null,hiddenSiblings:i}),r)}mount(e,n){const r=aC(this.containers,s=>s.modals.indexOf(e)!==-1),i=this.containers[r];i.restore||(i.restore=zte(i,n))}remove(e,n=!0){const r=this.modals.indexOf(e);if(r===-1)return r;const i=aC(this.containers,o=>o.modals.indexOf(e)!==-1),s=this.containers[i];if(s.modals.splice(s.modals.indexOf(e),1),this.modals.splice(r,1),s.modals.length===0)s.restore&&s.restore(),e.modalRef&&ng(e.modalRef,n),Hk(s.container,e.mount,e.modalRef,s.hiddenSiblings,!1),this.containers.splice(i,1);else{const o=s.modals[s.modals.length-1];o.modalRef&&ng(o.modalRef,!1)}return r}isTopModal(e){return this.modals.length>0&&this.modals[this.modals.length-1]===e}}function Vte(t){return typeof t=="function"?t():t}function Wte(t){return t?t.props.hasOwnProperty("in"):!1}const jte=new Hte;function Xte(t){const{container:e,disableEscapeKeyDown:n=!1,disableScrollLock:r=!1,manager:i=jte,closeAfterTransition:s=!1,onTransitionEnter:o,onTransitionExited:a,children:l,onClose:c,open:u,rootRef:d}=t,f=L.useRef({}),h=L.useRef(null),p=L.useRef(null),x=Wr(p,d),[v,y]=L.useState(!u),b=Wte(l);let S=!0;(t["aria-hidden"]==="false"||t["aria-hidden"]===!1)&&(S=!1);const w=()=>Ts(h.current),E=()=>(f.current.modalRef=p.current,f.current.mount=h.current,f.current),A=()=>{i.mount(E(),{disableScrollLock:r}),p.current&&(p.current.scrollTop=0)},T=ih(()=>{const Z=Vte(e)||w().body;i.add(E(),Z),p.current&&A()}),I=L.useCallback(()=>i.isTopModal(E()),[i]),N=ih(Z=>{h.current=Z,Z&&(u&&I()?A():p.current&&ng(p.current,S))}),M=L.useCallback(()=>{i.remove(E(),S)},[S,i]);L.useEffect(()=>()=>{M()},[M]),L.useEffect(()=>{u?T():(!b||!s)&&M()},[u,M,b,s,T]);const P=Z=>ne=>{var O;(O=Z.onKeyDown)==null||O.call(Z,ne),!(ne.key!=="Escape"||ne.which===229||!I())&&(n||(ne.stopPropagation(),c&&c(ne,"escapeKeyDown")))},B=Z=>ne=>{var O;(O=Z.onClick)==null||O.call(Z,ne),ne.target===ne.currentTarget&&c&&c(ne,"backdropClick")};return{getRootProps:(Z={})=>{const ne=UU(t);delete ne.onTransitionEnter,delete ne.onTransitionExited;const O=X({},ne,Z);return X({role:"presentation"},O,{onKeyDown:P(O),ref:x})},getBackdropProps:(Z={})=>{const ne=Z;return X({"aria-hidden":!0},ne,{onClick:B(ne),open:u})},getTransitionProps:()=>{const Z=()=>{y(!1),o&&o()},ne=()=>{y(!0),a&&a(),s&&M()};return{onEnter:xk(Z,l==null?void 0:l.props.onEnter),onExited:xk(ne,l==null?void 0:l.props.onExited)}},rootRef:x,portalRef:N,isTopModal:I,exited:v,hasTransition:b}}const Kte=["onChange","maxRows","minRows","style","value"];function yv(t){return parseInt(t,10)||0}const qte={shadow:{visibility:"hidden",position:"absolute",overflow:"hidden",height:0,top:0,left:0,transform:"translateZ(0)"}};function Jte(t){return t==null||Object.keys(t).length===0||t.outerHeightStyle===0&&!t.overflowing}const Yte=L.forwardRef(function(e,n){const{onChange:r,maxRows:i,minRows:s=1,style:o,value:a}=e,l=it(e,Kte),{current:c}=L.useRef(a!=null),u=L.useRef(null),d=Wr(n,u),f=L.useRef(null),h=L.useCallback(()=>{const v=u.current,b=fd(v).getComputedStyle(v);if(b.width==="0px")return{outerHeightStyle:0,overflowing:!1};const S=f.current;S.style.width=b.width,S.value=v.value||e.placeholder||"x",S.value.slice(-1)===`
`&&(S.value+=" ");const w=b.boxSizing,E=yv(b.paddingBottom)+yv(b.paddingTop),A=yv(b.borderBottomWidth)+yv(b.borderTopWidth),T=S.scrollHeight;S.value="x";const I=S.scrollHeight;let N=T;s&&(N=Math.max(Number(s)*I,N)),i&&(N=Math.min(Number(i)*I,N)),N=Math.max(N,I);const M=N+(w==="border-box"?E+A:0),P=Math.abs(N-T)<=1;return{outerHeightStyle:M,overflowing:P}},[i,s,e.placeholder]),p=L.useCallback(()=>{const v=h();if(Jte(v))return;const y=u.current;y.style.height=`${v.outerHeightStyle}px`,y.style.overflow=v.overflowing?"hidden":""},[h]);dd(()=>{const v=()=>{p()};let y;const b=mU(v),S=u.current,w=fd(S);w.addEventListener("resize",b);let E;return typeof ResizeObserver<"u"&&(E=new ResizeObserver(v),E.observe(S)),()=>{b.clear(),cancelAnimationFrame(y),w.removeEventListener("resize",b),E&&E.disconnect()}},[h,p]),dd(()=>{p()});const x=v=>{c||p(),r&&r(v)};return H.jsxs(L.Fragment,{children:[H.jsx("textarea",X({value:a,onChange:x,ref:d,rows:s,style:o},l)),H.jsx("textarea",{"aria-hidden":!0,className:e.className,readOnly:!0,ref:f,tabIndex:-1,style:X({},qte.shadow,o,{paddingTop:0,paddingBottom:0})})]})}),Qte=Os(H.jsx("path",{d:"M12 2C6.47 2 2 6.47 2 12s4.47 10 10 10 10-4.47 10-10S17.53 2 12 2zm5 13.59L15.59 17 12 13.41 8.41 17 7 15.59 10.59 12 7 8.41 8.41 7 12 10.59 15.59 7 17 8.41 13.41 12 17 15.59z"}),"Cancel");function Zte(t){return kt("MuiChip",t)}const ene=Bt("MuiChip",["root","sizeSmall","sizeMedium","colorError","colorInfo","colorPrimary","colorSecondary","colorSuccess","colorWarning","disabled","clickable","clickableColorPrimary","clickableColorSecondary","deletable","deletableColorPrimary","deletableColorSecondary","outlined","filled","outlinedPrimary","outlinedSecondary","filledPrimary","filledSecondary","avatar","avatarSmall","avatarMedium","avatarColorPrimary","avatarColorSecondary","icon","iconSmall","iconMedium","iconColorPrimary","iconColorSecondary","label","labelSmall","labelMedium","deleteIcon","deleteIconSmall","deleteIconMedium","deleteIconColorPrimary","deleteIconColorSecondary","deleteIconOutlinedColorPrimary","deleteIconOutlinedColorSecondary","deleteIconFilledColorPrimary","deleteIconFilledColorSecondary","focusVisible"]),ln=ene,tne=["avatar","className","clickable","color","component","deleteIcon","disabled","icon","label","onClick","onDelete","onKeyDown","onKeyUp","size","variant","tabIndex","skipFocusWhenDisabled"],nne=t=>{const{classes:e,disabled:n,size:r,color:i,iconColor:s,onDelete:o,clickable:a,variant:l}=t,c={root:["root",l,n&&"disabled",`size${Le(r)}`,`color${Le(i)}`,a&&"clickable",a&&`clickableColor${Le(i)}`,o&&"deletable",o&&`deletableColor${Le(i)}`,`${l}${Le(i)}`],label:["label",`label${Le(r)}`],avatar:["avatar",`avatar${Le(r)}`,`avatarColor${Le(i)}`],icon:["icon",`icon${Le(r)}`,`iconColor${Le(s)}`],deleteIcon:["deleteIcon",`deleteIcon${Le(r)}`,`deleteIconColor${Le(i)}`,`deleteIcon${Le(l)}Color${Le(i)}`]};return Ft(c,Zte,e)},rne=Ke("div",{name:"MuiChip",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t,{color:r,iconColor:i,clickable:s,onDelete:o,size:a,variant:l}=n;return[{[`& .${ln.avatar}`]:e.avatar},{[`& .${ln.avatar}`]:e[`avatar${Le(a)}`]},{[`& .${ln.avatar}`]:e[`avatarColor${Le(r)}`]},{[`& .${ln.icon}`]:e.icon},{[`& .${ln.icon}`]:e[`icon${Le(a)}`]},{[`& .${ln.icon}`]:e[`iconColor${Le(i)}`]},{[`& .${ln.deleteIcon}`]:e.deleteIcon},{[`& .${ln.deleteIcon}`]:e[`deleteIcon${Le(a)}`]},{[`& .${ln.deleteIcon}`]:e[`deleteIconColor${Le(r)}`]},{[`& .${ln.deleteIcon}`]:e[`deleteIcon${Le(l)}Color${Le(r)}`]},e.root,e[`size${Le(a)}`],e[`color${Le(r)}`],s&&e.clickable,s&&r!=="default"&&e[`clickableColor${Le(r)})`],o&&e.deletable,o&&r!=="default"&&e[`deletableColor${Le(r)}`],e[l],e[`${l}${Le(r)}`]]}})(({theme:t,ownerState:e})=>{const n=t.palette.mode==="light"?t.palette.grey[700]:t.palette.grey[300];return X({maxWidth:"100%",fontFamily:t.typography.fontFamily,fontSize:t.typography.pxToRem(13),display:"inline-flex",alignItems:"center",justifyContent:"center",height:32,color:(t.vars||t).palette.text.primary,backgroundColor:(t.vars||t).palette.action.selected,borderRadius:32/2,whiteSpace:"nowrap",transition:t.transitions.create(["background-color","box-shadow"]),cursor:"unset",outline:0,textDecoration:"none",border:0,padding:0,verticalAlign:"middle",boxSizing:"border-box",[`&.${ln.disabled}`]:{opacity:(t.vars||t).palette.action.disabledOpacity,pointerEvents:"none"},[`& .${ln.avatar}`]:{marginLeft:5,marginRight:-6,width:24,height:24,color:t.vars?t.vars.palette.Chip.defaultAvatarColor:n,fontSize:t.typography.pxToRem(12)},[`& .${ln.avatarColorPrimary}`]:{color:(t.vars||t).palette.primary.contrastText,backgroundColor:(t.vars||t).palette.primary.dark},[`& .${ln.avatarColorSecondary}`]:{color:(t.vars||t).palette.secondary.contrastText,backgroundColor:(t.vars||t).palette.secondary.dark},[`& .${ln.avatarSmall}`]:{marginLeft:4,marginRight:-4,width:18,height:18,fontSize:t.typography.pxToRem(10)},[`& .${ln.icon}`]:X({marginLeft:5,marginRight:-6},e.size==="small"&&{fontSize:18,marginLeft:4,marginRight:-4},e.iconColor===e.color&&X({color:t.vars?t.vars.palette.Chip.defaultIconColor:n},e.color!=="default"&&{color:"inherit"})),[`& .${ln.deleteIcon}`]:X({WebkitTapHighlightColor:"transparent",color:t.vars?`rgba(${t.vars.palette.text.primaryChannel} / 0.26)`:Tr(t.palette.text.primary,.26),fontSize:22,cursor:"pointer",margin:"0 5px 0 -6px","&:hover":{color:t.vars?`rgba(${t.vars.palette.text.primaryChannel} / 0.4)`:Tr(t.palette.text.primary,.4)}},e.size==="small"&&{fontSize:16,marginRight:4,marginLeft:-4},e.color!=="default"&&{color:t.vars?`rgba(${t.vars.palette[e.color].contrastTextChannel} / 0.7)`:Tr(t.palette[e.color].contrastText,.7),"&:hover, &:active":{color:(t.vars||t).palette[e.color].contrastText}})},e.size==="small"&&{height:24},e.color!=="default"&&{backgroundColor:(t.vars||t).palette[e.color].main,color:(t.vars||t).palette[e.color].contrastText},e.onDelete&&{[`&.${ln.focusVisible}`]:{backgroundColor:t.vars?`rgba(${t.vars.palette.action.selectedChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.focusOpacity}))`:Tr(t.palette.action.selected,t.palette.action.selectedOpacity+t.palette.action.focusOpacity)}},e.onDelete&&e.color!=="default"&&{[`&.${ln.focusVisible}`]:{backgroundColor:(t.vars||t).palette[e.color].dark}})},({theme:t,ownerState:e})=>X({},e.clickable&&{userSelect:"none",WebkitTapHighlightColor:"transparent",cursor:"pointer","&:hover":{backgroundColor:t.vars?`rgba(${t.vars.palette.action.selectedChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.hoverOpacity}))`:Tr(t.palette.action.selected,t.palette.action.selectedOpacity+t.palette.action.hoverOpacity)},[`&.${ln.focusVisible}`]:{backgroundColor:t.vars?`rgba(${t.vars.palette.action.selectedChannel} / calc(${t.vars.palette.action.selectedOpacity} + ${t.vars.palette.action.focusOpacity}))`:Tr(t.palette.action.selected,t.palette.action.selectedOpacity+t.palette.action.focusOpacity)},"&:active":{boxShadow:(t.vars||t).shadows[1]}},e.clickable&&e.color!=="default"&&{[`&:hover, &.${ln.focusVisible}`]:{backgroundColor:(t.vars||t).palette[e.color].dark}}),({theme:t,ownerState:e})=>X({},e.variant==="outlined"&&{backgroundColor:"transparent",border:t.vars?`1px solid ${t.vars.palette.Chip.defaultBorder}`:`1px solid ${t.palette.mode==="light"?t.palette.grey[400]:t.palette.grey[700]}`,[`&.${ln.clickable}:hover`]:{backgroundColor:(t.vars||t).palette.action.hover},[`&.${ln.focusVisible}`]:{backgroundColor:(t.vars||t).palette.action.focus},[`& .${ln.avatar}`]:{marginLeft:4},[`& .${ln.avatarSmall}`]:{marginLeft:2},[`& .${ln.icon}`]:{marginLeft:4},[`& .${ln.iconSmall}`]:{marginLeft:2},[`& .${ln.deleteIcon}`]:{marginRight:5},[`& .${ln.deleteIconSmall}`]:{marginRight:3}},e.variant==="outlined"&&e.color!=="default"&&{color:(t.vars||t).palette[e.color].main,border:`1px solid ${t.vars?`rgba(${t.vars.palette[e.color].mainChannel} / 0.7)`:Tr(t.palette[e.color].main,.7)}`,[`&.${ln.clickable}:hover`]:{backgroundColor:t.vars?`rgba(${t.vars.palette[e.color].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:Tr(t.palette[e.color].main,t.palette.action.hoverOpacity)},[`&.${ln.focusVisible}`]:{backgroundColor:t.vars?`rgba(${t.vars.palette[e.color].mainChannel} / ${t.vars.palette.action.focusOpacity})`:Tr(t.palette[e.color].main,t.palette.action.focusOpacity)},[`& .${ln.deleteIcon}`]:{color:t.vars?`rgba(${t.vars.palette[e.color].mainChannel} / 0.7)`:Tr(t.palette[e.color].main,.7),"&:hover, &:active":{color:(t.vars||t).palette[e.color].main}}})),ine=Ke("span",{name:"MuiChip",slot:"Label",overridesResolver:(t,e)=>{const{ownerState:n}=t,{size:r}=n;return[e.label,e[`label${Le(r)}`]]}})(({ownerState:t})=>X({overflow:"hidden",textOverflow:"ellipsis",paddingLeft:12,paddingRight:12,whiteSpace:"nowrap"},t.variant==="outlined"&&{paddingLeft:11,paddingRight:11},t.size==="small"&&{paddingLeft:8,paddingRight:8},t.size==="small"&&t.variant==="outlined"&&{paddingLeft:7,paddingRight:7}));function Vk(t){return t.key==="Backspace"||t.key==="Delete"}const sne=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiChip"}),{avatar:i,className:s,clickable:o,color:a="default",component:l,deleteIcon:c,disabled:u=!1,icon:d,label:f,onClick:h,onDelete:p,onKeyDown:x,onKeyUp:v,size:y="medium",variant:b="filled",tabIndex:S,skipFocusWhenDisabled:w=!1}=r,E=it(r,tne),A=L.useRef(null),T=Wr(A,n),I=G=>{G.stopPropagation(),p&&p(G)},N=G=>{G.currentTarget===G.target&&Vk(G)&&G.preventDefault(),x&&x(G)},M=G=>{G.currentTarget===G.target&&(p&&Vk(G)?p(G):G.key==="Escape"&&A.current&&A.current.blur()),v&&v(G)},P=o!==!1&&h?!0:o,B=P||p?hd:l||"div",F=X({},r,{component:B,disabled:u,size:y,color:a,iconColor:L.isValidElement(d)&&d.props.color||a,onDelete:!!p,clickable:P,variant:b}),U=nne(F),j=B===hd?X({component:l||"div",focusVisibleClassName:U.focusVisible},p&&{disableRipple:!0}):{};let Z=null;p&&(Z=c&&L.isValidElement(c)?L.cloneElement(c,{className:ct(c.props.className,U.deleteIcon),onClick:I}):H.jsx(Qte,{className:ct(U.deleteIcon),onClick:I}));let ne=null;i&&L.isValidElement(i)&&(ne=L.cloneElement(i,{className:ct(U.avatar,i.props.className)}));let O=null;return d&&L.isValidElement(d)&&(O=L.cloneElement(d,{className:ct(U.icon,d.props.className)})),H.jsxs(rne,X({as:B,className:ct(U.root,s),disabled:P&&u?!0:void 0,onClick:h,onKeyDown:N,onKeyUp:M,ref:T,tabIndex:w&&u?-1:S,ownerState:F},j,E,{children:[ne||O,H.jsx(ine,{className:ct(U.label),ownerState:F,children:f}),Z]}))}),HU=sne;function mp({props:t,states:e,muiFormControl:n}){return e.reduce((r,i)=>(r[i]=t[i],n&&typeof t[i]>"u"&&(r[i]=n[i]),r),{})}const one=L.createContext(void 0),vS=one;function Id(){return L.useContext(vS)}function ane(t){return H.jsx(KY,X({},t,{defaultTheme:sS,themeId:g0}))}function Wk(t){return t!=null&&!(Array.isArray(t)&&t.length===0)}function F1(t,e=!1){return t&&(Wk(t.value)&&t.value!==""||e&&Wk(t.defaultValue)&&t.defaultValue!=="")}function lne(t){return t.startAdornment}function cne(t){return kt("MuiInputBase",t)}const une=Bt("MuiInputBase",["root","formControl","focused","disabled","adornedStart","adornedEnd","error","sizeSmall","multiline","colorSecondary","fullWidth","hiddenLabel","readOnly","input","inputSizeSmall","inputMultiline","inputTypeSearch","inputAdornedStart","inputAdornedEnd","inputHiddenLabel"]),Fh=une,dne=["aria-describedby","autoComplete","autoFocus","className","color","components","componentsProps","defaultValue","disabled","disableInjectingGlobalStyles","endAdornment","error","fullWidth","id","inputComponent","inputProps","inputRef","margin","maxRows","minRows","multiline","name","onBlur","onChange","onClick","onFocus","onKeyDown","onKeyUp","placeholder","readOnly","renderSuffix","rows","size","slotProps","slots","startAdornment","type","value"],xS=(t,e)=>{const{ownerState:n}=t;return[e.root,n.formControl&&e.formControl,n.startAdornment&&e.adornedStart,n.endAdornment&&e.adornedEnd,n.error&&e.error,n.size==="small"&&e.sizeSmall,n.multiline&&e.multiline,n.color&&e[`color${Le(n.color)}`],n.fullWidth&&e.fullWidth,n.hiddenLabel&&e.hiddenLabel]},bS=(t,e)=>{const{ownerState:n}=t;return[e.input,n.size==="small"&&e.inputSizeSmall,n.multiline&&e.inputMultiline,n.type==="search"&&e.inputTypeSearch,n.startAdornment&&e.inputAdornedStart,n.endAdornment&&e.inputAdornedEnd,n.hiddenLabel&&e.inputHiddenLabel]},fne=t=>{const{classes:e,color:n,disabled:r,error:i,endAdornment:s,focused:o,formControl:a,fullWidth:l,hiddenLabel:c,multiline:u,readOnly:d,size:f,startAdornment:h,type:p}=t,x={root:["root",`color${Le(n)}`,r&&"disabled",i&&"error",l&&"fullWidth",o&&"focused",a&&"formControl",f&&f!=="medium"&&`size${Le(f)}`,u&&"multiline",h&&"adornedStart",s&&"adornedEnd",c&&"hiddenLabel",d&&"readOnly"],input:["input",r&&"disabled",p==="search"&&"inputTypeSearch",u&&"inputMultiline",f==="small"&&"inputSizeSmall",c&&"inputHiddenLabel",h&&"inputAdornedStart",s&&"inputAdornedEnd",d&&"readOnly"]};return Ft(x,cne,e)},SS=Ke("div",{name:"MuiInputBase",slot:"Root",overridesResolver:xS})(({theme:t,ownerState:e})=>X({},t.typography.body1,{color:(t.vars||t).palette.text.primary,lineHeight:"1.4375em",boxSizing:"border-box",position:"relative",cursor:"text",display:"inline-flex",alignItems:"center",[`&.${Fh.disabled}`]:{color:(t.vars||t).palette.text.disabled,cursor:"default"}},e.multiline&&X({padding:"4px 0 5px"},e.size==="small"&&{paddingTop:1}),e.fullWidth&&{width:"100%"})),_S=Ke("input",{name:"MuiInputBase",slot:"Input",overridesResolver:bS})(({theme:t,ownerState:e})=>{const n=t.palette.mode==="light",r=X({color:"currentColor"},t.vars?{opacity:t.vars.opacity.inputPlaceholder}:{opacity:n?.42:.5},{transition:t.transitions.create("opacity",{duration:t.transitions.duration.shorter})}),i={opacity:"0 !important"},s=t.vars?{opacity:t.vars.opacity.inputPlaceholder}:{opacity:n?.42:.5};return X({font:"inherit",letterSpacing:"inherit",color:"currentColor",padding:"4px 0 5px",border:0,boxSizing:"content-box",background:"none",height:"1.4375em",margin:0,WebkitTapHighlightColor:"transparent",display:"block",minWidth:0,width:"100%",animationName:"mui-auto-fill-cancel",animationDuration:"10ms","&::-webkit-input-placeholder":r,"&::-moz-placeholder":r,"&:-ms-input-placeholder":r,"&::-ms-input-placeholder":r,"&:focus":{outline:0},"&:invalid":{boxShadow:"none"},"&::-webkit-search-decoration":{WebkitAppearance:"none"},[`label[data-shrink=false] + .${Fh.formControl} &`]:{"&::-webkit-input-placeholder":i,"&::-moz-placeholder":i,"&:-ms-input-placeholder":i,"&::-ms-input-placeholder":i,"&:focus::-webkit-input-placeholder":s,"&:focus::-moz-placeholder":s,"&:focus:-ms-input-placeholder":s,"&:focus::-ms-input-placeholder":s},[`&.${Fh.disabled}`]:{opacity:1,WebkitTextFillColor:(t.vars||t).palette.text.disabled},"&:-webkit-autofill":{animationDuration:"5000s",animationName:"mui-auto-fill"}},e.size==="small"&&{paddingTop:1},e.multiline&&{height:"auto",resize:"none",padding:0,paddingTop:0},e.type==="search"&&{MozAppearance:"textfield"})}),hne=H.jsx(ane,{styles:{"@keyframes mui-auto-fill":{from:{display:"block"}},"@keyframes mui-auto-fill-cancel":{from:{display:"block"}}}}),pne=L.forwardRef(function(e,n){var r;const i=Vt({props:e,name:"MuiInputBase"}),{"aria-describedby":s,autoComplete:o,autoFocus:a,className:l,components:c={},componentsProps:u={},defaultValue:d,disabled:f,disableInjectingGlobalStyles:h,endAdornment:p,fullWidth:x=!1,id:v,inputComponent:y="input",inputProps:b={},inputRef:S,maxRows:w,minRows:E,multiline:A=!1,name:T,onBlur:I,onChange:N,onClick:M,onFocus:P,onKeyDown:B,onKeyUp:F,placeholder:U,readOnly:j,renderSuffix:Z,rows:ne,slotProps:O={},slots:G={},startAdornment:q,type:se="text",value:he}=i,ke=it(i,dne),re=b.value!=null?b.value:he,{current:pe}=L.useRef(re!=null),fe=L.useRef(),Ee=L.useCallback(Fe=>{},[]),We=Wr(fe,S,b.ref,Ee),[je,Je]=L.useState(!1),te=Id(),be=mp({props:i,muiFormControl:te,states:["color","disabled","error","hiddenLabel","size","required","filled"]});be.focused=te?te.focused:je,L.useEffect(()=>{!te&&f&&je&&(Je(!1),I&&I())},[te,f,je,I]);const ce=te&&te.onFilled,Me=te&&te.onEmpty,Ie=L.useCallback(Fe=>{F1(Fe)?ce&&ce():Me&&Me()},[ce,Me]);dd(()=>{pe&&Ie({value:re})},[re,Ie,pe]);const Oe=Fe=>{if(be.disabled){Fe.stopPropagation();return}P&&P(Fe),b.onFocus&&b.onFocus(Fe),te&&te.onFocus?te.onFocus(Fe):Je(!0)},V=Fe=>{I&&I(Fe),b.onBlur&&b.onBlur(Fe),te&&te.onBlur?te.onBlur(Fe):Je(!1)},$=(Fe,...$e)=>{if(!pe){const Ze=Fe.target||fe.current;if(Ze==null)throw new Error(cd(1));Ie({value:Ze.value})}b.onChange&&b.onChange(Fe,...$e),N&&N(Fe,...$e)};L.useEffect(()=>{Ie(fe.current)},[]);const ue=Fe=>{fe.current&&Fe.currentTarget===Fe.target&&fe.current.focus(),M&&M(Fe)};let ye=y,ve=b;A&&ye==="input"&&(ne?ve=X({type:void 0,minRows:ne,maxRows:ne},ve):ve=X({type:void 0,maxRows:w,minRows:E},ve),ye=Yte);const Ne=Fe=>{Ie(Fe.animationName==="mui-auto-fill-cancel"?fe.current:{value:"x"})};L.useEffect(()=>{te&&te.setAdornedStart(!!q)},[te,q]);const nt=X({},i,{color:be.color||"primary",disabled:be.disabled,endAdornment:p,error:be.error,focused:be.focused,formControl:te,fullWidth:x,hiddenLabel:be.hiddenLabel,multiline:A,size:be.size,startAdornment:q,type:se}),Ae=fne(nt),st=G.root||c.Root||SS,ht=O.root||u.root||{},Ue=G.input||c.Input||_S;return ve=X({},ve,(r=O.input)!=null?r:u.input),H.jsxs(L.Fragment,{children:[!h&&hne,H.jsxs(st,X({},ht,!B1(st)&&{ownerState:X({},nt,ht.ownerState)},{ref:n,onClick:ue},ke,{className:ct(Ae.root,ht.className,l,j&&"MuiInputBase-readOnly"),children:[q,H.jsx(vS.Provider,{value:null,children:H.jsx(Ue,X({ownerState:nt,"aria-invalid":be.error,"aria-describedby":s,autoComplete:o,autoFocus:a,defaultValue:d,disabled:be.disabled,id:v,onAnimationStart:Ne,name:T,placeholder:U,readOnly:j,required:be.required,rows:ne,value:re,onKeyDown:B,onKeyUp:F,type:se},ve,!B1(Ue)&&{as:ye,ownerState:X({},nt,ve.ownerState)},{ref:We,className:ct(Ae.input,ve.className,j&&"MuiInputBase-readOnly"),onBlur:V,onChange:$,onFocus:Oe}))}),p,Z?Z(X({},be,{startAdornment:q})):null]}))]})}),uR=pne;function mne(t){return kt("MuiInput",t)}const gne=X({},Fh,Bt("MuiInput",["root","underline","input"])),lm=gne;function yne(t){return kt("MuiOutlinedInput",t)}const vne=X({},Fh,Bt("MuiOutlinedInput",["root","notchedOutline","input"])),Hl=vne;function xne(t){return kt("MuiFilledInput",t)}const bne=X({},Fh,Bt("MuiFilledInput",["root","underline","input"])),eu=bne,Sne=Os(H.jsx("path",{d:"M7 10l5 5 5-5z"}),"ArrowDropDown"),_ne=["addEndListener","appear","children","easing","in","onEnter","onEntered","onEntering","onExit","onExited","onExiting","style","timeout","TransitionComponent"],wne={entering:{opacity:1},entered:{opacity:1}},Cne=L.forwardRef(function(e,n){const r=_0(),i={enter:r.transitions.duration.enteringScreen,exit:r.transitions.duration.leavingScreen},{addEndListener:s,appear:o=!0,children:a,easing:l,in:c,onEnter:u,onEntered:d,onEntering:f,onExit:h,onExited:p,onExiting:x,style:v,timeout:y=i,TransitionComponent:b=oR}=e,S=it(e,_ne),w=L.useRef(null),E=Wr(w,a.ref,n),A=U=>j=>{if(U){const Z=w.current;j===void 0?U(Z):U(Z,j)}},T=A(f),I=A((U,j)=>{LU(U);const Z=Bh({style:v,timeout:y,easing:l},{mode:"enter"});U.style.webkitTransition=r.transitions.create("opacity",Z),U.style.transition=r.transitions.create("opacity",Z),u&&u(U,j)}),N=A(d),M=A(x),P=A(U=>{const j=Bh({style:v,timeout:y,easing:l},{mode:"exit"});U.style.webkitTransition=r.transitions.create("opacity",j),U.style.transition=r.transitions.create("opacity",j),h&&h(U)}),B=A(p),F=U=>{s&&s(w.current,U)};return H.jsx(b,X({appear:o,in:c,nodeRef:w,onEnter:I,onEntered:N,onEntering:T,onExit:P,onExited:B,onExiting:M,addEndListener:F,timeout:y},S,{children:(U,j)=>L.cloneElement(a,X({style:X({opacity:0,visibility:U==="exited"&&!c?"hidden":void 0},wne[U],v,a.props.style),ref:E},j))}))}),Ene=Cne;function Ane(t){return kt("MuiBackdrop",t)}Bt("MuiBackdrop",["root","invisible"]);const Tne=["children","className","component","components","componentsProps","invisible","open","slotProps","slots","TransitionComponent","transitionDuration"],Mne=t=>{const{classes:e,invisible:n}=t;return Ft({root:["root",n&&"invisible"]},Ane,e)},Rne=Ke("div",{name:"MuiBackdrop",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,n.invisible&&e.invisible]}})(({ownerState:t})=>X({position:"fixed",display:"flex",alignItems:"center",justifyContent:"center",right:0,bottom:0,top:0,left:0,backgroundColor:"rgba(0, 0, 0, 0.5)",WebkitTapHighlightColor:"transparent"},t.invisible&&{backgroundColor:"transparent"})),Ine=L.forwardRef(function(e,n){var r,i,s;const o=Vt({props:e,name:"MuiBackdrop"}),{children:a,className:l,component:c="div",components:u={},componentsProps:d={},invisible:f=!1,open:h,slotProps:p={},slots:x={},TransitionComponent:v=Ene,transitionDuration:y}=o,b=it(o,Tne),S=X({},o,{component:c,invisible:f}),w=Mne(S),E=(r=p.root)!=null?r:d.root;return H.jsx(v,X({in:h,timeout:y},b,{children:H.jsx(Rne,X({"aria-hidden":!0},E,{as:(i=(s=x.root)!=null?s:u.Root)!=null?i:c,className:ct(w.root,l,E==null?void 0:E.className),ownerState:X({},S,E==null?void 0:E.ownerState),classes:w,ref:n,children:a}))}))}),Nne=Ine;function Pne(t){return kt("MuiBadge",t)}const kne=Bt("MuiBadge",["root","badge","dot","standard","anchorOriginTopRight","anchorOriginBottomRight","anchorOriginTopLeft","anchorOriginBottomLeft","invisible","colorError","colorInfo","colorPrimary","colorSecondary","colorSuccess","colorWarning","overlapRectangular","overlapCircular","anchorOriginTopLeftCircular","anchorOriginTopLeftRectangular","anchorOriginTopRightCircular","anchorOriginTopRightRectangular","anchorOriginBottomLeftCircular","anchorOriginBottomLeftRectangular","anchorOriginBottomRightCircular","anchorOriginBottomRightRectangular"]),Vl=kne,Dne=["anchorOrigin","className","classes","component","components","componentsProps","children","overlap","color","invisible","max","badgeContent","slots","slotProps","showZero","variant"],lC=10,cC=4,One=gS(),Lne=t=>{const{color:e,anchorOrigin:n,invisible:r,overlap:i,variant:s,classes:o={}}=t,a={root:["root"],badge:["badge",s,r&&"invisible",`anchorOrigin${Le(n.vertical)}${Le(n.horizontal)}`,`anchorOrigin${Le(n.vertical)}${Le(n.horizontal)}${Le(i)}`,`overlap${Le(i)}`,e!=="default"&&`color${Le(e)}`]};return Ft(a,Pne,o)},Bne=Ke("span",{name:"MuiBadge",slot:"Root",overridesResolver:(t,e)=>e.root})({position:"relative",display:"inline-flex",verticalAlign:"middle",flexShrink:0}),Fne=Ke("span",{name:"MuiBadge",slot:"Badge",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.badge,e[n.variant],e[`anchorOrigin${Le(n.anchorOrigin.vertical)}${Le(n.anchorOrigin.horizontal)}${Le(n.overlap)}`],n.color!=="default"&&e[`color${Le(n.color)}`],n.invisible&&e.invisible]}})(({theme:t})=>{var e;return{display:"flex",flexDirection:"row",flexWrap:"wrap",justifyContent:"center",alignContent:"center",alignItems:"center",position:"absolute",boxSizing:"border-box",fontFamily:t.typography.fontFamily,fontWeight:t.typography.fontWeightMedium,fontSize:t.typography.pxToRem(12),minWidth:lC*2,lineHeight:1,padding:"0 6px",height:lC*2,borderRadius:lC,zIndex:1,transition:t.transitions.create("transform",{easing:t.transitions.easing.easeInOut,duration:t.transitions.duration.enteringScreen}),variants:[...Object.keys(((e=t.vars)!=null?e:t).palette).filter(n=>{var r,i;return((r=t.vars)!=null?r:t).palette[n].main&&((i=t.vars)!=null?i:t).palette[n].contrastText}).map(n=>({props:{color:n},style:{backgroundColor:(t.vars||t).palette[n].main,color:(t.vars||t).palette[n].contrastText}})),{props:{variant:"dot"},style:{borderRadius:cC,height:cC*2,minWidth:cC*2,padding:0}},{props:({ownerState:n})=>n.anchorOrigin.vertical==="top"&&n.anchorOrigin.horizontal==="right"&&n.overlap==="rectangular",style:{top:0,right:0,transform:"scale(1) translate(50%, -50%)",transformOrigin:"100% 0%",[`&.${Vl.invisible}`]:{transform:"scale(0) translate(50%, -50%)"}}},{props:({ownerState:n})=>n.anchorOrigin.vertical==="bottom"&&n.anchorOrigin.horizontal==="right"&&n.overlap==="rectangular",style:{bottom:0,right:0,transform:"scale(1) translate(50%, 50%)",transformOrigin:"100% 100%",[`&.${Vl.invisible}`]:{transform:"scale(0) translate(50%, 50%)"}}},{props:({ownerState:n})=>n.anchorOrigin.vertical==="top"&&n.anchorOrigin.horizontal==="left"&&n.overlap==="rectangular",style:{top:0,left:0,transform:"scale(1) translate(-50%, -50%)",transformOrigin:"0% 0%",[`&.${Vl.invisible}`]:{transform:"scale(0) translate(-50%, -50%)"}}},{props:({ownerState:n})=>n.anchorOrigin.vertical==="bottom"&&n.anchorOrigin.horizontal==="left"&&n.overlap==="rectangular",style:{bottom:0,left:0,transform:"scale(1) translate(-50%, 50%)",transformOrigin:"0% 100%",[`&.${Vl.invisible}`]:{transform:"scale(0) translate(-50%, 50%)"}}},{props:({ownerState:n})=>n.anchorOrigin.vertical==="top"&&n.anchorOrigin.horizontal==="right"&&n.overlap==="circular",style:{top:"14%",right:"14%",transform:"scale(1) translate(50%, -50%)",transformOrigin:"100% 0%",[`&.${Vl.invisible}`]:{transform:"scale(0) translate(50%, -50%)"}}},{props:({ownerState:n})=>n.anchorOrigin.vertical==="bottom"&&n.anchorOrigin.horizontal==="right"&&n.overlap==="circular",style:{bottom:"14%",right:"14%",transform:"scale(1) translate(50%, 50%)",transformOrigin:"100% 100%",[`&.${Vl.invisible}`]:{transform:"scale(0) translate(50%, 50%)"}}},{props:({ownerState:n})=>n.anchorOrigin.vertical==="top"&&n.anchorOrigin.horizontal==="left"&&n.overlap==="circular",style:{top:"14%",left:"14%",transform:"scale(1) translate(-50%, -50%)",transformOrigin:"0% 0%",[`&.${Vl.invisible}`]:{transform:"scale(0) translate(-50%, -50%)"}}},{props:({ownerState:n})=>n.anchorOrigin.vertical==="bottom"&&n.anchorOrigin.horizontal==="left"&&n.overlap==="circular",style:{bottom:"14%",left:"14%",transform:"scale(1) translate(-50%, 50%)",transformOrigin:"0% 100%",[`&.${Vl.invisible}`]:{transform:"scale(0) translate(-50%, 50%)"}}},{props:{invisible:!0},style:{transition:t.transitions.create("transform",{easing:t.transitions.easing.easeInOut,duration:t.transitions.duration.leavingScreen})}}]}}),$ne=L.forwardRef(function(e,n){var r,i,s,o,a,l;const c=One({props:e,name:"MuiBadge"}),{anchorOrigin:u={vertical:"top",horizontal:"right"},className:d,component:f,components:h={},componentsProps:p={},children:x,overlap:v="rectangular",color:y="default",invisible:b=!1,max:S=99,badgeContent:w,slots:E,slotProps:A,showZero:T=!1,variant:I="standard"}=c,N=it(c,Dne),{badgeContent:M,invisible:P,max:B,displayValue:F}=Rte({max:S,invisible:b,badgeContent:w,showZero:T}),U=xU({anchorOrigin:u,color:y,overlap:v,variant:I,badgeContent:w}),j=P||M==null&&I!=="dot",{color:Z=y,overlap:ne=v,anchorOrigin:O=u,variant:G=I}=j?U:c,q=G!=="dot"?F:void 0,se=X({},c,{badgeContent:M,invisible:j,max:B,displayValue:q,showZero:T,anchorOrigin:O,color:Z,overlap:ne,variant:G}),he=Lne(se),ke=(r=(i=E==null?void 0:E.root)!=null?i:h.Root)!=null?r:Bne,re=(s=(o=E==null?void 0:E.badge)!=null?o:h.Badge)!=null?s:Fne,pe=(a=A==null?void 0:A.root)!=null?a:p.root,fe=(l=A==null?void 0:A.badge)!=null?l:p.badge,Ee=Ec({elementType:ke,externalSlotProps:pe,externalForwardedProps:N,additionalProps:{ref:n,as:f},ownerState:se,className:ct(pe==null?void 0:pe.className,he.root,d)}),We=Ec({elementType:re,externalSlotProps:fe,ownerState:se,className:ct(he.badge,fe==null?void 0:fe.className)});return H.jsxs(ke,X({},Ee,{children:[x,H.jsx(re,X({},We,{children:q}))]}))}),Une=$ne;function zne(t){return kt("MuiBottomNavigation",t)}Bt("MuiBottomNavigation",["root"]);const Gne=["children","className","component","onChange","showLabels","value"],Hne=t=>{const{classes:e}=t;return Ft({root:["root"]},zne,e)},Vne=Ke("div",{name:"MuiBottomNavigation",slot:"Root",overridesResolver:(t,e)=>e.root})(({theme:t})=>({display:"flex",justifyContent:"center",height:56,backgroundColor:(t.vars||t).palette.background.paper})),Wne=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiBottomNavigation"}),{children:i,className:s,component:o="div",onChange:a,showLabels:l=!1,value:c}=r,u=it(r,Gne),d=X({},r,{component:o,showLabels:l}),f=Hne(d);return H.jsx(Vne,X({as:o,className:ct(f.root,s),ref:n,ownerState:d},u,{children:L.Children.map(i,(h,p)=>{if(!L.isValidElement(h))return null;const x=h.props.value===void 0?p:h.props.value;return L.cloneElement(h,{selected:x===c,showLabel:h.props.showLabel!==void 0?h.props.showLabel:l,value:x,onChange:a})})}))}),jne=Wne;function Xne(t){return kt("MuiBottomNavigationAction",t)}const VU=Bt("MuiBottomNavigationAction",["root","iconOnly","selected","label"]),Kne=["className","icon","label","onChange","onClick","selected","showLabel","value"],qne=t=>{const{classes:e,showLabel:n,selected:r}=t;return Ft({root:["root",!n&&!r&&"iconOnly",r&&"selected"],label:["label",!n&&!r&&"iconOnly",r&&"selected"]},Xne,e)},Jne=Ke(hd,{name:"MuiBottomNavigationAction",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,!n.showLabel&&!n.selected&&e.iconOnly]}})(({theme:t,ownerState:e})=>X({transition:t.transitions.create(["color","padding-top"],{duration:t.transitions.duration.short}),padding:"0px 12px",minWidth:80,maxWidth:168,color:(t.vars||t).palette.text.secondary,flexDirection:"column",flex:"1"},!e.showLabel&&!e.selected&&{paddingTop:14},!e.showLabel&&!e.selected&&!e.label&&{paddingTop:0},{[`&.${VU.selected}`]:{color:(t.vars||t).palette.primary.main}})),Yne=Ke("span",{name:"MuiBottomNavigationAction",slot:"Label",overridesResolver:(t,e)=>e.label})(({theme:t,ownerState:e})=>X({fontFamily:t.typography.fontFamily,fontSize:t.typography.pxToRem(12),opacity:1,transition:"font-size 0.2s, opacity 0.2s",transitionDelay:"0.1s"},!e.showLabel&&!e.selected&&{opacity:0,transitionDelay:"0s"},{[`&.${VU.selected}`]:{fontSize:t.typography.pxToRem(14)}})),Qne=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiBottomNavigationAction"}),{className:i,icon:s,label:o,onChange:a,onClick:l,value:c}=r,u=it(r,Kne),d=r,f=qne(d),h=p=>{a&&a(p,c),l&&l(p)};return H.jsxs(Jne,X({ref:n,className:ct(f.root,i),focusRipple:!0,onClick:h,ownerState:d},u,{children:[s,H.jsx(Yne,{className:f.label,ownerState:d,children:o})]}))}),cm=Qne,Zne=Bt("MuiBox",["root"]),ere=Zne,tre=PU(),nre=eQ({themeId:g0,defaultTheme:tre,defaultClassName:ere.root,generateClassName:lU.generate}),uC=nre;function rre(t){return kt("MuiButton",t)}const ire=Bt("MuiButton",["root","text","textInherit","textPrimary","textSecondary","textSuccess","textError","textInfo","textWarning","outlined","outlinedInherit","outlinedPrimary","outlinedSecondary","outlinedSuccess","outlinedError","outlinedInfo","outlinedWarning","contained","containedInherit","containedPrimary","containedSecondary","containedSuccess","containedError","containedInfo","containedWarning","disableElevation","focusVisible","disabled","colorInherit","colorPrimary","colorSecondary","colorSuccess","colorError","colorInfo","colorWarning","textSizeSmall","textSizeMedium","textSizeLarge","outlinedSizeSmall","outlinedSizeMedium","outlinedSizeLarge","containedSizeSmall","containedSizeMedium","containedSizeLarge","sizeMedium","sizeSmall","sizeLarge","fullWidth","startIcon","endIcon","icon","iconSizeSmall","iconSizeMedium","iconSizeLarge"]),vv=ire,sre=L.createContext({}),ore=sre,are=L.createContext(void 0),lre=are,cre=["children","color","component","className","disabled","disableElevation","disableFocusRipple","endIcon","focusVisibleClassName","fullWidth","size","startIcon","type","variant"],ure=t=>{const{color:e,disableElevation:n,fullWidth:r,size:i,variant:s,classes:o}=t,a={root:["root",s,`${s}${Le(e)}`,`size${Le(i)}`,`${s}Size${Le(i)}`,`color${Le(e)}`,n&&"disableElevation",r&&"fullWidth"],label:["label"],startIcon:["icon","startIcon",`iconSize${Le(i)}`],endIcon:["icon","endIcon",`iconSize${Le(i)}`]},l=Ft(a,rre,o);return X({},o,l)},WU=t=>X({},t.size==="small"&&{"& > *:nth-of-type(1)":{fontSize:18}},t.size==="medium"&&{"& > *:nth-of-type(1)":{fontSize:20}},t.size==="large"&&{"& > *:nth-of-type(1)":{fontSize:22}}),dre=Ke(hd,{shouldForwardProp:t=>Jo(t)||t==="classes",name:"MuiButton",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,e[n.variant],e[`${n.variant}${Le(n.color)}`],e[`size${Le(n.size)}`],e[`${n.variant}Size${Le(n.size)}`],n.color==="inherit"&&e.colorInherit,n.disableElevation&&e.disableElevation,n.fullWidth&&e.fullWidth]}})(({theme:t,ownerState:e})=>{var n,r;const i=t.palette.mode==="light"?t.palette.grey[300]:t.palette.grey[800],s=t.palette.mode==="light"?t.palette.grey.A100:t.palette.grey[700];return X({},t.typography.button,{minWidth:64,padding:"6px 16px",borderRadius:(t.vars||t).shape.borderRadius,transition:t.transitions.create(["background-color","box-shadow","border-color","color"],{duration:t.transitions.duration.short}),"&:hover":X({textDecoration:"none",backgroundColor:t.vars?`rgba(${t.vars.palette.text.primaryChannel} / ${t.vars.palette.action.hoverOpacity})`:Tr(t.palette.text.primary,t.palette.action.hoverOpacity),"@media (hover: none)":{backgroundColor:"transparent"}},e.variant==="text"&&e.color!=="inherit"&&{backgroundColor:t.vars?`rgba(${t.vars.palette[e.color].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:Tr(t.palette[e.color].main,t.palette.action.hoverOpacity),"@media (hover: none)":{backgroundColor:"transparent"}},e.variant==="outlined"&&e.color!=="inherit"&&{border:`1px solid ${(t.vars||t).palette[e.color].main}`,backgroundColor:t.vars?`rgba(${t.vars.palette[e.color].mainChannel} / ${t.vars.palette.action.hoverOpacity})`:Tr(t.palette[e.color].main,t.palette.action.hoverOpacity),"@media (hover: none)":{backgroundColor:"transparent"}},e.variant==="contained"&&{backgroundColor:t.vars?t.vars.palette.Button.inheritContainedHoverBg:s,boxShadow:(t.vars||t).shadows[4],"@media (hover: none)":{boxShadow:(t.vars||t).shadows[2],backgroundColor:(t.vars||t).palette.grey[300]}},e.variant==="contained"&&e.color!=="inherit"&&{backgroundColor:(t.vars||t).palette[e.color].dark,"@media (hover: none)":{backgroundColor:(t.vars||t).palette[e.color].main}}),"&:active":X({},e.variant==="contained"&&{boxShadow:(t.vars||t).shadows[8]}),[`&.${vv.focusVisible}`]:X({},e.variant==="contained"&&{boxShadow:(t.vars||t).shadows[6]}),[`&.${vv.disabled}`]:X({color:(t.vars||t).palette.action.disabled},e.variant==="outlined"&&{border:`1px solid ${(t.vars||t).palette.action.disabledBackground}`},e.variant==="contained"&&{color:(t.vars||t).palette.action.disabled,boxShadow:(t.vars||t).shadows[0],backgroundColor:(t.vars||t).palette.action.disabledBackground})},e.variant==="text"&&{padding:"6px 8px"},e.variant==="text"&&e.color!=="inherit"&&{color:(t.vars||t).palette[e.color].main},e.variant==="outlined"&&{padding:"5px 15px",border:"1px solid currentColor"},e.variant==="outlined"&&e.color!=="inherit"&&{color:(t.vars||t).palette[e.color].main,border:t.vars?`1px solid rgba(${t.vars.palette[e.color].mainChannel} / 0.5)`:`1px solid ${Tr(t.palette[e.color].main,.5)}`},e.variant==="contained"&&{color:t.vars?t.vars.palette.text.primary:(n=(r=t.palette).getContrastText)==null?void 0:n.call(r,t.palette.grey[300]),backgroundColor:t.vars?t.vars.palette.Button.inheritContainedBg:i,boxShadow:(t.vars||t).shadows[2]},e.variant==="contained"&&e.color!=="inherit"&&{color:(t.vars||t).palette[e.color].contrastText,backgroundColor:(t.vars||t).palette[e.color].main},e.color==="inherit"&&{color:"inherit",borderColor:"currentColor"},e.size==="small"&&e.variant==="text"&&{padding:"4px 5px",fontSize:t.typography.pxToRem(13)},e.size==="large"&&e.variant==="text"&&{padding:"8px 11px",fontSize:t.typography.pxToRem(15)},e.size==="small"&&e.variant==="outlined"&&{padding:"3px 9px",fontSize:t.typography.pxToRem(13)},e.size==="large"&&e.variant==="outlined"&&{padding:"7px 21px",fontSize:t.typography.pxToRem(15)},e.size==="small"&&e.variant==="contained"&&{padding:"4px 10px",fontSize:t.typography.pxToRem(13)},e.size==="large"&&e.variant==="contained"&&{padding:"8px 22px",fontSize:t.typography.pxToRem(15)},e.fullWidth&&{width:"100%"})},({ownerState:t})=>t.disableElevation&&{boxShadow:"none","&:hover":{boxShadow:"none"},[`&.${vv.focusVisible}`]:{boxShadow:"none"},"&:active":{boxShadow:"none"},[`&.${vv.disabled}`]:{boxShadow:"none"}}),fre=Ke("span",{name:"MuiButton",slot:"StartIcon",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.startIcon,e[`iconSize${Le(n.size)}`]]}})(({ownerState:t})=>X({display:"inherit",marginRight:8,marginLeft:-4},t.size==="small"&&{marginLeft:-2},WU(t))),hre=Ke("span",{name:"MuiButton",slot:"EndIcon",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.endIcon,e[`iconSize${Le(n.size)}`]]}})(({ownerState:t})=>X({display:"inherit",marginRight:-4,marginLeft:8},t.size==="small"&&{marginRight:-2},WU(t))),pre=L.forwardRef(function(e,n){const r=L.useContext(ore),i=L.useContext(lre),s=YM(r,e),o=Vt({props:s,name:"MuiButton"}),{children:a,color:l="primary",component:c="button",className:u,disabled:d=!1,disableElevation:f=!1,disableFocusRipple:h=!1,endIcon:p,focusVisibleClassName:x,fullWidth:v=!1,size:y="medium",startIcon:b,type:S,variant:w="text"}=o,E=it(o,cre),A=X({},o,{color:l,component:c,disabled:d,disableElevation:f,disableFocusRipple:h,fullWidth:v,size:y,type:S,variant:w}),T=ure(A),I=b&&H.jsx(fre,{className:T.startIcon,ownerState:A,children:b}),N=p&&H.jsx(hre,{className:T.endIcon,ownerState:A,children:p}),M=i||"";return H.jsxs(dre,X({ownerState:A,className:ct(r.className,T.root,u,M),component:c,disabled:d,focusRipple:!h,focusVisibleClassName:ct(T.focusVisible,x),ref:n,type:S},E,{classes:T,children:[I,a,N]}))}),xh=pre;function mre(t){return kt("MuiCard",t)}Bt("MuiCard",["root"]);const gre=["className","raised"],yre=t=>{const{classes:e}=t;return Ft({root:["root"]},mre,e)},vre=Ke(Tl,{name:"MuiCard",slot:"Root",overridesResolver:(t,e)=>e.root})(()=>({overflow:"hidden"})),xre=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiCard"}),{className:i,raised:s=!1}=r,o=it(r,gre),a=X({},r,{raised:s}),l=yre(a);return H.jsx(vre,X({className:ct(l.root,i),elevation:s?8:void 0,ref:n,ownerState:a},o))}),bre=xre;function Sre(t){return kt("MuiCardActionArea",t)}const _re=Bt("MuiCardActionArea",["root","focusVisible","focusHighlight"]),dC=_re,wre=["children","className","focusVisibleClassName"],Cre=t=>{const{classes:e}=t;return Ft({root:["root"],focusHighlight:["focusHighlight"]},Sre,e)},Ere=Ke(hd,{name:"MuiCardActionArea",slot:"Root",overridesResolver:(t,e)=>e.root})(({theme:t})=>({display:"block",textAlign:"inherit",borderRadius:"inherit",width:"100%",[`&:hover .${dC.focusHighlight}`]:{opacity:(t.vars||t).palette.action.hoverOpacity,"@media (hover: none)":{opacity:0}},[`&.${dC.focusVisible} .${dC.focusHighlight}`]:{opacity:(t.vars||t).palette.action.focusOpacity}})),Are=Ke("span",{name:"MuiCardActionArea",slot:"FocusHighlight",overridesResolver:(t,e)=>e.focusHighlight})(({theme:t})=>({overflow:"hidden",pointerEvents:"none",position:"absolute",top:0,right:0,bottom:0,left:0,borderRadius:"inherit",opacity:0,backgroundColor:"currentcolor",transition:t.transitions.create("opacity",{duration:t.transitions.duration.short})})),Tre=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiCardActionArea"}),{children:i,className:s,focusVisibleClassName:o}=r,a=it(r,wre),l=r,c=Cre(l);return H.jsxs(Ere,X({className:ct(c.root,s),focusVisibleClassName:ct(o,c.focusVisible),ref:n,ownerState:l},a,{children:[i,H.jsx(Are,{className:c.focusHighlight,ownerState:l})]}))}),Mre=Tre;function Rre(t){return kt("MuiCardContent",t)}Bt("MuiCardContent",["root"]);const Ire=["className","component"],Nre=t=>{const{classes:e}=t;return Ft({root:["root"]},Rre,e)},Pre=Ke("div",{name:"MuiCardContent",slot:"Root",overridesResolver:(t,e)=>e.root})(()=>({padding:16,"&:last-child":{paddingBottom:24}})),kre=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiCardContent"}),{className:i,component:s="div"}=r,o=it(r,Ire),a=X({},r,{component:s}),l=Nre(a);return H.jsx(Pre,X({as:s,className:ct(l.root,i),ownerState:a,ref:n},o))}),Dre=kre;function Ore(t){return kt("MuiCardMedia",t)}Bt("MuiCardMedia",["root","media","img"]);const Lre=["children","className","component","image","src","style"],Bre=t=>{const{classes:e,isMediaComponent:n,isImageComponent:r}=t;return Ft({root:["root",n&&"media",r&&"img"]},Ore,e)},Fre=Ke("div",{name:"MuiCardMedia",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t,{isMediaComponent:r,isImageComponent:i}=n;return[e.root,r&&e.media,i&&e.img]}})(({ownerState:t})=>X({display:"block",backgroundSize:"cover",backgroundRepeat:"no-repeat",backgroundPosition:"center"},t.isMediaComponent&&{width:"100%"},t.isImageComponent&&{objectFit:"cover"})),$re=["video","audio","picture","iframe","img"],Ure=["picture","img"],zre=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiCardMedia"}),{children:i,className:s,component:o="div",image:a,src:l,style:c}=r,u=it(r,Lre),d=$re.indexOf(o)!==-1,f=!d&&a?X({backgroundImage:`url("${a}")`},c):c,h=X({},r,{component:o,isMediaComponent:d,isImageComponent:Ure.indexOf(o)!==-1}),p=Bre(h);return H.jsx(Fre,X({className:ct(p.root,s),as:o,role:!d&&a?"img":void 0,ref:n,style:f,ownerState:h,src:d?a||l:void 0},u,{children:i}))}),Gre=zre,Hre=LQ({createStyledComponent:Ke("div",{name:"MuiContainer",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,e[`maxWidth${Le(String(n.maxWidth))}`],n.fixed&&e.fixed,n.disableGutters&&e.disableGutters]}}),useThemeProps:t=>Vt({props:t,name:"MuiContainer"})}),jx=Hre;function Vre(t){return kt("MuiModal",t)}Bt("MuiModal",["root","hidden","backdrop"]);const Wre=["BackdropComponent","BackdropProps","classes","className","closeAfterTransition","children","container","component","components","componentsProps","disableAutoFocus","disableEnforceFocus","disableEscapeKeyDown","disablePortal","disableRestoreFocus","disableScrollLock","hideBackdrop","keepMounted","onBackdropClick","onClose","onTransitionEnter","onTransitionExited","open","slotProps","slots","theme"],jre=t=>{const{open:e,exited:n,classes:r}=t;return Ft({root:["root",!e&&n&&"hidden"],backdrop:["backdrop"]},Vre,r)},Xre=Ke("div",{name:"MuiModal",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,!n.open&&n.exited&&e.hidden]}})(({theme:t,ownerState:e})=>X({position:"fixed",zIndex:(t.vars||t).zIndex.modal,right:0,bottom:0,top:0,left:0},!e.open&&e.exited&&{visibility:"hidden"})),Kre=Ke(Nne,{name:"MuiModal",slot:"Backdrop",overridesResolver:(t,e)=>e.backdrop})({zIndex:-1}),qre=L.forwardRef(function(e,n){var r,i,s,o,a,l;const c=Vt({name:"MuiModal",props:e}),{BackdropComponent:u=Kre,BackdropProps:d,className:f,closeAfterTransition:h=!1,children:p,container:x,component:v,components:y={},componentsProps:b={},disableAutoFocus:S=!1,disableEnforceFocus:w=!1,disableEscapeKeyDown:E=!1,disablePortal:A=!1,disableRestoreFocus:T=!1,disableScrollLock:I=!1,hideBackdrop:N=!1,keepMounted:M=!1,onBackdropClick:P,open:B,slotProps:F,slots:U}=c,j=it(c,Wre),Z=X({},c,{closeAfterTransition:h,disableAutoFocus:S,disableEnforceFocus:w,disableEscapeKeyDown:E,disablePortal:A,disableRestoreFocus:T,disableScrollLock:I,hideBackdrop:N,keepMounted:M}),{getRootProps:ne,getBackdropProps:O,getTransitionProps:G,portalRef:q,isTopModal:se,exited:he,hasTransition:ke}=Xte(X({},Z,{rootRef:n})),re=X({},Z,{exited:he}),pe=jre(re),fe={};if(p.props.tabIndex===void 0&&(fe.tabIndex="-1"),ke){const{onEnter:ce,onExited:Me}=G();fe.onEnter=ce,fe.onExited=Me}const Ee=(r=(i=U==null?void 0:U.root)!=null?i:y.Root)!=null?r:Xre,We=(s=(o=U==null?void 0:U.backdrop)!=null?o:y.Backdrop)!=null?s:u,je=(a=F==null?void 0:F.root)!=null?a:b.root,Je=(l=F==null?void 0:F.backdrop)!=null?l:b.backdrop,te=Ec({elementType:Ee,externalSlotProps:je,externalForwardedProps:j,getSlotProps:ne,additionalProps:{ref:n,as:v},ownerState:re,className:ct(f,je==null?void 0:je.className,pe==null?void 0:pe.root,!re.open&&re.exited&&(pe==null?void 0:pe.hidden))}),be=Ec({elementType:We,externalSlotProps:Je,additionalProps:d,getSlotProps:ce=>O(X({},ce,{onClick:Me=>{P&&P(Me),ce!=null&&ce.onClick&&ce.onClick(Me)}})),className:ct(Je==null?void 0:Je.className,d==null?void 0:d.className,pe==null?void 0:pe.backdrop),ownerState:re});return!M&&!B&&(!ke||he)?null:H.jsx(Fte,{ref:q,container:x,disablePortal:A,children:H.jsxs(Ee,X({},te,{children:[!N&&u?H.jsx(We,X({},be)):null,H.jsx(Lte,{disableEnforceFocus:w,disableAutoFocus:S,disableRestoreFocus:T,isEnabled:se,open:B,children:L.cloneElement(p,fe)})]}))})}),Jre=qre,Yre=["disableUnderline","components","componentsProps","fullWidth","hiddenLabel","inputComponent","multiline","slotProps","slots","type"],Qre=t=>{const{classes:e,disableUnderline:n}=t,i=Ft({root:["root",!n&&"underline"],input:["input"]},xne,e);return X({},e,i)},Zre=Ke(SS,{shouldForwardProp:t=>Jo(t)||t==="classes",name:"MuiFilledInput",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[...xS(t,e),!n.disableUnderline&&e.underline]}})(({theme:t,ownerState:e})=>{var n;const r=t.palette.mode==="light",i=r?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)",s=r?"rgba(0, 0, 0, 0.06)":"rgba(255, 255, 255, 0.09)",o=r?"rgba(0, 0, 0, 0.09)":"rgba(255, 255, 255, 0.13)",a=r?"rgba(0, 0, 0, 0.12)":"rgba(255, 255, 255, 0.12)";return X({position:"relative",backgroundColor:t.vars?t.vars.palette.FilledInput.bg:s,borderTopLeftRadius:(t.vars||t).shape.borderRadius,borderTopRightRadius:(t.vars||t).shape.borderRadius,transition:t.transitions.create("background-color",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),"&:hover":{backgroundColor:t.vars?t.vars.palette.FilledInput.hoverBg:o,"@media (hover: none)":{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:s}},[`&.${eu.focused}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.bg:s},[`&.${eu.disabled}`]:{backgroundColor:t.vars?t.vars.palette.FilledInput.disabledBg:a}},!e.disableUnderline&&{"&::after":{borderBottom:`2px solid ${(n=(t.vars||t).palette[e.color||"primary"])==null?void 0:n.main}`,left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${eu.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${eu.error}`]:{"&::before, &::after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`:i}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${eu.disabled}, .${eu.error}):before`]:{borderBottom:`1px solid ${(t.vars||t).palette.text.primary}`},[`&.${eu.disabled}:before`]:{borderBottomStyle:"dotted"}},e.startAdornment&&{paddingLeft:12},e.endAdornment&&{paddingRight:12},e.multiline&&X({padding:"25px 12px 8px"},e.size==="small"&&{paddingTop:21,paddingBottom:4},e.hiddenLabel&&{paddingTop:16,paddingBottom:17},e.hiddenLabel&&e.size==="small"&&{paddingTop:8,paddingBottom:9}))}),eie=Ke(_S,{name:"MuiFilledInput",slot:"Input",overridesResolver:bS})(({theme:t,ownerState:e})=>X({paddingTop:25,paddingRight:12,paddingBottom:8,paddingLeft:12},!t.vars&&{"&:-webkit-autofill":{WebkitBoxShadow:t.palette.mode==="light"?null:"0 0 0 100px #266798 inset",WebkitTextFillColor:t.palette.mode==="light"?null:"#fff",caretColor:t.palette.mode==="light"?null:"#fff",borderTopLeftRadius:"inherit",borderTopRightRadius:"inherit"}},t.vars&&{"&:-webkit-autofill":{borderTopLeftRadius:"inherit",borderTopRightRadius:"inherit"},[t.getColorSchemeSelector("dark")]:{"&:-webkit-autofill":{WebkitBoxShadow:"0 0 0 100px #266798 inset",WebkitTextFillColor:"#fff",caretColor:"#fff"}}},e.size==="small"&&{paddingTop:21,paddingBottom:4},e.hiddenLabel&&{paddingTop:16,paddingBottom:17},e.startAdornment&&{paddingLeft:0},e.endAdornment&&{paddingRight:0},e.hiddenLabel&&e.size==="small"&&{paddingTop:8,paddingBottom:9},e.multiline&&{paddingTop:0,paddingBottom:0,paddingLeft:0,paddingRight:0})),jU=L.forwardRef(function(e,n){var r,i,s,o;const a=Vt({props:e,name:"MuiFilledInput"}),{components:l={},componentsProps:c,fullWidth:u=!1,inputComponent:d="input",multiline:f=!1,slotProps:h,slots:p={},type:x="text"}=a,v=it(a,Yre),y=X({},a,{fullWidth:u,inputComponent:d,multiline:f,type:x}),b=Qre(a),S={root:{ownerState:y},input:{ownerState:y}},w=h??c?Bi(S,h??c):S,E=(r=(i=p.root)!=null?i:l.Root)!=null?r:Zre,A=(s=(o=p.input)!=null?o:l.Input)!=null?s:eie;return H.jsx(uR,X({slots:{root:E,input:A},componentsProps:w,fullWidth:u,inputComponent:d,multiline:f,ref:n,type:x},v,{classes:b}))});jU.muiName="Input";const XU=jU;function tie(t){return kt("MuiFormControl",t)}Bt("MuiFormControl",["root","marginNone","marginNormal","marginDense","fullWidth","disabled"]);const nie=["children","className","color","component","disabled","error","focused","fullWidth","hiddenLabel","margin","required","size","variant"],rie=t=>{const{classes:e,margin:n,fullWidth:r}=t,i={root:["root",n!=="none"&&`margin${Le(n)}`,r&&"fullWidth"]};return Ft(i,tie,e)},iie=Ke("div",{name:"MuiFormControl",slot:"Root",overridesResolver:({ownerState:t},e)=>X({},e.root,e[`margin${Le(t.margin)}`],t.fullWidth&&e.fullWidth)})(({ownerState:t})=>X({display:"inline-flex",flexDirection:"column",position:"relative",minWidth:0,padding:0,margin:0,border:0,verticalAlign:"top"},t.margin==="normal"&&{marginTop:16,marginBottom:8},t.margin==="dense"&&{marginTop:8,marginBottom:4},t.fullWidth&&{width:"100%"})),sie=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiFormControl"}),{children:i,className:s,color:o="primary",component:a="div",disabled:l=!1,error:c=!1,focused:u,fullWidth:d=!1,hiddenLabel:f=!1,margin:h="none",required:p=!1,size:x="medium",variant:v="outlined"}=r,y=it(r,nie),b=X({},r,{color:o,component:a,disabled:l,error:c,fullWidth:d,hiddenLabel:f,margin:h,required:p,size:x,variant:v}),S=rie(b),[w,E]=L.useState(()=>{let F=!1;return i&&L.Children.forEach(i,U=>{if(!rC(U,["Input","Select"]))return;const j=rC(U,["Select"])?U.props.input:U;j&&lne(j.props)&&(F=!0)}),F}),[A,T]=L.useState(()=>{let F=!1;return i&&L.Children.forEach(i,U=>{rC(U,["Input","Select"])&&(F1(U.props,!0)||F1(U.props.inputProps,!0))&&(F=!0)}),F}),[I,N]=L.useState(!1);l&&I&&N(!1);const M=u!==void 0&&!l?u:I;let P;const B=L.useMemo(()=>({adornedStart:w,setAdornedStart:E,color:o,disabled:l,error:c,filled:A,focused:M,fullWidth:d,hiddenLabel:f,size:x,onBlur:()=>{N(!1)},onEmpty:()=>{T(!1)},onFilled:()=>{T(!0)},onFocus:()=>{N(!0)},registerEffect:P,required:p,variant:v}),[w,o,l,c,A,M,d,f,P,p,x,v]);return H.jsx(vS.Provider,{value:B,children:H.jsx(iie,X({as:a,ownerState:b,className:ct(S.root,s),ref:n},y,{children:i}))})}),oie=sie,aie=VQ({createStyledComponent:Ke("div",{name:"MuiStack",slot:"Root",overridesResolver:(t,e)=>e.root}),useThemeProps:t=>Vt({props:t,name:"MuiStack"})}),ku=aie;function lie(t){return kt("MuiFormHelperText",t)}const cie=Bt("MuiFormHelperText",["root","error","disabled","sizeSmall","sizeMedium","contained","focused","filled","required"]),jk=cie;var Xk;const uie=["children","className","component","disabled","error","filled","focused","margin","required","variant"],die=t=>{const{classes:e,contained:n,size:r,disabled:i,error:s,filled:o,focused:a,required:l}=t,c={root:["root",i&&"disabled",s&&"error",r&&`size${Le(r)}`,n&&"contained",a&&"focused",o&&"filled",l&&"required"]};return Ft(c,lie,e)},fie=Ke("p",{name:"MuiFormHelperText",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,n.size&&e[`size${Le(n.size)}`],n.contained&&e.contained,n.filled&&e.filled]}})(({theme:t,ownerState:e})=>X({color:(t.vars||t).palette.text.secondary},t.typography.caption,{textAlign:"left",marginTop:3,marginRight:0,marginBottom:0,marginLeft:0,[`&.${jk.disabled}`]:{color:(t.vars||t).palette.text.disabled},[`&.${jk.error}`]:{color:(t.vars||t).palette.error.main}},e.size==="small"&&{marginTop:4},e.contained&&{marginLeft:14,marginRight:14})),hie=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiFormHelperText"}),{children:i,className:s,component:o="p"}=r,a=it(r,uie),l=Id(),c=mp({props:r,muiFormControl:l,states:["variant","size","disabled","error","filled","focused","required"]}),u=X({},r,{component:o,contained:c.variant==="filled"||c.variant==="outlined",variant:c.variant,size:c.size,disabled:c.disabled,error:c.error,filled:c.filled,focused:c.focused,required:c.required}),d=die(u);return H.jsx(fie,X({as:o,ownerState:u,className:ct(d.root,s),ref:n},a,{children:i===" "?Xk||(Xk=H.jsx("span",{className:"notranslate",children:"​"})):i}))}),pie=hie;function mie(t){return kt("MuiFormLabel",t)}const gie=Bt("MuiFormLabel",["root","colorSecondary","focused","disabled","error","filled","required","asterisk"]),rg=gie,yie=["children","className","color","component","disabled","error","filled","focused","required"],vie=t=>{const{classes:e,color:n,focused:r,disabled:i,error:s,filled:o,required:a}=t,l={root:["root",`color${Le(n)}`,i&&"disabled",s&&"error",o&&"filled",r&&"focused",a&&"required"],asterisk:["asterisk",s&&"error"]};return Ft(l,mie,e)},xie=Ke("label",{name:"MuiFormLabel",slot:"Root",overridesResolver:({ownerState:t},e)=>X({},e.root,t.color==="secondary"&&e.colorSecondary,t.filled&&e.filled)})(({theme:t,ownerState:e})=>X({color:(t.vars||t).palette.text.secondary},t.typography.body1,{lineHeight:"1.4375em",padding:0,position:"relative",[`&.${rg.focused}`]:{color:(t.vars||t).palette[e.color].main},[`&.${rg.disabled}`]:{color:(t.vars||t).palette.text.disabled},[`&.${rg.error}`]:{color:(t.vars||t).palette.error.main}})),bie=Ke("span",{name:"MuiFormLabel",slot:"Asterisk",overridesResolver:(t,e)=>e.asterisk})(({theme:t})=>({[`&.${rg.error}`]:{color:(t.vars||t).palette.error.main}})),Sie=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiFormLabel"}),{children:i,className:s,component:o="label"}=r,a=it(r,yie),l=Id(),c=mp({props:r,muiFormControl:l,states:["color","required","focused","disabled","error","filled"]}),u=X({},r,{color:c.color||"primary",component:o,disabled:c.disabled,error:c.error,filled:c.filled,focused:c.focused,required:c.required}),d=vie(u);return H.jsxs(xie,X({as:o,ownerState:u,className:ct(d.root,s),ref:n},a,{children:[i,c.required&&H.jsxs(bie,{ownerState:u,"aria-hidden":!0,className:d.asterisk,children:[" ","*"]})]}))}),_ie=Sie,wie=L.createContext(),Kk=wie;function Cie(t){return kt("MuiGrid",t)}const Eie=[0,1,2,3,4,5,6,7,8,9,10],Aie=["column-reverse","column","row-reverse","row"],Tie=["nowrap","wrap-reverse","wrap"],um=["auto",!0,1,2,3,4,5,6,7,8,9,10,11,12],kg=Bt("MuiGrid",["root","container","item","zeroMinWidth",...Eie.map(t=>`spacing-xs-${t}`),...Aie.map(t=>`direction-xs-${t}`),...Tie.map(t=>`wrap-xs-${t}`),...um.map(t=>`grid-xs-${t}`),...um.map(t=>`grid-sm-${t}`),...um.map(t=>`grid-md-${t}`),...um.map(t=>`grid-lg-${t}`),...um.map(t=>`grid-xl-${t}`)]),Mie=["className","columns","columnSpacing","component","container","direction","item","rowSpacing","spacing","wrap","zeroMinWidth"];function bh(t){const e=parseFloat(t);return`${e}${String(t).replace(String(e),"")||"px"}`}function Rie({theme:t,ownerState:e}){let n;return t.breakpoints.keys.reduce((r,i)=>{let s={};if(e[i]&&(n=e[i]),!n)return r;if(n===!0)s={flexBasis:0,flexGrow:1,maxWidth:"100%"};else if(n==="auto")s={flexBasis:"auto",flexGrow:0,flexShrink:0,maxWidth:"none",width:"auto"};else{const o=Ku({values:e.columns,breakpoints:t.breakpoints.values}),a=typeof o=="object"?o[i]:o;if(a==null)return r;const l=`${Math.round(n/a*1e8)/1e6}%`;let c={};if(e.container&&e.item&&e.columnSpacing!==0){const u=t.spacing(e.columnSpacing);if(u!=="0px"){const d=`calc(${l} + ${bh(u)})`;c={flexBasis:d,maxWidth:d}}}s=X({flexBasis:l,flexGrow:0,maxWidth:l},c)}return t.breakpoints.values[i]===0?Object.assign(r,s):r[t.breakpoints.up(i)]=s,r},{})}function Iie({theme:t,ownerState:e}){const n=Ku({values:e.direction,breakpoints:t.breakpoints.values});return is({theme:t},n,r=>{const i={flexDirection:r};return r.indexOf("column")===0&&(i[`& > .${kg.item}`]={maxWidth:"none"}),i})}function KU({breakpoints:t,values:e}){let n="";Object.keys(e).forEach(i=>{n===""&&e[i]!==0&&(n=i)});const r=Object.keys(t).sort((i,s)=>t[i]-t[s]);return r.slice(0,r.indexOf(n))}function Nie({theme:t,ownerState:e}){const{container:n,rowSpacing:r}=e;let i={};if(n&&r!==0){const s=Ku({values:r,breakpoints:t.breakpoints.values});let o;typeof s=="object"&&(o=KU({breakpoints:t.breakpoints.values,values:s})),i=is({theme:t},s,(a,l)=>{var c;const u=t.spacing(a);return u!=="0px"?{marginTop:`-${bh(u)}`,[`& > .${kg.item}`]:{paddingTop:bh(u)}}:(c=o)!=null&&c.includes(l)?{}:{marginTop:0,[`& > .${kg.item}`]:{paddingTop:0}}})}return i}function Pie({theme:t,ownerState:e}){const{container:n,columnSpacing:r}=e;let i={};if(n&&r!==0){const s=Ku({values:r,breakpoints:t.breakpoints.values});let o;typeof s=="object"&&(o=KU({breakpoints:t.breakpoints.values,values:s})),i=is({theme:t},s,(a,l)=>{var c;const u=t.spacing(a);return u!=="0px"?{width:`calc(100% + ${bh(u)})`,marginLeft:`-${bh(u)}`,[`& > .${kg.item}`]:{paddingLeft:bh(u)}}:(c=o)!=null&&c.includes(l)?{}:{width:"100%",marginLeft:0,[`& > .${kg.item}`]:{paddingLeft:0}}})}return i}function kie(t,e,n={}){if(!t||t<=0)return[];if(typeof t=="string"&&!Number.isNaN(Number(t))||typeof t=="number")return[n[`spacing-xs-${String(t)}`]];const r=[];return e.forEach(i=>{const s=t[i];Number(s)>0&&r.push(n[`spacing-${i}-${String(s)}`])}),r}const Die=Ke("div",{name:"MuiGrid",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t,{container:r,direction:i,item:s,spacing:o,wrap:a,zeroMinWidth:l,breakpoints:c}=n;let u=[];r&&(u=kie(o,c,e));const d=[];return c.forEach(f=>{const h=n[f];h&&d.push(e[`grid-${f}-${String(h)}`])}),[e.root,r&&e.container,s&&e.item,l&&e.zeroMinWidth,...u,i!=="row"&&e[`direction-xs-${String(i)}`],a!=="wrap"&&e[`wrap-xs-${String(a)}`],...d]}})(({ownerState:t})=>X({boxSizing:"border-box"},t.container&&{display:"flex",flexWrap:"wrap",width:"100%"},t.item&&{margin:0},t.zeroMinWidth&&{minWidth:0},t.wrap!=="wrap"&&{flexWrap:t.wrap}),Iie,Nie,Pie,Rie);function Oie(t,e){if(!t||t<=0)return[];if(typeof t=="string"&&!Number.isNaN(Number(t))||typeof t=="number")return[`spacing-xs-${String(t)}`];const n=[];return e.forEach(r=>{const i=t[r];if(Number(i)>0){const s=`spacing-${r}-${String(i)}`;n.push(s)}}),n}const Lie=t=>{const{classes:e,container:n,direction:r,item:i,spacing:s,wrap:o,zeroMinWidth:a,breakpoints:l}=t;let c=[];n&&(c=Oie(s,l));const u=[];l.forEach(f=>{const h=t[f];h&&u.push(`grid-${f}-${String(h)}`)});const d={root:["root",n&&"container",i&&"item",a&&"zeroMinWidth",...c,r!=="row"&&`direction-xs-${String(r)}`,o!=="wrap"&&`wrap-xs-${String(o)}`,...u]};return Ft(d,Cie,e)},Bie=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiGrid"}),{breakpoints:i}=_0(),s=S0(r),{className:o,columns:a,columnSpacing:l,component:c="div",container:u=!1,direction:d="row",item:f=!1,rowSpacing:h,spacing:p=0,wrap:x="wrap",zeroMinWidth:v=!1}=s,y=it(s,Mie),b=h||p,S=l||p,w=L.useContext(Kk),E=u?a||12:w,A={},T=X({},y);i.keys.forEach(M=>{y[M]!=null&&(A[M]=y[M],delete T[M])});const I=X({},s,{columns:E,container:u,direction:d,item:f,rowSpacing:b,columnSpacing:S,wrap:x,zeroMinWidth:v,spacing:p},A,{breakpoints:i.keys}),N=Lie(I);return H.jsx(Kk.Provider,{value:E,children:H.jsx(Die,X({ownerState:I,className:ct(N.root,o),as:c,ref:n},T))})}),qk=Bie,Fie=["addEndListener","appear","children","easing","in","onEnter","onEntered","onEntering","onExit","onExited","onExiting","style","timeout","TransitionComponent"];function e2(t){return`scale(${t}, ${t**2})`}const $ie={entering:{opacity:1,transform:e2(1)},entered:{opacity:1,transform:"none"}},fC=typeof navigator<"u"&&/^((?!chrome|android).)*(safari|mobile)/i.test(navigator.userAgent)&&/(os |version\/)15(.|_)4/i.test(navigator.userAgent),qU=L.forwardRef(function(e,n){const{addEndListener:r,appear:i=!0,children:s,easing:o,in:a,onEnter:l,onEntered:c,onEntering:u,onExit:d,onExited:f,onExiting:h,style:p,timeout:x="auto",TransitionComponent:v=oR}=e,y=it(e,Fie),b=ZM(),S=L.useRef(),w=_0(),E=L.useRef(null),A=Wr(E,s.ref,n),T=j=>Z=>{if(j){const ne=E.current;Z===void 0?j(ne):j(ne,Z)}},I=T(u),N=T((j,Z)=>{LU(j);const{duration:ne,delay:O,easing:G}=Bh({style:p,timeout:x,easing:o},{mode:"enter"});let q;x==="auto"?(q=w.transitions.getAutoHeightDuration(j.clientHeight),S.current=q):q=ne,j.style.transition=[w.transitions.create("opacity",{duration:q,delay:O}),w.transitions.create("transform",{duration:fC?q:q*.666,delay:O,easing:G})].join(","),l&&l(j,Z)}),M=T(c),P=T(h),B=T(j=>{const{duration:Z,delay:ne,easing:O}=Bh({style:p,timeout:x,easing:o},{mode:"exit"});let G;x==="auto"?(G=w.transitions.getAutoHeightDuration(j.clientHeight),S.current=G):G=Z,j.style.transition=[w.transitions.create("opacity",{duration:G,delay:ne}),w.transitions.create("transform",{duration:fC?G:G*.666,delay:fC?ne:ne||G*.333,easing:O})].join(","),j.style.opacity=0,j.style.transform=e2(.75),d&&d(j)}),F=T(f),U=j=>{x==="auto"&&b.start(S.current||0,j),r&&r(E.current,j)};return H.jsx(v,X({appear:i,in:a,nodeRef:E,onEnter:N,onEntered:M,onEntering:I,onExit:B,onExited:F,onExiting:P,addEndListener:U,timeout:x==="auto"?null:x},y,{children:(j,Z)=>L.cloneElement(s,X({style:X({opacity:0,transform:e2(.75),visibility:j==="exited"&&!a?"hidden":void 0},$ie[j],p,s.props.style),ref:A},Z))}))});qU.muiSupportAuto=!0;const Uie=qU,zie=["disableUnderline","components","componentsProps","fullWidth","inputComponent","multiline","slotProps","slots","type"],Gie=t=>{const{classes:e,disableUnderline:n}=t,i=Ft({root:["root",!n&&"underline"],input:["input"]},mne,e);return X({},e,i)},Hie=Ke(SS,{shouldForwardProp:t=>Jo(t)||t==="classes",name:"MuiInput",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[...xS(t,e),!n.disableUnderline&&e.underline]}})(({theme:t,ownerState:e})=>{let r=t.palette.mode==="light"?"rgba(0, 0, 0, 0.42)":"rgba(255, 255, 255, 0.7)";return t.vars&&(r=`rgba(${t.vars.palette.common.onBackgroundChannel} / ${t.vars.opacity.inputUnderline})`),X({position:"relative"},e.formControl&&{"label + &":{marginTop:16}},!e.disableUnderline&&{"&::after":{borderBottom:`2px solid ${(t.vars||t).palette[e.color].main}`,left:0,bottom:0,content:'""',position:"absolute",right:0,transform:"scaleX(0)",transition:t.transitions.create("transform",{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut}),pointerEvents:"none"},[`&.${lm.focused}:after`]:{transform:"scaleX(1) translateX(0)"},[`&.${lm.error}`]:{"&::before, &::after":{borderBottomColor:(t.vars||t).palette.error.main}},"&::before":{borderBottom:`1px solid ${r}`,left:0,bottom:0,content:'"\\00a0"',position:"absolute",right:0,transition:t.transitions.create("border-bottom-color",{duration:t.transitions.duration.shorter}),pointerEvents:"none"},[`&:hover:not(.${lm.disabled}, .${lm.error}):before`]:{borderBottom:`2px solid ${(t.vars||t).palette.text.primary}`,"@media (hover: none)":{borderBottom:`1px solid ${r}`}},[`&.${lm.disabled}:before`]:{borderBottomStyle:"dotted"}})}),Vie=Ke(_S,{name:"MuiInput",slot:"Input",overridesResolver:bS})({}),JU=L.forwardRef(function(e,n){var r,i,s,o;const a=Vt({props:e,name:"MuiInput"}),{disableUnderline:l,components:c={},componentsProps:u,fullWidth:d=!1,inputComponent:f="input",multiline:h=!1,slotProps:p,slots:x={},type:v="text"}=a,y=it(a,zie),b=Gie(a),w={root:{ownerState:{disableUnderline:l}}},E=p??u?Bi(p??u,w):w,A=(r=(i=x.root)!=null?i:c.Root)!=null?r:Hie,T=(s=(o=x.input)!=null?o:c.Input)!=null?s:Vie;return H.jsx(uR,X({slots:{root:A,input:T},slotProps:E,fullWidth:d,inputComponent:f,multiline:h,ref:n,type:v},y,{classes:b}))});JU.muiName="Input";const YU=JU;function Wie(t){return kt("MuiInputAdornment",t)}const jie=Bt("MuiInputAdornment",["root","filled","standard","outlined","positionStart","positionEnd","disablePointerEvents","hiddenLabel","sizeSmall"]),Jk=jie;var Yk;const Xie=["children","className","component","disablePointerEvents","disableTypography","position","variant"],Kie=(t,e)=>{const{ownerState:n}=t;return[e.root,e[`position${Le(n.position)}`],n.disablePointerEvents===!0&&e.disablePointerEvents,e[n.variant]]},qie=t=>{const{classes:e,disablePointerEvents:n,hiddenLabel:r,position:i,size:s,variant:o}=t,a={root:["root",n&&"disablePointerEvents",i&&`position${Le(i)}`,o,r&&"hiddenLabel",s&&`size${Le(s)}`]};return Ft(a,Wie,e)},Jie=Ke("div",{name:"MuiInputAdornment",slot:"Root",overridesResolver:Kie})(({theme:t,ownerState:e})=>X({display:"flex",height:"0.01em",maxHeight:"2em",alignItems:"center",whiteSpace:"nowrap",color:(t.vars||t).palette.action.active},e.variant==="filled"&&{[`&.${Jk.positionStart}&:not(.${Jk.hiddenLabel})`]:{marginTop:16}},e.position==="start"&&{marginRight:8},e.position==="end"&&{marginLeft:8},e.disablePointerEvents===!0&&{pointerEvents:"none"})),Yie=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiInputAdornment"}),{children:i,className:s,component:o="div",disablePointerEvents:a=!1,disableTypography:l=!1,position:c,variant:u}=r,d=it(r,Xie),f=Id()||{};let h=u;u&&f.variant,f&&!h&&(h=f.variant);const p=X({},r,{hiddenLabel:f.hiddenLabel,size:f.size,disablePointerEvents:a,position:c,variant:h}),x=qie(p);return H.jsx(vS.Provider,{value:null,children:H.jsx(Jie,X({as:o,ownerState:p,className:ct(x.root,s),ref:n},d,{children:typeof i=="string"&&!l?H.jsx(va,{color:"text.secondary",children:i}):H.jsxs(L.Fragment,{children:[c==="start"?Yk||(Yk=H.jsx("span",{className:"notranslate",children:"​"})):null,i]})}))})}),Qie=Yie;function Zie(t){return kt("MuiInputLabel",t)}Bt("MuiInputLabel",["root","focused","disabled","error","required","asterisk","formControl","sizeSmall","shrink","animated","standard","filled","outlined"]);const ese=["disableAnimation","margin","shrink","variant","className"],tse=t=>{const{classes:e,formControl:n,size:r,shrink:i,disableAnimation:s,variant:o,required:a}=t,l={root:["root",n&&"formControl",!s&&"animated",i&&"shrink",r&&r!=="normal"&&`size${Le(r)}`,o],asterisk:[a&&"asterisk"]},c=Ft(l,Zie,e);return X({},e,c)},nse=Ke(_ie,{shouldForwardProp:t=>Jo(t)||t==="classes",name:"MuiInputLabel",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[{[`& .${rg.asterisk}`]:e.asterisk},e.root,n.formControl&&e.formControl,n.size==="small"&&e.sizeSmall,n.shrink&&e.shrink,!n.disableAnimation&&e.animated,n.focused&&e.focused,e[n.variant]]}})(({theme:t,ownerState:e})=>X({display:"block",transformOrigin:"top left",whiteSpace:"nowrap",overflow:"hidden",textOverflow:"ellipsis",maxWidth:"100%"},e.formControl&&{position:"absolute",left:0,top:0,transform:"translate(0, 20px) scale(1)"},e.size==="small"&&{transform:"translate(0, 17px) scale(1)"},e.shrink&&{transform:"translate(0, -1.5px) scale(0.75)",transformOrigin:"top left",maxWidth:"133%"},!e.disableAnimation&&{transition:t.transitions.create(["color","transform","max-width"],{duration:t.transitions.duration.shorter,easing:t.transitions.easing.easeOut})},e.variant==="filled"&&X({zIndex:1,pointerEvents:"none",transform:"translate(12px, 16px) scale(1)",maxWidth:"calc(100% - 24px)"},e.size==="small"&&{transform:"translate(12px, 13px) scale(1)"},e.shrink&&X({userSelect:"none",pointerEvents:"auto",transform:"translate(12px, 7px) scale(0.75)",maxWidth:"calc(133% - 24px)"},e.size==="small"&&{transform:"translate(12px, 4px) scale(0.75)"})),e.variant==="outlined"&&X({zIndex:1,pointerEvents:"none",transform:"translate(14px, 16px) scale(1)",maxWidth:"calc(100% - 24px)"},e.size==="small"&&{transform:"translate(14px, 9px) scale(1)"},e.shrink&&{userSelect:"none",pointerEvents:"auto",maxWidth:"calc(133% - 32px)",transform:"translate(14px, -9px) scale(0.75)"}))),rse=L.forwardRef(function(e,n){const r=Vt({name:"MuiInputLabel",props:e}),{disableAnimation:i=!1,shrink:s,className:o}=r,a=it(r,ese),l=Id();let c=s;typeof c>"u"&&l&&(c=l.filled||l.focused||l.adornedStart);const u=mp({props:r,muiFormControl:l,states:["size","variant","required","focused"]}),d=X({},r,{disableAnimation:i,formControl:l,shrink:c,size:u.size,variant:u.variant,required:u.required,focused:u.focused}),f=tse(d);return H.jsx(nse,X({"data-shrink":c,ownerState:d,ref:n,className:ct(f.root,o)},a,{classes:f}))}),ise=rse;function sse(t){return kt("MuiLinearProgress",t)}Bt("MuiLinearProgress",["root","colorPrimary","colorSecondary","determinate","indeterminate","buffer","query","dashed","dashedColorPrimary","dashedColorSecondary","bar","barColorPrimary","barColorSecondary","bar1Indeterminate","bar1Determinate","bar1Buffer","bar2Indeterminate","bar2Buffer"]);const ose=["className","color","value","valueBuffer","variant"];let gp=t=>t,Qk,Zk,eD,tD,nD,rD;const t2=4,ase=Rd(Qk||(Qk=gp`
  0% {
    left: -35%;
    right: 100%;
  }

  60% {
    left: 100%;
    right: -90%;
  }

  100% {
    left: 100%;
    right: -90%;
  }
`)),lse=Rd(Zk||(Zk=gp`
  0% {
    left: -200%;
    right: 100%;
  }

  60% {
    left: 107%;
    right: -8%;
  }

  100% {
    left: 107%;
    right: -8%;
  }
`)),cse=Rd(eD||(eD=gp`
  0% {
    opacity: 1;
    background-position: 0 -23px;
  }

  60% {
    opacity: 0;
    background-position: 0 -23px;
  }

  100% {
    opacity: 1;
    background-position: -200px -23px;
  }
`)),use=t=>{const{classes:e,variant:n,color:r}=t,i={root:["root",`color${Le(r)}`,n],dashed:["dashed",`dashedColor${Le(r)}`],bar1:["bar",`barColor${Le(r)}`,(n==="indeterminate"||n==="query")&&"bar1Indeterminate",n==="determinate"&&"bar1Determinate",n==="buffer"&&"bar1Buffer"],bar2:["bar",n!=="buffer"&&`barColor${Le(r)}`,n==="buffer"&&`color${Le(r)}`,(n==="indeterminate"||n==="query")&&"bar2Indeterminate",n==="buffer"&&"bar2Buffer"]};return Ft(i,sse,e)},dR=(t,e)=>e==="inherit"?"currentColor":t.vars?t.vars.palette.LinearProgress[`${e}Bg`]:t.palette.mode==="light"?EU(t.palette[e].main,.62):CU(t.palette[e].main,.5),dse=Ke("span",{name:"MuiLinearProgress",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,e[`color${Le(n.color)}`],e[n.variant]]}})(({ownerState:t,theme:e})=>X({position:"relative",overflow:"hidden",display:"block",height:4,zIndex:0,"@media print":{colorAdjust:"exact"},backgroundColor:dR(e,t.color)},t.color==="inherit"&&t.variant!=="buffer"&&{backgroundColor:"none","&::before":{content:'""',position:"absolute",left:0,top:0,right:0,bottom:0,backgroundColor:"currentColor",opacity:.3}},t.variant==="buffer"&&{backgroundColor:"transparent"},t.variant==="query"&&{transform:"rotate(180deg)"})),fse=Ke("span",{name:"MuiLinearProgress",slot:"Dashed",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.dashed,e[`dashedColor${Le(n.color)}`]]}})(({ownerState:t,theme:e})=>{const n=dR(e,t.color);return X({position:"absolute",marginTop:0,height:"100%",width:"100%"},t.color==="inherit"&&{opacity:.3},{backgroundImage:`radial-gradient(${n} 0%, ${n} 16%, transparent 42%)`,backgroundSize:"10px 10px",backgroundPosition:"0 -23px"})},v0(tD||(tD=gp`
    animation: ${0} 3s infinite linear;
  `),cse)),hse=Ke("span",{name:"MuiLinearProgress",slot:"Bar1",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.bar,e[`barColor${Le(n.color)}`],(n.variant==="indeterminate"||n.variant==="query")&&e.bar1Indeterminate,n.variant==="determinate"&&e.bar1Determinate,n.variant==="buffer"&&e.bar1Buffer]}})(({ownerState:t,theme:e})=>X({width:"100%",position:"absolute",left:0,bottom:0,top:0,transition:"transform 0.2s linear",transformOrigin:"left",backgroundColor:t.color==="inherit"?"currentColor":(e.vars||e).palette[t.color].main},t.variant==="determinate"&&{transition:`transform .${t2}s linear`},t.variant==="buffer"&&{zIndex:1,transition:`transform .${t2}s linear`}),({ownerState:t})=>(t.variant==="indeterminate"||t.variant==="query")&&v0(nD||(nD=gp`
      width: auto;
      animation: ${0} 2.1s cubic-bezier(0.65, 0.815, 0.735, 0.395) infinite;
    `),ase)),pse=Ke("span",{name:"MuiLinearProgress",slot:"Bar2",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.bar,e[`barColor${Le(n.color)}`],(n.variant==="indeterminate"||n.variant==="query")&&e.bar2Indeterminate,n.variant==="buffer"&&e.bar2Buffer]}})(({ownerState:t,theme:e})=>X({width:"100%",position:"absolute",left:0,bottom:0,top:0,transition:"transform 0.2s linear",transformOrigin:"left"},t.variant!=="buffer"&&{backgroundColor:t.color==="inherit"?"currentColor":(e.vars||e).palette[t.color].main},t.color==="inherit"&&{opacity:.3},t.variant==="buffer"&&{backgroundColor:dR(e,t.color),transition:`transform .${t2}s linear`}),({ownerState:t})=>(t.variant==="indeterminate"||t.variant==="query")&&v0(rD||(rD=gp`
      width: auto;
      animation: ${0} 2.1s cubic-bezier(0.165, 0.84, 0.44, 1) 1.15s infinite;
    `),lse)),mse=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiLinearProgress"}),{className:i,color:s="primary",value:o,valueBuffer:a,variant:l="indeterminate"}=r,c=it(r,ose),u=X({},r,{color:s,variant:l}),d=use(u),f=bU(),h={},p={bar1:{},bar2:{}};if((l==="determinate"||l==="buffer")&&o!==void 0){h["aria-valuenow"]=Math.round(o),h["aria-valuemin"]=0,h["aria-valuemax"]=100;let x=o-100;f&&(x=-x),p.bar1.transform=`translateX(${x}%)`}if(l==="buffer"&&a!==void 0){let x=(a||0)-100;f&&(x=-x),p.bar2.transform=`translateX(${x}%)`}return H.jsxs(dse,X({className:ct(d.root,i),ownerState:u,role:"progressbar"},h,{ref:n},c,{children:[l==="buffer"?H.jsx(fse,{className:d.dashed,ownerState:u}):null,H.jsx(hse,{className:d.bar1,ownerState:u,style:p.bar1}),l==="determinate"?null:H.jsx(pse,{className:d.bar2,ownerState:u,style:p.bar2})]}))}),gse=mse;function yse(t){return kt("MuiLink",t)}const vse=Bt("MuiLink",["root","underlineNone","underlineHover","underlineAlways","button","focusVisible"]),xse=vse,QU={primary:"primary.main",textPrimary:"text.primary",secondary:"secondary.main",textSecondary:"text.secondary",error:"error.main"},bse=t=>QU[t]||t,Sse=({theme:t,ownerState:e})=>{const n=bse(e.color),r=Lh(t,`palette.${n}`,!1)||e.color,i=Lh(t,`palette.${n}Channel`);return"vars"in t&&i?`rgba(${i} / 0.4)`:Tr(r,.4)},_se=["className","color","component","onBlur","onFocus","TypographyClasses","underline","variant","sx"],wse=t=>{const{classes:e,component:n,focusVisible:r,underline:i}=t,s={root:["root",`underline${Le(i)}`,n==="button"&&"button",r&&"focusVisible"]};return Ft(s,yse,e)},Cse=Ke(va,{name:"MuiLink",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,e[`underline${Le(n.underline)}`],n.component==="button"&&e.button]}})(({theme:t,ownerState:e})=>X({},e.underline==="none"&&{textDecoration:"none"},e.underline==="hover"&&{textDecoration:"none","&:hover":{textDecoration:"underline"}},e.underline==="always"&&X({textDecoration:"underline"},e.color!=="inherit"&&{textDecorationColor:Sse({theme:t,ownerState:e})},{"&:hover":{textDecorationColor:"inherit"}}),e.component==="button"&&{position:"relative",WebkitTapHighlightColor:"transparent",backgroundColor:"transparent",outline:0,border:0,margin:0,borderRadius:0,padding:0,cursor:"pointer",userSelect:"none",verticalAlign:"middle",MozAppearance:"none",WebkitAppearance:"none","&::-moz-focus-inner":{borderStyle:"none"},[`&.${xse.focusVisible}`]:{outline:"auto"}})),Ese=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiLink"}),{className:i,color:s="primary",component:o="a",onBlur:a,onFocus:l,TypographyClasses:c,underline:u="always",variant:d="inherit",sx:f}=r,h=it(r,_se),{isFocusVisibleRef:p,onBlur:x,onFocus:v,ref:y}=yU(),[b,S]=L.useState(!1),w=Wr(n,y),E=N=>{x(N),p.current===!1&&S(!1),a&&a(N)},A=N=>{v(N),p.current===!0&&S(!0),l&&l(N)},T=X({},r,{color:s,component:o,focusVisible:b,underline:u,variant:d}),I=wse(T);return H.jsx(Cse,X({color:s,className:ct(I.root,i),classes:c,component:o,onBlur:E,onFocus:A,ref:w,ownerState:T,variant:d,sx:[...Object.keys(QU).includes(s)?[]:[{color:s}],...Array.isArray(f)?f:[f]]},h))}),iD=Ese,Ase=L.createContext({}),Tse=Ase;function Mse(t){return kt("MuiList",t)}Bt("MuiList",["root","padding","dense","subheader"]);const Rse=["children","className","component","dense","disablePadding","subheader"],Ise=t=>{const{classes:e,disablePadding:n,dense:r,subheader:i}=t;return Ft({root:["root",!n&&"padding",r&&"dense",i&&"subheader"]},Mse,e)},Nse=Ke("ul",{name:"MuiList",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,!n.disablePadding&&e.padding,n.dense&&e.dense,n.subheader&&e.subheader]}})(({ownerState:t})=>X({listStyle:"none",margin:0,padding:0,position:"relative"},!t.disablePadding&&{paddingTop:8,paddingBottom:8},t.subheader&&{paddingTop:0})),Pse=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiList"}),{children:i,className:s,component:o="ul",dense:a=!1,disablePadding:l=!1,subheader:c}=r,u=it(r,Rse),d=L.useMemo(()=>({dense:a}),[a]),f=X({},r,{component:o,dense:a,disablePadding:l}),h=Ise(f);return H.jsx(Tse.Provider,{value:d,children:H.jsxs(Nse,X({as:o,className:ct(h.root,s),ref:n,ownerState:f},u,{children:[c,i]}))})}),kse=Pse,Dse=["actions","autoFocus","autoFocusItem","children","className","disabledItemsFocusable","disableListWrap","onKeyDown","variant"];function hC(t,e,n){return t===e?t.firstChild:e&&e.nextElementSibling?e.nextElementSibling:n?null:t.firstChild}function sD(t,e,n){return t===e?n?t.firstChild:t.lastChild:e&&e.previousElementSibling?e.previousElementSibling:n?null:t.lastChild}function ZU(t,e){if(e===void 0)return!0;let n=t.innerText;return n===void 0&&(n=t.textContent),n=n.trim().toLowerCase(),n.length===0?!1:e.repeating?n[0]===e.keys[0]:n.indexOf(e.keys.join(""))===0}function dm(t,e,n,r,i,s){let o=!1,a=i(t,e,e?n:!1);for(;a;){if(a===t.firstChild){if(o)return!1;o=!0}const l=r?!1:a.disabled||a.getAttribute("aria-disabled")==="true";if(!a.hasAttribute("tabindex")||!ZU(a,s)||l)a=i(t,a,n);else return a.focus(),!0}return!1}const Ose=L.forwardRef(function(e,n){const{actions:r,autoFocus:i=!1,autoFocusItem:s=!1,children:o,className:a,disabledItemsFocusable:l=!1,disableListWrap:c=!1,onKeyDown:u,variant:d="selectedMenu"}=e,f=it(e,Dse),h=L.useRef(null),p=L.useRef({keys:[],repeating:!0,previousKeyMatched:!0,lastTime:null});dd(()=>{i&&h.current.focus()},[i]),L.useImperativeHandle(r,()=>({adjustStyleForScrollbar:(S,{direction:w})=>{const E=!h.current.style.width;if(S.clientHeight<h.current.clientHeight&&E){const A=`${vU(Ts(S))}px`;h.current.style[w==="rtl"?"paddingLeft":"paddingRight"]=A,h.current.style.width=`calc(100% + ${A})`}return h.current}}),[]);const x=S=>{const w=h.current,E=S.key,A=Ts(w).activeElement;if(E==="ArrowDown")S.preventDefault(),dm(w,A,c,l,hC);else if(E==="ArrowUp")S.preventDefault(),dm(w,A,c,l,sD);else if(E==="Home")S.preventDefault(),dm(w,null,c,l,hC);else if(E==="End")S.preventDefault(),dm(w,null,c,l,sD);else if(E.length===1){const T=p.current,I=E.toLowerCase(),N=performance.now();T.keys.length>0&&(N-T.lastTime>500?(T.keys=[],T.repeating=!0,T.previousKeyMatched=!0):T.repeating&&I!==T.keys[0]&&(T.repeating=!1)),T.lastTime=N,T.keys.push(I);const M=A&&!T.repeating&&ZU(A,T);T.previousKeyMatched&&(M||dm(w,A,!1,l,hC,T))?S.preventDefault():T.previousKeyMatched=!1}u&&u(S)},v=Wr(h,n);let y=-1;L.Children.forEach(o,(S,w)=>{if(!L.isValidElement(S)){y===w&&(y+=1,y>=o.length&&(y=-1));return}S.props.disabled||(d==="selectedMenu"&&S.props.selected||y===-1)&&(y=w),y===w&&(S.props.disabled||S.props.muiSkipListHighlight||S.type.muiSkipListHighlight)&&(y+=1,y>=o.length&&(y=-1))});const b=L.Children.map(o,(S,w)=>{if(w===y){const E={};return s&&(E.autoFocus=!0),S.props.tabIndex===void 0&&d==="selectedMenu"&&(E.tabIndex=0),L.cloneElement(S,E)}return S});return H.jsx(kse,X({role:"menu",ref:v,className:a,onKeyDown:x,tabIndex:i?0:-1},f,{children:b}))}),Lse=Ose;function Bse(t){return kt("MuiPopover",t)}Bt("MuiPopover",["root","paper"]);const Fse=["onEntering"],$se=["action","anchorEl","anchorOrigin","anchorPosition","anchorReference","children","className","container","elevation","marginThreshold","open","PaperProps","slots","slotProps","transformOrigin","TransitionComponent","transitionDuration","TransitionProps","disableScrollLock"],Use=["slotProps"];function oD(t,e){let n=0;return typeof e=="number"?n=e:e==="center"?n=t.height/2:e==="bottom"&&(n=t.height),n}function aD(t,e){let n=0;return typeof e=="number"?n=e:e==="center"?n=t.width/2:e==="right"&&(n=t.width),n}function lD(t){return[t.horizontal,t.vertical].map(e=>typeof e=="number"?`${e}px`:e).join(" ")}function pC(t){return typeof t=="function"?t():t}const zse=t=>{const{classes:e}=t;return Ft({root:["root"],paper:["paper"]},Bse,e)},Gse=Ke(Jre,{name:"MuiPopover",slot:"Root",overridesResolver:(t,e)=>e.root})({}),e9=Ke(Tl,{name:"MuiPopover",slot:"Paper",overridesResolver:(t,e)=>e.paper})({position:"absolute",overflowY:"auto",overflowX:"hidden",minWidth:16,minHeight:16,maxWidth:"calc(100% - 32px)",maxHeight:"calc(100% - 32px)",outline:0}),Hse=L.forwardRef(function(e,n){var r,i,s;const o=Vt({props:e,name:"MuiPopover"}),{action:a,anchorEl:l,anchorOrigin:c={vertical:"top",horizontal:"left"},anchorPosition:u,anchorReference:d="anchorEl",children:f,className:h,container:p,elevation:x=8,marginThreshold:v=16,open:y,PaperProps:b={},slots:S,slotProps:w,transformOrigin:E={vertical:"top",horizontal:"left"},TransitionComponent:A=Uie,transitionDuration:T="auto",TransitionProps:{onEntering:I}={},disableScrollLock:N=!1}=o,M=it(o.TransitionProps,Fse),P=it(o,$se),B=(r=w==null?void 0:w.paper)!=null?r:b,F=L.useRef(),U=Wr(F,B.ref),j=X({},o,{anchorOrigin:c,anchorReference:d,elevation:x,marginThreshold:v,externalPaperSlotProps:B,transformOrigin:E,TransitionComponent:A,transitionDuration:T,TransitionProps:M}),Z=zse(j),ne=L.useCallback(()=>{if(d==="anchorPosition")return u;const ce=pC(l),Ie=(ce&&ce.nodeType===1?ce:Ts(F.current).body).getBoundingClientRect();return{top:Ie.top+oD(Ie,c.vertical),left:Ie.left+aD(Ie,c.horizontal)}},[l,c.horizontal,c.vertical,u,d]),O=L.useCallback(ce=>({vertical:oD(ce,E.vertical),horizontal:aD(ce,E.horizontal)}),[E.horizontal,E.vertical]),G=L.useCallback(ce=>{const Me={width:ce.offsetWidth,height:ce.offsetHeight},Ie=O(Me);if(d==="none")return{top:null,left:null,transformOrigin:lD(Ie)};const Oe=ne();let V=Oe.top-Ie.vertical,$=Oe.left-Ie.horizontal;const ue=V+Me.height,ye=$+Me.width,ve=fd(pC(l)),Ne=ve.innerHeight-v,nt=ve.innerWidth-v;if(v!==null&&V<v){const Ae=V-v;V-=Ae,Ie.vertical+=Ae}else if(v!==null&&ue>Ne){const Ae=ue-Ne;V-=Ae,Ie.vertical+=Ae}if(v!==null&&$<v){const Ae=$-v;$-=Ae,Ie.horizontal+=Ae}else if(ye>nt){const Ae=ye-nt;$-=Ae,Ie.horizontal+=Ae}return{top:`${Math.round(V)}px`,left:`${Math.round($)}px`,transformOrigin:lD(Ie)}},[l,d,ne,O,v]),[q,se]=L.useState(y),he=L.useCallback(()=>{const ce=F.current;if(!ce)return;const Me=G(ce);Me.top!==null&&(ce.style.top=Me.top),Me.left!==null&&(ce.style.left=Me.left),ce.style.transformOrigin=Me.transformOrigin,se(!0)},[G]);L.useEffect(()=>(N&&window.addEventListener("scroll",he),()=>window.removeEventListener("scroll",he)),[l,N,he]);const ke=(ce,Me)=>{I&&I(ce,Me),he()},re=()=>{se(!1)};L.useEffect(()=>{y&&he()}),L.useImperativeHandle(a,()=>y?{updatePosition:()=>{he()}}:null,[y,he]),L.useEffect(()=>{if(!y)return;const ce=mU(()=>{he()}),Me=fd(l);return Me.addEventListener("resize",ce),()=>{ce.clear(),Me.removeEventListener("resize",ce)}},[l,y,he]);let pe=T;T==="auto"&&!A.muiSupportAuto&&(pe=void 0);const fe=p||(l?Ts(pC(l)).body:void 0),Ee=(i=S==null?void 0:S.root)!=null?i:Gse,We=(s=S==null?void 0:S.paper)!=null?s:e9,je=Ec({elementType:We,externalSlotProps:X({},B,{style:q?B.style:X({},B.style,{opacity:0})}),additionalProps:{elevation:x,ref:U},ownerState:j,className:ct(Z.paper,B==null?void 0:B.className)}),Je=Ec({elementType:Ee,externalSlotProps:(w==null?void 0:w.root)||{},externalForwardedProps:P,additionalProps:{ref:n,slotProps:{backdrop:{invisible:!0}},container:fe,open:y},ownerState:j,className:ct(Z.root,h)}),{slotProps:te}=Je,be=it(Je,Use);return H.jsx(Ee,X({},be,!B1(Ee)&&{slotProps:te,disableScrollLock:N},{children:H.jsx(A,X({appear:!0,in:y,onEntering:ke,onExited:re,timeout:pe},M,{children:H.jsx(We,X({},je,{children:f}))}))}))}),Vse=Hse;function Wse(t){return kt("MuiMenu",t)}Bt("MuiMenu",["root","paper","list"]);const jse=["onEntering"],Xse=["autoFocus","children","className","disableAutoFocusItem","MenuListProps","onClose","open","PaperProps","PopoverClasses","transitionDuration","TransitionProps","variant","slots","slotProps"],Kse={vertical:"top",horizontal:"right"},qse={vertical:"top",horizontal:"left"},Jse=t=>{const{classes:e}=t;return Ft({root:["root"],paper:["paper"],list:["list"]},Wse,e)},Yse=Ke(Vse,{shouldForwardProp:t=>Jo(t)||t==="classes",name:"MuiMenu",slot:"Root",overridesResolver:(t,e)=>e.root})({}),Qse=Ke(e9,{name:"MuiMenu",slot:"Paper",overridesResolver:(t,e)=>e.paper})({maxHeight:"calc(100% - 96px)",WebkitOverflowScrolling:"touch"}),Zse=Ke(Lse,{name:"MuiMenu",slot:"List",overridesResolver:(t,e)=>e.list})({outline:0}),eoe=L.forwardRef(function(e,n){var r,i;const s=Vt({props:e,name:"MuiMenu"}),{autoFocus:o=!0,children:a,className:l,disableAutoFocusItem:c=!1,MenuListProps:u={},onClose:d,open:f,PaperProps:h={},PopoverClasses:p,transitionDuration:x="auto",TransitionProps:{onEntering:v}={},variant:y="selectedMenu",slots:b={},slotProps:S={}}=s,w=it(s.TransitionProps,jse),E=it(s,Xse),A=bU(),T=X({},s,{autoFocus:o,disableAutoFocusItem:c,MenuListProps:u,onEntering:v,PaperProps:h,transitionDuration:x,TransitionProps:w,variant:y}),I=Jse(T),N=o&&!c&&f,M=L.useRef(null),P=(O,G)=>{M.current&&M.current.adjustStyleForScrollbar(O,{direction:A?"rtl":"ltr"}),v&&v(O,G)},B=O=>{O.key==="Tab"&&(O.preventDefault(),d&&d(O,"tabKeyDown"))};let F=-1;L.Children.map(a,(O,G)=>{L.isValidElement(O)&&(O.props.disabled||(y==="selectedMenu"&&O.props.selected||F===-1)&&(F=G))});const U=(r=b.paper)!=null?r:Qse,j=(i=S.paper)!=null?i:h,Z=Ec({elementType:b.root,externalSlotProps:S.root,ownerState:T,className:[I.root,l]}),ne=Ec({elementType:U,externalSlotProps:j,ownerState:T,className:I.paper});return H.jsx(Yse,X({onClose:d,anchorOrigin:{vertical:"bottom",horizontal:A?"right":"left"},transformOrigin:A?Kse:qse,slots:{paper:U,root:b.root},slotProps:{root:Z,paper:ne},open:f,ref:n,transitionDuration:x,TransitionProps:X({onEntering:P},w),ownerState:T},E,{classes:p,children:H.jsx(Zse,X({onKeyDown:B,actions:M,autoFocus:o&&(F===-1||c),autoFocusItem:N,variant:y},u,{className:ct(I.list,u.className),children:a}))}))}),toe=eoe;function noe(t){return kt("MuiMobileStepper",t)}Bt("MuiMobileStepper",["root","positionBottom","positionTop","positionStatic","dots","dot","dotActive","progress"]);const roe=["activeStep","backButton","className","LinearProgressProps","nextButton","position","steps","variant"],ioe=t=>{const{classes:e,position:n}=t,r={root:["root",`position${Le(n)}`],dots:["dots"],dot:["dot"],dotActive:["dotActive"],progress:["progress"]};return Ft(r,noe,e)},soe=Ke(Tl,{name:"MuiMobileStepper",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,e[`position${Le(n.position)}`]]}})(({theme:t,ownerState:e})=>X({display:"flex",flexDirection:"row",justifyContent:"space-between",alignItems:"center",background:(t.vars||t).palette.background.default,padding:8},e.position==="bottom"&&{position:"fixed",bottom:0,left:0,right:0,zIndex:(t.vars||t).zIndex.mobileStepper},e.position==="top"&&{position:"fixed",top:0,left:0,right:0,zIndex:(t.vars||t).zIndex.mobileStepper})),ooe=Ke("div",{name:"MuiMobileStepper",slot:"Dots",overridesResolver:(t,e)=>e.dots})(({ownerState:t})=>X({},t.variant==="dots"&&{display:"flex",flexDirection:"row"})),aoe=Ke("div",{name:"MuiMobileStepper",slot:"Dot",shouldForwardProp:t=>rR(t)&&t!=="dotActive",overridesResolver:(t,e)=>{const{dotActive:n}=t;return[e.dot,n&&e.dotActive]}})(({theme:t,ownerState:e,dotActive:n})=>X({},e.variant==="dots"&&X({transition:t.transitions.create("background-color",{duration:t.transitions.duration.shortest}),backgroundColor:(t.vars||t).palette.action.disabled,borderRadius:"50%",width:8,height:8,margin:"0 2px"},n&&{backgroundColor:(t.vars||t).palette.primary.main}))),loe=Ke(gse,{name:"MuiMobileStepper",slot:"Progress",overridesResolver:(t,e)=>e.progress})(({ownerState:t})=>X({},t.variant==="progress"&&{width:"50%"})),coe=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiMobileStepper"}),{activeStep:i=0,backButton:s,className:o,LinearProgressProps:a,nextButton:l,position:c="bottom",steps:u,variant:d="dots"}=r,f=it(r,roe),h=X({},r,{activeStep:i,position:c,variant:d});let p;d==="progress"&&(u===1?p=100:p=Math.ceil(i/(u-1)*100));const x=ioe(h);return H.jsxs(soe,X({square:!0,elevation:0,className:ct(x.root,o),ref:n,ownerState:h},f,{children:[s,d==="text"&&H.jsxs(L.Fragment,{children:[i+1," / ",u]}),d==="dots"&&H.jsx(ooe,{ownerState:h,className:x.dots,children:[...new Array(u)].map((v,y)=>H.jsx(aoe,{className:ct(x.dot,y===i&&x.dotActive),ownerState:h,dotActive:y===i},y))}),d==="progress"&&H.jsx(loe,X({ownerState:h,className:x.progress,variant:"determinate",value:p},a)),l]}))}),uoe=coe;function doe(t){return kt("MuiNativeSelect",t)}const foe=Bt("MuiNativeSelect",["root","select","multiple","filled","outlined","standard","disabled","icon","iconOpen","iconFilled","iconOutlined","iconStandard","nativeInput","error"]),fR=foe,hoe=["className","disabled","error","IconComponent","inputRef","variant"],poe=t=>{const{classes:e,variant:n,disabled:r,multiple:i,open:s,error:o}=t,a={select:["select",n,r&&"disabled",i&&"multiple",o&&"error"],icon:["icon",`icon${Le(n)}`,s&&"iconOpen",r&&"disabled"]};return Ft(a,doe,e)},t9=({ownerState:t,theme:e})=>X({MozAppearance:"none",WebkitAppearance:"none",userSelect:"none",borderRadius:0,cursor:"pointer","&:focus":X({},e.vars?{backgroundColor:`rgba(${e.vars.palette.common.onBackgroundChannel} / 0.05)`}:{backgroundColor:e.palette.mode==="light"?"rgba(0, 0, 0, 0.05)":"rgba(255, 255, 255, 0.05)"},{borderRadius:0}),"&::-ms-expand":{display:"none"},[`&.${fR.disabled}`]:{cursor:"default"},"&[multiple]":{height:"auto"},"&:not([multiple]) option, &:not([multiple]) optgroup":{backgroundColor:(e.vars||e).palette.background.paper},"&&&":{paddingRight:24,minWidth:16}},t.variant==="filled"&&{"&&&":{paddingRight:32}},t.variant==="outlined"&&{borderRadius:(e.vars||e).shape.borderRadius,"&:focus":{borderRadius:(e.vars||e).shape.borderRadius},"&&&":{paddingRight:32}}),moe=Ke("select",{name:"MuiNativeSelect",slot:"Select",shouldForwardProp:Jo,overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.select,e[n.variant],n.error&&e.error,{[`&.${fR.multiple}`]:e.multiple}]}})(t9),n9=({ownerState:t,theme:e})=>X({position:"absolute",right:0,top:"calc(50% - .5em)",pointerEvents:"none",color:(e.vars||e).palette.action.active,[`&.${fR.disabled}`]:{color:(e.vars||e).palette.action.disabled}},t.open&&{transform:"rotate(180deg)"},t.variant==="filled"&&{right:7},t.variant==="outlined"&&{right:7}),goe=Ke("svg",{name:"MuiNativeSelect",slot:"Icon",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.icon,n.variant&&e[`icon${Le(n.variant)}`],n.open&&e.iconOpen]}})(n9),yoe=L.forwardRef(function(e,n){const{className:r,disabled:i,error:s,IconComponent:o,inputRef:a,variant:l="standard"}=e,c=it(e,hoe),u=X({},e,{disabled:i,variant:l,error:s}),d=poe(u);return H.jsxs(L.Fragment,{children:[H.jsx(moe,X({ownerState:u,className:ct(d.select,r),disabled:i,ref:a||n},c)),e.multiple?null:H.jsx(goe,{as:o,ownerState:u,className:d.icon})]})}),voe=yoe;var cD;const xoe=["children","classes","className","label","notched"],boe=Ke("fieldset",{shouldForwardProp:Jo})({textAlign:"left",position:"absolute",bottom:0,right:0,top:-5,left:0,margin:0,padding:"0 8px",pointerEvents:"none",borderRadius:"inherit",borderStyle:"solid",borderWidth:1,overflow:"hidden",minWidth:"0%"}),Soe=Ke("legend",{shouldForwardProp:Jo})(({ownerState:t,theme:e})=>X({float:"unset",width:"auto",overflow:"hidden"},!t.withLabel&&{padding:0,lineHeight:"11px",transition:e.transitions.create("width",{duration:150,easing:e.transitions.easing.easeOut})},t.withLabel&&X({display:"block",padding:0,height:11,fontSize:"0.75em",visibility:"hidden",maxWidth:.01,transition:e.transitions.create("max-width",{duration:50,easing:e.transitions.easing.easeOut}),whiteSpace:"nowrap","& > span":{paddingLeft:5,paddingRight:5,display:"inline-block",opacity:0,visibility:"visible"}},t.notched&&{maxWidth:"100%",transition:e.transitions.create("max-width",{duration:100,easing:e.transitions.easing.easeOut,delay:50})})));function _oe(t){const{className:e,label:n,notched:r}=t,i=it(t,xoe),s=n!=null&&n!=="",o=X({},t,{notched:r,withLabel:s});return H.jsx(boe,X({"aria-hidden":!0,className:e,ownerState:o},i,{children:H.jsx(Soe,{ownerState:o,children:s?H.jsx("span",{children:n}):cD||(cD=H.jsx("span",{className:"notranslate",children:"​"}))})}))}const woe=["components","fullWidth","inputComponent","label","multiline","notched","slots","type"],Coe=t=>{const{classes:e}=t,r=Ft({root:["root"],notchedOutline:["notchedOutline"],input:["input"]},yne,e);return X({},e,r)},Eoe=Ke(SS,{shouldForwardProp:t=>Jo(t)||t==="classes",name:"MuiOutlinedInput",slot:"Root",overridesResolver:xS})(({theme:t,ownerState:e})=>{const n=t.palette.mode==="light"?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return X({position:"relative",borderRadius:(t.vars||t).shape.borderRadius,[`&:hover .${Hl.notchedOutline}`]:{borderColor:(t.vars||t).palette.text.primary},"@media (hover: none)":{[`&:hover .${Hl.notchedOutline}`]:{borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:n}},[`&.${Hl.focused} .${Hl.notchedOutline}`]:{borderColor:(t.vars||t).palette[e.color].main,borderWidth:2},[`&.${Hl.error} .${Hl.notchedOutline}`]:{borderColor:(t.vars||t).palette.error.main},[`&.${Hl.disabled} .${Hl.notchedOutline}`]:{borderColor:(t.vars||t).palette.action.disabled}},e.startAdornment&&{paddingLeft:14},e.endAdornment&&{paddingRight:14},e.multiline&&X({padding:"16.5px 14px"},e.size==="small"&&{padding:"8.5px 14px"}))}),Aoe=Ke(_oe,{name:"MuiOutlinedInput",slot:"NotchedOutline",overridesResolver:(t,e)=>e.notchedOutline})(({theme:t})=>{const e=t.palette.mode==="light"?"rgba(0, 0, 0, 0.23)":"rgba(255, 255, 255, 0.23)";return{borderColor:t.vars?`rgba(${t.vars.palette.common.onBackgroundChannel} / 0.23)`:e}}),Toe=Ke(_S,{name:"MuiOutlinedInput",slot:"Input",overridesResolver:bS})(({theme:t,ownerState:e})=>X({padding:"16.5px 14px"},!t.vars&&{"&:-webkit-autofill":{WebkitBoxShadow:t.palette.mode==="light"?null:"0 0 0 100px #266798 inset",WebkitTextFillColor:t.palette.mode==="light"?null:"#fff",caretColor:t.palette.mode==="light"?null:"#fff",borderRadius:"inherit"}},t.vars&&{"&:-webkit-autofill":{borderRadius:"inherit"},[t.getColorSchemeSelector("dark")]:{"&:-webkit-autofill":{WebkitBoxShadow:"0 0 0 100px #266798 inset",WebkitTextFillColor:"#fff",caretColor:"#fff"}}},e.size==="small"&&{padding:"8.5px 14px"},e.multiline&&{padding:0},e.startAdornment&&{paddingLeft:0},e.endAdornment&&{paddingRight:0})),r9=L.forwardRef(function(e,n){var r,i,s,o,a;const l=Vt({props:e,name:"MuiOutlinedInput"}),{components:c={},fullWidth:u=!1,inputComponent:d="input",label:f,multiline:h=!1,notched:p,slots:x={},type:v="text"}=l,y=it(l,woe),b=Coe(l),S=Id(),w=mp({props:l,muiFormControl:S,states:["color","disabled","error","focused","hiddenLabel","size","required"]}),E=X({},l,{color:w.color||"primary",disabled:w.disabled,error:w.error,focused:w.focused,formControl:S,fullWidth:u,hiddenLabel:w.hiddenLabel,multiline:h,size:w.size,type:v}),A=(r=(i=x.root)!=null?i:c.Root)!=null?r:Eoe,T=(s=(o=x.input)!=null?o:c.Input)!=null?s:Toe;return H.jsx(uR,X({slots:{root:A,input:T},renderSuffix:I=>H.jsx(Aoe,{ownerState:E,className:b.notchedOutline,label:f!=null&&f!==""&&w.required?a||(a=H.jsxs(L.Fragment,{children:[f," ","*"]})):f,notched:typeof p<"u"?p:!!(I.startAdornment||I.filled||I.focused)}),fullWidth:u,inputComponent:d,multiline:h,ref:n,type:v},y,{classes:X({},b,{notchedOutline:null})}))});r9.muiName="Input";const i9=r9;function Moe(t){return kt("MuiSelect",t)}const fm=Bt("MuiSelect",["root","select","multiple","filled","outlined","standard","disabled","focused","icon","iconOpen","iconFilled","iconOutlined","iconStandard","nativeInput","error"]);var uD;const Roe=["aria-describedby","aria-label","autoFocus","autoWidth","children","className","defaultOpen","defaultValue","disabled","displayEmpty","error","IconComponent","inputRef","labelId","MenuProps","multiple","name","onBlur","onChange","onClose","onFocus","onOpen","open","readOnly","renderValue","SelectDisplayProps","tabIndex","type","value","variant"],Ioe=Ke("div",{name:"MuiSelect",slot:"Select",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[{[`&.${fm.select}`]:e.select},{[`&.${fm.select}`]:e[n.variant]},{[`&.${fm.error}`]:e.error},{[`&.${fm.multiple}`]:e.multiple}]}})(t9,{[`&.${fm.select}`]:{height:"auto",minHeight:"1.4375em",textOverflow:"ellipsis",whiteSpace:"nowrap",overflow:"hidden"}}),Noe=Ke("svg",{name:"MuiSelect",slot:"Icon",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.icon,n.variant&&e[`icon${Le(n.variant)}`],n.open&&e.iconOpen]}})(n9),Poe=Ke("input",{shouldForwardProp:t=>rR(t)&&t!=="classes",name:"MuiSelect",slot:"NativeInput",overridesResolver:(t,e)=>e.nativeInput})({bottom:0,left:0,position:"absolute",opacity:0,pointerEvents:"none",width:"100%",boxSizing:"border-box"});function dD(t,e){return typeof e=="object"&&e!==null?t===e:String(t)===String(e)}function koe(t){return t==null||typeof t=="string"&&!t.trim()}const Doe=t=>{const{classes:e,variant:n,disabled:r,multiple:i,open:s,error:o}=t,a={select:["select",n,r&&"disabled",i&&"multiple",o&&"error"],icon:["icon",`icon${Le(n)}`,s&&"iconOpen",r&&"disabled"],nativeInput:["nativeInput"]};return Ft(a,Moe,e)},Ooe=L.forwardRef(function(e,n){var r;const{"aria-describedby":i,"aria-label":s,autoFocus:o,autoWidth:a,children:l,className:c,defaultOpen:u,defaultValue:d,disabled:f,displayEmpty:h,error:p=!1,IconComponent:x,inputRef:v,labelId:y,MenuProps:b={},multiple:S,name:w,onBlur:E,onChange:A,onClose:T,onFocus:I,onOpen:N,open:M,readOnly:P,renderValue:B,SelectDisplayProps:F={},tabIndex:U,value:j,variant:Z="standard"}=e,ne=it(e,Roe),[O,G]=XA({controlled:j,default:d,name:"Select"}),[q,se]=XA({controlled:M,default:u,name:"Select"}),he=L.useRef(null),ke=L.useRef(null),[re,pe]=L.useState(null),{current:fe}=L.useRef(M!=null),[Ee,We]=L.useState(),je=Wr(n,v),Je=L.useCallback(Ge=>{ke.current=Ge,Ge&&pe(Ge)},[]),te=re==null?void 0:re.parentNode;L.useImperativeHandle(je,()=>({focus:()=>{ke.current.focus()},node:he.current,value:O}),[O]),L.useEffect(()=>{u&&q&&re&&!fe&&(We(a?null:te.clientWidth),ke.current.focus())},[re,a]),L.useEffect(()=>{o&&ke.current.focus()},[o]),L.useEffect(()=>{if(!y)return;const Ge=Ts(ke.current).getElementById(y);if(Ge){const yt=()=>{getSelection().isCollapsed&&ke.current.focus()};return Ge.addEventListener("click",yt),()=>{Ge.removeEventListener("click",yt)}}},[y]);const be=(Ge,yt)=>{Ge?N&&N(yt):T&&T(yt),fe||(We(a?null:te.clientWidth),se(Ge))},ce=Ge=>{Ge.button===0&&(Ge.preventDefault(),ke.current.focus(),be(!0,Ge))},Me=Ge=>{be(!1,Ge)},Ie=L.Children.toArray(l),Oe=Ge=>{const yt=Ie.find(_t=>_t.props.value===Ge.target.value);yt!==void 0&&(G(yt.props.value),A&&A(Ge,yt))},V=Ge=>yt=>{let _t;if(yt.currentTarget.hasAttribute("tabindex")){if(S){_t=Array.isArray(O)?O.slice():[];const ie=O.indexOf(Ge.props.value);ie===-1?_t.push(Ge.props.value):_t.splice(ie,1)}else _t=Ge.props.value;if(Ge.props.onClick&&Ge.props.onClick(yt),O!==_t&&(G(_t),A)){const ie=yt.nativeEvent||yt,_e=new ie.constructor(ie.type,ie);Object.defineProperty(_e,"target",{writable:!0,value:{value:_t,name:w}}),A(_e,Ge)}S||be(!1,yt)}},$=Ge=>{P||[" ","ArrowUp","ArrowDown","Enter"].indexOf(Ge.key)!==-1&&(Ge.preventDefault(),be(!0,Ge))},ue=re!==null&&q,ye=Ge=>{!ue&&E&&(Object.defineProperty(Ge,"target",{writable:!0,value:{value:O,name:w}}),E(Ge))};delete ne["aria-invalid"];let ve,Ne;const nt=[];let Ae=!1;(F1({value:O})||h)&&(B?ve=B(O):Ae=!0);const st=Ie.map(Ge=>{if(!L.isValidElement(Ge))return null;let yt;if(S){if(!Array.isArray(O))throw new Error(cd(2));yt=O.some(_t=>dD(_t,Ge.props.value)),yt&&Ae&&nt.push(Ge.props.children)}else yt=dD(O,Ge.props.value),yt&&Ae&&(Ne=Ge.props.children);return L.cloneElement(Ge,{"aria-selected":yt?"true":"false",onClick:V(Ge),onKeyUp:_t=>{_t.key===" "&&_t.preventDefault(),Ge.props.onKeyUp&&Ge.props.onKeyUp(_t)},role:"option",selected:yt,value:void 0,"data-value":Ge.props.value})});Ae&&(S?nt.length===0?ve=null:ve=nt.reduce((Ge,yt,_t)=>(Ge.push(yt),_t<nt.length-1&&Ge.push(", "),Ge),[]):ve=Ne);let ht=Ee;!a&&fe&&re&&(ht=te.clientWidth);let Ue;typeof U<"u"?Ue=U:Ue=f?null:0;const Fe=F.id||(w?`mui-component-select-${w}`:void 0),$e=X({},e,{variant:Z,value:O,open:ue,error:p}),Ze=Doe($e),ot=X({},b.PaperProps,(r=b.slotProps)==null?void 0:r.paper),Pt=gU();return H.jsxs(L.Fragment,{children:[H.jsx(Ioe,X({ref:Je,tabIndex:Ue,role:"combobox","aria-controls":Pt,"aria-disabled":f?"true":void 0,"aria-expanded":ue?"true":"false","aria-haspopup":"listbox","aria-label":s,"aria-labelledby":[y,Fe].filter(Boolean).join(" ")||void 0,"aria-describedby":i,onKeyDown:$,onMouseDown:f||P?null:ce,onBlur:ye,onFocus:I},F,{ownerState:$e,className:ct(F.className,Ze.select,c),id:Fe,children:koe(ve)?uD||(uD=H.jsx("span",{className:"notranslate",children:"​"})):ve})),H.jsx(Poe,X({"aria-invalid":p,value:Array.isArray(O)?O.join(","):O,name:w,ref:he,"aria-hidden":!0,onChange:Oe,tabIndex:-1,disabled:f,className:Ze.nativeInput,autoFocus:o,ownerState:$e},ne)),H.jsx(Noe,{as:x,className:Ze.icon,ownerState:$e}),H.jsx(toe,X({id:`menu-${w||""}`,anchorEl:te,open:ue,onClose:Me,anchorOrigin:{vertical:"bottom",horizontal:"center"},transformOrigin:{vertical:"top",horizontal:"center"}},b,{MenuListProps:X({"aria-labelledby":y,role:"listbox","aria-multiselectable":S?"true":void 0,disableListWrap:!0,id:Pt},b.MenuListProps),slotProps:X({},b.slotProps,{paper:X({},ot,{style:X({minWidth:ht},ot!=null?ot.style:null)})}),children:st}))]})}),Loe=Ooe,Boe=["autoWidth","children","classes","className","defaultOpen","displayEmpty","IconComponent","id","input","inputProps","label","labelId","MenuProps","multiple","native","onClose","onOpen","open","renderValue","SelectDisplayProps","variant"],Foe=["root"],$oe=t=>{const{classes:e}=t;return e},hR={name:"MuiSelect",overridesResolver:(t,e)=>e.root,shouldForwardProp:t=>Jo(t)&&t!=="variant",slot:"Root"},Uoe=Ke(YU,hR)(""),zoe=Ke(i9,hR)(""),Goe=Ke(XU,hR)(""),s9=L.forwardRef(function(e,n){const r=Vt({name:"MuiSelect",props:e}),{autoWidth:i=!1,children:s,classes:o={},className:a,defaultOpen:l=!1,displayEmpty:c=!1,IconComponent:u=Sne,id:d,input:f,inputProps:h,label:p,labelId:x,MenuProps:v,multiple:y=!1,native:b=!1,onClose:S,onOpen:w,open:E,renderValue:A,SelectDisplayProps:T,variant:I="outlined"}=r,N=it(r,Boe),M=b?voe:Loe,P=Id(),B=mp({props:r,muiFormControl:P,states:["variant","error"]}),F=B.variant||I,U=X({},r,{variant:F,classes:o}),j=$oe(U),Z=it(j,Foe),ne=f||{standard:H.jsx(Uoe,{ownerState:U}),outlined:H.jsx(zoe,{label:p,ownerState:U}),filled:H.jsx(Goe,{ownerState:U})}[F],O=Wr(n,ne.ref);return H.jsx(L.Fragment,{children:L.cloneElement(ne,X({inputComponent:M,inputProps:X({children:s,error:B.error,IconComponent:u,variant:F,type:void 0,multiple:y},b?{id:d}:{autoWidth:i,defaultOpen:l,displayEmpty:c,labelId:x,MenuProps:v,onClose:S,onOpen:w,open:E,renderValue:A,SelectDisplayProps:X({id:d},T)},h,{classes:h?Bi(Z,h.classes):Z},f?f.props.inputProps:{})},(y&&b||c)&&F==="outlined"?{notched:!0}:{},{ref:O,className:ct(ne.props.className,a,j.root)},!f&&{variant:F},N))})});s9.muiName="Select";const Hoe=s9;function Voe(t){return kt("MuiToolbar",t)}Bt("MuiToolbar",["root","gutters","regular","dense"]);const Woe=["className","component","disableGutters","variant"],joe=t=>{const{classes:e,disableGutters:n,variant:r}=t;return Ft({root:["root",!n&&"gutters",r]},Voe,e)},Xoe=Ke("div",{name:"MuiToolbar",slot:"Root",overridesResolver:(t,e)=>{const{ownerState:n}=t;return[e.root,!n.disableGutters&&e.gutters,e[n.variant]]}})(({theme:t,ownerState:e})=>X({position:"relative",display:"flex",alignItems:"center"},!e.disableGutters&&{paddingLeft:t.spacing(2),paddingRight:t.spacing(2),[t.breakpoints.up("sm")]:{paddingLeft:t.spacing(3),paddingRight:t.spacing(3)}},e.variant==="dense"&&{minHeight:48}),({theme:t,ownerState:e})=>e.variant==="regular"&&t.mixins.toolbar),Koe=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiToolbar"}),{className:i,component:s="div",disableGutters:o=!1,variant:a="regular"}=r,l=it(r,Woe),c=X({},r,{component:s,disableGutters:o,variant:a}),u=joe(c);return H.jsx(Xoe,X({as:s,className:ct(u.root,i),ref:n,ownerState:c},l))}),qoe=Koe;function Joe(t){return kt("MuiTextField",t)}Bt("MuiTextField",["root"]);const Yoe=["autoComplete","autoFocus","children","className","color","defaultValue","disabled","error","FormHelperTextProps","fullWidth","helperText","id","InputLabelProps","inputProps","InputProps","inputRef","label","maxRows","minRows","multiline","name","onBlur","onChange","onFocus","placeholder","required","rows","select","SelectProps","type","value","variant"],Qoe={standard:YU,filled:XU,outlined:i9},Zoe=t=>{const{classes:e}=t;return Ft({root:["root"]},Joe,e)},eae=Ke(oie,{name:"MuiTextField",slot:"Root",overridesResolver:(t,e)=>e.root})({}),tae=L.forwardRef(function(e,n){const r=Vt({props:e,name:"MuiTextField"}),{autoComplete:i,autoFocus:s=!1,children:o,className:a,color:l="primary",defaultValue:c,disabled:u=!1,error:d=!1,FormHelperTextProps:f,fullWidth:h=!1,helperText:p,id:x,InputLabelProps:v,inputProps:y,InputProps:b,inputRef:S,label:w,maxRows:E,minRows:A,multiline:T=!1,name:I,onBlur:N,onChange:M,onFocus:P,placeholder:B,required:F=!1,rows:U,select:j=!1,SelectProps:Z,type:ne,value:O,variant:G="outlined"}=r,q=it(r,Yoe),se=X({},r,{autoFocus:s,color:l,disabled:u,error:d,fullWidth:h,multiline:T,required:F,select:j,variant:G}),he=Zoe(se),ke={};G==="outlined"&&(v&&typeof v.shrink<"u"&&(ke.notched=v.shrink),ke.label=w),j&&((!Z||!Z.native)&&(ke.id=void 0),ke["aria-describedby"]=void 0);const re=gU(x),pe=p&&re?`${re}-helper-text`:void 0,fe=w&&re?`${re}-label`:void 0,Ee=Qoe[G],We=H.jsx(Ee,X({"aria-describedby":pe,autoComplete:i,autoFocus:s,defaultValue:c,fullWidth:h,multiline:T,name:I,rows:U,maxRows:E,minRows:A,type:ne,value:O,id:re,inputRef:S,onBlur:N,onChange:M,onFocus:P,placeholder:B,inputProps:y},ke,b));return H.jsxs(eae,X({className:ct(he.root,a),disabled:u,error:d,fullWidth:h,ref:n,required:F,color:l,variant:G,ownerState:se},q,{children:[w!=null&&w!==""&&H.jsx(ise,X({htmlFor:re,id:fe},v,{children:w})),j?H.jsx(Hoe,X({"aria-describedby":pe,id:re,labelId:fe,value:O,input:We},Z,{children:o})):We,p&&H.jsx(pie,X({id:pe},f,{children:p}))]}))}),nae=tae,rae=()=>{const t=m0(),e=()=>{},n=()=>{t("/products")};return H.jsx(Tl,{sx:{position:"fixed",top:0,left:0,right:0},children:H.jsxs(jx,{sx:{display:"flex",flexDirection:"column",justifyContent:"center",alignItems:"center",height:"100vh",background:"linear-gradient(135deg, #FF8F1C, #FFF)",color:"#FFF"},maxWidth:!1,children:[H.jsxs(va,{variant:"h2",component:"h1",gutterBottom:!0,sx:{textAlign:"center",marginBottom:"100px"},children:[H.jsx("strong",{children:"AR"}),"dverts"]}),H.jsx(xh,{variant:"contained",onClick:e,sx:{backgroundColor:"#fff",color:"#FF8F1C",padding:"15px 30px",borderRadius:"50px",marginBottom:"20px",textTransform:"none","&:hover":{backgroundColor:"#fff"}},children:H.jsx("strong",{children:"I want Sell"})}),H.jsx(xh,{variant:"contained",onClick:n,sx:{background:"#FF8F1C",color:"#fff",padding:"15px 30px",borderRadius:"50px",textTransform:"none","&:hover":{backgroundColor:"#FF8F1C"}},children:H.jsx("strong",{children:"I want Buy"})})]})})},fD=Os(H.jsx("path",{d:"M16.59 8.59 12 13.17 7.41 8.59 6 10l6 6 6-6z"}),"ExpandMore"),o9=Os(H.jsx("path",{d:"m12 21.35-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54z"}),"Favorite"),iae=Os(H.jsx("path",{d:"M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"}),"Home"),mC=Os(H.jsx("path",{d:"M15.41 16.59 10.83 12l4.58-4.59L14 6l-6 6 6 6z"}),"KeyboardArrowLeft"),hD=Os(H.jsx("path",{d:"M8.59 16.59 13.17 12 8.59 7.41 10 6l6 6-6 6z"}),"KeyboardArrowRight"),sae=Os(H.jsx("path",{d:"M7 9H2V7h5zm0 3H2v2h5zm13.59 7-3.83-3.83c-.8.52-1.74.83-2.76.83-2.76 0-5-2.24-5-5s2.24-5 5-5 5 2.24 5 5c0 1.02-.31 1.96-.83 2.75L22 17.59zM17 11c0-1.65-1.35-3-3-3s-3 1.35-3 3 1.35 3 3 3 3-1.35 3-3M2 19h10v-2H2z"}),"ManageSearch"),oae=Os(H.jsx("path",{d:"M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2m1.41 16.09V20h-2.67v-1.93c-1.71-.36-3.16-1.46-3.27-3.4h1.96c.1 1.05.82 1.87 2.65 1.87 1.96 0 2.4-.98 2.4-1.59 0-.83-.44-1.61-2.67-2.14-2.48-.6-4.18-1.62-4.18-3.67 0-1.72 1.39-2.84 3.11-3.21V4h2.67v1.95c1.86.45 2.79 1.86 2.85 3.39H14.3c-.05-1.11-.64-1.87-2.22-1.87-1.5 0-2.4.68-2.4 1.64 0 .84.65 1.39 2.67 1.91s4.18 1.39 4.18 3.91c-.01 1.83-1.38 2.83-3.12 3.16"}),"MonetizationOn"),aae=Os(H.jsx("path",{d:"M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4m0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4"}),"Person"),lae=Os(H.jsx("path",{d:"M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14"}),"Search"),cae=Os(H.jsx("path",{d:"M7 18c-1.1 0-1.99.9-1.99 2S5.9 22 7 22s2-.9 2-2-.9-2-2-2M1 2v2h2l3.6 7.59-1.35 2.45c-.16.28-.25.61-.25.96 0 1.1.9 2 2 2h12v-2H7.42c-.14 0-.25-.11-.25-.25l.03-.12.9-1.63h7.45c.75 0 1.41-.41 1.75-1.03l3.58-6.49c.08-.14.12-.31.12-.48 0-.55-.45-1-1-1H5.21l-.94-2zm16 16c-1.1 0-1.99.9-1.99 2s.89 2 1.99 2 2-.9 2-2-.9-2-2-2"}),"ShoppingCart"),uae=Os(H.jsx("path",{d:"m18.25 7.6-5.5-3.18c-.46-.27-1.04-.27-1.5 0L5.75 7.6c-.46.27-.75.76-.75 1.3v6.35c0 .54.29 1.03.75 1.3l5.5 3.18c.46.27 1.04.27 1.5 0l5.5-3.18c.46-.27.75-.76.75-1.3V8.9c0-.54-.29-1.03-.75-1.3M7 14.96v-4.62l4 2.32v4.61zm5-4.03L8 8.61l4-2.31 4 2.31zm1 6.34v-4.61l4-2.32v4.62zM7 2H3.5C2.67 2 2 2.67 2 3.5V7h2V4h3zm10 0h3.5c.83 0 1.5.67 1.5 1.5V7h-2V4h-3zM7 22H3.5c-.83 0-1.5-.67-1.5-1.5V17h2v3h3zm10 0h3.5c.83 0 1.5-.67 1.5-1.5V17h-2v3h-3z"}),"ViewInAr"),a9=()=>{const[t,e]=L.useState(0);return H.jsx(Tl,{sx:{position:"fixed",bottom:0,left:0,right:0},elevation:3,children:H.jsxs(jne,{showLabels:!0,value:t,onChange:(n,r)=>e(r),children:[H.jsx(cm,{component:iD,to:"/",label:"Home",icon:H.jsx(iae,{})}),H.jsx(cm,{label:"Category",icon:H.jsx(sae,{})}),H.jsx(cm,{label:"Sell",icon:H.jsx(oae,{})}),H.jsx(cm,{label:"Favourites",icon:H.jsx(o9,{})}),H.jsx(cm,{component:iD,to:"/profile",label:"Me",icon:H.jsx(aae,{})})]})})},dae=()=>H.jsx(nae,{id:"input-with-icon-textfield",placeholder:"Search for items, members...",InputProps:{endAdornment:H.jsx(Qie,{position:"end",children:H.jsx(lae,{})})},variant:"outlined",fullWidth:!0,sx:{p:"10px 32px","& .MuiOutlinedInput-root":{color:"#FFF","& .MuiOutlinedInput-notchedOutline":{borderColor:"#FFF",borderWidth:"2px"}}}}),fae=()=>{const t=m0();return H.jsx(Tl,{sx:{position:"fixed",top:0,left:0,right:0,zIndex:10},elevation:3,children:H.jsx(Mte,{sx:{background:"#FF8F1C"},children:H.jsxs(qoe,{children:[H.jsx(va,{variant:"h4",component:"h1",translate:"no",onClick:()=>{t("/")},children:"AR"}),H.jsx(dae,{}),H.jsx(cR,{color:"inherit",children:H.jsx(Une,{badgeContent:4,color:"error",children:H.jsx(cae,{})})})]})})})},pR=[{id:1,name:"Superdry Sunglasses",description:"Superdry sunglasses in very good condition.",additionalInfo:"Used only few times, comes with case.",price:"€15.00",category:"accessory",size:"N/A",type:"glasses",images:[{imgPath:"../../assets/images/glasses/sunglasses.png",label:"Superdry Sunglasses"}]},{id:2,name:"Ray-ban Sunglasses",description:"Ray-ban sunglasses aviator.",additionalInfo:"Very good condition, mirrored sunglasses.",price:"€50.00",category:"accessory",size:"N/A",type:"glasses",images:[{imgPath:"../../assets/images/glasses/sunglasses2.png",label:"Ray-ban Sunglasses"}]},{id:3,name:"Generic Sunglasses",description:"Generic sunglasses, never used.",additionalInfo:"Unwanted gift, no brand.",price:"€5.00",category:"accessory",size:"N/A",type:"glasses",images:[{imgPath:"../../assets/images/glasses/sunglasses3.png",label:"Generic Sunglasses"}]},{id:4,name:"Reading Glasses",description:"Reading glasses brand new.",additionalInfo:"Never used, comes with case.",price:"€10.00",category:"accessory",size:"N/A",type:"glasses",images:[{imgPath:"../../assets/images/glasses/glasses.png",label:"Glasses"}]},{id:5,name:"Headphones",description:"Headphones in good condition.",additionalInfo:"Used only few times, comes with case and cables.",price:"€20.00",category:"accessory",size:"N/A",type:"headphones",images:[{imgPath:"../../assets/images/headphones/headphones1.png",label:"Headphones1"},{imgPath:"../../assets/images/headphones/headphones2.png",label:"Headphones2"},{imgPath:"../../assets/images/headphones/headphones3.png",label:"Headphones3"},{imgPath:"../../assets/images/headphones/headphones4.png",label:"Headphones4"}]},{id:6,name:"6",description:"Superdry sunglasses in very good condition.",additionalInfo:"Used only few times, comes with case.",price:"€15.00",category:"accessory",size:"N/A",images:[{imgPath:"../../assets/images/glasses/sunglasses.png",label:""}]},{id:7,name:"7",description:"Superdry sunglasses in very good condition.",additionalInfo:"Used only few times, comes with case.",price:"€15.00",category:"accessory",size:"N/A",images:[{imgPath:"../../assets/images/glasses/sunglasses.png",label:""}]},{id:8,name:"8",description:"Superdry sunglasses in very good condition.",additionalInfo:"Used only few times, comes with case.",price:"€15.00",category:"accessory",size:"N/A",images:[{imgPath:"../../assets/images/glasses/sunglasses.png",label:""}]},{id:9,name:"9",description:"Superdry sunglasses in very good condition.",additionalInfo:"Used only few times, comes with case.",price:"€15.00",category:"accessory",size:"N/A",images:[{imgPath:"../../assets/images/glasses/sunglasses.png",label:""}]}],hae=({item:t})=>{const{id:e,name:n,images:r,price:i,size:s}=t;return H.jsx(bre,{style:{marginBottom:"8px"},children:H.jsxs(Mre,{component:Rq,to:`/products/${e}`,children:[H.jsx(Gre,{component:"img",loading:"lazy",src:new URL(r[0].imgPath,import.meta.url).href,title:n}),H.jsxs(Dre,{children:[H.jsx(ku,{direction:"row",children:H.jsx(va,{gutterBottom:!0,variant:"h6",color:"textPrimary",children:n})}),H.jsxs(ku,{direction:"row",justifyContent:"space-between",alignItems:"center",children:[H.jsx(va,{variant:"h7",color:"textPrimary",children:i}),H.jsx(HU,{label:`Size: ${s}`,variant:"filled",size:"small"})]})]})]})},e)},pae=()=>H.jsx("div",{style:{marginTop:"80px"},children:H.jsx(qk,{container:!0,spacing:{xs:2,md:3},children:pR.map(t=>H.jsx(qk,{item:!0,xs:6,sm:4,md:4,children:H.jsx(hae,{item:t})},t.id))})}),mae=()=>H.jsxs(H.Fragment,{children:[H.jsx(fae,{}),H.jsx(pae,{}),H.jsx(a9,{})]});var l9={};function gae(t){if(t&&t.__esModule)return t;var e={};if(t!=null){for(var n in t)if(Object.prototype.hasOwnProperty.call(t,n)){var r=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(t,n):{};r.get||r.set?Object.defineProperty(e,n,r):e[n]=t[n]}}return e.default=t,e}var c9=gae,Ga={},gC,pD;function yae(){if(pD)return gC;pD=1;function t(e){return e&&e.__esModule?e:{default:e}}return gC=t,gC}var xv,mD;function vae(){if(mD)return xv;mD=1;function t(){return xv=t=Object.assign||function(e){for(var n=1;n<arguments.length;n++){var r=arguments[n];for(var i in r)Object.prototype.hasOwnProperty.call(r,i)&&(e[i]=r[i])}return e},t.apply(this,arguments)}return xv=t,xv}var yC,gD;function xae(){if(gD)return yC;gD=1;function t(e,n){if(e==null)return{};var r={},i=Object.keys(e),s,o;for(o=0;o<i.length;o++)s=i[o],!(n.indexOf(s)>=0)&&(r[s]=e[s]);return r}return yC=t,yC}var vC,yD;function bae(){if(yD)return vC;yD=1;var t=xae();function e(n,r){if(n==null)return{};var i=t(n,r),s,o;if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);for(o=0;o<a.length;o++)s=a[o],!(r.indexOf(s)>=0)&&Object.prototype.propertyIsEnumerable.call(n,s)&&(i[s]=n[s])}return i}return vC=e,vC}var xC,vD;function Sae(){if(vD)return xC;vD=1;function t(e,n){if(!(e instanceof n))throw new TypeError("Cannot call a class as a function")}return xC=t,xC}var bC,xD;function _ae(){if(xD)return bC;xD=1;function t(n,r){for(var i=0;i<r.length;i++){var s=r[i];s.enumerable=s.enumerable||!1,s.configurable=!0,"value"in s&&(s.writable=!0),Object.defineProperty(n,s.key,s)}}function e(n,r,i){return r&&t(n.prototype,r),i&&t(n,i),n}return bC=e,bC}var bv,bD;function wae(){if(bD)return bv;bD=1;function t(e,n){return bv=t=Object.setPrototypeOf||function(i,s){return i.__proto__=s,i},t(e,n)}return bv=t,bv}var SC,SD;function Cae(){if(SD)return SC;SD=1;var t=wae();function e(n,r){if(typeof r!="function"&&r!==null)throw new TypeError("Super expression must either be null or a function");n.prototype=Object.create(r&&r.prototype,{constructor:{value:n,writable:!0,configurable:!0}}),r&&t(n,r)}return SC=e,SC}var _C,_D;function u9(){if(_D)return _C;_D=1;var t=function(){};return _C=t,_C}var wC={},CC,wD;function wS(){if(wD)return CC;wD=1;function t(e){return e&&e.__esModule?e:{default:e}}return CC=t,CC}var hm={},CD;function Eae(){if(CD)return hm;CD=1;var t=wS();Object.defineProperty(hm,"__esModule",{value:!0}),hm.default=void 0;var e=t(L);t(u9());var n=function(s){s.index;var o=s.children;e.default.Children.count(o)},r=n;return hm.default=r,hm}var Sv={},pm={},ED;function d9(){if(ED)return pm;ED=1,Object.defineProperty(pm,"__esModule",{value:!0}),pm.default=void 0;var t={RESISTANCE_COEF:.6,UNCERTAINTY_THRESHOLD:3};return pm.default=t,pm}var AD;function Aae(){if(AD)return Sv;AD=1;var t=wS();Object.defineProperty(Sv,"__esModule",{value:!0}),Sv.default=r;var e=t(L),n=t(d9());function r(i){var s=i.children,o=i.startIndex,a=i.startX,l=i.pageX,c=i.viewLength,u=i.resistance,d=e.default.Children.count(s)-1,f=o+(a-l)/c,h;return u?f<0?f=Math.exp(f*n.default.RESISTANCE_COEF)-1:f>d&&(f=d+1-Math.exp((d-f)*n.default.RESISTANCE_COEF)):f<0?(f=0,h=(f-o)*c+l):f>d&&(f=d,h=(f-o)*c+l),{index:f,startX:h}}return Sv}var mm={},TD;function Tae(){if(TD)return mm;TD=1;var t=wS();Object.defineProperty(mm,"__esModule",{value:!0}),mm.default=void 0;var e=t(L),n=function(s,o){var a=!1,l=function(p){return p?p.key:"empty"};if(s.children.length&&o.children.length){var c=e.default.Children.map(s.children,l),u=c[s.index];if(u!=null){var d=e.default.Children.map(o.children,l),f=d[o.index];u===f&&(a=!0)}}return a},r=n;return mm.default=r,mm}var gm={},MD;function Mae(){if(MD)return gm;MD=1,Object.defineProperty(gm,"__esModule",{value:!0}),gm.default=void 0;function t(n,r){var i=n%r;return i<0?i+r:i}var e=t;return gm.default=e,gm}var RD;function Rae(){return RD||(RD=1,function(t){var e=wS();Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"checkIndexBounds",{enumerable:!0,get:function(){return n.default}}),Object.defineProperty(t,"computeIndex",{enumerable:!0,get:function(){return r.default}}),Object.defineProperty(t,"constant",{enumerable:!0,get:function(){return i.default}}),Object.defineProperty(t,"getDisplaySameSlide",{enumerable:!0,get:function(){return s.default}}),Object.defineProperty(t,"mod",{enumerable:!0,get:function(){return o.default}});var n=e(Eae()),r=e(Aae()),i=e(d9()),s=e(Tae()),o=e(Mae())}(wC)),wC}var ID;function Iae(){if(ID)return Ga;ID=1;var t=yae(),e=c9;Object.defineProperty(Ga,"__esModule",{value:!0}),Ga.default=Ga.SwipeableViewsContext=void 0,Ga.findNativeHandler=S,Ga.getDomTreeShapes=y;var n=t(vae()),r=t(bae()),i=t(Sae()),s=t(_ae()),o=t(Cae()),a=t(oj),l=e(L);t(WJ),t(u9());var c=Rae(),u=["action","animateHeight","animateTransitions","axis","children","containerStyle","disabled","disableLazyLoading","enableMouseEvents","hysteresis","ignoreNativeScroll","index","onChangeIndex","onSwitching","onTransitionEnd","resistance","slideStyle","slideClassName","springConfig","style","threshold"];function d(T,I,N,M){return T.addEventListener(I,N,M),{remove:function(){T.removeEventListener(I,N,M)}}}var f={container:{direction:"ltr",display:"flex",willChange:"transform"},slide:{width:"100%",WebkitFlexShrink:0,flexShrink:0,overflow:"auto"}},h={root:{x:{overflowX:"hidden"},"x-reverse":{overflowX:"hidden"},y:{overflowY:"hidden"},"y-reverse":{overflowY:"hidden"}},flexDirection:{x:"row","x-reverse":"row-reverse",y:"column","y-reverse":"column-reverse"},transform:{x:function(I){return"translate(".concat(-I,"%, 0)")},"x-reverse":function(I){return"translate(".concat(I,"%, 0)")},y:function(I){return"translate(0, ".concat(-I,"%)")},"y-reverse":function(I){return"translate(0, ".concat(I,"%)")}},length:{x:"width","x-reverse":"width",y:"height","y-reverse":"height"},rotationMatrix:{x:{x:[1,0],y:[0,1]},"x-reverse":{x:[-1,0],y:[0,1]},y:{x:[0,1],y:[1,0]},"y-reverse":{x:[0,-1],y:[1,0]}},scrollPosition:{x:"scrollLeft","x-reverse":"scrollLeft",y:"scrollTop","y-reverse":"scrollTop"},scrollLength:{x:"scrollWidth","x-reverse":"scrollWidth",y:"scrollHeight","y-reverse":"scrollHeight"},clientLength:{x:"clientWidth","x-reverse":"clientWidth",y:"clientHeight","y-reverse":"clientHeight"}};function p(T,I){var N=I.duration,M=I.easeFunction,P=I.delay;return"".concat(T," ").concat(N," ").concat(M," ").concat(P)}function x(T,I){var N=h.rotationMatrix[I];return{pageX:N.x[0]*T.pageX+N.x[1]*T.pageY,pageY:N.y[0]*T.pageX+N.y[1]*T.pageY}}function v(T){return T.touches=[{pageX:T.pageX,pageY:T.pageY}],T}function y(T,I){for(var N=[];T&&T!==I&&T!==document.body&&!T.hasAttribute("data-swipeable");){var M=window.getComputedStyle(T);M.getPropertyValue("position")==="absolute"||M.getPropertyValue("overflow-x")==="hidden"?N=[]:(T.clientWidth>0&&T.scrollWidth>T.clientWidth||T.clientHeight>0&&T.scrollHeight>T.clientHeight)&&N.push({element:T,scrollWidth:T.scrollWidth,scrollHeight:T.scrollHeight,clientWidth:T.clientWidth,clientHeight:T.clientHeight,scrollLeft:T.scrollLeft,scrollTop:T.scrollTop}),T=T.parentNode}return N}var b=null;function S(T){var I=T.domTreeShapes,N=T.pageX,M=T.startX,P=T.axis;return I.some(function(B){var F=N>=M;(P==="x"||P==="y")&&(F=!F);var U=Math.round(B[h.scrollPosition[P]]),j=U>0,Z=U+B[h.clientLength[P]]<B[h.scrollLength[P]];return F&&Z||!F&&j?(b=B.element,!0):!1})}var w=l.createContext();Ga.SwipeableViewsContext=w;var E=function(T){(0,o.default)(N,T);var I=(0,a.default)(N);function N(M){var P;return(0,i.default)(this,N),P=I.call(this,M),P.rootNode=null,P.containerNode=null,P.ignoreNextScrollEvents=!1,P.viewLength=0,P.startX=0,P.lastX=0,P.vx=0,P.startY=0,P.isSwiping=void 0,P.started=!1,P.startIndex=0,P.transitionListener=null,P.touchMoveListener=null,P.activeSlide=null,P.indexCurrent=null,P.firstRenderTimeout=null,P.setRootNode=function(B){P.rootNode=B},P.setContainerNode=function(B){P.containerNode=B},P.setActiveSlide=function(B){P.activeSlide=B,P.updateHeight()},P.handleSwipeStart=function(B){var F=P.props.axis,U=x(B.touches[0],F);P.viewLength=P.rootNode.getBoundingClientRect()[h.length[F]],P.startX=U.pageX,P.lastX=U.pageX,P.vx=0,P.startY=U.pageY,P.isSwiping=void 0,P.started=!0;var j=window.getComputedStyle(P.containerNode),Z=j.getPropertyValue("-webkit-transform")||j.getPropertyValue("transform");if(Z&&Z!=="none"){var ne=Z.split("(")[1].split(")")[0].split(","),O=window.getComputedStyle(P.rootNode),G=x({pageX:parseInt(ne[4],10),pageY:parseInt(ne[5],10)},F);P.startIndex=-G.pageX/(P.viewLength-parseInt(O.paddingLeft,10)-parseInt(O.paddingRight,10))||0}},P.handleSwipeMove=function(B){if(!P.started){P.handleTouchStart(B);return}if(!(b!==null&&b!==P.rootNode)){var F=P.props,U=F.axis,j=F.children,Z=F.ignoreNativeScroll,ne=F.onSwitching,O=F.resistance,G=x(B.touches[0],U);if(P.isSwiping===void 0){var q=Math.abs(G.pageX-P.startX),se=Math.abs(G.pageY-P.startY),he=q>se&&q>c.constant.UNCERTAINTY_THRESHOLD;if(!O&&(U==="y"||U==="y-reverse")&&(P.indexCurrent===0&&P.startX<G.pageX||P.indexCurrent===l.Children.count(P.props.children)-1&&P.startX>G.pageX)){P.isSwiping=!1;return}if(q>se&&B.preventDefault(),he===!0||se>c.constant.UNCERTAINTY_THRESHOLD){P.isSwiping=he,P.startX=G.pageX;return}}if(P.isSwiping===!0){B.preventDefault(),P.vx=P.vx*.5+(G.pageX-P.lastX)*.5,P.lastX=G.pageX;var ke=(0,c.computeIndex)({children:j,resistance:O,pageX:G.pageX,startIndex:P.startIndex,startX:P.startX,viewLength:P.viewLength}),re=ke.index,pe=ke.startX;if(b===null&&!Z){var fe=y(B.target,P.rootNode),Ee=S({domTreeShapes:fe,startX:P.startX,pageX:G.pageX,axis:U});if(Ee)return}pe?P.startX=pe:b===null&&(b=P.rootNode),P.setIndexCurrent(re);var We=function(){ne&&ne(re,"move")};(P.state.displaySameSlide||!P.state.isDragging)&&P.setState({displaySameSlide:!1,isDragging:!0},We),We()}}},P.handleSwipeEnd=function(){if(b=null,!!P.started&&(P.started=!1,P.isSwiping===!0)){var B=P.state.indexLatest,F=P.indexCurrent,U=B-F,j;Math.abs(P.vx)>P.props.threshold?P.vx>0?j=Math.floor(F):j=Math.ceil(F):Math.abs(U)>P.props.hysteresis?j=U>0?Math.floor(F):Math.ceil(F):j=B;var Z=l.Children.count(P.props.children)-1;j<0?j=0:j>Z&&(j=Z),P.setIndexCurrent(j),P.setState({indexLatest:j,isDragging:!1},function(){P.props.onSwitching&&P.props.onSwitching(j,"end"),P.props.onChangeIndex&&j!==B&&P.props.onChangeIndex(j,B,{reason:"swipe"}),F===B&&P.handleTransitionEnd()})}},P.handleTouchStart=function(B){P.props.onTouchStart&&P.props.onTouchStart(B),P.handleSwipeStart(B)},P.handleTouchEnd=function(B){P.props.onTouchEnd&&P.props.onTouchEnd(B),P.handleSwipeEnd(B)},P.handleMouseDown=function(B){P.props.onMouseDown&&P.props.onMouseDown(B),B.persist(),P.handleSwipeStart(v(B))},P.handleMouseUp=function(B){P.props.onMouseUp&&P.props.onMouseUp(B),P.handleSwipeEnd(v(B))},P.handleMouseLeave=function(B){P.props.onMouseLeave&&P.props.onMouseLeave(B),P.started&&P.handleSwipeEnd(v(B))},P.handleMouseMove=function(B){P.props.onMouseMove&&P.props.onMouseMove(B),P.started&&P.handleSwipeMove(v(B))},P.handleScroll=function(B){if(P.props.onScroll&&P.props.onScroll(B),B.target===P.rootNode){if(P.ignoreNextScrollEvents){P.ignoreNextScrollEvents=!1;return}var F=P.state.indexLatest,U=Math.ceil(B.target.scrollLeft/B.target.clientWidth)+F;P.ignoreNextScrollEvents=!0,B.target.scrollLeft=0,P.props.onChangeIndex&&U!==F&&P.props.onChangeIndex(U,F,{reason:"focus"})}},P.updateHeight=function(){if(P.activeSlide!==null){var B=P.activeSlide.children[0];B!==void 0&&B.offsetHeight!==void 0&&P.state.heightLatest!==B.offsetHeight&&P.setState({heightLatest:B.offsetHeight})}},P.state={indexLatest:M.index,isDragging:!1,renderOnlyActive:!M.disableLazyLoading,heightLatest:0,displaySameSlide:!0},P.setIndexCurrent(M.index),P}return(0,s.default)(N,[{key:"componentDidMount",value:function(){var P=this;this.transitionListener=d(this.containerNode,"transitionend",function(B){B.target===P.containerNode&&P.handleTransitionEnd()}),this.touchMoveListener=d(this.rootNode,"touchmove",function(B){P.props.disabled||P.handleSwipeMove(B)},{passive:!1}),this.props.disableLazyLoading||(this.firstRenderTimeout=setTimeout(function(){P.setState({renderOnlyActive:!1})},0)),this.props.action&&this.props.action({updateHeight:this.updateHeight})}},{key:"UNSAFE_componentWillReceiveProps",value:function(P){var B=P.index;typeof B=="number"&&B!==this.props.index&&(this.setIndexCurrent(B),this.setState({displaySameSlide:(0,c.getDisplaySameSlide)(this.props,P),indexLatest:B}))}},{key:"componentWillUnmount",value:function(){this.transitionListener.remove(),this.touchMoveListener.remove(),clearTimeout(this.firstRenderTimeout)}},{key:"getSwipeableViewsContext",value:function(){var P=this;return{slideUpdateHeight:function(){P.updateHeight()}}}},{key:"setIndexCurrent",value:function(P){if(!this.props.animateTransitions&&this.indexCurrent!==P&&this.handleTransitionEnd(),this.indexCurrent=P,this.containerNode){var B=this.props.axis,F=h.transform[B](P*100);this.containerNode.style.WebkitTransform=F,this.containerNode.style.transform=F}}},{key:"handleTransitionEnd",value:function(){this.props.onTransitionEnd&&(this.state.displaySameSlide||this.state.isDragging||this.props.onTransitionEnd())}},{key:"render",value:function(){var P=this,B=this.props;B.action;var F=B.animateHeight,U=B.animateTransitions,j=B.axis,Z=B.children,ne=B.containerStyle,O=B.disabled;B.disableLazyLoading;var G=B.enableMouseEvents;B.hysteresis,B.ignoreNativeScroll,B.index,B.onChangeIndex,B.onSwitching,B.onTransitionEnd,B.resistance;var q=B.slideStyle,se=B.slideClassName,he=B.springConfig,ke=B.style;B.threshold;var re=(0,r.default)(B,u),pe=this.state,fe=pe.displaySameSlide,Ee=pe.heightLatest,We=pe.indexLatest,je=pe.isDragging,Je=pe.renderOnlyActive,te=O?{}:{onTouchStart:this.handleTouchStart,onTouchEnd:this.handleTouchEnd},be=!O&&G?{onMouseDown:this.handleMouseDown,onMouseUp:this.handleMouseUp,onMouseLeave:this.handleMouseLeave,onMouseMove:this.handleMouseMove}:{},ce=(0,n.default)({},f.slide,q),Me,Ie;if(je||!U||fe)Me="all 0s ease 0s",Ie="all 0s ease 0s";else if(Me=p("transform",he),Ie=p("-webkit-transform",he),Ee!==0){var Oe=", ".concat(p("height",he));Me+=Oe,Ie+=Oe}var V={height:null,WebkitFlexDirection:h.flexDirection[j],flexDirection:h.flexDirection[j],WebkitTransition:Ie,transition:Me};if(!Je){var $=h.transform[j](this.indexCurrent*100);V.WebkitTransform=$,V.transform=$}return F&&(V.height=Ee),l.createElement(w.Provider,{value:this.getSwipeableViewsContext()},l.createElement("div",(0,n.default)({ref:this.setRootNode,style:(0,n.default)({},h.root[j],ke)},re,te,be,{onScroll:this.handleScroll}),l.createElement("div",{ref:this.setContainerNode,style:(0,n.default)({},V,f.container,ne),className:"react-swipeable-view-container"},l.Children.map(Z,function(ue,ye){if(Je&&ye!==We)return null;var ve,Ne=!0;return ye===We&&(Ne=!1,F&&(ve=P.setActiveSlide,ce.overflowY="hidden")),l.createElement("div",{ref:ve,style:ce,className:se,"aria-hidden":Ne,"data-swipeable":"true"},ue)}))))}}]),N}(l.Component);E.displayName="ReactSwipableView",E.propTypes={},E.defaultProps={animateHeight:!1,animateTransitions:!0,axis:"x",disabled:!1,disableLazyLoading:!1,enableMouseEvents:!1,hysteresis:.6,ignoreNativeScroll:!1,index:0,threshold:5,springConfig:{duration:"0.35s",easeFunction:"cubic-bezier(0.15, 0.3, 0.25, 1)",delay:"0s"},resistance:!1};var A=E;return Ga.default=A,Ga}(function(t){var e=c9;Object.defineProperty(t,"__esModule",{value:!0}),Object.defineProperty(t,"SwipeableViewsContext",{enumerable:!0,get:function(){return n.SwipeableViewsContext}}),Object.defineProperty(t,"default",{enumerable:!0,get:function(){return n.default}});var n=e(Iae())})(l9);const Nae=Ed(l9),Pae=({images:t})=>{const e=m0(),n=_0(),[r,i]=L.useState(0),s=t.length,o=()=>{i(c=>c+1)},a=()=>{i(c=>c-1)},l=c=>{i(c)};return H.jsxs(uC,{sx:{flexGrow:1},children:[H.jsxs(ku,{direction:"row",justifyContent:"space-between",children:[H.jsxs(xh,{size:"small",onClick:()=>e(-1),children:[H.jsx(mC,{}),"BACK"]}),H.jsx(cR,{"aria-label":"Favorite",edge:"start",color:"tertiary",children:H.jsx(o9,{})})]}),H.jsx(Nae,{axis:n.direction==="rtl"?"x-reverse":"x",index:r,onChangeIndex:l,enableMouseEvents:!0,children:H.jsx(uC,{display:"flex",justifyContent:"center",children:t.map((c,u)=>H.jsx("div",{children:Math.abs(r-u)<=2?H.jsx(uC,{component:"img",sx:{height:255,display:"block",maxWidth:"sm",overflow:"hidden",width:"100%"},src:new URL(c.imgPath,import.meta.url).href,alt:c.label}):null},c.label))})}),H.jsx(uoe,{steps:s,position:"static",activeStep:r,nextButton:H.jsxs(xh,{size:"small",onClick:o,disabled:r===s-1,children:["Next",n.direction==="rtl"?H.jsx(mC,{}):H.jsx(hD,{})]}),backButton:H.jsxs(xh,{size:"small",onClick:a,disabled:r===0,children:[n.direction==="rtl"?H.jsx(hD,{}):H.jsx(mC,{}),"Prev"]})})]})},kae=()=>{const{productId:t}=A$(),e=m0(),n=pR.find(i=>i.id===Number(t));if(!n)return H.jsx(jx,{children:"Product not found"});const r=()=>{e(`/products/${n.id}/try/${n.type}`)};return H.jsxs(Tl,{sx:{position:"absolute",top:0,left:0,right:0},elevation:0,children:[H.jsx(jx,{sx:{pb:2},children:H.jsx(Pae,{images:n.images})}),H.jsxs(jx,{sx:{pb:2},children:[H.jsx(ku,{direction:"row",justifyContent:"center",alignItems:"center",children:H.jsxs(cR,{"aria-label":"AR",size:"large",onClick:()=>r(n.images[0].imgPath),sx:{"&:hover":{backgroundColor:"#FFF"}},children:[H.jsx(uae,{fontSize:"large"}),H.jsx(va,{variant:"body2",color:"textSecondary",children:"View in AR"})]})}),H.jsxs(ku,{direction:"row",justifyContent:"space-between",children:[H.jsx(va,{variant:"h4",color:"textPrimary",children:n.name}),H.jsx(va,{variant:"h5",color:"textPrimary",children:n.price})]}),H.jsxs(ku,{direction:"row",spacing:4,mt:2,alignItems:"center",children:[H.jsx(va,{variant:"body2",color:"textSecondary",children:n.category}),H.jsx(HU,{label:`Size: ${n.size}`,variant:"filled"})]}),H.jsxs(ku,{direction:"column",mt:2,mb:2,children:[H.jsxs(Dk,{children:[H.jsx(Uk,{expandIcon:H.jsx(fD,{}),"aria-controls":"panel1-content",id:"panel1-header",sx:{backgroundColor:"#EBEBEB"},children:"Description"}),H.jsx(Ok,{children:n.description})]}),H.jsxs(Dk,{children:[H.jsx(Uk,{expandIcon:H.jsx(fD,{}),"aria-controls":"panel1-content",id:"panel2-header",sx:{backgroundColor:"#EBEBEB"},children:"Additional Info"}),H.jsx(Ok,{children:n.additionalInfo})]})]}),H.jsx(xh,{fullWidth:!0,variant:"contained",sx:{background:"#FF8F1C",color:"#fff",textTransform:"none","&:hover":{backgroundColor:"#FF8F1C"}},children:"Add to Cart"})]})]})},Dae=()=>H.jsxs(H.Fragment,{children:[H.jsx(kae,{}),H.jsx(a9,{})]});var f9={exports:{}};(function(t,e){(function(r,i){t.exports=i(L)})(Pc,function(n){return function(r){var i={};function s(o){if(i[o])return i[o].exports;var a=i[o]={i:o,l:!1,exports:{}};return r[o].call(a.exports,a,a.exports,s),a.l=!0,a.exports}return s.m=r,s.c=i,s.d=function(o,a,l){s.o(o,a)||Object.defineProperty(o,a,{enumerable:!0,get:l})},s.r=function(o){typeof Symbol<"u"&&Symbol.toStringTag&&Object.defineProperty(o,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(o,"__esModule",{value:!0})},s.t=function(o,a){if(a&1&&(o=s(o)),a&8||a&4&&typeof o=="object"&&o&&o.__esModule)return o;var l=Object.create(null);if(s.r(l),Object.defineProperty(l,"default",{enumerable:!0,value:o}),a&2&&typeof o!="string")for(var c in o)s.d(l,c,(function(u){return o[u]}).bind(null,c));return l},s.n=function(o){var a=o&&o.__esModule?function(){return o.default}:function(){return o};return s.d(a,"a",a),a},s.o=function(o,a){return Object.prototype.hasOwnProperty.call(o,a)},s.p="",s(s.s="./src/react-webcam.tsx")}({"./src/react-webcam.tsx":function(r,i,s){s.r(i);var o=s("react"),a=function(){var f=function(h,p){return f=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(x,v){x.__proto__=v}||function(x,v){for(var y in v)v.hasOwnProperty(y)&&(x[y]=v[y])},f(h,p)};return function(h,p){f(h,p);function x(){this.constructor=h}h.prototype=p===null?Object.create(p):(x.prototype=p.prototype,new x)}}(),l=function(){return l=Object.assign||function(f){for(var h,p=1,x=arguments.length;p<x;p++){h=arguments[p];for(var v in h)Object.prototype.hasOwnProperty.call(h,v)&&(f[v]=h[v])}return f},l.apply(this,arguments)},c=function(f,h){var p={};for(var x in f)Object.prototype.hasOwnProperty.call(f,x)&&h.indexOf(x)<0&&(p[x]=f[x]);if(f!=null&&typeof Object.getOwnPropertySymbols=="function")for(var v=0,x=Object.getOwnPropertySymbols(f);v<x.length;v++)h.indexOf(x[v])<0&&Object.prototype.propertyIsEnumerable.call(f,x[v])&&(p[x[v]]=f[x[v]]);return p};(function(){typeof window>"u"||(navigator.mediaDevices===void 0&&(navigator.mediaDevices={}),navigator.mediaDevices.getUserMedia===void 0&&(navigator.mediaDevices.getUserMedia=function(h){var p=navigator.getUserMedia||navigator.webkitGetUserMedia||navigator.mozGetUserMedia||navigator.msGetUserMedia;return p?new Promise(function(x,v){p.call(navigator,h,x,v)}):Promise.reject(new Error("getUserMedia is not implemented in this browser"))}))})();function u(){return!!(navigator.mediaDevices&&navigator.mediaDevices.getUserMedia)}var d=function(f){a(h,f);function h(p){var x=f.call(this,p)||this;return x.canvas=null,x.ctx=null,x.requestUserMediaId=0,x.unmounted=!1,x.state={hasUserMedia:!1},x}return h.prototype.componentDidMount=function(){var p=this,x=p.state,v=p.props;if(this.unmounted=!1,!u()){v.onUserMediaError("getUserMedia not supported");return}x.hasUserMedia||this.requestUserMedia(),v.children&&typeof v.children!="function"&&console.warn("children must be a function")},h.prototype.componentDidUpdate=function(p){var x=this.props;if(!u()){x.onUserMediaError("getUserMedia not supported");return}var v=JSON.stringify(p.audioConstraints)!==JSON.stringify(x.audioConstraints),y=JSON.stringify(p.videoConstraints)!==JSON.stringify(x.videoConstraints),b=p.minScreenshotWidth!==x.minScreenshotWidth,S=p.minScreenshotHeight!==x.minScreenshotHeight;(y||b||S)&&(this.canvas=null,this.ctx=null),(v||y)&&(this.stopAndCleanup(),this.requestUserMedia())},h.prototype.componentWillUnmount=function(){this.unmounted=!0,this.stopAndCleanup()},h.stopMediaStream=function(p){p&&(p.getVideoTracks&&p.getAudioTracks?(p.getVideoTracks().map(function(x){p.removeTrack(x),x.stop()}),p.getAudioTracks().map(function(x){p.removeTrack(x),x.stop()})):p.stop())},h.prototype.stopAndCleanup=function(){var p=this.state;p.hasUserMedia&&(h.stopMediaStream(this.stream),p.src&&window.URL.revokeObjectURL(p.src))},h.prototype.getScreenshot=function(p){var x=this,v=x.state,y=x.props;if(!v.hasUserMedia)return null;var b=this.getCanvas(p);return b&&b.toDataURL(y.screenshotFormat,y.screenshotQuality)},h.prototype.getCanvas=function(p){var x=this,v=x.state,y=x.props;if(!this.video||!v.hasUserMedia||!this.video.videoHeight)return null;if(!this.ctx){var b=this.video.videoWidth,S=this.video.videoHeight;if(!this.props.forceScreenshotSourceSize){var w=b/S;b=y.minScreenshotWidth||this.video.clientWidth,S=b/w,y.minScreenshotHeight&&S<y.minScreenshotHeight&&(S=y.minScreenshotHeight,b=S*w)}this.canvas=document.createElement("canvas"),this.canvas.width=(p==null?void 0:p.width)||b,this.canvas.height=(p==null?void 0:p.height)||S,this.ctx=this.canvas.getContext("2d")}var E=this,A=E.ctx,T=E.canvas;return A&&T&&(T.width=(p==null?void 0:p.width)||T.width,T.height=(p==null?void 0:p.height)||T.height,y.mirrored&&(A.translate(T.width,0),A.scale(-1,1)),A.imageSmoothingEnabled=y.imageSmoothing,A.drawImage(this.video,0,0,(p==null?void 0:p.width)||T.width,(p==null?void 0:p.height)||T.height),y.mirrored&&(A.scale(-1,1),A.translate(-T.width,0))),T},h.prototype.requestUserMedia=function(){var p=this,x=this.props,v=function(S,w){var E={video:typeof w<"u"?w:!0};x.audio&&(E.audio=typeof S<"u"?S:!0),p.requestUserMediaId++;var A=p.requestUserMediaId;navigator.mediaDevices.getUserMedia(E).then(function(T){p.unmounted||A!==p.requestUserMediaId?h.stopMediaStream(T):p.handleUserMedia(null,T)}).catch(function(T){p.handleUserMedia(T)})};if("mediaDevices"in navigator)v(x.audioConstraints,x.videoConstraints);else{var y=function(S){return{optional:[{sourceId:S}]}},b=function(S){var w=S.deviceId;return typeof w=="string"?w:Array.isArray(w)&&w.length>0?w[0]:typeof w=="object"&&w.ideal?w.ideal:null};MediaStreamTrack.getSources(function(S){var w=null,E=null;S.forEach(function(I){I.kind==="audio"?w=I.id:I.kind==="video"&&(E=I.id)});var A=b(x.audioConstraints);A&&(w=A);var T=b(x.videoConstraints);T&&(E=T),v(y(w),y(E))})}},h.prototype.handleUserMedia=function(p,x){var v=this.props;if(p||!x){this.setState({hasUserMedia:!1}),v.onUserMediaError(p);return}this.stream=x;try{this.video&&(this.video.srcObject=x),this.setState({hasUserMedia:!0})}catch{this.setState({hasUserMedia:!0,src:window.URL.createObjectURL(x)})}v.onUserMedia(x)},h.prototype.render=function(){var p=this,x=this,v=x.state,y=x.props,b=y.audio;y.forceScreenshotSourceSize;var S=y.disablePictureInPicture;y.onUserMedia,y.onUserMediaError,y.screenshotFormat,y.screenshotQuality,y.minScreenshotWidth,y.minScreenshotHeight,y.audioConstraints,y.videoConstraints,y.imageSmoothing;var w=y.mirrored,E=y.style,A=E===void 0?{}:E,T=y.children,I=c(y,["audio","forceScreenshotSourceSize","disablePictureInPicture","onUserMedia","onUserMediaError","screenshotFormat","screenshotQuality","minScreenshotWidth","minScreenshotHeight","audioConstraints","videoConstraints","imageSmoothing","mirrored","style","children"]),N=w?l(l({},A),{transform:(A.transform||"")+" scaleX(-1)"}):A,M={getScreenshot:this.getScreenshot.bind(this)};return o.createElement(o.Fragment,null,o.createElement("video",l({autoPlay:!0,disablePictureInPicture:S,src:v.src,muted:!b,playsInline:!0,ref:function(P){p.video=P},style:N},I)),T&&T(M))},h.defaultProps={audio:!1,disablePictureInPicture:!1,forceScreenshotSourceSize:!1,imageSmoothing:!0,mirrored:!1,onUserMedia:function(){},onUserMediaError:function(){},screenshotFormat:"image/webp",screenshotQuality:.92},h}(o.Component);i.default=d},react:function(r,i){r.exports=n}}).default})})(f9);var Oae=f9.exports;const Lae=Ed(Oae);/**
 * @license
 * Copyright 2010-2023 Three.js Authors
 * SPDX-License-Identifier: MIT
 */const C0="163",bu={LEFT:0,MIDDLE:1,RIGHT:2,ROTATE:0,DOLLY:1,PAN:2},Su={ROTATE:0,PAN:1,DOLLY_PAN:2,DOLLY_ROTATE:3},h9=0,n2=1,p9=2,Bae=3,m9=0,CS=1,ig=2,ko=3,Ia=0,Fi=1,Uo=2,cl=0,qu=1,r2=2,i2=3,s2=4,g9=5,sc=100,y9=101,v9=102,x9=103,b9=104,S9=200,_9=201,w9=202,C9=203,$1=204,U1=205,E9=206,A9=207,T9=208,M9=209,R9=210,I9=211,N9=212,P9=213,k9=214,D9=0,O9=1,L9=2,Dg=3,B9=4,F9=5,$9=6,U9=7,E0=0,z9=1,G9=2,Ca=0,H9=1,V9=2,W9=3,mR=4,j9=5,X9=6,K9=7,o2="attached",q9="detached",ES=300,xl=301,Ac=302,Og=303,Lg=304,yp=306,Tc=1e3,ws=1001,$h=1002,Nr=1003,AS=1004,Fae=1004,Du=1005,$ae=1005,or=1006,Sh=1007,Uae=1007,ao=1008,zae=1008,Ea=1009,J9=1010,Y9=1011,gR=1012,yR=1013,pd=1014,lo=1015,Bg=1016,vR=1017,xR=1018,vp=1020,Q9=35902,Z9=1021,e5=1022,Yi=1023,t5=1024,n5=1025,Ju=1026,Uh=1027,bR=1028,SR=1029,r5=1030,_R=1031,wR=1033,Xx=33776,Kx=33777,qx=33778,Jx=33779,a2=35840,l2=35841,c2=35842,u2=35843,CR=36196,d2=37492,f2=37496,h2=37808,p2=37809,m2=37810,g2=37811,y2=37812,v2=37813,x2=37814,b2=37815,S2=37816,_2=37817,w2=37818,C2=37819,E2=37820,A2=37821,Yx=36492,T2=36494,M2=36495,i5=36283,R2=36284,I2=36285,N2=36286,s5=2200,o5=2201,a5=2202,zh=2300,md=2301,Qx=2302,Ou=2400,Lu=2401,Fg=2402,TS=2500,ER=2501,l5=0,AR=1,z1=2,c5=3200,u5=3201,Bc=0,d5=1,tl="",xs="srgb",Ml="srgb-linear",MS="display-p3",A0="display-p3-linear",$g="linear",Tn="srgb",Ug="rec709",zg="p3",Gae=0,_u=7680,Hae=7681,Vae=7682,Wae=7683,jae=34055,Xae=34056,Kae=5386,qae=512,Jae=513,Yae=514,Qae=515,Zae=516,ele=517,tle=518,P2=519,f5=512,h5=513,p5=514,TR=515,m5=516,g5=517,y5=518,v5=519,Gg=35044,nle=35048,rle=35040,ile=35045,sle=35049,ole=35041,ale=35046,lle=35050,cle=35042,ule="100",k2="300 es",xa=2e3,Hg=2001;class ka{addEventListener(e,n){this._listeners===void 0&&(this._listeners={});const r=this._listeners;r[e]===void 0&&(r[e]=[]),r[e].indexOf(n)===-1&&r[e].push(n)}hasEventListener(e,n){if(this._listeners===void 0)return!1;const r=this._listeners;return r[e]!==void 0&&r[e].indexOf(n)!==-1}removeEventListener(e,n){if(this._listeners===void 0)return;const i=this._listeners[e];if(i!==void 0){const s=i.indexOf(n);s!==-1&&i.splice(s,1)}}dispatchEvent(e){if(this._listeners===void 0)return;const r=this._listeners[e.type];if(r!==void 0){e.target=this;const i=r.slice(0);for(let s=0,o=i.length;s<o;s++)i[s].call(this,e);e.target=null}}}const ci=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let ND=1234567;const Yu=Math.PI/180,Gh=180/Math.PI;function Ms(){const t=Math.random()*4294967295|0,e=Math.random()*4294967295|0,n=Math.random()*4294967295|0,r=Math.random()*4294967295|0;return(ci[t&255]+ci[t>>8&255]+ci[t>>16&255]+ci[t>>24&255]+"-"+ci[e&255]+ci[e>>8&255]+"-"+ci[e>>16&15|64]+ci[e>>24&255]+"-"+ci[n&63|128]+ci[n>>8&255]+"-"+ci[n>>16&255]+ci[n>>24&255]+ci[r&255]+ci[r>>8&255]+ci[r>>16&255]+ci[r>>24&255]).toLowerCase()}function sr(t,e,n){return Math.max(e,Math.min(n,t))}function MR(t,e){return(t%e+e)%e}function dle(t,e,n,r,i){return r+(t-e)*(i-r)/(n-e)}function fle(t,e,n){return t!==e?(n-t)/(e-t):0}function sg(t,e,n){return(1-n)*t+n*e}function hle(t,e,n,r){return sg(t,e,1-Math.exp(-n*r))}function ple(t,e=1){return e-Math.abs(MR(t,e*2)-e)}function mle(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e),t*t*(3-2*t))}function gle(t,e,n){return t<=e?0:t>=n?1:(t=(t-e)/(n-e),t*t*t*(t*(t*6-15)+10))}function yle(t,e){return t+Math.floor(Math.random()*(e-t+1))}function vle(t,e){return t+Math.random()*(e-t)}function xle(t){return t*(.5-Math.random())}function ble(t){t!==void 0&&(ND=t);let e=ND+=1831565813;return e=Math.imul(e^e>>>15,e|1),e^=e+Math.imul(e^e>>>7,e|61),((e^e>>>14)>>>0)/4294967296}function Sle(t){return t*Yu}function _le(t){return t*Gh}function wle(t){return(t&t-1)===0&&t!==0}function Cle(t){return Math.pow(2,Math.ceil(Math.log(t)/Math.LN2))}function Ele(t){return Math.pow(2,Math.floor(Math.log(t)/Math.LN2))}function Ale(t,e,n,r,i){const s=Math.cos,o=Math.sin,a=s(n/2),l=o(n/2),c=s((e+r)/2),u=o((e+r)/2),d=s((e-r)/2),f=o((e-r)/2),h=s((r-e)/2),p=o((r-e)/2);switch(i){case"XYX":t.set(a*u,l*d,l*f,a*c);break;case"YZY":t.set(l*f,a*u,l*d,a*c);break;case"ZXZ":t.set(l*d,l*f,a*u,a*c);break;case"XZX":t.set(a*u,l*p,l*h,a*c);break;case"YXY":t.set(l*h,a*u,l*p,a*c);break;case"ZYZ":t.set(l*p,l*h,a*u,a*c);break;default:console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+i)}}function Pi(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return t/4294967295;case Uint16Array:return t/65535;case Uint8Array:return t/255;case Int32Array:return Math.max(t/2147483647,-1);case Int16Array:return Math.max(t/32767,-1);case Int8Array:return Math.max(t/127,-1);default:throw new Error("Invalid component type.")}}function Ut(t,e){switch(e.constructor){case Float32Array:return t;case Uint32Array:return Math.round(t*4294967295);case Uint16Array:return Math.round(t*65535);case Uint8Array:return Math.round(t*255);case Int32Array:return Math.round(t*2147483647);case Int16Array:return Math.round(t*32767);case Int8Array:return Math.round(t*127);default:throw new Error("Invalid component type.")}}const x5={DEG2RAD:Yu,RAD2DEG:Gh,generateUUID:Ms,clamp:sr,euclideanModulo:MR,mapLinear:dle,inverseLerp:fle,lerp:sg,damp:hle,pingpong:ple,smoothstep:mle,smootherstep:gle,randInt:yle,randFloat:vle,randFloatSpread:xle,seededRandom:ble,degToRad:Sle,radToDeg:_le,isPowerOfTwo:wle,ceilPowerOfTwo:Cle,floorPowerOfTwo:Ele,setQuaternionFromProperEuler:Ale,normalize:Ut,denormalize:Pi};class Re{constructor(e=0,n=0){Re.prototype.isVector2=!0,this.x=e,this.y=n}get width(){return this.x}set width(e){this.x=e}get height(){return this.y}set height(e){this.y=e}set(e,n){return this.x=e,this.y=n,this}setScalar(e){return this.x=e,this.y=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setComponent(e,n){switch(e){case 0:this.x=n;break;case 1:this.y=n;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y)}copy(e){return this.x=e.x,this.y=e.y,this}add(e){return this.x+=e.x,this.y+=e.y,this}addScalar(e){return this.x+=e,this.y+=e,this}addVectors(e,n){return this.x=e.x+n.x,this.y=e.y+n.y,this}addScaledVector(e,n){return this.x+=e.x*n,this.y+=e.y*n,this}sub(e){return this.x-=e.x,this.y-=e.y,this}subScalar(e){return this.x-=e,this.y-=e,this}subVectors(e,n){return this.x=e.x-n.x,this.y=e.y-n.y,this}multiply(e){return this.x*=e.x,this.y*=e.y,this}multiplyScalar(e){return this.x*=e,this.y*=e,this}divide(e){return this.x/=e.x,this.y/=e.y,this}divideScalar(e){return this.multiplyScalar(1/e)}applyMatrix3(e){const n=this.x,r=this.y,i=e.elements;return this.x=i[0]*n+i[3]*r+i[6],this.y=i[1]*n+i[4]*r+i[7],this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this}clamp(e,n){return this.x=Math.max(e.x,Math.min(n.x,this.x)),this.y=Math.max(e.y,Math.min(n.y,this.y)),this}clampScalar(e,n){return this.x=Math.max(e,Math.min(n,this.x)),this.y=Math.max(e,Math.min(n,this.y)),this}clampLength(e,n){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(n,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(e){return this.x*e.x+this.y*e.y}cross(e){return this.x*e.y-this.y*e.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(e){const n=Math.sqrt(this.lengthSq()*e.lengthSq());if(n===0)return Math.PI/2;const r=this.dot(e)/n;return Math.acos(sr(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const n=this.x-e.x,r=this.y-e.y;return n*n+r*r}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,n){return this.x+=(e.x-this.x)*n,this.y+=(e.y-this.y)*n,this}lerpVectors(e,n,r){return this.x=e.x+(n.x-e.x)*r,this.y=e.y+(n.y-e.y)*r,this}equals(e){return e.x===this.x&&e.y===this.y}fromArray(e,n=0){return this.x=e[n],this.y=e[n+1],this}toArray(e=[],n=0){return e[n]=this.x,e[n+1]=this.y,e}fromBufferAttribute(e,n){return this.x=e.getX(n),this.y=e.getY(n),this}rotateAround(e,n){const r=Math.cos(n),i=Math.sin(n),s=this.x-e.x,o=this.y-e.y;return this.x=s*r-o*i+e.x,this.y=s*i+o*r+e.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class $t{constructor(e,n,r,i,s,o,a,l,c){$t.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],e!==void 0&&this.set(e,n,r,i,s,o,a,l,c)}set(e,n,r,i,s,o,a,l,c){const u=this.elements;return u[0]=e,u[1]=i,u[2]=a,u[3]=n,u[4]=s,u[5]=l,u[6]=r,u[7]=o,u[8]=c,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(e){const n=this.elements,r=e.elements;return n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=r[3],n[4]=r[4],n[5]=r[5],n[6]=r[6],n[7]=r[7],n[8]=r[8],this}extractBasis(e,n,r){return e.setFromMatrix3Column(this,0),n.setFromMatrix3Column(this,1),r.setFromMatrix3Column(this,2),this}setFromMatrix4(e){const n=e.elements;return this.set(n[0],n[4],n[8],n[1],n[5],n[9],n[2],n[6],n[10]),this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,n){const r=e.elements,i=n.elements,s=this.elements,o=r[0],a=r[3],l=r[6],c=r[1],u=r[4],d=r[7],f=r[2],h=r[5],p=r[8],x=i[0],v=i[3],y=i[6],b=i[1],S=i[4],w=i[7],E=i[2],A=i[5],T=i[8];return s[0]=o*x+a*b+l*E,s[3]=o*v+a*S+l*A,s[6]=o*y+a*w+l*T,s[1]=c*x+u*b+d*E,s[4]=c*v+u*S+d*A,s[7]=c*y+u*w+d*T,s[2]=f*x+h*b+p*E,s[5]=f*v+h*S+p*A,s[8]=f*y+h*w+p*T,this}multiplyScalar(e){const n=this.elements;return n[0]*=e,n[3]*=e,n[6]*=e,n[1]*=e,n[4]*=e,n[7]*=e,n[2]*=e,n[5]*=e,n[8]*=e,this}determinant(){const e=this.elements,n=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8];return n*o*u-n*a*c-r*s*u+r*a*l+i*s*c-i*o*l}invert(){const e=this.elements,n=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],d=u*o-a*c,f=a*l-u*s,h=c*s-o*l,p=n*d+r*f+i*h;if(p===0)return this.set(0,0,0,0,0,0,0,0,0);const x=1/p;return e[0]=d*x,e[1]=(i*c-u*r)*x,e[2]=(a*r-i*o)*x,e[3]=f*x,e[4]=(u*n-i*l)*x,e[5]=(i*s-a*n)*x,e[6]=h*x,e[7]=(r*l-c*n)*x,e[8]=(o*n-r*s)*x,this}transpose(){let e;const n=this.elements;return e=n[1],n[1]=n[3],n[3]=e,e=n[2],n[2]=n[6],n[6]=e,e=n[5],n[5]=n[7],n[7]=e,this}getNormalMatrix(e){return this.setFromMatrix4(e).invert().transpose()}transposeIntoArray(e){const n=this.elements;return e[0]=n[0],e[1]=n[3],e[2]=n[6],e[3]=n[1],e[4]=n[4],e[5]=n[7],e[6]=n[2],e[7]=n[5],e[8]=n[8],this}setUvTransform(e,n,r,i,s,o,a){const l=Math.cos(s),c=Math.sin(s);return this.set(r*l,r*c,-r*(l*o+c*a)+o+e,-i*c,i*l,-i*(-c*o+l*a)+a+n,0,0,1),this}scale(e,n){return this.premultiply(EC.makeScale(e,n)),this}rotate(e){return this.premultiply(EC.makeRotation(-e)),this}translate(e,n){return this.premultiply(EC.makeTranslation(e,n)),this}makeTranslation(e,n){return e.isVector2?this.set(1,0,e.x,0,1,e.y,0,0,1):this.set(1,0,e,0,1,n,0,0,1),this}makeRotation(e){const n=Math.cos(e),r=Math.sin(e);return this.set(n,-r,0,r,n,0,0,0,1),this}makeScale(e,n){return this.set(e,0,0,0,n,0,0,0,1),this}equals(e){const n=this.elements,r=e.elements;for(let i=0;i<9;i++)if(n[i]!==r[i])return!1;return!0}fromArray(e,n=0){for(let r=0;r<9;r++)this.elements[r]=e[r+n];return this}toArray(e=[],n=0){const r=this.elements;return e[n]=r[0],e[n+1]=r[1],e[n+2]=r[2],e[n+3]=r[3],e[n+4]=r[4],e[n+5]=r[5],e[n+6]=r[6],e[n+7]=r[7],e[n+8]=r[8],e}clone(){return new this.constructor().fromArray(this.elements)}}const EC=new $t;function b5(t){for(let e=t.length-1;e>=0;--e)if(t[e]>=65535)return!0;return!1}const Tle={Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array};function oh(t,e){return new Tle[t](e)}function Vg(t){return document.createElementNS("http://www.w3.org/1999/xhtml",t)}function S5(){const t=Vg("canvas");return t.style.display="block",t}const PD={};function _5(t){t in PD||(PD[t]=!0,console.warn(t))}const kD=new $t().set(.8224621,.177538,0,.0331941,.9668058,0,.0170827,.0723974,.9105199),DD=new $t().set(1.2249401,-.2249404,0,-.0420569,1.0420571,0,-.0196376,-.0786361,1.0982735),_v={[Ml]:{transfer:$g,primaries:Ug,toReference:t=>t,fromReference:t=>t},[xs]:{transfer:Tn,primaries:Ug,toReference:t=>t.convertSRGBToLinear(),fromReference:t=>t.convertLinearToSRGB()},[A0]:{transfer:$g,primaries:zg,toReference:t=>t.applyMatrix3(DD),fromReference:t=>t.applyMatrix3(kD)},[MS]:{transfer:Tn,primaries:zg,toReference:t=>t.convertSRGBToLinear().applyMatrix3(DD),fromReference:t=>t.applyMatrix3(kD).convertLinearToSRGB()}},Mle=new Set([Ml,A0]),gn={enabled:!0,_workingColorSpace:Ml,get workingColorSpace(){return this._workingColorSpace},set workingColorSpace(t){if(!Mle.has(t))throw new Error(`Unsupported working color space, "${t}".`);this._workingColorSpace=t},convert:function(t,e,n){if(this.enabled===!1||e===n||!e||!n)return t;const r=_v[e].toReference,i=_v[n].fromReference;return i(r(t))},fromWorkingColorSpace:function(t,e){return this.convert(t,this._workingColorSpace,e)},toWorkingColorSpace:function(t,e){return this.convert(t,e,this._workingColorSpace)},getPrimaries:function(t){return _v[t].primaries},getTransfer:function(t){return t===tl?$g:_v[t].transfer}};function _h(t){return t<.04045?t*.0773993808:Math.pow(t*.9478672986+.0521327014,2.4)}function AC(t){return t<.0031308?t*12.92:1.055*Math.pow(t,.41666)-.055}let df;class w5{static getDataURL(e){if(/^data:/i.test(e.src)||typeof HTMLCanvasElement>"u")return e.src;let n;if(e instanceof HTMLCanvasElement)n=e;else{df===void 0&&(df=Vg("canvas")),df.width=e.width,df.height=e.height;const r=df.getContext("2d");e instanceof ImageData?r.putImageData(e,0,0):r.drawImage(e,0,0,e.width,e.height),n=df}return n.width>2048||n.height>2048?(console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",e),n.toDataURL("image/jpeg",.6)):n.toDataURL("image/png")}static sRGBToLinear(e){if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap){const n=Vg("canvas");n.width=e.width,n.height=e.height;const r=n.getContext("2d");r.drawImage(e,0,0,e.width,e.height);const i=r.getImageData(0,0,e.width,e.height),s=i.data;for(let o=0;o<s.length;o++)s[o]=_h(s[o]/255)*255;return r.putImageData(i,0,0),n}else if(e.data){const n=e.data.slice(0);for(let r=0;r<n.length;r++)n instanceof Uint8Array||n instanceof Uint8ClampedArray?n[r]=Math.floor(_h(n[r]/255)*255):n[r]=_h(n[r]);return{data:n,width:e.width,height:e.height}}else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),e}}let Rle=0;class Bu{constructor(e=null){this.isSource=!0,Object.defineProperty(this,"id",{value:Rle++}),this.uuid=Ms(),this.data=e,this.dataReady=!0,this.version=0}set needsUpdate(e){e===!0&&this.version++}toJSON(e){const n=e===void 0||typeof e=="string";if(!n&&e.images[this.uuid]!==void 0)return e.images[this.uuid];const r={uuid:this.uuid,url:""},i=this.data;if(i!==null){let s;if(Array.isArray(i)){s=[];for(let o=0,a=i.length;o<a;o++)i[o].isDataTexture?s.push(TC(i[o].image)):s.push(TC(i[o]))}else s=TC(i);r.url=s}return n||(e.images[this.uuid]=r),r}}function TC(t){return typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&t instanceof ImageBitmap?w5.getDataURL(t):t.data?{data:Array.from(t.data),width:t.width,height:t.height,type:t.data.constructor.name}:(console.warn("THREE.Texture: Unable to serialize Texture."),{})}let Ile=0;class Bn extends ka{constructor(e=Bn.DEFAULT_IMAGE,n=Bn.DEFAULT_MAPPING,r=ws,i=ws,s=or,o=ao,a=Yi,l=Ea,c=Bn.DEFAULT_ANISOTROPY,u=tl){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:Ile++}),this.uuid=Ms(),this.name="",this.source=new Bu(e),this.mipmaps=[],this.mapping=n,this.channel=0,this.wrapS=r,this.wrapT=i,this.magFilter=s,this.minFilter=o,this.anisotropy=c,this.format=a,this.internalFormat=null,this.type=l,this.offset=new Re(0,0),this.repeat=new Re(1,1),this.center=new Re(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new $t,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=u,this.userData={},this.version=0,this.onUpdate=null,this.isRenderTargetTexture=!1,this.pmremVersion=0}get image(){return this.source.data}set image(e=null){this.source.data=e}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}clone(){return new this.constructor().copy(this)}copy(e){return this.name=e.name,this.source=e.source,this.mipmaps=e.mipmaps.slice(0),this.mapping=e.mapping,this.channel=e.channel,this.wrapS=e.wrapS,this.wrapT=e.wrapT,this.magFilter=e.magFilter,this.minFilter=e.minFilter,this.anisotropy=e.anisotropy,this.format=e.format,this.internalFormat=e.internalFormat,this.type=e.type,this.offset.copy(e.offset),this.repeat.copy(e.repeat),this.center.copy(e.center),this.rotation=e.rotation,this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrix.copy(e.matrix),this.generateMipmaps=e.generateMipmaps,this.premultiplyAlpha=e.premultiplyAlpha,this.flipY=e.flipY,this.unpackAlignment=e.unpackAlignment,this.colorSpace=e.colorSpace,this.userData=JSON.parse(JSON.stringify(e.userData)),this.needsUpdate=!0,this}toJSON(e){const n=e===void 0||typeof e=="string";if(!n&&e.textures[this.uuid]!==void 0)return e.textures[this.uuid];const r={metadata:{version:4.6,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(e).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(r.userData=this.userData),n||(e.textures[this.uuid]=r),r}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(e){if(this.mapping!==ES)return e;if(e.applyMatrix3(this.matrix),e.x<0||e.x>1)switch(this.wrapS){case Tc:e.x=e.x-Math.floor(e.x);break;case ws:e.x=e.x<0?0:1;break;case $h:Math.abs(Math.floor(e.x)%2)===1?e.x=Math.ceil(e.x)-e.x:e.x=e.x-Math.floor(e.x);break}if(e.y<0||e.y>1)switch(this.wrapT){case Tc:e.y=e.y-Math.floor(e.y);break;case ws:e.y=e.y<0?0:1;break;case $h:Math.abs(Math.floor(e.y)%2)===1?e.y=Math.ceil(e.y)-e.y:e.y=e.y-Math.floor(e.y);break}return this.flipY&&(e.y=1-e.y),e}set needsUpdate(e){e===!0&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(e){e===!0&&this.pmremVersion++}}Bn.DEFAULT_IMAGE=null;Bn.DEFAULT_MAPPING=ES;Bn.DEFAULT_ANISOTROPY=1;class vn{constructor(e=0,n=0,r=0,i=1){vn.prototype.isVector4=!0,this.x=e,this.y=n,this.z=r,this.w=i}get width(){return this.z}set width(e){this.z=e}get height(){return this.w}set height(e){this.w=e}set(e,n,r,i){return this.x=e,this.y=n,this.z=r,this.w=i,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this.w=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setW(e){return this.w=e,this}setComponent(e,n){switch(e){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;case 3:this.w=n;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w!==void 0?e.w:1,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this.w+=e.w,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this.w+=e,this}addVectors(e,n){return this.x=e.x+n.x,this.y=e.y+n.y,this.z=e.z+n.z,this.w=e.w+n.w,this}addScaledVector(e,n){return this.x+=e.x*n,this.y+=e.y*n,this.z+=e.z*n,this.w+=e.w*n,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this.w-=e.w,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this.w-=e,this}subVectors(e,n){return this.x=e.x-n.x,this.y=e.y-n.y,this.z=e.z-n.z,this.w=e.w-n.w,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this.w*=e.w,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this.w*=e,this}applyMatrix4(e){const n=this.x,r=this.y,i=this.z,s=this.w,o=e.elements;return this.x=o[0]*n+o[4]*r+o[8]*i+o[12]*s,this.y=o[1]*n+o[5]*r+o[9]*i+o[13]*s,this.z=o[2]*n+o[6]*r+o[10]*i+o[14]*s,this.w=o[3]*n+o[7]*r+o[11]*i+o[15]*s,this}divideScalar(e){return this.multiplyScalar(1/e)}setAxisAngleFromQuaternion(e){this.w=2*Math.acos(e.w);const n=Math.sqrt(1-e.w*e.w);return n<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=e.x/n,this.y=e.y/n,this.z=e.z/n),this}setAxisAngleFromRotationMatrix(e){let n,r,i,s;const l=e.elements,c=l[0],u=l[4],d=l[8],f=l[1],h=l[5],p=l[9],x=l[2],v=l[6],y=l[10];if(Math.abs(u-f)<.01&&Math.abs(d-x)<.01&&Math.abs(p-v)<.01){if(Math.abs(u+f)<.1&&Math.abs(d+x)<.1&&Math.abs(p+v)<.1&&Math.abs(c+h+y-3)<.1)return this.set(1,0,0,0),this;n=Math.PI;const S=(c+1)/2,w=(h+1)/2,E=(y+1)/2,A=(u+f)/4,T=(d+x)/4,I=(p+v)/4;return S>w&&S>E?S<.01?(r=0,i=.707106781,s=.707106781):(r=Math.sqrt(S),i=A/r,s=T/r):w>E?w<.01?(r=.707106781,i=0,s=.707106781):(i=Math.sqrt(w),r=A/i,s=I/i):E<.01?(r=.707106781,i=.707106781,s=0):(s=Math.sqrt(E),r=T/s,i=I/s),this.set(r,i,s,n),this}let b=Math.sqrt((v-p)*(v-p)+(d-x)*(d-x)+(f-u)*(f-u));return Math.abs(b)<.001&&(b=1),this.x=(v-p)/b,this.y=(d-x)/b,this.z=(f-u)/b,this.w=Math.acos((c+h+y-1)/2),this}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this.w=Math.min(this.w,e.w),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this.w=Math.max(this.w,e.w),this}clamp(e,n){return this.x=Math.max(e.x,Math.min(n.x,this.x)),this.y=Math.max(e.y,Math.min(n.y,this.y)),this.z=Math.max(e.z,Math.min(n.z,this.z)),this.w=Math.max(e.w,Math.min(n.w,this.w)),this}clampScalar(e,n){return this.x=Math.max(e,Math.min(n,this.x)),this.y=Math.max(e,Math.min(n,this.y)),this.z=Math.max(e,Math.min(n,this.z)),this.w=Math.max(e,Math.min(n,this.w)),this}clampLength(e,n){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(n,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z+this.w*e.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,n){return this.x+=(e.x-this.x)*n,this.y+=(e.y-this.y)*n,this.z+=(e.z-this.z)*n,this.w+=(e.w-this.w)*n,this}lerpVectors(e,n,r){return this.x=e.x+(n.x-e.x)*r,this.y=e.y+(n.y-e.y)*r,this.z=e.z+(n.z-e.z)*r,this.w=e.w+(n.w-e.w)*r,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z&&e.w===this.w}fromArray(e,n=0){return this.x=e[n],this.y=e[n+1],this.z=e[n+2],this.w=e[n+3],this}toArray(e=[],n=0){return e[n]=this.x,e[n+1]=this.y,e[n+2]=this.z,e[n+3]=this.w,e}fromBufferAttribute(e,n){return this.x=e.getX(n),this.y=e.getY(n),this.z=e.getZ(n),this.w=e.getW(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class C5 extends ka{constructor(e=1,n=1,r={}){super(),this.isRenderTarget=!0,this.width=e,this.height=n,this.depth=1,this.scissor=new vn(0,0,e,n),this.scissorTest=!1,this.viewport=new vn(0,0,e,n);const i={width:e,height:n,depth:1};r=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:or,depthBuffer:!0,stencilBuffer:!1,depthTexture:null,samples:0,count:1},r);const s=new Bn(i,r.mapping,r.wrapS,r.wrapT,r.magFilter,r.minFilter,r.format,r.type,r.anisotropy,r.colorSpace);s.flipY=!1,s.generateMipmaps=r.generateMipmaps,s.internalFormat=r.internalFormat,this.textures=[];const o=r.count;for(let a=0;a<o;a++)this.textures[a]=s.clone(),this.textures[a].isRenderTargetTexture=!0;this.depthBuffer=r.depthBuffer,this.stencilBuffer=r.stencilBuffer,this.depthTexture=r.depthTexture,this.samples=r.samples}get texture(){return this.textures[0]}set texture(e){this.textures[0]=e}setSize(e,n,r=1){if(this.width!==e||this.height!==n||this.depth!==r){this.width=e,this.height=n,this.depth=r;for(let i=0,s=this.textures.length;i<s;i++)this.textures[i].image.width=e,this.textures[i].image.height=n,this.textures[i].image.depth=r;this.dispose()}this.viewport.set(0,0,e,n),this.scissor.set(0,0,e,n)}clone(){return new this.constructor().copy(this)}copy(e){this.width=e.width,this.height=e.height,this.depth=e.depth,this.scissor.copy(e.scissor),this.scissorTest=e.scissorTest,this.viewport.copy(e.viewport),this.textures.length=0;for(let r=0,i=e.textures.length;r<i;r++)this.textures[r]=e.textures[r].clone(),this.textures[r].isRenderTargetTexture=!0;const n=Object.assign({},e.texture.image);return this.texture.source=new Bu(n),this.depthBuffer=e.depthBuffer,this.stencilBuffer=e.stencilBuffer,e.depthTexture!==null&&(this.depthTexture=e.depthTexture.clone()),this.samples=e.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class Xo extends C5{constructor(e=1,n=1,r={}){super(e,n,r),this.isWebGLRenderTarget=!0}}class RS extends Bn{constructor(e=null,n=1,r=1,i=1){super(null),this.isDataArrayTexture=!0,this.image={data:e,width:n,height:r,depth:i},this.magFilter=Nr,this.minFilter=Nr,this.wrapR=ws,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Nle extends Xo{constructor(e=1,n=1,r=1,i={}){super(e,n,i),this.isWebGLArrayRenderTarget=!0,this.depth=r,this.texture=new RS(null,e,n,r),this.texture.isRenderTargetTexture=!0}}class RR extends Bn{constructor(e=null,n=1,r=1,i=1){super(null),this.isData3DTexture=!0,this.image={data:e,width:n,height:r,depth:i},this.magFilter=Nr,this.minFilter=Nr,this.wrapR=ws,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Ple extends Xo{constructor(e=1,n=1,r=1,i={}){super(e,n,i),this.isWebGL3DRenderTarget=!0,this.depth=r,this.texture=new RR(null,e,n,r),this.texture.isRenderTargetTexture=!0}}class Hr{constructor(e=0,n=0,r=0,i=1){this.isQuaternion=!0,this._x=e,this._y=n,this._z=r,this._w=i}static slerpFlat(e,n,r,i,s,o,a){let l=r[i+0],c=r[i+1],u=r[i+2],d=r[i+3];const f=s[o+0],h=s[o+1],p=s[o+2],x=s[o+3];if(a===0){e[n+0]=l,e[n+1]=c,e[n+2]=u,e[n+3]=d;return}if(a===1){e[n+0]=f,e[n+1]=h,e[n+2]=p,e[n+3]=x;return}if(d!==x||l!==f||c!==h||u!==p){let v=1-a;const y=l*f+c*h+u*p+d*x,b=y>=0?1:-1,S=1-y*y;if(S>Number.EPSILON){const E=Math.sqrt(S),A=Math.atan2(E,y*b);v=Math.sin(v*A)/E,a=Math.sin(a*A)/E}const w=a*b;if(l=l*v+f*w,c=c*v+h*w,u=u*v+p*w,d=d*v+x*w,v===1-a){const E=1/Math.sqrt(l*l+c*c+u*u+d*d);l*=E,c*=E,u*=E,d*=E}}e[n]=l,e[n+1]=c,e[n+2]=u,e[n+3]=d}static multiplyQuaternionsFlat(e,n,r,i,s,o){const a=r[i],l=r[i+1],c=r[i+2],u=r[i+3],d=s[o],f=s[o+1],h=s[o+2],p=s[o+3];return e[n]=a*p+u*d+l*h-c*f,e[n+1]=l*p+u*f+c*d-a*h,e[n+2]=c*p+u*h+a*f-l*d,e[n+3]=u*p-a*d-l*f-c*h,e}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get w(){return this._w}set w(e){this._w=e,this._onChangeCallback()}set(e,n,r,i){return this._x=e,this._y=n,this._z=r,this._w=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(e){return this._x=e.x,this._y=e.y,this._z=e.z,this._w=e.w,this._onChangeCallback(),this}setFromEuler(e,n=!0){const r=e._x,i=e._y,s=e._z,o=e._order,a=Math.cos,l=Math.sin,c=a(r/2),u=a(i/2),d=a(s/2),f=l(r/2),h=l(i/2),p=l(s/2);switch(o){case"XYZ":this._x=f*u*d+c*h*p,this._y=c*h*d-f*u*p,this._z=c*u*p+f*h*d,this._w=c*u*d-f*h*p;break;case"YXZ":this._x=f*u*d+c*h*p,this._y=c*h*d-f*u*p,this._z=c*u*p-f*h*d,this._w=c*u*d+f*h*p;break;case"ZXY":this._x=f*u*d-c*h*p,this._y=c*h*d+f*u*p,this._z=c*u*p+f*h*d,this._w=c*u*d-f*h*p;break;case"ZYX":this._x=f*u*d-c*h*p,this._y=c*h*d+f*u*p,this._z=c*u*p-f*h*d,this._w=c*u*d+f*h*p;break;case"YZX":this._x=f*u*d+c*h*p,this._y=c*h*d+f*u*p,this._z=c*u*p-f*h*d,this._w=c*u*d-f*h*p;break;case"XZY":this._x=f*u*d-c*h*p,this._y=c*h*d-f*u*p,this._z=c*u*p+f*h*d,this._w=c*u*d+f*h*p;break;default:console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: "+o)}return n===!0&&this._onChangeCallback(),this}setFromAxisAngle(e,n){const r=n/2,i=Math.sin(r);return this._x=e.x*i,this._y=e.y*i,this._z=e.z*i,this._w=Math.cos(r),this._onChangeCallback(),this}setFromRotationMatrix(e){const n=e.elements,r=n[0],i=n[4],s=n[8],o=n[1],a=n[5],l=n[9],c=n[2],u=n[6],d=n[10],f=r+a+d;if(f>0){const h=.5/Math.sqrt(f+1);this._w=.25/h,this._x=(u-l)*h,this._y=(s-c)*h,this._z=(o-i)*h}else if(r>a&&r>d){const h=2*Math.sqrt(1+r-a-d);this._w=(u-l)/h,this._x=.25*h,this._y=(i+o)/h,this._z=(s+c)/h}else if(a>d){const h=2*Math.sqrt(1+a-r-d);this._w=(s-c)/h,this._x=(i+o)/h,this._y=.25*h,this._z=(l+u)/h}else{const h=2*Math.sqrt(1+d-r-a);this._w=(o-i)/h,this._x=(s+c)/h,this._y=(l+u)/h,this._z=.25*h}return this._onChangeCallback(),this}setFromUnitVectors(e,n){let r=e.dot(n)+1;return r<Number.EPSILON?(r=0,Math.abs(e.x)>Math.abs(e.z)?(this._x=-e.y,this._y=e.x,this._z=0,this._w=r):(this._x=0,this._y=-e.z,this._z=e.y,this._w=r)):(this._x=e.y*n.z-e.z*n.y,this._y=e.z*n.x-e.x*n.z,this._z=e.x*n.y-e.y*n.x,this._w=r),this.normalize()}angleTo(e){return 2*Math.acos(Math.abs(sr(this.dot(e),-1,1)))}rotateTowards(e,n){const r=this.angleTo(e);if(r===0)return this;const i=Math.min(1,n/r);return this.slerp(e,i),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(e){return this._x*e._x+this._y*e._y+this._z*e._z+this._w*e._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let e=this.length();return e===0?(this._x=0,this._y=0,this._z=0,this._w=1):(e=1/e,this._x=this._x*e,this._y=this._y*e,this._z=this._z*e,this._w=this._w*e),this._onChangeCallback(),this}multiply(e){return this.multiplyQuaternions(this,e)}premultiply(e){return this.multiplyQuaternions(e,this)}multiplyQuaternions(e,n){const r=e._x,i=e._y,s=e._z,o=e._w,a=n._x,l=n._y,c=n._z,u=n._w;return this._x=r*u+o*a+i*c-s*l,this._y=i*u+o*l+s*a-r*c,this._z=s*u+o*c+r*l-i*a,this._w=o*u-r*a-i*l-s*c,this._onChangeCallback(),this}slerp(e,n){if(n===0)return this;if(n===1)return this.copy(e);const r=this._x,i=this._y,s=this._z,o=this._w;let a=o*e._w+r*e._x+i*e._y+s*e._z;if(a<0?(this._w=-e._w,this._x=-e._x,this._y=-e._y,this._z=-e._z,a=-a):this.copy(e),a>=1)return this._w=o,this._x=r,this._y=i,this._z=s,this;const l=1-a*a;if(l<=Number.EPSILON){const h=1-n;return this._w=h*o+n*this._w,this._x=h*r+n*this._x,this._y=h*i+n*this._y,this._z=h*s+n*this._z,this.normalize(),this}const c=Math.sqrt(l),u=Math.atan2(c,a),d=Math.sin((1-n)*u)/c,f=Math.sin(n*u)/c;return this._w=o*d+this._w*f,this._x=r*d+this._x*f,this._y=i*d+this._y*f,this._z=s*d+this._z*f,this._onChangeCallback(),this}slerpQuaternions(e,n,r){return this.copy(e).slerp(n,r)}random(){const e=2*Math.PI*Math.random(),n=2*Math.PI*Math.random(),r=Math.random(),i=Math.sqrt(1-r),s=Math.sqrt(r);return this.set(i*Math.sin(e),i*Math.cos(e),s*Math.sin(n),s*Math.cos(n))}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._w===this._w}fromArray(e,n=0){return this._x=e[n],this._y=e[n+1],this._z=e[n+2],this._w=e[n+3],this._onChangeCallback(),this}toArray(e=[],n=0){return e[n]=this._x,e[n+1]=this._y,e[n+2]=this._z,e[n+3]=this._w,e}fromBufferAttribute(e,n){return this._x=e.getX(n),this._y=e.getY(n),this._z=e.getZ(n),this._w=e.getW(n),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class K{constructor(e=0,n=0,r=0){K.prototype.isVector3=!0,this.x=e,this.y=n,this.z=r}set(e,n,r){return r===void 0&&(r=this.z),this.x=e,this.y=n,this.z=r,this}setScalar(e){return this.x=e,this.y=e,this.z=e,this}setX(e){return this.x=e,this}setY(e){return this.y=e,this}setZ(e){return this.z=e,this}setComponent(e,n){switch(e){case 0:this.x=n;break;case 1:this.y=n;break;case 2:this.z=n;break;default:throw new Error("index is out of range: "+e)}return this}getComponent(e){switch(e){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+e)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(e){return this.x=e.x,this.y=e.y,this.z=e.z,this}add(e){return this.x+=e.x,this.y+=e.y,this.z+=e.z,this}addScalar(e){return this.x+=e,this.y+=e,this.z+=e,this}addVectors(e,n){return this.x=e.x+n.x,this.y=e.y+n.y,this.z=e.z+n.z,this}addScaledVector(e,n){return this.x+=e.x*n,this.y+=e.y*n,this.z+=e.z*n,this}sub(e){return this.x-=e.x,this.y-=e.y,this.z-=e.z,this}subScalar(e){return this.x-=e,this.y-=e,this.z-=e,this}subVectors(e,n){return this.x=e.x-n.x,this.y=e.y-n.y,this.z=e.z-n.z,this}multiply(e){return this.x*=e.x,this.y*=e.y,this.z*=e.z,this}multiplyScalar(e){return this.x*=e,this.y*=e,this.z*=e,this}multiplyVectors(e,n){return this.x=e.x*n.x,this.y=e.y*n.y,this.z=e.z*n.z,this}applyEuler(e){return this.applyQuaternion(OD.setFromEuler(e))}applyAxisAngle(e,n){return this.applyQuaternion(OD.setFromAxisAngle(e,n))}applyMatrix3(e){const n=this.x,r=this.y,i=this.z,s=e.elements;return this.x=s[0]*n+s[3]*r+s[6]*i,this.y=s[1]*n+s[4]*r+s[7]*i,this.z=s[2]*n+s[5]*r+s[8]*i,this}applyNormalMatrix(e){return this.applyMatrix3(e).normalize()}applyMatrix4(e){const n=this.x,r=this.y,i=this.z,s=e.elements,o=1/(s[3]*n+s[7]*r+s[11]*i+s[15]);return this.x=(s[0]*n+s[4]*r+s[8]*i+s[12])*o,this.y=(s[1]*n+s[5]*r+s[9]*i+s[13])*o,this.z=(s[2]*n+s[6]*r+s[10]*i+s[14])*o,this}applyQuaternion(e){const n=this.x,r=this.y,i=this.z,s=e.x,o=e.y,a=e.z,l=e.w,c=2*(o*i-a*r),u=2*(a*n-s*i),d=2*(s*r-o*n);return this.x=n+l*c+o*d-a*u,this.y=r+l*u+a*c-s*d,this.z=i+l*d+s*u-o*c,this}project(e){return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)}unproject(e){return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)}transformDirection(e){const n=this.x,r=this.y,i=this.z,s=e.elements;return this.x=s[0]*n+s[4]*r+s[8]*i,this.y=s[1]*n+s[5]*r+s[9]*i,this.z=s[2]*n+s[6]*r+s[10]*i,this.normalize()}divide(e){return this.x/=e.x,this.y/=e.y,this.z/=e.z,this}divideScalar(e){return this.multiplyScalar(1/e)}min(e){return this.x=Math.min(this.x,e.x),this.y=Math.min(this.y,e.y),this.z=Math.min(this.z,e.z),this}max(e){return this.x=Math.max(this.x,e.x),this.y=Math.max(this.y,e.y),this.z=Math.max(this.z,e.z),this}clamp(e,n){return this.x=Math.max(e.x,Math.min(n.x,this.x)),this.y=Math.max(e.y,Math.min(n.y,this.y)),this.z=Math.max(e.z,Math.min(n.z,this.z)),this}clampScalar(e,n){return this.x=Math.max(e,Math.min(n,this.x)),this.y=Math.max(e,Math.min(n,this.y)),this.z=Math.max(e,Math.min(n,this.z)),this}clampLength(e,n){const r=this.length();return this.divideScalar(r||1).multiplyScalar(Math.max(e,Math.min(n,r)))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(e){return this.x*e.x+this.y*e.y+this.z*e.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(e){return this.normalize().multiplyScalar(e)}lerp(e,n){return this.x+=(e.x-this.x)*n,this.y+=(e.y-this.y)*n,this.z+=(e.z-this.z)*n,this}lerpVectors(e,n,r){return this.x=e.x+(n.x-e.x)*r,this.y=e.y+(n.y-e.y)*r,this.z=e.z+(n.z-e.z)*r,this}cross(e){return this.crossVectors(this,e)}crossVectors(e,n){const r=e.x,i=e.y,s=e.z,o=n.x,a=n.y,l=n.z;return this.x=i*l-s*a,this.y=s*o-r*l,this.z=r*a-i*o,this}projectOnVector(e){const n=e.lengthSq();if(n===0)return this.set(0,0,0);const r=e.dot(this)/n;return this.copy(e).multiplyScalar(r)}projectOnPlane(e){return MC.copy(this).projectOnVector(e),this.sub(MC)}reflect(e){return this.sub(MC.copy(e).multiplyScalar(2*this.dot(e)))}angleTo(e){const n=Math.sqrt(this.lengthSq()*e.lengthSq());if(n===0)return Math.PI/2;const r=this.dot(e)/n;return Math.acos(sr(r,-1,1))}distanceTo(e){return Math.sqrt(this.distanceToSquared(e))}distanceToSquared(e){const n=this.x-e.x,r=this.y-e.y,i=this.z-e.z;return n*n+r*r+i*i}manhattanDistanceTo(e){return Math.abs(this.x-e.x)+Math.abs(this.y-e.y)+Math.abs(this.z-e.z)}setFromSpherical(e){return this.setFromSphericalCoords(e.radius,e.phi,e.theta)}setFromSphericalCoords(e,n,r){const i=Math.sin(n)*e;return this.x=i*Math.sin(r),this.y=Math.cos(n)*e,this.z=i*Math.cos(r),this}setFromCylindrical(e){return this.setFromCylindricalCoords(e.radius,e.theta,e.y)}setFromCylindricalCoords(e,n,r){return this.x=e*Math.sin(n),this.y=r,this.z=e*Math.cos(n),this}setFromMatrixPosition(e){const n=e.elements;return this.x=n[12],this.y=n[13],this.z=n[14],this}setFromMatrixScale(e){const n=this.setFromMatrixColumn(e,0).length(),r=this.setFromMatrixColumn(e,1).length(),i=this.setFromMatrixColumn(e,2).length();return this.x=n,this.y=r,this.z=i,this}setFromMatrixColumn(e,n){return this.fromArray(e.elements,n*4)}setFromMatrix3Column(e,n){return this.fromArray(e.elements,n*3)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(e){return this.x=e.r,this.y=e.g,this.z=e.b,this}equals(e){return e.x===this.x&&e.y===this.y&&e.z===this.z}fromArray(e,n=0){return this.x=e[n],this.y=e[n+1],this.z=e[n+2],this}toArray(e=[],n=0){return e[n]=this.x,e[n+1]=this.y,e[n+2]=this.z,e}fromBufferAttribute(e,n){return this.x=e.getX(n),this.y=e.getY(n),this.z=e.getZ(n),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const e=Math.random()*Math.PI*2,n=Math.random()*2-1,r=Math.sqrt(1-n*n);return this.x=r*Math.cos(e),this.y=n,this.z=r*Math.sin(e),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const MC=new K,OD=new Hr;class vi{constructor(e=new K(1/0,1/0,1/0),n=new K(-1/0,-1/0,-1/0)){this.isBox3=!0,this.min=e,this.max=n}set(e,n){return this.min.copy(e),this.max.copy(n),this}setFromArray(e){this.makeEmpty();for(let n=0,r=e.length;n<r;n+=3)this.expandByPoint(Mo.fromArray(e,n));return this}setFromBufferAttribute(e){this.makeEmpty();for(let n=0,r=e.count;n<r;n++)this.expandByPoint(Mo.fromBufferAttribute(e,n));return this}setFromPoints(e){this.makeEmpty();for(let n=0,r=e.length;n<r;n++)this.expandByPoint(e[n]);return this}setFromCenterAndSize(e,n){const r=Mo.copy(n).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}setFromObject(e,n=!1){return this.makeEmpty(),this.expandByObject(e,n)}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=1/0,this.max.x=this.max.y=this.max.z=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(e){return this.isEmpty()?e.set(0,0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}expandByObject(e,n=!1){e.updateWorldMatrix(!1,!1);const r=e.geometry;if(r!==void 0){const s=r.getAttribute("position");if(n===!0&&s!==void 0&&e.isInstancedMesh!==!0)for(let o=0,a=s.count;o<a;o++)e.isMesh===!0?e.getVertexPosition(o,Mo):Mo.fromBufferAttribute(s,o),Mo.applyMatrix4(e.matrixWorld),this.expandByPoint(Mo);else e.boundingBox!==void 0?(e.boundingBox===null&&e.computeBoundingBox(),wv.copy(e.boundingBox)):(r.boundingBox===null&&r.computeBoundingBox(),wv.copy(r.boundingBox)),wv.applyMatrix4(e.matrixWorld),this.union(wv)}const i=e.children;for(let s=0,o=i.length;s<o;s++)this.expandByObject(i[s],n);return this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y||e.z<this.min.z||e.z>this.max.z)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y&&this.min.z<=e.min.z&&e.max.z<=this.max.z}getParameter(e,n){return n.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y),(e.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y||e.max.z<this.min.z||e.min.z>this.max.z)}intersectsSphere(e){return this.clampPoint(e.center,Mo),Mo.distanceToSquared(e.center)<=e.radius*e.radius}intersectsPlane(e){let n,r;return e.normal.x>0?(n=e.normal.x*this.min.x,r=e.normal.x*this.max.x):(n=e.normal.x*this.max.x,r=e.normal.x*this.min.x),e.normal.y>0?(n+=e.normal.y*this.min.y,r+=e.normal.y*this.max.y):(n+=e.normal.y*this.max.y,r+=e.normal.y*this.min.y),e.normal.z>0?(n+=e.normal.z*this.min.z,r+=e.normal.z*this.max.z):(n+=e.normal.z*this.max.z,r+=e.normal.z*this.min.z),n<=-e.constant&&r>=-e.constant}intersectsTriangle(e){if(this.isEmpty())return!1;this.getCenter(ym),Cv.subVectors(this.max,ym),ff.subVectors(e.a,ym),hf.subVectors(e.b,ym),pf.subVectors(e.c,ym),Wl.subVectors(hf,ff),jl.subVectors(pf,hf),tu.subVectors(ff,pf);let n=[0,-Wl.z,Wl.y,0,-jl.z,jl.y,0,-tu.z,tu.y,Wl.z,0,-Wl.x,jl.z,0,-jl.x,tu.z,0,-tu.x,-Wl.y,Wl.x,0,-jl.y,jl.x,0,-tu.y,tu.x,0];return!RC(n,ff,hf,pf,Cv)||(n=[1,0,0,0,1,0,0,0,1],!RC(n,ff,hf,pf,Cv))?!1:(Ev.crossVectors(Wl,jl),n=[Ev.x,Ev.y,Ev.z],RC(n,ff,hf,pf,Cv))}clampPoint(e,n){return n.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,Mo).distanceTo(e)}getBoundingSphere(e){return this.isEmpty()?e.makeEmpty():(this.getCenter(e.center),e.radius=this.getSize(Mo).length()*.5),e}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}applyMatrix4(e){return this.isEmpty()?this:(Ha[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(e),Ha[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(e),Ha[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(e),Ha[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(e),Ha[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(e),Ha[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(e),Ha[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(e),Ha[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(e),this.setFromPoints(Ha),this)}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const Ha=[new K,new K,new K,new K,new K,new K,new K,new K],Mo=new K,wv=new vi,ff=new K,hf=new K,pf=new K,Wl=new K,jl=new K,tu=new K,ym=new K,Cv=new K,Ev=new K,nu=new K;function RC(t,e,n,r,i){for(let s=0,o=t.length-3;s<=o;s+=3){nu.fromArray(t,s);const a=i.x*Math.abs(nu.x)+i.y*Math.abs(nu.y)+i.z*Math.abs(nu.z),l=e.dot(nu),c=n.dot(nu),u=r.dot(nu);if(Math.max(-Math.max(l,c,u),Math.min(l,c,u))>a)return!1}return!0}const kle=new vi,vm=new K,IC=new K;class Zr{constructor(e=new K,n=-1){this.isSphere=!0,this.center=e,this.radius=n}set(e,n){return this.center.copy(e),this.radius=n,this}setFromPoints(e,n){const r=this.center;n!==void 0?r.copy(n):kle.setFromPoints(e).getCenter(r);let i=0;for(let s=0,o=e.length;s<o;s++)i=Math.max(i,r.distanceToSquared(e[s]));return this.radius=Math.sqrt(i),this}copy(e){return this.center.copy(e.center),this.radius=e.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(e){return e.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(e){return e.distanceTo(this.center)-this.radius}intersectsSphere(e){const n=this.radius+e.radius;return e.center.distanceToSquared(this.center)<=n*n}intersectsBox(e){return e.intersectsSphere(this)}intersectsPlane(e){return Math.abs(e.distanceToPoint(this.center))<=this.radius}clampPoint(e,n){const r=this.center.distanceToSquared(e);return n.copy(e),r>this.radius*this.radius&&(n.sub(this.center).normalize(),n.multiplyScalar(this.radius).add(this.center)),n}getBoundingBox(e){return this.isEmpty()?(e.makeEmpty(),e):(e.set(this.center,this.center),e.expandByScalar(this.radius),e)}applyMatrix4(e){return this.center.applyMatrix4(e),this.radius=this.radius*e.getMaxScaleOnAxis(),this}translate(e){return this.center.add(e),this}expandByPoint(e){if(this.isEmpty())return this.center.copy(e),this.radius=0,this;vm.subVectors(e,this.center);const n=vm.lengthSq();if(n>this.radius*this.radius){const r=Math.sqrt(n),i=(r-this.radius)*.5;this.center.addScaledVector(vm,i/r),this.radius+=i}return this}union(e){return e.isEmpty()?this:this.isEmpty()?(this.copy(e),this):(this.center.equals(e.center)===!0?this.radius=Math.max(this.radius,e.radius):(IC.subVectors(e.center,this.center).setLength(e.radius),this.expandByPoint(vm.copy(e.center).add(IC)),this.expandByPoint(vm.copy(e.center).sub(IC))),this)}equals(e){return e.center.equals(this.center)&&e.radius===this.radius}clone(){return new this.constructor().copy(this)}}const Va=new K,NC=new K,Av=new K,Xl=new K,PC=new K,Tv=new K,kC=new K;class Nd{constructor(e=new K,n=new K(0,0,-1)){this.origin=e,this.direction=n}set(e,n){return this.origin.copy(e),this.direction.copy(n),this}copy(e){return this.origin.copy(e.origin),this.direction.copy(e.direction),this}at(e,n){return n.copy(this.origin).addScaledVector(this.direction,e)}lookAt(e){return this.direction.copy(e).sub(this.origin).normalize(),this}recast(e){return this.origin.copy(this.at(e,Va)),this}closestPointToPoint(e,n){n.subVectors(e,this.origin);const r=n.dot(this.direction);return r<0?n.copy(this.origin):n.copy(this.origin).addScaledVector(this.direction,r)}distanceToPoint(e){return Math.sqrt(this.distanceSqToPoint(e))}distanceSqToPoint(e){const n=Va.subVectors(e,this.origin).dot(this.direction);return n<0?this.origin.distanceToSquared(e):(Va.copy(this.origin).addScaledVector(this.direction,n),Va.distanceToSquared(e))}distanceSqToSegment(e,n,r,i){NC.copy(e).add(n).multiplyScalar(.5),Av.copy(n).sub(e).normalize(),Xl.copy(this.origin).sub(NC);const s=e.distanceTo(n)*.5,o=-this.direction.dot(Av),a=Xl.dot(this.direction),l=-Xl.dot(Av),c=Xl.lengthSq(),u=Math.abs(1-o*o);let d,f,h,p;if(u>0)if(d=o*l-a,f=o*a-l,p=s*u,d>=0)if(f>=-p)if(f<=p){const x=1/u;d*=x,f*=x,h=d*(d+o*f+2*a)+f*(o*d+f+2*l)+c}else f=s,d=Math.max(0,-(o*f+a)),h=-d*d+f*(f+2*l)+c;else f=-s,d=Math.max(0,-(o*f+a)),h=-d*d+f*(f+2*l)+c;else f<=-p?(d=Math.max(0,-(-o*s+a)),f=d>0?-s:Math.min(Math.max(-s,-l),s),h=-d*d+f*(f+2*l)+c):f<=p?(d=0,f=Math.min(Math.max(-s,-l),s),h=f*(f+2*l)+c):(d=Math.max(0,-(o*s+a)),f=d>0?s:Math.min(Math.max(-s,-l),s),h=-d*d+f*(f+2*l)+c);else f=o>0?-s:s,d=Math.max(0,-(o*f+a)),h=-d*d+f*(f+2*l)+c;return r&&r.copy(this.origin).addScaledVector(this.direction,d),i&&i.copy(NC).addScaledVector(Av,f),h}intersectSphere(e,n){Va.subVectors(e.center,this.origin);const r=Va.dot(this.direction),i=Va.dot(Va)-r*r,s=e.radius*e.radius;if(i>s)return null;const o=Math.sqrt(s-i),a=r-o,l=r+o;return l<0?null:a<0?this.at(l,n):this.at(a,n)}intersectsSphere(e){return this.distanceSqToPoint(e.center)<=e.radius*e.radius}distanceToPlane(e){const n=e.normal.dot(this.direction);if(n===0)return e.distanceToPoint(this.origin)===0?0:null;const r=-(this.origin.dot(e.normal)+e.constant)/n;return r>=0?r:null}intersectPlane(e,n){const r=this.distanceToPlane(e);return r===null?null:this.at(r,n)}intersectsPlane(e){const n=e.distanceToPoint(this.origin);return n===0||e.normal.dot(this.direction)*n<0}intersectBox(e,n){let r,i,s,o,a,l;const c=1/this.direction.x,u=1/this.direction.y,d=1/this.direction.z,f=this.origin;return c>=0?(r=(e.min.x-f.x)*c,i=(e.max.x-f.x)*c):(r=(e.max.x-f.x)*c,i=(e.min.x-f.x)*c),u>=0?(s=(e.min.y-f.y)*u,o=(e.max.y-f.y)*u):(s=(e.max.y-f.y)*u,o=(e.min.y-f.y)*u),r>o||s>i||((s>r||isNaN(r))&&(r=s),(o<i||isNaN(i))&&(i=o),d>=0?(a=(e.min.z-f.z)*d,l=(e.max.z-f.z)*d):(a=(e.max.z-f.z)*d,l=(e.min.z-f.z)*d),r>l||a>i)||((a>r||r!==r)&&(r=a),(l<i||i!==i)&&(i=l),i<0)?null:this.at(r>=0?r:i,n)}intersectsBox(e){return this.intersectBox(e,Va)!==null}intersectTriangle(e,n,r,i,s){PC.subVectors(n,e),Tv.subVectors(r,e),kC.crossVectors(PC,Tv);let o=this.direction.dot(kC),a;if(o>0){if(i)return null;a=1}else if(o<0)a=-1,o=-o;else return null;Xl.subVectors(this.origin,e);const l=a*this.direction.dot(Tv.crossVectors(Xl,Tv));if(l<0)return null;const c=a*this.direction.dot(PC.cross(Xl));if(c<0||l+c>o)return null;const u=-a*Xl.dot(kC);return u<0?null:this.at(u/o,s)}applyMatrix4(e){return this.origin.applyMatrix4(e),this.direction.transformDirection(e),this}equals(e){return e.origin.equals(this.origin)&&e.direction.equals(this.direction)}clone(){return new this.constructor().copy(this)}}class St{constructor(e,n,r,i,s,o,a,l,c,u,d,f,h,p,x,v){St.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],e!==void 0&&this.set(e,n,r,i,s,o,a,l,c,u,d,f,h,p,x,v)}set(e,n,r,i,s,o,a,l,c,u,d,f,h,p,x,v){const y=this.elements;return y[0]=e,y[4]=n,y[8]=r,y[12]=i,y[1]=s,y[5]=o,y[9]=a,y[13]=l,y[2]=c,y[6]=u,y[10]=d,y[14]=f,y[3]=h,y[7]=p,y[11]=x,y[15]=v,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return new St().fromArray(this.elements)}copy(e){const n=this.elements,r=e.elements;return n[0]=r[0],n[1]=r[1],n[2]=r[2],n[3]=r[3],n[4]=r[4],n[5]=r[5],n[6]=r[6],n[7]=r[7],n[8]=r[8],n[9]=r[9],n[10]=r[10],n[11]=r[11],n[12]=r[12],n[13]=r[13],n[14]=r[14],n[15]=r[15],this}copyPosition(e){const n=this.elements,r=e.elements;return n[12]=r[12],n[13]=r[13],n[14]=r[14],this}setFromMatrix3(e){const n=e.elements;return this.set(n[0],n[3],n[6],0,n[1],n[4],n[7],0,n[2],n[5],n[8],0,0,0,0,1),this}extractBasis(e,n,r){return e.setFromMatrixColumn(this,0),n.setFromMatrixColumn(this,1),r.setFromMatrixColumn(this,2),this}makeBasis(e,n,r){return this.set(e.x,n.x,r.x,0,e.y,n.y,r.y,0,e.z,n.z,r.z,0,0,0,0,1),this}extractRotation(e){const n=this.elements,r=e.elements,i=1/mf.setFromMatrixColumn(e,0).length(),s=1/mf.setFromMatrixColumn(e,1).length(),o=1/mf.setFromMatrixColumn(e,2).length();return n[0]=r[0]*i,n[1]=r[1]*i,n[2]=r[2]*i,n[3]=0,n[4]=r[4]*s,n[5]=r[5]*s,n[6]=r[6]*s,n[7]=0,n[8]=r[8]*o,n[9]=r[9]*o,n[10]=r[10]*o,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromEuler(e){const n=this.elements,r=e.x,i=e.y,s=e.z,o=Math.cos(r),a=Math.sin(r),l=Math.cos(i),c=Math.sin(i),u=Math.cos(s),d=Math.sin(s);if(e.order==="XYZ"){const f=o*u,h=o*d,p=a*u,x=a*d;n[0]=l*u,n[4]=-l*d,n[8]=c,n[1]=h+p*c,n[5]=f-x*c,n[9]=-a*l,n[2]=x-f*c,n[6]=p+h*c,n[10]=o*l}else if(e.order==="YXZ"){const f=l*u,h=l*d,p=c*u,x=c*d;n[0]=f+x*a,n[4]=p*a-h,n[8]=o*c,n[1]=o*d,n[5]=o*u,n[9]=-a,n[2]=h*a-p,n[6]=x+f*a,n[10]=o*l}else if(e.order==="ZXY"){const f=l*u,h=l*d,p=c*u,x=c*d;n[0]=f-x*a,n[4]=-o*d,n[8]=p+h*a,n[1]=h+p*a,n[5]=o*u,n[9]=x-f*a,n[2]=-o*c,n[6]=a,n[10]=o*l}else if(e.order==="ZYX"){const f=o*u,h=o*d,p=a*u,x=a*d;n[0]=l*u,n[4]=p*c-h,n[8]=f*c+x,n[1]=l*d,n[5]=x*c+f,n[9]=h*c-p,n[2]=-c,n[6]=a*l,n[10]=o*l}else if(e.order==="YZX"){const f=o*l,h=o*c,p=a*l,x=a*c;n[0]=l*u,n[4]=x-f*d,n[8]=p*d+h,n[1]=d,n[5]=o*u,n[9]=-a*u,n[2]=-c*u,n[6]=h*d+p,n[10]=f-x*d}else if(e.order==="XZY"){const f=o*l,h=o*c,p=a*l,x=a*c;n[0]=l*u,n[4]=-d,n[8]=c*u,n[1]=f*d+x,n[5]=o*u,n[9]=h*d-p,n[2]=p*d-h,n[6]=a*u,n[10]=x*d+f}return n[3]=0,n[7]=0,n[11]=0,n[12]=0,n[13]=0,n[14]=0,n[15]=1,this}makeRotationFromQuaternion(e){return this.compose(Dle,e,Ole)}lookAt(e,n,r){const i=this.elements;return ms.subVectors(e,n),ms.lengthSq()===0&&(ms.z=1),ms.normalize(),Kl.crossVectors(r,ms),Kl.lengthSq()===0&&(Math.abs(r.z)===1?ms.x+=1e-4:ms.z+=1e-4,ms.normalize(),Kl.crossVectors(r,ms)),Kl.normalize(),Mv.crossVectors(ms,Kl),i[0]=Kl.x,i[4]=Mv.x,i[8]=ms.x,i[1]=Kl.y,i[5]=Mv.y,i[9]=ms.y,i[2]=Kl.z,i[6]=Mv.z,i[10]=ms.z,this}multiply(e){return this.multiplyMatrices(this,e)}premultiply(e){return this.multiplyMatrices(e,this)}multiplyMatrices(e,n){const r=e.elements,i=n.elements,s=this.elements,o=r[0],a=r[4],l=r[8],c=r[12],u=r[1],d=r[5],f=r[9],h=r[13],p=r[2],x=r[6],v=r[10],y=r[14],b=r[3],S=r[7],w=r[11],E=r[15],A=i[0],T=i[4],I=i[8],N=i[12],M=i[1],P=i[5],B=i[9],F=i[13],U=i[2],j=i[6],Z=i[10],ne=i[14],O=i[3],G=i[7],q=i[11],se=i[15];return s[0]=o*A+a*M+l*U+c*O,s[4]=o*T+a*P+l*j+c*G,s[8]=o*I+a*B+l*Z+c*q,s[12]=o*N+a*F+l*ne+c*se,s[1]=u*A+d*M+f*U+h*O,s[5]=u*T+d*P+f*j+h*G,s[9]=u*I+d*B+f*Z+h*q,s[13]=u*N+d*F+f*ne+h*se,s[2]=p*A+x*M+v*U+y*O,s[6]=p*T+x*P+v*j+y*G,s[10]=p*I+x*B+v*Z+y*q,s[14]=p*N+x*F+v*ne+y*se,s[3]=b*A+S*M+w*U+E*O,s[7]=b*T+S*P+w*j+E*G,s[11]=b*I+S*B+w*Z+E*q,s[15]=b*N+S*F+w*ne+E*se,this}multiplyScalar(e){const n=this.elements;return n[0]*=e,n[4]*=e,n[8]*=e,n[12]*=e,n[1]*=e,n[5]*=e,n[9]*=e,n[13]*=e,n[2]*=e,n[6]*=e,n[10]*=e,n[14]*=e,n[3]*=e,n[7]*=e,n[11]*=e,n[15]*=e,this}determinant(){const e=this.elements,n=e[0],r=e[4],i=e[8],s=e[12],o=e[1],a=e[5],l=e[9],c=e[13],u=e[2],d=e[6],f=e[10],h=e[14],p=e[3],x=e[7],v=e[11],y=e[15];return p*(+s*l*d-i*c*d-s*a*f+r*c*f+i*a*h-r*l*h)+x*(+n*l*h-n*c*f+s*o*f-i*o*h+i*c*u-s*l*u)+v*(+n*c*d-n*a*h-s*o*d+r*o*h+s*a*u-r*c*u)+y*(-i*a*u-n*l*d+n*a*f+i*o*d-r*o*f+r*l*u)}transpose(){const e=this.elements;let n;return n=e[1],e[1]=e[4],e[4]=n,n=e[2],e[2]=e[8],e[8]=n,n=e[6],e[6]=e[9],e[9]=n,n=e[3],e[3]=e[12],e[12]=n,n=e[7],e[7]=e[13],e[13]=n,n=e[11],e[11]=e[14],e[14]=n,this}setPosition(e,n,r){const i=this.elements;return e.isVector3?(i[12]=e.x,i[13]=e.y,i[14]=e.z):(i[12]=e,i[13]=n,i[14]=r),this}invert(){const e=this.elements,n=e[0],r=e[1],i=e[2],s=e[3],o=e[4],a=e[5],l=e[6],c=e[7],u=e[8],d=e[9],f=e[10],h=e[11],p=e[12],x=e[13],v=e[14],y=e[15],b=d*v*c-x*f*c+x*l*h-a*v*h-d*l*y+a*f*y,S=p*f*c-u*v*c-p*l*h+o*v*h+u*l*y-o*f*y,w=u*x*c-p*d*c+p*a*h-o*x*h-u*a*y+o*d*y,E=p*d*l-u*x*l-p*a*f+o*x*f+u*a*v-o*d*v,A=n*b+r*S+i*w+s*E;if(A===0)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const T=1/A;return e[0]=b*T,e[1]=(x*f*s-d*v*s-x*i*h+r*v*h+d*i*y-r*f*y)*T,e[2]=(a*v*s-x*l*s+x*i*c-r*v*c-a*i*y+r*l*y)*T,e[3]=(d*l*s-a*f*s-d*i*c+r*f*c+a*i*h-r*l*h)*T,e[4]=S*T,e[5]=(u*v*s-p*f*s+p*i*h-n*v*h-u*i*y+n*f*y)*T,e[6]=(p*l*s-o*v*s-p*i*c+n*v*c+o*i*y-n*l*y)*T,e[7]=(o*f*s-u*l*s+u*i*c-n*f*c-o*i*h+n*l*h)*T,e[8]=w*T,e[9]=(p*d*s-u*x*s-p*r*h+n*x*h+u*r*y-n*d*y)*T,e[10]=(o*x*s-p*a*s+p*r*c-n*x*c-o*r*y+n*a*y)*T,e[11]=(u*a*s-o*d*s-u*r*c+n*d*c+o*r*h-n*a*h)*T,e[12]=E*T,e[13]=(u*x*i-p*d*i+p*r*f-n*x*f-u*r*v+n*d*v)*T,e[14]=(p*a*i-o*x*i-p*r*l+n*x*l+o*r*v-n*a*v)*T,e[15]=(o*d*i-u*a*i+u*r*l-n*d*l-o*r*f+n*a*f)*T,this}scale(e){const n=this.elements,r=e.x,i=e.y,s=e.z;return n[0]*=r,n[4]*=i,n[8]*=s,n[1]*=r,n[5]*=i,n[9]*=s,n[2]*=r,n[6]*=i,n[10]*=s,n[3]*=r,n[7]*=i,n[11]*=s,this}getMaxScaleOnAxis(){const e=this.elements,n=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],r=e[4]*e[4]+e[5]*e[5]+e[6]*e[6],i=e[8]*e[8]+e[9]*e[9]+e[10]*e[10];return Math.sqrt(Math.max(n,r,i))}makeTranslation(e,n,r){return e.isVector3?this.set(1,0,0,e.x,0,1,0,e.y,0,0,1,e.z,0,0,0,1):this.set(1,0,0,e,0,1,0,n,0,0,1,r,0,0,0,1),this}makeRotationX(e){const n=Math.cos(e),r=Math.sin(e);return this.set(1,0,0,0,0,n,-r,0,0,r,n,0,0,0,0,1),this}makeRotationY(e){const n=Math.cos(e),r=Math.sin(e);return this.set(n,0,r,0,0,1,0,0,-r,0,n,0,0,0,0,1),this}makeRotationZ(e){const n=Math.cos(e),r=Math.sin(e);return this.set(n,-r,0,0,r,n,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(e,n){const r=Math.cos(n),i=Math.sin(n),s=1-r,o=e.x,a=e.y,l=e.z,c=s*o,u=s*a;return this.set(c*o+r,c*a-i*l,c*l+i*a,0,c*a+i*l,u*a+r,u*l-i*o,0,c*l-i*a,u*l+i*o,s*l*l+r,0,0,0,0,1),this}makeScale(e,n,r){return this.set(e,0,0,0,0,n,0,0,0,0,r,0,0,0,0,1),this}makeShear(e,n,r,i,s,o){return this.set(1,r,s,0,e,1,o,0,n,i,1,0,0,0,0,1),this}compose(e,n,r){const i=this.elements,s=n._x,o=n._y,a=n._z,l=n._w,c=s+s,u=o+o,d=a+a,f=s*c,h=s*u,p=s*d,x=o*u,v=o*d,y=a*d,b=l*c,S=l*u,w=l*d,E=r.x,A=r.y,T=r.z;return i[0]=(1-(x+y))*E,i[1]=(h+w)*E,i[2]=(p-S)*E,i[3]=0,i[4]=(h-w)*A,i[5]=(1-(f+y))*A,i[6]=(v+b)*A,i[7]=0,i[8]=(p+S)*T,i[9]=(v-b)*T,i[10]=(1-(f+x))*T,i[11]=0,i[12]=e.x,i[13]=e.y,i[14]=e.z,i[15]=1,this}decompose(e,n,r){const i=this.elements;let s=mf.set(i[0],i[1],i[2]).length();const o=mf.set(i[4],i[5],i[6]).length(),a=mf.set(i[8],i[9],i[10]).length();this.determinant()<0&&(s=-s),e.x=i[12],e.y=i[13],e.z=i[14],Ro.copy(this);const c=1/s,u=1/o,d=1/a;return Ro.elements[0]*=c,Ro.elements[1]*=c,Ro.elements[2]*=c,Ro.elements[4]*=u,Ro.elements[5]*=u,Ro.elements[6]*=u,Ro.elements[8]*=d,Ro.elements[9]*=d,Ro.elements[10]*=d,n.setFromRotationMatrix(Ro),r.x=s,r.y=o,r.z=a,this}makePerspective(e,n,r,i,s,o,a=xa){const l=this.elements,c=2*s/(n-e),u=2*s/(r-i),d=(n+e)/(n-e),f=(r+i)/(r-i);let h,p;if(a===xa)h=-(o+s)/(o-s),p=-2*o*s/(o-s);else if(a===Hg)h=-o/(o-s),p=-o*s/(o-s);else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+a);return l[0]=c,l[4]=0,l[8]=d,l[12]=0,l[1]=0,l[5]=u,l[9]=f,l[13]=0,l[2]=0,l[6]=0,l[10]=h,l[14]=p,l[3]=0,l[7]=0,l[11]=-1,l[15]=0,this}makeOrthographic(e,n,r,i,s,o,a=xa){const l=this.elements,c=1/(n-e),u=1/(r-i),d=1/(o-s),f=(n+e)*c,h=(r+i)*u;let p,x;if(a===xa)p=(o+s)*d,x=-2*d;else if(a===Hg)p=s*d,x=-1*d;else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+a);return l[0]=2*c,l[4]=0,l[8]=0,l[12]=-f,l[1]=0,l[5]=2*u,l[9]=0,l[13]=-h,l[2]=0,l[6]=0,l[10]=x,l[14]=-p,l[3]=0,l[7]=0,l[11]=0,l[15]=1,this}equals(e){const n=this.elements,r=e.elements;for(let i=0;i<16;i++)if(n[i]!==r[i])return!1;return!0}fromArray(e,n=0){for(let r=0;r<16;r++)this.elements[r]=e[r+n];return this}toArray(e=[],n=0){const r=this.elements;return e[n]=r[0],e[n+1]=r[1],e[n+2]=r[2],e[n+3]=r[3],e[n+4]=r[4],e[n+5]=r[5],e[n+6]=r[6],e[n+7]=r[7],e[n+8]=r[8],e[n+9]=r[9],e[n+10]=r[10],e[n+11]=r[11],e[n+12]=r[12],e[n+13]=r[13],e[n+14]=r[14],e[n+15]=r[15],e}}const mf=new K,Ro=new St,Dle=new K(0,0,0),Ole=new K(1,1,1),Kl=new K,Mv=new K,ms=new K,LD=new St,BD=new Hr;class Is{constructor(e=0,n=0,r=0,i=Is.DEFAULT_ORDER){this.isEuler=!0,this._x=e,this._y=n,this._z=r,this._order=i}get x(){return this._x}set x(e){this._x=e,this._onChangeCallback()}get y(){return this._y}set y(e){this._y=e,this._onChangeCallback()}get z(){return this._z}set z(e){this._z=e,this._onChangeCallback()}get order(){return this._order}set order(e){this._order=e,this._onChangeCallback()}set(e,n,r,i=this._order){return this._x=e,this._y=n,this._z=r,this._order=i,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(e){return this._x=e._x,this._y=e._y,this._z=e._z,this._order=e._order,this._onChangeCallback(),this}setFromRotationMatrix(e,n=this._order,r=!0){const i=e.elements,s=i[0],o=i[4],a=i[8],l=i[1],c=i[5],u=i[9],d=i[2],f=i[6],h=i[10];switch(n){case"XYZ":this._y=Math.asin(sr(a,-1,1)),Math.abs(a)<.9999999?(this._x=Math.atan2(-u,h),this._z=Math.atan2(-o,s)):(this._x=Math.atan2(f,c),this._z=0);break;case"YXZ":this._x=Math.asin(-sr(u,-1,1)),Math.abs(u)<.9999999?(this._y=Math.atan2(a,h),this._z=Math.atan2(l,c)):(this._y=Math.atan2(-d,s),this._z=0);break;case"ZXY":this._x=Math.asin(sr(f,-1,1)),Math.abs(f)<.9999999?(this._y=Math.atan2(-d,h),this._z=Math.atan2(-o,c)):(this._y=0,this._z=Math.atan2(l,s));break;case"ZYX":this._y=Math.asin(-sr(d,-1,1)),Math.abs(d)<.9999999?(this._x=Math.atan2(f,h),this._z=Math.atan2(l,s)):(this._x=0,this._z=Math.atan2(-o,c));break;case"YZX":this._z=Math.asin(sr(l,-1,1)),Math.abs(l)<.9999999?(this._x=Math.atan2(-u,c),this._y=Math.atan2(-d,s)):(this._x=0,this._y=Math.atan2(a,h));break;case"XZY":this._z=Math.asin(-sr(o,-1,1)),Math.abs(o)<.9999999?(this._x=Math.atan2(f,c),this._y=Math.atan2(a,s)):(this._x=Math.atan2(-u,h),this._y=0);break;default:console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: "+n)}return this._order=n,r===!0&&this._onChangeCallback(),this}setFromQuaternion(e,n,r){return LD.makeRotationFromQuaternion(e),this.setFromRotationMatrix(LD,n,r)}setFromVector3(e,n=this._order){return this.set(e.x,e.y,e.z,n)}reorder(e){return BD.setFromEuler(this),this.setFromQuaternion(BD,e)}equals(e){return e._x===this._x&&e._y===this._y&&e._z===this._z&&e._order===this._order}fromArray(e){return this._x=e[0],this._y=e[1],this._z=e[2],e[3]!==void 0&&(this._order=e[3]),this._onChangeCallback(),this}toArray(e=[],n=0){return e[n]=this._x,e[n+1]=this._y,e[n+2]=this._z,e[n+3]=this._order,e}_onChange(e){return this._onChangeCallback=e,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Is.DEFAULT_ORDER="XYZ";class Qu{constructor(){this.mask=1}set(e){this.mask=(1<<e|0)>>>0}enable(e){this.mask|=1<<e|0}enableAll(){this.mask=-1}toggle(e){this.mask^=1<<e|0}disable(e){this.mask&=~(1<<e|0)}disableAll(){this.mask=0}test(e){return(this.mask&e.mask)!==0}isEnabled(e){return(this.mask&(1<<e|0))!==0}}let Lle=0;const FD=new K,gf=new Hr,Wa=new St,Rv=new K,xm=new K,Ble=new K,Fle=new Hr,$D=new K(1,0,0),UD=new K(0,1,0),zD=new K(0,0,1),GD={type:"added"},$le={type:"removed"},yf={type:"childadded",child:null},DC={type:"childremoved",child:null};class Zt extends ka{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:Lle++}),this.uuid=Ms(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Zt.DEFAULT_UP.clone();const e=new K,n=new Is,r=new Hr,i=new K(1,1,1);function s(){r.setFromEuler(n,!1)}function o(){n.setFromQuaternion(r,void 0,!1)}n._onChange(s),r._onChange(o),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:e},rotation:{configurable:!0,enumerable:!0,value:n},quaternion:{configurable:!0,enumerable:!0,value:r},scale:{configurable:!0,enumerable:!0,value:i},modelViewMatrix:{value:new St},normalMatrix:{value:new $t}}),this.matrix=new St,this.matrixWorld=new St,this.matrixAutoUpdate=Zt.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Zt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Qu,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.userData={}}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(e){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(e),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(e){return this.quaternion.premultiply(e),this}setRotationFromAxisAngle(e,n){this.quaternion.setFromAxisAngle(e,n)}setRotationFromEuler(e){this.quaternion.setFromEuler(e,!0)}setRotationFromMatrix(e){this.quaternion.setFromRotationMatrix(e)}setRotationFromQuaternion(e){this.quaternion.copy(e)}rotateOnAxis(e,n){return gf.setFromAxisAngle(e,n),this.quaternion.multiply(gf),this}rotateOnWorldAxis(e,n){return gf.setFromAxisAngle(e,n),this.quaternion.premultiply(gf),this}rotateX(e){return this.rotateOnAxis($D,e)}rotateY(e){return this.rotateOnAxis(UD,e)}rotateZ(e){return this.rotateOnAxis(zD,e)}translateOnAxis(e,n){return FD.copy(e).applyQuaternion(this.quaternion),this.position.add(FD.multiplyScalar(n)),this}translateX(e){return this.translateOnAxis($D,e)}translateY(e){return this.translateOnAxis(UD,e)}translateZ(e){return this.translateOnAxis(zD,e)}localToWorld(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(this.matrixWorld)}worldToLocal(e){return this.updateWorldMatrix(!0,!1),e.applyMatrix4(Wa.copy(this.matrixWorld).invert())}lookAt(e,n,r){e.isVector3?Rv.copy(e):Rv.set(e,n,r);const i=this.parent;this.updateWorldMatrix(!0,!1),xm.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?Wa.lookAt(xm,Rv,this.up):Wa.lookAt(Rv,xm,this.up),this.quaternion.setFromRotationMatrix(Wa),i&&(Wa.extractRotation(i.matrixWorld),gf.setFromRotationMatrix(Wa),this.quaternion.premultiply(gf.invert()))}add(e){if(arguments.length>1){for(let n=0;n<arguments.length;n++)this.add(arguments[n]);return this}return e===this?(console.error("THREE.Object3D.add: object can't be added as a child of itself.",e),this):(e&&e.isObject3D?(e.removeFromParent(),e.parent=this,this.children.push(e),e.dispatchEvent(GD),yf.child=e,this.dispatchEvent(yf),yf.child=null):console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.",e),this)}remove(e){if(arguments.length>1){for(let r=0;r<arguments.length;r++)this.remove(arguments[r]);return this}const n=this.children.indexOf(e);return n!==-1&&(e.parent=null,this.children.splice(n,1),e.dispatchEvent($le),DC.child=e,this.dispatchEvent(DC),DC.child=null),this}removeFromParent(){const e=this.parent;return e!==null&&e.remove(this),this}clear(){return this.remove(...this.children)}attach(e){return this.updateWorldMatrix(!0,!1),Wa.copy(this.matrixWorld).invert(),e.parent!==null&&(e.parent.updateWorldMatrix(!0,!1),Wa.multiply(e.parent.matrixWorld)),e.applyMatrix4(Wa),e.removeFromParent(),e.parent=this,this.children.push(e),e.updateWorldMatrix(!1,!0),e.dispatchEvent(GD),yf.child=e,this.dispatchEvent(yf),yf.child=null,this}getObjectById(e){return this.getObjectByProperty("id",e)}getObjectByName(e){return this.getObjectByProperty("name",e)}getObjectByProperty(e,n){if(this[e]===n)return this;for(let r=0,i=this.children.length;r<i;r++){const o=this.children[r].getObjectByProperty(e,n);if(o!==void 0)return o}}getObjectsByProperty(e,n,r=[]){this[e]===n&&r.push(this);const i=this.children;for(let s=0,o=i.length;s<o;s++)i[s].getObjectsByProperty(e,n,r);return r}getWorldPosition(e){return this.updateWorldMatrix(!0,!1),e.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(xm,e,Ble),e}getWorldScale(e){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(xm,Fle,e),e}getWorldDirection(e){this.updateWorldMatrix(!0,!1);const n=this.matrixWorld.elements;return e.set(n[8],n[9],n[10]).normalize()}raycast(){}traverse(e){e(this);const n=this.children;for(let r=0,i=n.length;r<i;r++)n[r].traverse(e)}traverseVisible(e){if(this.visible===!1)return;e(this);const n=this.children;for(let r=0,i=n.length;r<i;r++)n[r].traverseVisible(e)}traverseAncestors(e){const n=this.parent;n!==null&&(e(n),n.traverseAncestors(e))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale),this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(e){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||e)&&(this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),this.matrixWorldNeedsUpdate=!1,e=!0);const n=this.children;for(let r=0,i=n.length;r<i;r++){const s=n[r];(s.matrixWorldAutoUpdate===!0||e===!0)&&s.updateMatrixWorld(e)}}updateWorldMatrix(e,n){const r=this.parent;if(e===!0&&r!==null&&r.matrixWorldAutoUpdate===!0&&r.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),this.parent===null?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix),n===!0){const i=this.children;for(let s=0,o=i.length;s<o;s++){const a=i[s];a.matrixWorldAutoUpdate===!0&&a.updateWorldMatrix(!1,!0)}}}toJSON(e){const n=e===void 0||typeof e=="string",r={};n&&(e={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},r.metadata={version:4.6,type:"Object",generator:"Object3D.toJSON"});const i={};i.uuid=this.uuid,i.type=this.type,this.name!==""&&(i.name=this.name),this.castShadow===!0&&(i.castShadow=!0),this.receiveShadow===!0&&(i.receiveShadow=!0),this.visible===!1&&(i.visible=!1),this.frustumCulled===!1&&(i.frustumCulled=!1),this.renderOrder!==0&&(i.renderOrder=this.renderOrder),Object.keys(this.userData).length>0&&(i.userData=this.userData),i.layers=this.layers.mask,i.matrix=this.matrix.toArray(),i.up=this.up.toArray(),this.matrixAutoUpdate===!1&&(i.matrixAutoUpdate=!1),this.isInstancedMesh&&(i.type="InstancedMesh",i.count=this.count,i.instanceMatrix=this.instanceMatrix.toJSON(),this.instanceColor!==null&&(i.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(i.type="BatchedMesh",i.perObjectFrustumCulled=this.perObjectFrustumCulled,i.sortObjects=this.sortObjects,i.drawRanges=this._drawRanges,i.reservedRanges=this._reservedRanges,i.visibility=this._visibility,i.active=this._active,i.bounds=this._bounds.map(a=>({boxInitialized:a.boxInitialized,boxMin:a.box.min.toArray(),boxMax:a.box.max.toArray(),sphereInitialized:a.sphereInitialized,sphereRadius:a.sphere.radius,sphereCenter:a.sphere.center.toArray()})),i.maxGeometryCount=this._maxGeometryCount,i.maxVertexCount=this._maxVertexCount,i.maxIndexCount=this._maxIndexCount,i.geometryInitialized=this._geometryInitialized,i.geometryCount=this._geometryCount,i.matricesTexture=this._matricesTexture.toJSON(e),this.boundingSphere!==null&&(i.boundingSphere={center:i.boundingSphere.center.toArray(),radius:i.boundingSphere.radius}),this.boundingBox!==null&&(i.boundingBox={min:i.boundingBox.min.toArray(),max:i.boundingBox.max.toArray()}));function s(a,l){return a[l.uuid]===void 0&&(a[l.uuid]=l.toJSON(e)),l.uuid}if(this.isScene)this.background&&(this.background.isColor?i.background=this.background.toJSON():this.background.isTexture&&(i.background=this.background.toJSON(e).uuid)),this.environment&&this.environment.isTexture&&this.environment.isRenderTargetTexture!==!0&&(i.environment=this.environment.toJSON(e).uuid);else if(this.isMesh||this.isLine||this.isPoints){i.geometry=s(e.geometries,this.geometry);const a=this.geometry.parameters;if(a!==void 0&&a.shapes!==void 0){const l=a.shapes;if(Array.isArray(l))for(let c=0,u=l.length;c<u;c++){const d=l[c];s(e.shapes,d)}else s(e.shapes,l)}}if(this.isSkinnedMesh&&(i.bindMode=this.bindMode,i.bindMatrix=this.bindMatrix.toArray(),this.skeleton!==void 0&&(s(e.skeletons,this.skeleton),i.skeleton=this.skeleton.uuid)),this.material!==void 0)if(Array.isArray(this.material)){const a=[];for(let l=0,c=this.material.length;l<c;l++)a.push(s(e.materials,this.material[l]));i.material=a}else i.material=s(e.materials,this.material);if(this.children.length>0){i.children=[];for(let a=0;a<this.children.length;a++)i.children.push(this.children[a].toJSON(e).object)}if(this.animations.length>0){i.animations=[];for(let a=0;a<this.animations.length;a++){const l=this.animations[a];i.animations.push(s(e.animations,l))}}if(n){const a=o(e.geometries),l=o(e.materials),c=o(e.textures),u=o(e.images),d=o(e.shapes),f=o(e.skeletons),h=o(e.animations),p=o(e.nodes);a.length>0&&(r.geometries=a),l.length>0&&(r.materials=l),c.length>0&&(r.textures=c),u.length>0&&(r.images=u),d.length>0&&(r.shapes=d),f.length>0&&(r.skeletons=f),h.length>0&&(r.animations=h),p.length>0&&(r.nodes=p)}return r.object=i,r;function o(a){const l=[];for(const c in a){const u=a[c];delete u.metadata,l.push(u)}return l}}clone(e){return new this.constructor().copy(this,e)}copy(e,n=!0){if(this.name=e.name,this.up.copy(e.up),this.position.copy(e.position),this.rotation.order=e.rotation.order,this.quaternion.copy(e.quaternion),this.scale.copy(e.scale),this.matrix.copy(e.matrix),this.matrixWorld.copy(e.matrixWorld),this.matrixAutoUpdate=e.matrixAutoUpdate,this.matrixWorldAutoUpdate=e.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=e.matrixWorldNeedsUpdate,this.layers.mask=e.layers.mask,this.visible=e.visible,this.castShadow=e.castShadow,this.receiveShadow=e.receiveShadow,this.frustumCulled=e.frustumCulled,this.renderOrder=e.renderOrder,this.animations=e.animations.slice(),this.userData=JSON.parse(JSON.stringify(e.userData)),n===!0)for(let r=0;r<e.children.length;r++){const i=e.children[r];this.add(i.clone())}return this}}Zt.DEFAULT_UP=new K(0,1,0);Zt.DEFAULT_MATRIX_AUTO_UPDATE=!0;Zt.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;const Io=new K,ja=new K,OC=new K,Xa=new K,vf=new K,xf=new K,HD=new K,LC=new K,BC=new K,FC=new K;class Ss{constructor(e=new K,n=new K,r=new K){this.a=e,this.b=n,this.c=r}static getNormal(e,n,r,i){i.subVectors(r,n),Io.subVectors(e,n),i.cross(Io);const s=i.lengthSq();return s>0?i.multiplyScalar(1/Math.sqrt(s)):i.set(0,0,0)}static getBarycoord(e,n,r,i,s){Io.subVectors(i,n),ja.subVectors(r,n),OC.subVectors(e,n);const o=Io.dot(Io),a=Io.dot(ja),l=Io.dot(OC),c=ja.dot(ja),u=ja.dot(OC),d=o*c-a*a;if(d===0)return s.set(0,0,0),null;const f=1/d,h=(c*l-a*u)*f,p=(o*u-a*l)*f;return s.set(1-h-p,p,h)}static containsPoint(e,n,r,i){return this.getBarycoord(e,n,r,i,Xa)===null?!1:Xa.x>=0&&Xa.y>=0&&Xa.x+Xa.y<=1}static getInterpolation(e,n,r,i,s,o,a,l){return this.getBarycoord(e,n,r,i,Xa)===null?(l.x=0,l.y=0,"z"in l&&(l.z=0),"w"in l&&(l.w=0),null):(l.setScalar(0),l.addScaledVector(s,Xa.x),l.addScaledVector(o,Xa.y),l.addScaledVector(a,Xa.z),l)}static isFrontFacing(e,n,r,i){return Io.subVectors(r,n),ja.subVectors(e,n),Io.cross(ja).dot(i)<0}set(e,n,r){return this.a.copy(e),this.b.copy(n),this.c.copy(r),this}setFromPointsAndIndices(e,n,r,i){return this.a.copy(e[n]),this.b.copy(e[r]),this.c.copy(e[i]),this}setFromAttributeAndIndices(e,n,r,i){return this.a.fromBufferAttribute(e,n),this.b.fromBufferAttribute(e,r),this.c.fromBufferAttribute(e,i),this}clone(){return new this.constructor().copy(this)}copy(e){return this.a.copy(e.a),this.b.copy(e.b),this.c.copy(e.c),this}getArea(){return Io.subVectors(this.c,this.b),ja.subVectors(this.a,this.b),Io.cross(ja).length()*.5}getMidpoint(e){return e.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(e){return Ss.getNormal(this.a,this.b,this.c,e)}getPlane(e){return e.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(e,n){return Ss.getBarycoord(e,this.a,this.b,this.c,n)}getInterpolation(e,n,r,i,s){return Ss.getInterpolation(e,this.a,this.b,this.c,n,r,i,s)}containsPoint(e){return Ss.containsPoint(e,this.a,this.b,this.c)}isFrontFacing(e){return Ss.isFrontFacing(this.a,this.b,this.c,e)}intersectsBox(e){return e.intersectsTriangle(this)}closestPointToPoint(e,n){const r=this.a,i=this.b,s=this.c;let o,a;vf.subVectors(i,r),xf.subVectors(s,r),LC.subVectors(e,r);const l=vf.dot(LC),c=xf.dot(LC);if(l<=0&&c<=0)return n.copy(r);BC.subVectors(e,i);const u=vf.dot(BC),d=xf.dot(BC);if(u>=0&&d<=u)return n.copy(i);const f=l*d-u*c;if(f<=0&&l>=0&&u<=0)return o=l/(l-u),n.copy(r).addScaledVector(vf,o);FC.subVectors(e,s);const h=vf.dot(FC),p=xf.dot(FC);if(p>=0&&h<=p)return n.copy(s);const x=h*c-l*p;if(x<=0&&c>=0&&p<=0)return a=c/(c-p),n.copy(r).addScaledVector(xf,a);const v=u*p-h*d;if(v<=0&&d-u>=0&&h-p>=0)return HD.subVectors(s,i),a=(d-u)/(d-u+(h-p)),n.copy(i).addScaledVector(HD,a);const y=1/(v+x+f);return o=x*y,a=f*y,n.copy(r).addScaledVector(vf,o).addScaledVector(xf,a)}equals(e){return e.a.equals(this.a)&&e.b.equals(this.b)&&e.c.equals(this.c)}}const E5={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},ql={h:0,s:0,l:0},Iv={h:0,s:0,l:0};function $C(t,e,n){return n<0&&(n+=1),n>1&&(n-=1),n<1/6?t+(e-t)*6*n:n<1/2?e:n<2/3?t+(e-t)*6*(2/3-n):t}class Qe{constructor(e,n,r){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(e,n,r)}set(e,n,r){if(n===void 0&&r===void 0){const i=e;i&&i.isColor?this.copy(i):typeof i=="number"?this.setHex(i):typeof i=="string"&&this.setStyle(i)}else this.setRGB(e,n,r);return this}setScalar(e){return this.r=e,this.g=e,this.b=e,this}setHex(e,n=xs){return e=Math.floor(e),this.r=(e>>16&255)/255,this.g=(e>>8&255)/255,this.b=(e&255)/255,gn.toWorkingColorSpace(this,n),this}setRGB(e,n,r,i=gn.workingColorSpace){return this.r=e,this.g=n,this.b=r,gn.toWorkingColorSpace(this,i),this}setHSL(e,n,r,i=gn.workingColorSpace){if(e=MR(e,1),n=sr(n,0,1),r=sr(r,0,1),n===0)this.r=this.g=this.b=r;else{const s=r<=.5?r*(1+n):r+n-r*n,o=2*r-s;this.r=$C(o,s,e+1/3),this.g=$C(o,s,e),this.b=$C(o,s,e-1/3)}return gn.toWorkingColorSpace(this,i),this}setStyle(e,n=xs){function r(s){s!==void 0&&parseFloat(s)<1&&console.warn("THREE.Color: Alpha component of "+e+" will be ignored.")}let i;if(i=/^(\w+)\(([^\)]*)\)/.exec(e)){let s;const o=i[1],a=i[2];switch(o){case"rgb":case"rgba":if(s=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return r(s[4]),this.setRGB(Math.min(255,parseInt(s[1],10))/255,Math.min(255,parseInt(s[2],10))/255,Math.min(255,parseInt(s[3],10))/255,n);if(s=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return r(s[4]),this.setRGB(Math.min(100,parseInt(s[1],10))/100,Math.min(100,parseInt(s[2],10))/100,Math.min(100,parseInt(s[3],10))/100,n);break;case"hsl":case"hsla":if(s=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))return r(s[4]),this.setHSL(parseFloat(s[1])/360,parseFloat(s[2])/100,parseFloat(s[3])/100,n);break;default:console.warn("THREE.Color: Unknown color model "+e)}}else if(i=/^\#([A-Fa-f\d]+)$/.exec(e)){const s=i[1],o=s.length;if(o===3)return this.setRGB(parseInt(s.charAt(0),16)/15,parseInt(s.charAt(1),16)/15,parseInt(s.charAt(2),16)/15,n);if(o===6)return this.setHex(parseInt(s,16),n);console.warn("THREE.Color: Invalid hex color "+e)}else if(e&&e.length>0)return this.setColorName(e,n);return this}setColorName(e,n=xs){const r=E5[e.toLowerCase()];return r!==void 0?this.setHex(r,n):console.warn("THREE.Color: Unknown color "+e),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(e){return this.r=e.r,this.g=e.g,this.b=e.b,this}copySRGBToLinear(e){return this.r=_h(e.r),this.g=_h(e.g),this.b=_h(e.b),this}copyLinearToSRGB(e){return this.r=AC(e.r),this.g=AC(e.g),this.b=AC(e.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(e=xs){return gn.fromWorkingColorSpace(ui.copy(this),e),Math.round(sr(ui.r*255,0,255))*65536+Math.round(sr(ui.g*255,0,255))*256+Math.round(sr(ui.b*255,0,255))}getHexString(e=xs){return("000000"+this.getHex(e).toString(16)).slice(-6)}getHSL(e,n=gn.workingColorSpace){gn.fromWorkingColorSpace(ui.copy(this),n);const r=ui.r,i=ui.g,s=ui.b,o=Math.max(r,i,s),a=Math.min(r,i,s);let l,c;const u=(a+o)/2;if(a===o)l=0,c=0;else{const d=o-a;switch(c=u<=.5?d/(o+a):d/(2-o-a),o){case r:l=(i-s)/d+(i<s?6:0);break;case i:l=(s-r)/d+2;break;case s:l=(r-i)/d+4;break}l/=6}return e.h=l,e.s=c,e.l=u,e}getRGB(e,n=gn.workingColorSpace){return gn.fromWorkingColorSpace(ui.copy(this),n),e.r=ui.r,e.g=ui.g,e.b=ui.b,e}getStyle(e=xs){gn.fromWorkingColorSpace(ui.copy(this),e);const n=ui.r,r=ui.g,i=ui.b;return e!==xs?`color(${e} ${n.toFixed(3)} ${r.toFixed(3)} ${i.toFixed(3)})`:`rgb(${Math.round(n*255)},${Math.round(r*255)},${Math.round(i*255)})`}offsetHSL(e,n,r){return this.getHSL(ql),this.setHSL(ql.h+e,ql.s+n,ql.l+r)}add(e){return this.r+=e.r,this.g+=e.g,this.b+=e.b,this}addColors(e,n){return this.r=e.r+n.r,this.g=e.g+n.g,this.b=e.b+n.b,this}addScalar(e){return this.r+=e,this.g+=e,this.b+=e,this}sub(e){return this.r=Math.max(0,this.r-e.r),this.g=Math.max(0,this.g-e.g),this.b=Math.max(0,this.b-e.b),this}multiply(e){return this.r*=e.r,this.g*=e.g,this.b*=e.b,this}multiplyScalar(e){return this.r*=e,this.g*=e,this.b*=e,this}lerp(e,n){return this.r+=(e.r-this.r)*n,this.g+=(e.g-this.g)*n,this.b+=(e.b-this.b)*n,this}lerpColors(e,n,r){return this.r=e.r+(n.r-e.r)*r,this.g=e.g+(n.g-e.g)*r,this.b=e.b+(n.b-e.b)*r,this}lerpHSL(e,n){this.getHSL(ql),e.getHSL(Iv);const r=sg(ql.h,Iv.h,n),i=sg(ql.s,Iv.s,n),s=sg(ql.l,Iv.l,n);return this.setHSL(r,i,s),this}setFromVector3(e){return this.r=e.x,this.g=e.y,this.b=e.z,this}applyMatrix3(e){const n=this.r,r=this.g,i=this.b,s=e.elements;return this.r=s[0]*n+s[3]*r+s[6]*i,this.g=s[1]*n+s[4]*r+s[7]*i,this.b=s[2]*n+s[5]*r+s[8]*i,this}equals(e){return e.r===this.r&&e.g===this.g&&e.b===this.b}fromArray(e,n=0){return this.r=e[n],this.g=e[n+1],this.b=e[n+2],this}toArray(e=[],n=0){return e[n]=this.r,e[n+1]=this.g,e[n+2]=this.b,e}fromBufferAttribute(e,n){return this.r=e.getX(n),this.g=e.getY(n),this.b=e.getZ(n),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const ui=new Qe;Qe.NAMES=E5;let Ule=0;class wr extends ka{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:Ule++}),this.uuid=Ms(),this.name="",this.type="Material",this.blending=qu,this.side=Ia,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=$1,this.blendDst=U1,this.blendEquation=sc,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Qe(0,0,0),this.blendAlpha=0,this.depthFunc=Dg,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=P2,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=_u,this.stencilZFail=_u,this.stencilZPass=_u,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(e){this._alphaTest>0!=e>0&&this.version++,this._alphaTest=e}onBuild(){}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(e){if(e!==void 0)for(const n in e){const r=e[n];if(r===void 0){console.warn(`THREE.Material: parameter '${n}' has value of undefined.`);continue}const i=this[n];if(i===void 0){console.warn(`THREE.Material: '${n}' is not a property of THREE.${this.type}.`);continue}i&&i.isColor?i.set(r):i&&i.isVector3&&r&&r.isVector3?i.copy(r):this[n]=r}}toJSON(e){const n=e===void 0||typeof e=="string";n&&(e={textures:{},images:{}});const r={metadata:{version:4.6,type:"Material",generator:"Material.toJSON"}};r.uuid=this.uuid,r.type=this.type,this.name!==""&&(r.name=this.name),this.color&&this.color.isColor&&(r.color=this.color.getHex()),this.roughness!==void 0&&(r.roughness=this.roughness),this.metalness!==void 0&&(r.metalness=this.metalness),this.sheen!==void 0&&(r.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(r.sheenColor=this.sheenColor.getHex()),this.sheenRoughness!==void 0&&(r.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(r.emissive=this.emissive.getHex()),this.emissiveIntensity!==void 0&&this.emissiveIntensity!==1&&(r.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(r.specular=this.specular.getHex()),this.specularIntensity!==void 0&&(r.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(r.specularColor=this.specularColor.getHex()),this.shininess!==void 0&&(r.shininess=this.shininess),this.clearcoat!==void 0&&(r.clearcoat=this.clearcoat),this.clearcoatRoughness!==void 0&&(r.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(r.clearcoatMap=this.clearcoatMap.toJSON(e).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(r.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(e).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(r.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(e).uuid,r.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.iridescence!==void 0&&(r.iridescence=this.iridescence),this.iridescenceIOR!==void 0&&(r.iridescenceIOR=this.iridescenceIOR),this.iridescenceThicknessRange!==void 0&&(r.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(r.iridescenceMap=this.iridescenceMap.toJSON(e).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(r.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(e).uuid),this.anisotropy!==void 0&&(r.anisotropy=this.anisotropy),this.anisotropyRotation!==void 0&&(r.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(r.anisotropyMap=this.anisotropyMap.toJSON(e).uuid),this.map&&this.map.isTexture&&(r.map=this.map.toJSON(e).uuid),this.matcap&&this.matcap.isTexture&&(r.matcap=this.matcap.toJSON(e).uuid),this.alphaMap&&this.alphaMap.isTexture&&(r.alphaMap=this.alphaMap.toJSON(e).uuid),this.lightMap&&this.lightMap.isTexture&&(r.lightMap=this.lightMap.toJSON(e).uuid,r.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(r.aoMap=this.aoMap.toJSON(e).uuid,r.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(r.bumpMap=this.bumpMap.toJSON(e).uuid,r.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(r.normalMap=this.normalMap.toJSON(e).uuid,r.normalMapType=this.normalMapType,r.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(r.displacementMap=this.displacementMap.toJSON(e).uuid,r.displacementScale=this.displacementScale,r.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(r.roughnessMap=this.roughnessMap.toJSON(e).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(r.metalnessMap=this.metalnessMap.toJSON(e).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(r.emissiveMap=this.emissiveMap.toJSON(e).uuid),this.specularMap&&this.specularMap.isTexture&&(r.specularMap=this.specularMap.toJSON(e).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(r.specularIntensityMap=this.specularIntensityMap.toJSON(e).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(r.specularColorMap=this.specularColorMap.toJSON(e).uuid),this.envMap&&this.envMap.isTexture&&(r.envMap=this.envMap.toJSON(e).uuid,this.combine!==void 0&&(r.combine=this.combine)),this.envMapRotation!==void 0&&(r.envMapRotation=this.envMapRotation.toArray()),this.envMapIntensity!==void 0&&(r.envMapIntensity=this.envMapIntensity),this.reflectivity!==void 0&&(r.reflectivity=this.reflectivity),this.refractionRatio!==void 0&&(r.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(r.gradientMap=this.gradientMap.toJSON(e).uuid),this.transmission!==void 0&&(r.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(r.transmissionMap=this.transmissionMap.toJSON(e).uuid),this.thickness!==void 0&&(r.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(r.thicknessMap=this.thicknessMap.toJSON(e).uuid),this.attenuationDistance!==void 0&&this.attenuationDistance!==1/0&&(r.attenuationDistance=this.attenuationDistance),this.attenuationColor!==void 0&&(r.attenuationColor=this.attenuationColor.getHex()),this.size!==void 0&&(r.size=this.size),this.shadowSide!==null&&(r.shadowSide=this.shadowSide),this.sizeAttenuation!==void 0&&(r.sizeAttenuation=this.sizeAttenuation),this.blending!==qu&&(r.blending=this.blending),this.side!==Ia&&(r.side=this.side),this.vertexColors===!0&&(r.vertexColors=!0),this.opacity<1&&(r.opacity=this.opacity),this.transparent===!0&&(r.transparent=!0),this.blendSrc!==$1&&(r.blendSrc=this.blendSrc),this.blendDst!==U1&&(r.blendDst=this.blendDst),this.blendEquation!==sc&&(r.blendEquation=this.blendEquation),this.blendSrcAlpha!==null&&(r.blendSrcAlpha=this.blendSrcAlpha),this.blendDstAlpha!==null&&(r.blendDstAlpha=this.blendDstAlpha),this.blendEquationAlpha!==null&&(r.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(r.blendColor=this.blendColor.getHex()),this.blendAlpha!==0&&(r.blendAlpha=this.blendAlpha),this.depthFunc!==Dg&&(r.depthFunc=this.depthFunc),this.depthTest===!1&&(r.depthTest=this.depthTest),this.depthWrite===!1&&(r.depthWrite=this.depthWrite),this.colorWrite===!1&&(r.colorWrite=this.colorWrite),this.stencilWriteMask!==255&&(r.stencilWriteMask=this.stencilWriteMask),this.stencilFunc!==P2&&(r.stencilFunc=this.stencilFunc),this.stencilRef!==0&&(r.stencilRef=this.stencilRef),this.stencilFuncMask!==255&&(r.stencilFuncMask=this.stencilFuncMask),this.stencilFail!==_u&&(r.stencilFail=this.stencilFail),this.stencilZFail!==_u&&(r.stencilZFail=this.stencilZFail),this.stencilZPass!==_u&&(r.stencilZPass=this.stencilZPass),this.stencilWrite===!0&&(r.stencilWrite=this.stencilWrite),this.rotation!==void 0&&this.rotation!==0&&(r.rotation=this.rotation),this.polygonOffset===!0&&(r.polygonOffset=!0),this.polygonOffsetFactor!==0&&(r.polygonOffsetFactor=this.polygonOffsetFactor),this.polygonOffsetUnits!==0&&(r.polygonOffsetUnits=this.polygonOffsetUnits),this.linewidth!==void 0&&this.linewidth!==1&&(r.linewidth=this.linewidth),this.dashSize!==void 0&&(r.dashSize=this.dashSize),this.gapSize!==void 0&&(r.gapSize=this.gapSize),this.scale!==void 0&&(r.scale=this.scale),this.dithering===!0&&(r.dithering=!0),this.alphaTest>0&&(r.alphaTest=this.alphaTest),this.alphaHash===!0&&(r.alphaHash=!0),this.alphaToCoverage===!0&&(r.alphaToCoverage=!0),this.premultipliedAlpha===!0&&(r.premultipliedAlpha=!0),this.forceSinglePass===!0&&(r.forceSinglePass=!0),this.wireframe===!0&&(r.wireframe=!0),this.wireframeLinewidth>1&&(r.wireframeLinewidth=this.wireframeLinewidth),this.wireframeLinecap!=="round"&&(r.wireframeLinecap=this.wireframeLinecap),this.wireframeLinejoin!=="round"&&(r.wireframeLinejoin=this.wireframeLinejoin),this.flatShading===!0&&(r.flatShading=!0),this.visible===!1&&(r.visible=!1),this.toneMapped===!1&&(r.toneMapped=!1),this.fog===!1&&(r.fog=!1),Object.keys(this.userData).length>0&&(r.userData=this.userData);function i(s){const o=[];for(const a in s){const l=s[a];delete l.metadata,o.push(l)}return o}if(n){const s=i(e.textures),o=i(e.images);s.length>0&&(r.textures=s),o.length>0&&(r.images=o)}return r}clone(){return new this.constructor().copy(this)}copy(e){this.name=e.name,this.blending=e.blending,this.side=e.side,this.vertexColors=e.vertexColors,this.opacity=e.opacity,this.transparent=e.transparent,this.blendSrc=e.blendSrc,this.blendDst=e.blendDst,this.blendEquation=e.blendEquation,this.blendSrcAlpha=e.blendSrcAlpha,this.blendDstAlpha=e.blendDstAlpha,this.blendEquationAlpha=e.blendEquationAlpha,this.blendColor.copy(e.blendColor),this.blendAlpha=e.blendAlpha,this.depthFunc=e.depthFunc,this.depthTest=e.depthTest,this.depthWrite=e.depthWrite,this.stencilWriteMask=e.stencilWriteMask,this.stencilFunc=e.stencilFunc,this.stencilRef=e.stencilRef,this.stencilFuncMask=e.stencilFuncMask,this.stencilFail=e.stencilFail,this.stencilZFail=e.stencilZFail,this.stencilZPass=e.stencilZPass,this.stencilWrite=e.stencilWrite;const n=e.clippingPlanes;let r=null;if(n!==null){const i=n.length;r=new Array(i);for(let s=0;s!==i;++s)r[s]=n[s].clone()}return this.clippingPlanes=r,this.clipIntersection=e.clipIntersection,this.clipShadows=e.clipShadows,this.shadowSide=e.shadowSide,this.colorWrite=e.colorWrite,this.precision=e.precision,this.polygonOffset=e.polygonOffset,this.polygonOffsetFactor=e.polygonOffsetFactor,this.polygonOffsetUnits=e.polygonOffsetUnits,this.dithering=e.dithering,this.alphaTest=e.alphaTest,this.alphaHash=e.alphaHash,this.alphaToCoverage=e.alphaToCoverage,this.premultipliedAlpha=e.premultipliedAlpha,this.forceSinglePass=e.forceSinglePass,this.visible=e.visible,this.toneMapped=e.toneMapped,this.userData=JSON.parse(JSON.stringify(e.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(e){e===!0&&this.version++}}class Qi extends wr{constructor(e){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Qe(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Is,this.combine=E0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}const nl=zle();function zle(){const t=new ArrayBuffer(4),e=new Float32Array(t),n=new Uint32Array(t),r=new Uint32Array(512),i=new Uint32Array(512);for(let l=0;l<256;++l){const c=l-127;c<-27?(r[l]=0,r[l|256]=32768,i[l]=24,i[l|256]=24):c<-14?(r[l]=1024>>-c-14,r[l|256]=1024>>-c-14|32768,i[l]=-c-1,i[l|256]=-c-1):c<=15?(r[l]=c+15<<10,r[l|256]=c+15<<10|32768,i[l]=13,i[l|256]=13):c<128?(r[l]=31744,r[l|256]=64512,i[l]=24,i[l|256]=24):(r[l]=31744,r[l|256]=64512,i[l]=13,i[l|256]=13)}const s=new Uint32Array(2048),o=new Uint32Array(64),a=new Uint32Array(64);for(let l=1;l<1024;++l){let c=l<<13,u=0;for(;!(c&8388608);)c<<=1,u-=8388608;c&=-8388609,u+=947912704,s[l]=c|u}for(let l=1024;l<2048;++l)s[l]=939524096+(l-1024<<13);for(let l=1;l<31;++l)o[l]=l<<23;o[31]=1199570944,o[32]=2147483648;for(let l=33;l<63;++l)o[l]=2147483648+(l-32<<23);o[63]=3347054592;for(let l=1;l<64;++l)l!==32&&(a[l]=1024);return{floatView:e,uint32View:n,baseTable:r,shiftTable:i,mantissaTable:s,exponentTable:o,offsetTable:a}}function ji(t){Math.abs(t)>65504&&console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),t=sr(t,-65504,65504),nl.floatView[0]=t;const e=nl.uint32View[0],n=e>>23&511;return nl.baseTable[n]+((e&8388607)>>nl.shiftTable[n])}function Um(t){const e=t>>10;return nl.uint32View[0]=nl.mantissaTable[nl.offsetTable[e]+(t&1023)]+nl.exponentTable[e],nl.floatView[0]}const Gle={toHalfFloat:ji,fromHalfFloat:Um},xr=new K,Nv=new Re;class en{constructor(e,n,r=!1){if(Array.isArray(e))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,this.name="",this.array=e,this.itemSize=n,this.count=e!==void 0?e.length/n:0,this.normalized=r,this.usage=Gg,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.gpuType=lo,this.version=0}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return _5("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,n){this.updateRanges.push({start:e,count:n})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.name=e.name,this.array=new e.array.constructor(e.array),this.itemSize=e.itemSize,this.count=e.count,this.normalized=e.normalized,this.usage=e.usage,this.gpuType=e.gpuType,this}copyAt(e,n,r){e*=this.itemSize,r*=n.itemSize;for(let i=0,s=this.itemSize;i<s;i++)this.array[e+i]=n.array[r+i];return this}copyArray(e){return this.array.set(e),this}applyMatrix3(e){if(this.itemSize===2)for(let n=0,r=this.count;n<r;n++)Nv.fromBufferAttribute(this,n),Nv.applyMatrix3(e),this.setXY(n,Nv.x,Nv.y);else if(this.itemSize===3)for(let n=0,r=this.count;n<r;n++)xr.fromBufferAttribute(this,n),xr.applyMatrix3(e),this.setXYZ(n,xr.x,xr.y,xr.z);return this}applyMatrix4(e){for(let n=0,r=this.count;n<r;n++)xr.fromBufferAttribute(this,n),xr.applyMatrix4(e),this.setXYZ(n,xr.x,xr.y,xr.z);return this}applyNormalMatrix(e){for(let n=0,r=this.count;n<r;n++)xr.fromBufferAttribute(this,n),xr.applyNormalMatrix(e),this.setXYZ(n,xr.x,xr.y,xr.z);return this}transformDirection(e){for(let n=0,r=this.count;n<r;n++)xr.fromBufferAttribute(this,n),xr.transformDirection(e),this.setXYZ(n,xr.x,xr.y,xr.z);return this}set(e,n=0){return this.array.set(e,n),this}getComponent(e,n){let r=this.array[e*this.itemSize+n];return this.normalized&&(r=Pi(r,this.array)),r}setComponent(e,n,r){return this.normalized&&(r=Ut(r,this.array)),this.array[e*this.itemSize+n]=r,this}getX(e){let n=this.array[e*this.itemSize];return this.normalized&&(n=Pi(n,this.array)),n}setX(e,n){return this.normalized&&(n=Ut(n,this.array)),this.array[e*this.itemSize]=n,this}getY(e){let n=this.array[e*this.itemSize+1];return this.normalized&&(n=Pi(n,this.array)),n}setY(e,n){return this.normalized&&(n=Ut(n,this.array)),this.array[e*this.itemSize+1]=n,this}getZ(e){let n=this.array[e*this.itemSize+2];return this.normalized&&(n=Pi(n,this.array)),n}setZ(e,n){return this.normalized&&(n=Ut(n,this.array)),this.array[e*this.itemSize+2]=n,this}getW(e){let n=this.array[e*this.itemSize+3];return this.normalized&&(n=Pi(n,this.array)),n}setW(e,n){return this.normalized&&(n=Ut(n,this.array)),this.array[e*this.itemSize+3]=n,this}setXY(e,n,r){return e*=this.itemSize,this.normalized&&(n=Ut(n,this.array),r=Ut(r,this.array)),this.array[e+0]=n,this.array[e+1]=r,this}setXYZ(e,n,r,i){return e*=this.itemSize,this.normalized&&(n=Ut(n,this.array),r=Ut(r,this.array),i=Ut(i,this.array)),this.array[e+0]=n,this.array[e+1]=r,this.array[e+2]=i,this}setXYZW(e,n,r,i,s){return e*=this.itemSize,this.normalized&&(n=Ut(n,this.array),r=Ut(r,this.array),i=Ut(i,this.array),s=Ut(s,this.array)),this.array[e+0]=n,this.array[e+1]=r,this.array[e+2]=i,this.array[e+3]=s,this}onUpload(e){return this.onUploadCallback=e,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const e={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return this.name!==""&&(e.name=this.name),this.usage!==Gg&&(e.usage=this.usage),e}}class Hle extends en{constructor(e,n,r){super(new Int8Array(e),n,r)}}class Vle extends en{constructor(e,n,r){super(new Uint8Array(e),n,r)}}class Wle extends en{constructor(e,n,r){super(new Uint8ClampedArray(e),n,r)}}class jle extends en{constructor(e,n,r){super(new Int16Array(e),n,r)}}class IR extends en{constructor(e,n,r){super(new Uint16Array(e),n,r)}}class Xle extends en{constructor(e,n,r){super(new Int32Array(e),n,r)}}class NR extends en{constructor(e,n,r){super(new Uint32Array(e),n,r)}}class Kle extends en{constructor(e,n,r){super(new Uint16Array(e),n,r),this.isFloat16BufferAttribute=!0}getX(e){let n=Um(this.array[e*this.itemSize]);return this.normalized&&(n=Pi(n,this.array)),n}setX(e,n){return this.normalized&&(n=Ut(n,this.array)),this.array[e*this.itemSize]=ji(n),this}getY(e){let n=Um(this.array[e*this.itemSize+1]);return this.normalized&&(n=Pi(n,this.array)),n}setY(e,n){return this.normalized&&(n=Ut(n,this.array)),this.array[e*this.itemSize+1]=ji(n),this}getZ(e){let n=Um(this.array[e*this.itemSize+2]);return this.normalized&&(n=Pi(n,this.array)),n}setZ(e,n){return this.normalized&&(n=Ut(n,this.array)),this.array[e*this.itemSize+2]=ji(n),this}getW(e){let n=Um(this.array[e*this.itemSize+3]);return this.normalized&&(n=Pi(n,this.array)),n}setW(e,n){return this.normalized&&(n=Ut(n,this.array)),this.array[e*this.itemSize+3]=ji(n),this}setXY(e,n,r){return e*=this.itemSize,this.normalized&&(n=Ut(n,this.array),r=Ut(r,this.array)),this.array[e+0]=ji(n),this.array[e+1]=ji(r),this}setXYZ(e,n,r,i){return e*=this.itemSize,this.normalized&&(n=Ut(n,this.array),r=Ut(r,this.array),i=Ut(i,this.array)),this.array[e+0]=ji(n),this.array[e+1]=ji(r),this.array[e+2]=ji(i),this}setXYZW(e,n,r,i,s){return e*=this.itemSize,this.normalized&&(n=Ut(n,this.array),r=Ut(r,this.array),i=Ut(i,this.array),s=Ut(s,this.array)),this.array[e+0]=ji(n),this.array[e+1]=ji(r),this.array[e+2]=ji(i),this.array[e+3]=ji(s),this}}class mt extends en{constructor(e,n,r){super(new Float32Array(e),n,r)}}let qle=0;const Ks=new St,UC=new Zt,bf=new K,gs=new vi,bm=new vi,Fr=new K;class Lt extends ka{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:qle++}),this.uuid=Ms(),this.name="",this.type="BufferGeometry",this.index=null,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:1/0},this.userData={}}getIndex(){return this.index}setIndex(e){return Array.isArray(e)?this.index=new(b5(e)?NR:IR)(e,1):this.index=e,this}getAttribute(e){return this.attributes[e]}setAttribute(e,n){return this.attributes[e]=n,this}deleteAttribute(e){return delete this.attributes[e],this}hasAttribute(e){return this.attributes[e]!==void 0}addGroup(e,n,r=0){this.groups.push({start:e,count:n,materialIndex:r})}clearGroups(){this.groups=[]}setDrawRange(e,n){this.drawRange.start=e,this.drawRange.count=n}applyMatrix4(e){const n=this.attributes.position;n!==void 0&&(n.applyMatrix4(e),n.needsUpdate=!0);const r=this.attributes.normal;if(r!==void 0){const s=new $t().getNormalMatrix(e);r.applyNormalMatrix(s),r.needsUpdate=!0}const i=this.attributes.tangent;return i!==void 0&&(i.transformDirection(e),i.needsUpdate=!0),this.boundingBox!==null&&this.computeBoundingBox(),this.boundingSphere!==null&&this.computeBoundingSphere(),this}applyQuaternion(e){return Ks.makeRotationFromQuaternion(e),this.applyMatrix4(Ks),this}rotateX(e){return Ks.makeRotationX(e),this.applyMatrix4(Ks),this}rotateY(e){return Ks.makeRotationY(e),this.applyMatrix4(Ks),this}rotateZ(e){return Ks.makeRotationZ(e),this.applyMatrix4(Ks),this}translate(e,n,r){return Ks.makeTranslation(e,n,r),this.applyMatrix4(Ks),this}scale(e,n,r){return Ks.makeScale(e,n,r),this.applyMatrix4(Ks),this}lookAt(e){return UC.lookAt(e),UC.updateMatrix(),this.applyMatrix4(UC.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(bf).negate(),this.translate(bf.x,bf.y,bf.z),this}setFromPoints(e){const n=[];for(let r=0,i=e.length;r<i;r++){const s=e[r];n.push(s.x,s.y,s.z||0)}return this.setAttribute("position",new mt(n,3)),this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new vi);const e=this.attributes.position,n=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),this.boundingBox.set(new K(-1/0,-1/0,-1/0),new K(1/0,1/0,1/0));return}if(e!==void 0){if(this.boundingBox.setFromBufferAttribute(e),n)for(let r=0,i=n.length;r<i;r++){const s=n[r];gs.setFromBufferAttribute(s),this.morphTargetsRelative?(Fr.addVectors(this.boundingBox.min,gs.min),this.boundingBox.expandByPoint(Fr),Fr.addVectors(this.boundingBox.max,gs.max),this.boundingBox.expandByPoint(Fr)):(this.boundingBox.expandByPoint(gs.min),this.boundingBox.expandByPoint(gs.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Zr);const e=this.attributes.position,n=this.morphAttributes.position;if(e&&e.isGLBufferAttribute){console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),this.boundingSphere.set(new K,1/0);return}if(e){const r=this.boundingSphere.center;if(gs.setFromBufferAttribute(e),n)for(let s=0,o=n.length;s<o;s++){const a=n[s];bm.setFromBufferAttribute(a),this.morphTargetsRelative?(Fr.addVectors(gs.min,bm.min),gs.expandByPoint(Fr),Fr.addVectors(gs.max,bm.max),gs.expandByPoint(Fr)):(gs.expandByPoint(bm.min),gs.expandByPoint(bm.max))}gs.getCenter(r);let i=0;for(let s=0,o=e.count;s<o;s++)Fr.fromBufferAttribute(e,s),i=Math.max(i,r.distanceToSquared(Fr));if(n)for(let s=0,o=n.length;s<o;s++){const a=n[s],l=this.morphTargetsRelative;for(let c=0,u=a.count;c<u;c++)Fr.fromBufferAttribute(a,c),l&&(bf.fromBufferAttribute(e,c),Fr.add(bf)),i=Math.max(i,r.distanceToSquared(Fr))}this.boundingSphere.radius=Math.sqrt(i),isNaN(this.boundingSphere.radius)&&console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const e=this.index,n=this.attributes;if(e===null||n.position===void 0||n.normal===void 0||n.uv===void 0){console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");return}const r=n.position,i=n.normal,s=n.uv;this.hasAttribute("tangent")===!1&&this.setAttribute("tangent",new en(new Float32Array(4*r.count),4));const o=this.getAttribute("tangent"),a=[],l=[];for(let I=0;I<r.count;I++)a[I]=new K,l[I]=new K;const c=new K,u=new K,d=new K,f=new Re,h=new Re,p=new Re,x=new K,v=new K;function y(I,N,M){c.fromBufferAttribute(r,I),u.fromBufferAttribute(r,N),d.fromBufferAttribute(r,M),f.fromBufferAttribute(s,I),h.fromBufferAttribute(s,N),p.fromBufferAttribute(s,M),u.sub(c),d.sub(c),h.sub(f),p.sub(f);const P=1/(h.x*p.y-p.x*h.y);isFinite(P)&&(x.copy(u).multiplyScalar(p.y).addScaledVector(d,-h.y).multiplyScalar(P),v.copy(d).multiplyScalar(h.x).addScaledVector(u,-p.x).multiplyScalar(P),a[I].add(x),a[N].add(x),a[M].add(x),l[I].add(v),l[N].add(v),l[M].add(v))}let b=this.groups;b.length===0&&(b=[{start:0,count:e.count}]);for(let I=0,N=b.length;I<N;++I){const M=b[I],P=M.start,B=M.count;for(let F=P,U=P+B;F<U;F+=3)y(e.getX(F+0),e.getX(F+1),e.getX(F+2))}const S=new K,w=new K,E=new K,A=new K;function T(I){E.fromBufferAttribute(i,I),A.copy(E);const N=a[I];S.copy(N),S.sub(E.multiplyScalar(E.dot(N))).normalize(),w.crossVectors(A,N);const P=w.dot(l[I])<0?-1:1;o.setXYZW(I,S.x,S.y,S.z,P)}for(let I=0,N=b.length;I<N;++I){const M=b[I],P=M.start,B=M.count;for(let F=P,U=P+B;F<U;F+=3)T(e.getX(F+0)),T(e.getX(F+1)),T(e.getX(F+2))}}computeVertexNormals(){const e=this.index,n=this.getAttribute("position");if(n!==void 0){let r=this.getAttribute("normal");if(r===void 0)r=new en(new Float32Array(n.count*3),3),this.setAttribute("normal",r);else for(let f=0,h=r.count;f<h;f++)r.setXYZ(f,0,0,0);const i=new K,s=new K,o=new K,a=new K,l=new K,c=new K,u=new K,d=new K;if(e)for(let f=0,h=e.count;f<h;f+=3){const p=e.getX(f+0),x=e.getX(f+1),v=e.getX(f+2);i.fromBufferAttribute(n,p),s.fromBufferAttribute(n,x),o.fromBufferAttribute(n,v),u.subVectors(o,s),d.subVectors(i,s),u.cross(d),a.fromBufferAttribute(r,p),l.fromBufferAttribute(r,x),c.fromBufferAttribute(r,v),a.add(u),l.add(u),c.add(u),r.setXYZ(p,a.x,a.y,a.z),r.setXYZ(x,l.x,l.y,l.z),r.setXYZ(v,c.x,c.y,c.z)}else for(let f=0,h=n.count;f<h;f+=3)i.fromBufferAttribute(n,f+0),s.fromBufferAttribute(n,f+1),o.fromBufferAttribute(n,f+2),u.subVectors(o,s),d.subVectors(i,s),u.cross(d),r.setXYZ(f+0,u.x,u.y,u.z),r.setXYZ(f+1,u.x,u.y,u.z),r.setXYZ(f+2,u.x,u.y,u.z);this.normalizeNormals(),r.needsUpdate=!0}}normalizeNormals(){const e=this.attributes.normal;for(let n=0,r=e.count;n<r;n++)Fr.fromBufferAttribute(e,n),Fr.normalize(),e.setXYZ(n,Fr.x,Fr.y,Fr.z)}toNonIndexed(){function e(a,l){const c=a.array,u=a.itemSize,d=a.normalized,f=new c.constructor(l.length*u);let h=0,p=0;for(let x=0,v=l.length;x<v;x++){a.isInterleavedBufferAttribute?h=l[x]*a.data.stride+a.offset:h=l[x]*u;for(let y=0;y<u;y++)f[p++]=c[h++]}return new en(f,u,d)}if(this.index===null)return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const n=new Lt,r=this.index.array,i=this.attributes;for(const a in i){const l=i[a],c=e(l,r);n.setAttribute(a,c)}const s=this.morphAttributes;for(const a in s){const l=[],c=s[a];for(let u=0,d=c.length;u<d;u++){const f=c[u],h=e(f,r);l.push(h)}n.morphAttributes[a]=l}n.morphTargetsRelative=this.morphTargetsRelative;const o=this.groups;for(let a=0,l=o.length;a<l;a++){const c=o[a];n.addGroup(c.start,c.count,c.materialIndex)}return n}toJSON(){const e={metadata:{version:4.6,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(e.uuid=this.uuid,e.type=this.type,this.name!==""&&(e.name=this.name),Object.keys(this.userData).length>0&&(e.userData=this.userData),this.parameters!==void 0){const l=this.parameters;for(const c in l)l[c]!==void 0&&(e[c]=l[c]);return e}e.data={attributes:{}};const n=this.index;n!==null&&(e.data.index={type:n.array.constructor.name,array:Array.prototype.slice.call(n.array)});const r=this.attributes;for(const l in r){const c=r[l];e.data.attributes[l]=c.toJSON(e.data)}const i={};let s=!1;for(const l in this.morphAttributes){const c=this.morphAttributes[l],u=[];for(let d=0,f=c.length;d<f;d++){const h=c[d];u.push(h.toJSON(e.data))}u.length>0&&(i[l]=u,s=!0)}s&&(e.data.morphAttributes=i,e.data.morphTargetsRelative=this.morphTargetsRelative);const o=this.groups;o.length>0&&(e.data.groups=JSON.parse(JSON.stringify(o)));const a=this.boundingSphere;return a!==null&&(e.data.boundingSphere={center:a.center.toArray(),radius:a.radius}),e}clone(){return new this.constructor().copy(this)}copy(e){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const n={};this.name=e.name;const r=e.index;r!==null&&this.setIndex(r.clone(n));const i=e.attributes;for(const c in i){const u=i[c];this.setAttribute(c,u.clone(n))}const s=e.morphAttributes;for(const c in s){const u=[],d=s[c];for(let f=0,h=d.length;f<h;f++)u.push(d[f].clone(n));this.morphAttributes[c]=u}this.morphTargetsRelative=e.morphTargetsRelative;const o=e.groups;for(let c=0,u=o.length;c<u;c++){const d=o[c];this.addGroup(d.start,d.count,d.materialIndex)}const a=e.boundingBox;a!==null&&(this.boundingBox=a.clone());const l=e.boundingSphere;return l!==null&&(this.boundingSphere=l.clone()),this.drawRange.start=e.drawRange.start,this.drawRange.count=e.drawRange.count,this.userData=e.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}const VD=new St,ru=new Nd,Pv=new Zr,WD=new K,Sf=new K,_f=new K,wf=new K,zC=new K,kv=new K,Dv=new Re,Ov=new Re,Lv=new Re,jD=new K,XD=new K,KD=new K,Bv=new K,Fv=new K;class lr extends Zt{constructor(e=new Lt,n=new Qi){super(),this.isMesh=!0,this.type="Mesh",this.geometry=e,this.material=n,this.updateMorphTargets()}copy(e,n){return super.copy(e,n),e.morphTargetInfluences!==void 0&&(this.morphTargetInfluences=e.morphTargetInfluences.slice()),e.morphTargetDictionary!==void 0&&(this.morphTargetDictionary=Object.assign({},e.morphTargetDictionary)),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}updateMorphTargets(){const n=this.geometry.morphAttributes,r=Object.keys(n);if(r.length>0){const i=n[r[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}getVertexPosition(e,n){const r=this.geometry,i=r.attributes.position,s=r.morphAttributes.position,o=r.morphTargetsRelative;n.fromBufferAttribute(i,e);const a=this.morphTargetInfluences;if(s&&a){kv.set(0,0,0);for(let l=0,c=s.length;l<c;l++){const u=a[l],d=s[l];u!==0&&(zC.fromBufferAttribute(d,e),o?kv.addScaledVector(zC,u):kv.addScaledVector(zC.sub(n),u))}n.add(kv)}return n}raycast(e,n){const r=this.geometry,i=this.material,s=this.matrixWorld;i!==void 0&&(r.boundingSphere===null&&r.computeBoundingSphere(),Pv.copy(r.boundingSphere),Pv.applyMatrix4(s),ru.copy(e.ray).recast(e.near),!(Pv.containsPoint(ru.origin)===!1&&(ru.intersectSphere(Pv,WD)===null||ru.origin.distanceToSquared(WD)>(e.far-e.near)**2))&&(VD.copy(s).invert(),ru.copy(e.ray).applyMatrix4(VD),!(r.boundingBox!==null&&ru.intersectsBox(r.boundingBox)===!1)&&this._computeIntersections(e,n,ru)))}_computeIntersections(e,n,r){let i;const s=this.geometry,o=this.material,a=s.index,l=s.attributes.position,c=s.attributes.uv,u=s.attributes.uv1,d=s.attributes.normal,f=s.groups,h=s.drawRange;if(a!==null)if(Array.isArray(o))for(let p=0,x=f.length;p<x;p++){const v=f[p],y=o[v.materialIndex],b=Math.max(v.start,h.start),S=Math.min(a.count,Math.min(v.start+v.count,h.start+h.count));for(let w=b,E=S;w<E;w+=3){const A=a.getX(w),T=a.getX(w+1),I=a.getX(w+2);i=$v(this,y,e,r,c,u,d,A,T,I),i&&(i.faceIndex=Math.floor(w/3),i.face.materialIndex=v.materialIndex,n.push(i))}}else{const p=Math.max(0,h.start),x=Math.min(a.count,h.start+h.count);for(let v=p,y=x;v<y;v+=3){const b=a.getX(v),S=a.getX(v+1),w=a.getX(v+2);i=$v(this,o,e,r,c,u,d,b,S,w),i&&(i.faceIndex=Math.floor(v/3),n.push(i))}}else if(l!==void 0)if(Array.isArray(o))for(let p=0,x=f.length;p<x;p++){const v=f[p],y=o[v.materialIndex],b=Math.max(v.start,h.start),S=Math.min(l.count,Math.min(v.start+v.count,h.start+h.count));for(let w=b,E=S;w<E;w+=3){const A=w,T=w+1,I=w+2;i=$v(this,y,e,r,c,u,d,A,T,I),i&&(i.faceIndex=Math.floor(w/3),i.face.materialIndex=v.materialIndex,n.push(i))}}else{const p=Math.max(0,h.start),x=Math.min(l.count,h.start+h.count);for(let v=p,y=x;v<y;v+=3){const b=v,S=v+1,w=v+2;i=$v(this,o,e,r,c,u,d,b,S,w),i&&(i.faceIndex=Math.floor(v/3),n.push(i))}}}}function Jle(t,e,n,r,i,s,o,a){let l;if(e.side===Fi?l=r.intersectTriangle(o,s,i,!0,a):l=r.intersectTriangle(i,s,o,e.side===Ia,a),l===null)return null;Fv.copy(a),Fv.applyMatrix4(t.matrixWorld);const c=n.ray.origin.distanceTo(Fv);return c<n.near||c>n.far?null:{distance:c,point:Fv.clone(),object:t}}function $v(t,e,n,r,i,s,o,a,l,c){t.getVertexPosition(a,Sf),t.getVertexPosition(l,_f),t.getVertexPosition(c,wf);const u=Jle(t,e,n,r,Sf,_f,wf,Bv);if(u){i&&(Dv.fromBufferAttribute(i,a),Ov.fromBufferAttribute(i,l),Lv.fromBufferAttribute(i,c),u.uv=Ss.getInterpolation(Bv,Sf,_f,wf,Dv,Ov,Lv,new Re)),s&&(Dv.fromBufferAttribute(s,a),Ov.fromBufferAttribute(s,l),Lv.fromBufferAttribute(s,c),u.uv1=Ss.getInterpolation(Bv,Sf,_f,wf,Dv,Ov,Lv,new Re)),o&&(jD.fromBufferAttribute(o,a),XD.fromBufferAttribute(o,l),KD.fromBufferAttribute(o,c),u.normal=Ss.getInterpolation(Bv,Sf,_f,wf,jD,XD,KD,new K),u.normal.dot(r.direction)>0&&u.normal.multiplyScalar(-1));const d={a,b:l,c,normal:new K,materialIndex:0};Ss.getNormal(Sf,_f,wf,d.normal),u.face=d}return u}class Pd extends Lt{constructor(e=1,n=1,r=1,i=1,s=1,o=1){super(),this.type="BoxGeometry",this.parameters={width:e,height:n,depth:r,widthSegments:i,heightSegments:s,depthSegments:o};const a=this;i=Math.floor(i),s=Math.floor(s),o=Math.floor(o);const l=[],c=[],u=[],d=[];let f=0,h=0;p("z","y","x",-1,-1,r,n,e,o,s,0),p("z","y","x",1,-1,r,n,-e,o,s,1),p("x","z","y",1,1,e,r,n,i,o,2),p("x","z","y",1,-1,e,r,-n,i,o,3),p("x","y","z",1,-1,e,n,r,i,s,4),p("x","y","z",-1,-1,e,n,-r,i,s,5),this.setIndex(l),this.setAttribute("position",new mt(c,3)),this.setAttribute("normal",new mt(u,3)),this.setAttribute("uv",new mt(d,2));function p(x,v,y,b,S,w,E,A,T,I,N){const M=w/T,P=E/I,B=w/2,F=E/2,U=A/2,j=T+1,Z=I+1;let ne=0,O=0;const G=new K;for(let q=0;q<Z;q++){const se=q*P-F;for(let he=0;he<j;he++){const ke=he*M-B;G[x]=ke*b,G[v]=se*S,G[y]=U,c.push(G.x,G.y,G.z),G[x]=0,G[v]=0,G[y]=A>0?1:-1,u.push(G.x,G.y,G.z),d.push(he/T),d.push(1-q/I),ne+=1}}for(let q=0;q<I;q++)for(let se=0;se<T;se++){const he=f+se+j*q,ke=f+se+j*(q+1),re=f+(se+1)+j*(q+1),pe=f+(se+1)+j*q;l.push(he,ke,pe),l.push(ke,re,pe),O+=6}a.addGroup(h,O,N),h+=O,f+=ne}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Pd(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)}}function Hh(t){const e={};for(const n in t){e[n]={};for(const r in t[n]){const i=t[n][r];i&&(i.isColor||i.isMatrix3||i.isMatrix4||i.isVector2||i.isVector3||i.isVector4||i.isTexture||i.isQuaternion)?i.isRenderTargetTexture?(console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),e[n][r]=null):e[n][r]=i.clone():Array.isArray(i)?e[n][r]=i.slice():e[n][r]=i}}return e}function Ii(t){const e={};for(let n=0;n<t.length;n++){const r=Hh(t[n]);for(const i in r)e[i]=r[i]}return e}function Yle(t){const e=[];for(let n=0;n<t.length;n++)e.push(t[n].clone());return e}function A5(t){const e=t.getRenderTarget();return e===null?t.outputColorSpace:e.isXRRenderTarget===!0?e.texture.colorSpace:gn.workingColorSpace}const T5={clone:Hh,merge:Ii};var Qle=`void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,Zle=`void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;class Ko extends wr{constructor(e){super(),this.isShaderMaterial=!0,this.type="ShaderMaterial",this.defines={},this.uniforms={},this.uniformsGroups=[],this.vertexShader=Qle,this.fragmentShader=Zle,this.linewidth=1,this.wireframe=!1,this.wireframeLinewidth=1,this.fog=!1,this.lights=!1,this.clipping=!1,this.forceSinglePass=!0,this.extensions={clipCullDistance:!1,multiDraw:!1},this.defaultAttributeValues={color:[1,1,1],uv:[0,0],uv1:[0,0]},this.index0AttributeName=void 0,this.uniformsNeedUpdate=!1,this.glslVersion=null,e!==void 0&&this.setValues(e)}copy(e){return super.copy(e),this.fragmentShader=e.fragmentShader,this.vertexShader=e.vertexShader,this.uniforms=Hh(e.uniforms),this.uniformsGroups=Yle(e.uniformsGroups),this.defines=Object.assign({},e.defines),this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.fog=e.fog,this.lights=e.lights,this.clipping=e.clipping,this.extensions=Object.assign({},e.extensions),this.glslVersion=e.glslVersion,this}toJSON(e){const n=super.toJSON(e);n.glslVersion=this.glslVersion,n.uniforms={};for(const i in this.uniforms){const o=this.uniforms[i].value;o&&o.isTexture?n.uniforms[i]={type:"t",value:o.toJSON(e).uuid}:o&&o.isColor?n.uniforms[i]={type:"c",value:o.getHex()}:o&&o.isVector2?n.uniforms[i]={type:"v2",value:o.toArray()}:o&&o.isVector3?n.uniforms[i]={type:"v3",value:o.toArray()}:o&&o.isVector4?n.uniforms[i]={type:"v4",value:o.toArray()}:o&&o.isMatrix3?n.uniforms[i]={type:"m3",value:o.toArray()}:o&&o.isMatrix4?n.uniforms[i]={type:"m4",value:o.toArray()}:n.uniforms[i]={value:o}}Object.keys(this.defines).length>0&&(n.defines=this.defines),n.vertexShader=this.vertexShader,n.fragmentShader=this.fragmentShader,n.lights=this.lights,n.clipping=this.clipping;const r={};for(const i in this.extensions)this.extensions[i]===!0&&(r[i]=!0);return Object.keys(r).length>0&&(n.extensions=r),n}}class T0 extends Zt{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new St,this.projectionMatrix=new St,this.projectionMatrixInverse=new St,this.coordinateSystem=xa}copy(e,n){return super.copy(e,n),this.matrixWorldInverse.copy(e.matrixWorldInverse),this.projectionMatrix.copy(e.projectionMatrix),this.projectionMatrixInverse.copy(e.projectionMatrixInverse),this.coordinateSystem=e.coordinateSystem,this}getWorldDirection(e){return super.getWorldDirection(e).negate()}updateMatrixWorld(e){super.updateMatrixWorld(e),this.matrixWorldInverse.copy(this.matrixWorld).invert()}updateWorldMatrix(e,n){super.updateWorldMatrix(e,n),this.matrixWorldInverse.copy(this.matrixWorld).invert()}clone(){return new this.constructor().copy(this)}}const Jl=new K,qD=new Re,JD=new Re;class Hn extends T0{constructor(e=50,n=1,r=.1,i=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=e,this.zoom=1,this.near=r,this.far=i,this.focus=10,this.aspect=n,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(e,n){return super.copy(e,n),this.fov=e.fov,this.zoom=e.zoom,this.near=e.near,this.far=e.far,this.focus=e.focus,this.aspect=e.aspect,this.view=e.view===null?null:Object.assign({},e.view),this.filmGauge=e.filmGauge,this.filmOffset=e.filmOffset,this}setFocalLength(e){const n=.5*this.getFilmHeight()/e;this.fov=Gh*2*Math.atan(n),this.updateProjectionMatrix()}getFocalLength(){const e=Math.tan(Yu*.5*this.fov);return .5*this.getFilmHeight()/e}getEffectiveFOV(){return Gh*2*Math.atan(Math.tan(Yu*.5*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(e,n,r){Jl.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),n.set(Jl.x,Jl.y).multiplyScalar(-e/Jl.z),Jl.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),r.set(Jl.x,Jl.y).multiplyScalar(-e/Jl.z)}getViewSize(e,n){return this.getViewBounds(e,qD,JD),n.subVectors(JD,qD)}setViewOffset(e,n,r,i,s,o){this.aspect=e/n,this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=n,this.view.offsetX=r,this.view.offsetY=i,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=this.near;let n=e*Math.tan(Yu*.5*this.fov)/this.zoom,r=2*n,i=this.aspect*r,s=-.5*i;const o=this.view;if(this.view!==null&&this.view.enabled){const l=o.fullWidth,c=o.fullHeight;s+=o.offsetX*i/l,n-=o.offsetY*r/c,i*=o.width/l,r*=o.height/c}const a=this.filmOffset;a!==0&&(s+=e*a/this.getFilmWidth()),this.projectionMatrix.makePerspective(s,s+i,n,n-r,e,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const n=super.toJSON(e);return n.object.fov=this.fov,n.object.zoom=this.zoom,n.object.near=this.near,n.object.far=this.far,n.object.focus=this.focus,n.object.aspect=this.aspect,this.view!==null&&(n.object.view=Object.assign({},this.view)),n.object.filmGauge=this.filmGauge,n.object.filmOffset=this.filmOffset,n}}const Cf=-90,Ef=1;class M5 extends Zt{constructor(e,n,r){super(),this.type="CubeCamera",this.renderTarget=r,this.coordinateSystem=null,this.activeMipmapLevel=0;const i=new Hn(Cf,Ef,e,n);i.layers=this.layers,this.add(i);const s=new Hn(Cf,Ef,e,n);s.layers=this.layers,this.add(s);const o=new Hn(Cf,Ef,e,n);o.layers=this.layers,this.add(o);const a=new Hn(Cf,Ef,e,n);a.layers=this.layers,this.add(a);const l=new Hn(Cf,Ef,e,n);l.layers=this.layers,this.add(l);const c=new Hn(Cf,Ef,e,n);c.layers=this.layers,this.add(c)}updateCoordinateSystem(){const e=this.coordinateSystem,n=this.children.concat(),[r,i,s,o,a,l]=n;for(const c of n)this.remove(c);if(e===xa)r.up.set(0,1,0),r.lookAt(1,0,0),i.up.set(0,1,0),i.lookAt(-1,0,0),s.up.set(0,0,-1),s.lookAt(0,1,0),o.up.set(0,0,1),o.lookAt(0,-1,0),a.up.set(0,1,0),a.lookAt(0,0,1),l.up.set(0,1,0),l.lookAt(0,0,-1);else if(e===Hg)r.up.set(0,-1,0),r.lookAt(-1,0,0),i.up.set(0,-1,0),i.lookAt(1,0,0),s.up.set(0,0,1),s.lookAt(0,1,0),o.up.set(0,0,-1),o.lookAt(0,-1,0),a.up.set(0,-1,0),a.lookAt(0,0,1),l.up.set(0,-1,0),l.lookAt(0,0,-1);else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+e);for(const c of n)this.add(c),c.updateMatrixWorld()}update(e,n){this.parent===null&&this.updateMatrixWorld();const{renderTarget:r,activeMipmapLevel:i}=this;this.coordinateSystem!==e.coordinateSystem&&(this.coordinateSystem=e.coordinateSystem,this.updateCoordinateSystem());const[s,o,a,l,c,u]=this.children,d=e.getRenderTarget(),f=e.getActiveCubeFace(),h=e.getActiveMipmapLevel(),p=e.xr.enabled;e.xr.enabled=!1;const x=r.texture.generateMipmaps;r.texture.generateMipmaps=!1,e.setRenderTarget(r,0,i),e.render(n,s),e.setRenderTarget(r,1,i),e.render(n,o),e.setRenderTarget(r,2,i),e.render(n,a),e.setRenderTarget(r,3,i),e.render(n,l),e.setRenderTarget(r,4,i),e.render(n,c),r.texture.generateMipmaps=x,e.setRenderTarget(r,5,i),e.render(n,u),e.setRenderTarget(d,f,h),e.xr.enabled=p,r.texture.needsPMREMUpdate=!0}}class M0 extends Bn{constructor(e,n,r,i,s,o,a,l,c,u){e=e!==void 0?e:[],n=n!==void 0?n:xl,super(e,n,r,i,s,o,a,l,c,u),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(e){this.image=e}}class R5 extends Xo{constructor(e=1,n={}){super(e,e,n),this.isWebGLCubeRenderTarget=!0;const r={width:e,height:e,depth:1},i=[r,r,r,r,r,r];this.texture=new M0(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace),this.texture.isRenderTargetTexture=!0,this.texture.generateMipmaps=n.generateMipmaps!==void 0?n.generateMipmaps:!1,this.texture.minFilter=n.minFilter!==void 0?n.minFilter:or}fromEquirectangularTexture(e,n){this.texture.type=n.type,this.texture.colorSpace=n.colorSpace,this.texture.generateMipmaps=n.generateMipmaps,this.texture.minFilter=n.minFilter,this.texture.magFilter=n.magFilter;const r={uniforms:{tEquirect:{value:null}},vertexShader:`

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,fragmentShader:`

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`},i=new Pd(5,5,5),s=new Ko({name:"CubemapFromEquirect",uniforms:Hh(r.uniforms),vertexShader:r.vertexShader,fragmentShader:r.fragmentShader,side:Fi,blending:cl});s.uniforms.tEquirect.value=n;const o=new lr(i,s),a=n.minFilter;return n.minFilter===ao&&(n.minFilter=or),new M5(1,10,this).update(e,o),n.minFilter=a,o.geometry.dispose(),o.material.dispose(),this}clear(e,n,r,i){const s=e.getRenderTarget();for(let o=0;o<6;o++)e.setRenderTarget(this,o),e.clear(n,r,i);e.setRenderTarget(s)}}const GC=new K,ece=new K,tce=new $t;class Ya{constructor(e=new K(1,0,0),n=0){this.isPlane=!0,this.normal=e,this.constant=n}set(e,n){return this.normal.copy(e),this.constant=n,this}setComponents(e,n,r,i){return this.normal.set(e,n,r),this.constant=i,this}setFromNormalAndCoplanarPoint(e,n){return this.normal.copy(e),this.constant=-n.dot(this.normal),this}setFromCoplanarPoints(e,n,r){const i=GC.subVectors(r,n).cross(ece.subVectors(e,n)).normalize();return this.setFromNormalAndCoplanarPoint(i,e),this}copy(e){return this.normal.copy(e.normal),this.constant=e.constant,this}normalize(){const e=1/this.normal.length();return this.normal.multiplyScalar(e),this.constant*=e,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(e){return this.normal.dot(e)+this.constant}distanceToSphere(e){return this.distanceToPoint(e.center)-e.radius}projectPoint(e,n){return n.copy(e).addScaledVector(this.normal,-this.distanceToPoint(e))}intersectLine(e,n){const r=e.delta(GC),i=this.normal.dot(r);if(i===0)return this.distanceToPoint(e.start)===0?n.copy(e.start):null;const s=-(e.start.dot(this.normal)+this.constant)/i;return s<0||s>1?null:n.copy(e.start).addScaledVector(r,s)}intersectsLine(e){const n=this.distanceToPoint(e.start),r=this.distanceToPoint(e.end);return n<0&&r>0||r<0&&n>0}intersectsBox(e){return e.intersectsPlane(this)}intersectsSphere(e){return e.intersectsPlane(this)}coplanarPoint(e){return e.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(e,n){const r=n||tce.getNormalMatrix(e),i=this.coplanarPoint(GC).applyMatrix4(e),s=this.normal.applyMatrix3(r).normalize();return this.constant=-i.dot(s),this}translate(e){return this.constant-=e.dot(this.normal),this}equals(e){return e.normal.equals(this.normal)&&e.constant===this.constant}clone(){return new this.constructor().copy(this)}}const iu=new Zr,Uv=new K;class R0{constructor(e=new Ya,n=new Ya,r=new Ya,i=new Ya,s=new Ya,o=new Ya){this.planes=[e,n,r,i,s,o]}set(e,n,r,i,s,o){const a=this.planes;return a[0].copy(e),a[1].copy(n),a[2].copy(r),a[3].copy(i),a[4].copy(s),a[5].copy(o),this}copy(e){const n=this.planes;for(let r=0;r<6;r++)n[r].copy(e.planes[r]);return this}setFromProjectionMatrix(e,n=xa){const r=this.planes,i=e.elements,s=i[0],o=i[1],a=i[2],l=i[3],c=i[4],u=i[5],d=i[6],f=i[7],h=i[8],p=i[9],x=i[10],v=i[11],y=i[12],b=i[13],S=i[14],w=i[15];if(r[0].setComponents(l-s,f-c,v-h,w-y).normalize(),r[1].setComponents(l+s,f+c,v+h,w+y).normalize(),r[2].setComponents(l+o,f+u,v+p,w+b).normalize(),r[3].setComponents(l-o,f-u,v-p,w-b).normalize(),r[4].setComponents(l-a,f-d,v-x,w-S).normalize(),n===xa)r[5].setComponents(l+a,f+d,v+x,w+S).normalize();else if(n===Hg)r[5].setComponents(a,d,x,S).normalize();else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+n);return this}intersectsObject(e){if(e.boundingSphere!==void 0)e.boundingSphere===null&&e.computeBoundingSphere(),iu.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);else{const n=e.geometry;n.boundingSphere===null&&n.computeBoundingSphere(),iu.copy(n.boundingSphere).applyMatrix4(e.matrixWorld)}return this.intersectsSphere(iu)}intersectsSprite(e){return iu.center.set(0,0,0),iu.radius=.7071067811865476,iu.applyMatrix4(e.matrixWorld),this.intersectsSphere(iu)}intersectsSphere(e){const n=this.planes,r=e.center,i=-e.radius;for(let s=0;s<6;s++)if(n[s].distanceToPoint(r)<i)return!1;return!0}intersectsBox(e){const n=this.planes;for(let r=0;r<6;r++){const i=n[r];if(Uv.x=i.normal.x>0?e.max.x:e.min.x,Uv.y=i.normal.y>0?e.max.y:e.min.y,Uv.z=i.normal.z>0?e.max.z:e.min.z,i.distanceToPoint(Uv)<0)return!1}return!0}containsPoint(e){const n=this.planes;for(let r=0;r<6;r++)if(n[r].distanceToPoint(e)<0)return!1;return!0}clone(){return new this.constructor().copy(this)}}function I5(){let t=null,e=!1,n=null,r=null;function i(s,o){n(s,o),r=t.requestAnimationFrame(i)}return{start:function(){e!==!0&&n!==null&&(r=t.requestAnimationFrame(i),e=!0)},stop:function(){t.cancelAnimationFrame(r),e=!1},setAnimationLoop:function(s){n=s},setContext:function(s){t=s}}}function nce(t){const e=new WeakMap;function n(a,l){const c=a.array,u=a.usage,d=c.byteLength,f=t.createBuffer();t.bindBuffer(l,f),t.bufferData(l,c,u),a.onUploadCallback();let h;if(c instanceof Float32Array)h=t.FLOAT;else if(c instanceof Uint16Array)a.isFloat16BufferAttribute?h=t.HALF_FLOAT:h=t.UNSIGNED_SHORT;else if(c instanceof Int16Array)h=t.SHORT;else if(c instanceof Uint32Array)h=t.UNSIGNED_INT;else if(c instanceof Int32Array)h=t.INT;else if(c instanceof Int8Array)h=t.BYTE;else if(c instanceof Uint8Array)h=t.UNSIGNED_BYTE;else if(c instanceof Uint8ClampedArray)h=t.UNSIGNED_BYTE;else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: "+c);return{buffer:f,type:h,bytesPerElement:c.BYTES_PER_ELEMENT,version:a.version,size:d}}function r(a,l,c){const u=l.array,d=l._updateRange,f=l.updateRanges;if(t.bindBuffer(c,a),d.count===-1&&f.length===0&&t.bufferSubData(c,0,u),f.length!==0){for(let h=0,p=f.length;h<p;h++){const x=f[h];t.bufferSubData(c,x.start*u.BYTES_PER_ELEMENT,u,x.start,x.count)}l.clearUpdateRanges()}d.count!==-1&&(t.bufferSubData(c,d.offset*u.BYTES_PER_ELEMENT,u,d.offset,d.count),d.count=-1),l.onUploadCallback()}function i(a){return a.isInterleavedBufferAttribute&&(a=a.data),e.get(a)}function s(a){a.isInterleavedBufferAttribute&&(a=a.data);const l=e.get(a);l&&(t.deleteBuffer(l.buffer),e.delete(a))}function o(a,l){if(a.isGLBufferAttribute){const u=e.get(a);(!u||u.version<a.version)&&e.set(a,{buffer:a.buffer,type:a.type,bytesPerElement:a.elementSize,version:a.version});return}a.isInterleavedBufferAttribute&&(a=a.data);const c=e.get(a);if(c===void 0)e.set(a,n(a,l));else if(c.version<a.version){if(c.size!==a.array.byteLength)throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");r(c.buffer,a,l),c.version=a.version}}return{get:i,remove:s,update:o}}class kd extends Lt{constructor(e=1,n=1,r=1,i=1){super(),this.type="PlaneGeometry",this.parameters={width:e,height:n,widthSegments:r,heightSegments:i};const s=e/2,o=n/2,a=Math.floor(r),l=Math.floor(i),c=a+1,u=l+1,d=e/a,f=n/l,h=[],p=[],x=[],v=[];for(let y=0;y<u;y++){const b=y*f-o;for(let S=0;S<c;S++){const w=S*d-s;p.push(w,-b,0),x.push(0,0,1),v.push(S/a),v.push(1-y/l)}}for(let y=0;y<l;y++)for(let b=0;b<a;b++){const S=b+c*y,w=b+c*(y+1),E=b+1+c*(y+1),A=b+1+c*y;h.push(S,w,A),h.push(w,E,A)}this.setIndex(h),this.setAttribute("position",new mt(p,3)),this.setAttribute("normal",new mt(x,3)),this.setAttribute("uv",new mt(v,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new kd(e.width,e.height,e.widthSegments,e.heightSegments)}}var rce=`#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,ice=`#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,sce=`#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,oce=`#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,ace=`#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,lce=`#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,cce=`#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,uce=`#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,dce=`#ifdef USE_BATCHING
	attribute float batchId;
	uniform highp sampler2D batchingTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,fce=`#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( batchId );
#endif`,hce=`vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,pce=`vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,mce=`float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,gce=`#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,yce=`#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,vce=`#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,xce=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,bce=`#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,Sce=`#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,_ce=`#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,wce=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,Cce=`#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	varying vec3 vColor;
#endif`,Ece=`#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif`,Ace=`#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
float luminance( const in vec3 rgb ) {
	const vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );
	return dot( weights, rgb );
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,Tce=`#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,Mce=`vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,Rce=`#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,Ice=`#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,Nce=`#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,Pce=`#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,kce="gl_FragColor = linearToOutputTexel( gl_FragColor );",Dce=`
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}
vec4 LinearToLinear( in vec4 value ) {
	return value;
}
vec4 LinearTosRGB( in vec4 value ) {
	return sRGBTransferOETF( value );
}`,Oce=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,Lce=`#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,Bce=`#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,Fce=`#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,$ce=`#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,Uce=`#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,zce=`#ifdef USE_FOG
	varying float vFogDepth;
#endif`,Gce=`#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,Hce=`#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,Vce=`#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,Wce=`#ifdef USE_LIGHTMAP
	vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
	vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
	reflectedLight.indirectDiffuse += lightMapIrradiance;
#endif`,jce=`#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,Xce=`LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,Kce=`varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,qce=`uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	#if defined ( LEGACY_LIGHTS )
		if ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {
			return pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );
		}
		return 1.0;
	#else
		float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
		if ( cutoffDistance > 0.0 ) {
			distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
		}
		return distanceFalloff;
	#endif
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,Jce=`#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,Yce=`ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,Qce=`varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,Zce=`BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,eue=`varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,tue=`PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,nue=`struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,rue=`
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,iue=`#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,sue=`#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,oue=`#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,aue=`#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,lue=`#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,cue=`#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,uue=`#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,due=`#ifdef USE_MAP
	uniform sampler2D map;
#endif`,fue=`#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,hue=`#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,pue=`float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,mue=`#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,gue=`#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[MORPHTARGETS_COUNT];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,yue=`#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,vue=`#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		objectNormal += morphNormal0 * morphTargetInfluences[ 0 ];
		objectNormal += morphNormal1 * morphTargetInfluences[ 1 ];
		objectNormal += morphNormal2 * morphTargetInfluences[ 2 ];
		objectNormal += morphNormal3 * morphTargetInfluences[ 3 ];
	#endif
#endif`,xue=`#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
	#endif
	#ifdef MORPHTARGETS_TEXTURE
		#ifndef USE_INSTANCING_MORPH
			uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
		#endif
		uniform sampler2DArray morphTargetsTexture;
		uniform ivec2 morphTargetsTextureSize;
		vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
			int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
			int y = texelIndex / morphTargetsTextureSize.x;
			int x = texelIndex - y * morphTargetsTextureSize.x;
			ivec3 morphUV = ivec3( x, y, morphTargetIndex );
			return texelFetch( morphTargetsTexture, morphUV, 0 );
		}
	#else
		#ifndef USE_MORPHNORMALS
			uniform float morphTargetInfluences[ 8 ];
		#else
			uniform float morphTargetInfluences[ 4 ];
		#endif
	#endif
#endif`,bue=`#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	#ifdef MORPHTARGETS_TEXTURE
		for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
			if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
		}
	#else
		transformed += morphTarget0 * morphTargetInfluences[ 0 ];
		transformed += morphTarget1 * morphTargetInfluences[ 1 ];
		transformed += morphTarget2 * morphTargetInfluences[ 2 ];
		transformed += morphTarget3 * morphTargetInfluences[ 3 ];
		#ifndef USE_MORPHNORMALS
			transformed += morphTarget4 * morphTargetInfluences[ 4 ];
			transformed += morphTarget5 * morphTargetInfluences[ 5 ];
			transformed += morphTarget6 * morphTargetInfluences[ 6 ];
			transformed += morphTarget7 * morphTargetInfluences[ 7 ];
		#endif
	#endif
#endif`,Sue=`float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,_ue=`#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,wue=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Cue=`#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,Eue=`#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,Aue=`#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,Tue=`#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,Mue=`#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,Rue=`#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,Iue=`#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,Nue=`#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,Pue=`vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;
const vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );
const vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );
const float ShiftRight8 = 1. / 256.;
vec4 packDepthToRGBA( const in float v ) {
	vec4 r = vec4( fract( v * PackFactors ), v );
	r.yzw -= r.xyz * ShiftRight8;	return r * PackUpscale;
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors );
}
vec2 packDepthToRG( in highp float v ) {
	return packDepthToRGBA( v ).yx;
}
float unpackRGToDepth( const in highp vec2 v ) {
	return unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );
}
vec4 pack2HalfToRGBA( vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,kue=`#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,Due=`vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,Oue=`#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,Lue=`#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,Bue=`float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,Fue=`#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,$ue=`#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return shadow;
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return shadow;
	}
#endif`,Uue=`#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,zue=`#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,Gue=`float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,Hue=`#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,Vue=`#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,Wue=`#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,jue=`#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,Xue=`float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,Kue=`#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,que=`#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,Jue=`#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 OptimizedCineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	float startCompression = 0.8 - 0.04;
	float desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min(color.r, min(color.g, color.b));
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max(color.r, max(color.g, color.b));
	if (peak < startCompression) return color;
	float d = 1. - startCompression;
	float newPeak = 1. - d * d / (peak + d - startCompression);
	color *= newPeak / peak;
	float g = 1. - 1. / (desaturation * (peak - newPeak) + 1.);
	return mix(color, newPeak * vec3(1, 1, 1), g);
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,Yue=`#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,Que=`#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
		vec3 refractedRayExit = position + transmissionRay;
		vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
		vec2 refractionCoords = ndcPos.xy / ndcPos.w;
		refractionCoords += 1.0;
		refractionCoords /= 2.0;
		vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
		vec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,Zue=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,ede=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,tde=`#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,nde=`#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;const rde=`varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,ide=`uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,sde=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,ode=`#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,ade=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,lde=`uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,cde=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,ude=`#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#endif
}`,dde=`#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,fde=`#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,hde=`varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,pde=`uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,mde=`uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,gde=`uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,yde=`#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,vde=`uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,xde=`#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,bde=`#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Sde=`#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,_de=`#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,wde=`#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,Cde=`#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,Ede=`#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Ade=`#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Tde=`#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,Mde=`#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Rde=`#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Ide=`#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,Nde=`uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,Pde=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,kde=`#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,Dde=`uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Ode=`uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,Lde=`uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,Gt={alphahash_fragment:rce,alphahash_pars_fragment:ice,alphamap_fragment:sce,alphamap_pars_fragment:oce,alphatest_fragment:ace,alphatest_pars_fragment:lce,aomap_fragment:cce,aomap_pars_fragment:uce,batching_pars_vertex:dce,batching_vertex:fce,begin_vertex:hce,beginnormal_vertex:pce,bsdfs:mce,iridescence_fragment:gce,bumpmap_pars_fragment:yce,clipping_planes_fragment:vce,clipping_planes_pars_fragment:xce,clipping_planes_pars_vertex:bce,clipping_planes_vertex:Sce,color_fragment:_ce,color_pars_fragment:wce,color_pars_vertex:Cce,color_vertex:Ece,common:Ace,cube_uv_reflection_fragment:Tce,defaultnormal_vertex:Mce,displacementmap_pars_vertex:Rce,displacementmap_vertex:Ice,emissivemap_fragment:Nce,emissivemap_pars_fragment:Pce,colorspace_fragment:kce,colorspace_pars_fragment:Dce,envmap_fragment:Oce,envmap_common_pars_fragment:Lce,envmap_pars_fragment:Bce,envmap_pars_vertex:Fce,envmap_physical_pars_fragment:Jce,envmap_vertex:$ce,fog_vertex:Uce,fog_pars_vertex:zce,fog_fragment:Gce,fog_pars_fragment:Hce,gradientmap_pars_fragment:Vce,lightmap_fragment:Wce,lightmap_pars_fragment:jce,lights_lambert_fragment:Xce,lights_lambert_pars_fragment:Kce,lights_pars_begin:qce,lights_toon_fragment:Yce,lights_toon_pars_fragment:Qce,lights_phong_fragment:Zce,lights_phong_pars_fragment:eue,lights_physical_fragment:tue,lights_physical_pars_fragment:nue,lights_fragment_begin:rue,lights_fragment_maps:iue,lights_fragment_end:sue,logdepthbuf_fragment:oue,logdepthbuf_pars_fragment:aue,logdepthbuf_pars_vertex:lue,logdepthbuf_vertex:cue,map_fragment:uue,map_pars_fragment:due,map_particle_fragment:fue,map_particle_pars_fragment:hue,metalnessmap_fragment:pue,metalnessmap_pars_fragment:mue,morphinstance_vertex:gue,morphcolor_vertex:yue,morphnormal_vertex:vue,morphtarget_pars_vertex:xue,morphtarget_vertex:bue,normal_fragment_begin:Sue,normal_fragment_maps:_ue,normal_pars_fragment:wue,normal_pars_vertex:Cue,normal_vertex:Eue,normalmap_pars_fragment:Aue,clearcoat_normal_fragment_begin:Tue,clearcoat_normal_fragment_maps:Mue,clearcoat_pars_fragment:Rue,iridescence_pars_fragment:Iue,opaque_fragment:Nue,packing:Pue,premultiplied_alpha_fragment:kue,project_vertex:Due,dithering_fragment:Oue,dithering_pars_fragment:Lue,roughnessmap_fragment:Bue,roughnessmap_pars_fragment:Fue,shadowmap_pars_fragment:$ue,shadowmap_pars_vertex:Uue,shadowmap_vertex:zue,shadowmask_pars_fragment:Gue,skinbase_vertex:Hue,skinning_pars_vertex:Vue,skinning_vertex:Wue,skinnormal_vertex:jue,specularmap_fragment:Xue,specularmap_pars_fragment:Kue,tonemapping_fragment:que,tonemapping_pars_fragment:Jue,transmission_fragment:Yue,transmission_pars_fragment:Que,uv_pars_fragment:Zue,uv_pars_vertex:ede,uv_vertex:tde,worldpos_vertex:nde,background_vert:rde,background_frag:ide,backgroundCube_vert:sde,backgroundCube_frag:ode,cube_vert:ade,cube_frag:lde,depth_vert:cde,depth_frag:ude,distanceRGBA_vert:dde,distanceRGBA_frag:fde,equirect_vert:hde,equirect_frag:pde,linedashed_vert:mde,linedashed_frag:gde,meshbasic_vert:yde,meshbasic_frag:vde,meshlambert_vert:xde,meshlambert_frag:bde,meshmatcap_vert:Sde,meshmatcap_frag:_de,meshnormal_vert:wde,meshnormal_frag:Cde,meshphong_vert:Ede,meshphong_frag:Ade,meshphysical_vert:Tde,meshphysical_frag:Mde,meshtoon_vert:Rde,meshtoon_frag:Ide,points_vert:Nde,points_frag:Pde,shadow_vert:kde,shadow_frag:Dde,sprite_vert:Ode,sprite_frag:Lde},Ye={common:{diffuse:{value:new Qe(16777215)},opacity:{value:1},map:{value:null},mapTransform:{value:new $t},alphaMap:{value:null},alphaMapTransform:{value:new $t},alphaTest:{value:0}},specularmap:{specularMap:{value:null},specularMapTransform:{value:new $t}},envmap:{envMap:{value:null},envMapRotation:{value:new $t},flipEnvMap:{value:-1},reflectivity:{value:1},ior:{value:1.5},refractionRatio:{value:.98}},aomap:{aoMap:{value:null},aoMapIntensity:{value:1},aoMapTransform:{value:new $t}},lightmap:{lightMap:{value:null},lightMapIntensity:{value:1},lightMapTransform:{value:new $t}},bumpmap:{bumpMap:{value:null},bumpMapTransform:{value:new $t},bumpScale:{value:1}},normalmap:{normalMap:{value:null},normalMapTransform:{value:new $t},normalScale:{value:new Re(1,1)}},displacementmap:{displacementMap:{value:null},displacementMapTransform:{value:new $t},displacementScale:{value:1},displacementBias:{value:0}},emissivemap:{emissiveMap:{value:null},emissiveMapTransform:{value:new $t}},metalnessmap:{metalnessMap:{value:null},metalnessMapTransform:{value:new $t}},roughnessmap:{roughnessMap:{value:null},roughnessMapTransform:{value:new $t}},gradientmap:{gradientMap:{value:null}},fog:{fogDensity:{value:25e-5},fogNear:{value:1},fogFar:{value:2e3},fogColor:{value:new Qe(16777215)}},lights:{ambientLightColor:{value:[]},lightProbe:{value:[]},directionalLights:{value:[],properties:{direction:{},color:{}}},directionalLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},directionalShadowMap:{value:[]},directionalShadowMatrix:{value:[]},spotLights:{value:[],properties:{color:{},position:{},direction:{},distance:{},coneCos:{},penumbraCos:{},decay:{}}},spotLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{}}},spotLightMap:{value:[]},spotShadowMap:{value:[]},spotLightMatrix:{value:[]},pointLights:{value:[],properties:{color:{},position:{},decay:{},distance:{}}},pointLightShadows:{value:[],properties:{shadowBias:{},shadowNormalBias:{},shadowRadius:{},shadowMapSize:{},shadowCameraNear:{},shadowCameraFar:{}}},pointShadowMap:{value:[]},pointShadowMatrix:{value:[]},hemisphereLights:{value:[],properties:{direction:{},skyColor:{},groundColor:{}}},rectAreaLights:{value:[],properties:{color:{},position:{},width:{},height:{}}},ltc_1:{value:null},ltc_2:{value:null}},points:{diffuse:{value:new Qe(16777215)},opacity:{value:1},size:{value:1},scale:{value:1},map:{value:null},alphaMap:{value:null},alphaMapTransform:{value:new $t},alphaTest:{value:0},uvTransform:{value:new $t}},sprite:{diffuse:{value:new Qe(16777215)},opacity:{value:1},center:{value:new Re(.5,.5)},rotation:{value:0},map:{value:null},mapTransform:{value:new $t},alphaMap:{value:null},alphaMapTransform:{value:new $t},alphaTest:{value:0}}},Bo={basic:{uniforms:Ii([Ye.common,Ye.specularmap,Ye.envmap,Ye.aomap,Ye.lightmap,Ye.fog]),vertexShader:Gt.meshbasic_vert,fragmentShader:Gt.meshbasic_frag},lambert:{uniforms:Ii([Ye.common,Ye.specularmap,Ye.envmap,Ye.aomap,Ye.lightmap,Ye.emissivemap,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.fog,Ye.lights,{emissive:{value:new Qe(0)}}]),vertexShader:Gt.meshlambert_vert,fragmentShader:Gt.meshlambert_frag},phong:{uniforms:Ii([Ye.common,Ye.specularmap,Ye.envmap,Ye.aomap,Ye.lightmap,Ye.emissivemap,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.fog,Ye.lights,{emissive:{value:new Qe(0)},specular:{value:new Qe(1118481)},shininess:{value:30}}]),vertexShader:Gt.meshphong_vert,fragmentShader:Gt.meshphong_frag},standard:{uniforms:Ii([Ye.common,Ye.envmap,Ye.aomap,Ye.lightmap,Ye.emissivemap,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.roughnessmap,Ye.metalnessmap,Ye.fog,Ye.lights,{emissive:{value:new Qe(0)},roughness:{value:1},metalness:{value:0},envMapIntensity:{value:1}}]),vertexShader:Gt.meshphysical_vert,fragmentShader:Gt.meshphysical_frag},toon:{uniforms:Ii([Ye.common,Ye.aomap,Ye.lightmap,Ye.emissivemap,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.gradientmap,Ye.fog,Ye.lights,{emissive:{value:new Qe(0)}}]),vertexShader:Gt.meshtoon_vert,fragmentShader:Gt.meshtoon_frag},matcap:{uniforms:Ii([Ye.common,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,Ye.fog,{matcap:{value:null}}]),vertexShader:Gt.meshmatcap_vert,fragmentShader:Gt.meshmatcap_frag},points:{uniforms:Ii([Ye.points,Ye.fog]),vertexShader:Gt.points_vert,fragmentShader:Gt.points_frag},dashed:{uniforms:Ii([Ye.common,Ye.fog,{scale:{value:1},dashSize:{value:1},totalSize:{value:2}}]),vertexShader:Gt.linedashed_vert,fragmentShader:Gt.linedashed_frag},depth:{uniforms:Ii([Ye.common,Ye.displacementmap]),vertexShader:Gt.depth_vert,fragmentShader:Gt.depth_frag},normal:{uniforms:Ii([Ye.common,Ye.bumpmap,Ye.normalmap,Ye.displacementmap,{opacity:{value:1}}]),vertexShader:Gt.meshnormal_vert,fragmentShader:Gt.meshnormal_frag},sprite:{uniforms:Ii([Ye.sprite,Ye.fog]),vertexShader:Gt.sprite_vert,fragmentShader:Gt.sprite_frag},background:{uniforms:{uvTransform:{value:new $t},t2D:{value:null},backgroundIntensity:{value:1}},vertexShader:Gt.background_vert,fragmentShader:Gt.background_frag},backgroundCube:{uniforms:{envMap:{value:null},flipEnvMap:{value:-1},backgroundBlurriness:{value:0},backgroundIntensity:{value:1},backgroundRotation:{value:new $t}},vertexShader:Gt.backgroundCube_vert,fragmentShader:Gt.backgroundCube_frag},cube:{uniforms:{tCube:{value:null},tFlip:{value:-1},opacity:{value:1}},vertexShader:Gt.cube_vert,fragmentShader:Gt.cube_frag},equirect:{uniforms:{tEquirect:{value:null}},vertexShader:Gt.equirect_vert,fragmentShader:Gt.equirect_frag},distanceRGBA:{uniforms:Ii([Ye.common,Ye.displacementmap,{referencePosition:{value:new K},nearDistance:{value:1},farDistance:{value:1e3}}]),vertexShader:Gt.distanceRGBA_vert,fragmentShader:Gt.distanceRGBA_frag},shadow:{uniforms:Ii([Ye.lights,Ye.fog,{color:{value:new Qe(0)},opacity:{value:1}}]),vertexShader:Gt.shadow_vert,fragmentShader:Gt.shadow_frag}};Bo.physical={uniforms:Ii([Bo.standard.uniforms,{clearcoat:{value:0},clearcoatMap:{value:null},clearcoatMapTransform:{value:new $t},clearcoatNormalMap:{value:null},clearcoatNormalMapTransform:{value:new $t},clearcoatNormalScale:{value:new Re(1,1)},clearcoatRoughness:{value:0},clearcoatRoughnessMap:{value:null},clearcoatRoughnessMapTransform:{value:new $t},iridescence:{value:0},iridescenceMap:{value:null},iridescenceMapTransform:{value:new $t},iridescenceIOR:{value:1.3},iridescenceThicknessMinimum:{value:100},iridescenceThicknessMaximum:{value:400},iridescenceThicknessMap:{value:null},iridescenceThicknessMapTransform:{value:new $t},sheen:{value:0},sheenColor:{value:new Qe(0)},sheenColorMap:{value:null},sheenColorMapTransform:{value:new $t},sheenRoughness:{value:1},sheenRoughnessMap:{value:null},sheenRoughnessMapTransform:{value:new $t},transmission:{value:0},transmissionMap:{value:null},transmissionMapTransform:{value:new $t},transmissionSamplerSize:{value:new Re},transmissionSamplerMap:{value:null},thickness:{value:0},thicknessMap:{value:null},thicknessMapTransform:{value:new $t},attenuationDistance:{value:0},attenuationColor:{value:new Qe(0)},specularColor:{value:new Qe(1,1,1)},specularColorMap:{value:null},specularColorMapTransform:{value:new $t},specularIntensity:{value:1},specularIntensityMap:{value:null},specularIntensityMapTransform:{value:new $t},anisotropyVector:{value:new Re},anisotropyMap:{value:null},anisotropyMapTransform:{value:new $t}}]),vertexShader:Gt.meshphysical_vert,fragmentShader:Gt.meshphysical_frag};const zv={r:0,b:0,g:0},su=new Is,Bde=new St;function Fde(t,e,n,r,i,s,o){const a=new Qe(0);let l=s===!0?0:1,c,u,d=null,f=0,h=null;function p(v,y){let b=!1,S=y.isScene===!0?y.background:null;S&&S.isTexture&&(S=(y.backgroundBlurriness>0?n:e).get(S)),S===null?x(a,l):S&&S.isColor&&(x(S,1),b=!0);const w=t.xr.getEnvironmentBlendMode();w==="additive"?r.buffers.color.setClear(0,0,0,1,o):w==="alpha-blend"&&r.buffers.color.setClear(0,0,0,0,o),(t.autoClear||b)&&t.clear(t.autoClearColor,t.autoClearDepth,t.autoClearStencil),S&&(S.isCubeTexture||S.mapping===yp)?(u===void 0&&(u=new lr(new Pd(1,1,1),new Ko({name:"BackgroundCubeMaterial",uniforms:Hh(Bo.backgroundCube.uniforms),vertexShader:Bo.backgroundCube.vertexShader,fragmentShader:Bo.backgroundCube.fragmentShader,side:Fi,depthTest:!1,depthWrite:!1,fog:!1})),u.geometry.deleteAttribute("normal"),u.geometry.deleteAttribute("uv"),u.onBeforeRender=function(E,A,T){this.matrixWorld.copyPosition(T.matrixWorld)},Object.defineProperty(u.material,"envMap",{get:function(){return this.uniforms.envMap.value}}),i.update(u)),su.copy(y.backgroundRotation),su.x*=-1,su.y*=-1,su.z*=-1,S.isCubeTexture&&S.isRenderTargetTexture===!1&&(su.y*=-1,su.z*=-1),u.material.uniforms.envMap.value=S,u.material.uniforms.flipEnvMap.value=S.isCubeTexture&&S.isRenderTargetTexture===!1?-1:1,u.material.uniforms.backgroundBlurriness.value=y.backgroundBlurriness,u.material.uniforms.backgroundIntensity.value=y.backgroundIntensity,u.material.uniforms.backgroundRotation.value.setFromMatrix4(Bde.makeRotationFromEuler(su)),u.material.toneMapped=gn.getTransfer(S.colorSpace)!==Tn,(d!==S||f!==S.version||h!==t.toneMapping)&&(u.material.needsUpdate=!0,d=S,f=S.version,h=t.toneMapping),u.layers.enableAll(),v.unshift(u,u.geometry,u.material,0,0,null)):S&&S.isTexture&&(c===void 0&&(c=new lr(new kd(2,2),new Ko({name:"BackgroundMaterial",uniforms:Hh(Bo.background.uniforms),vertexShader:Bo.background.vertexShader,fragmentShader:Bo.background.fragmentShader,side:Ia,depthTest:!1,depthWrite:!1,fog:!1})),c.geometry.deleteAttribute("normal"),Object.defineProperty(c.material,"map",{get:function(){return this.uniforms.t2D.value}}),i.update(c)),c.material.uniforms.t2D.value=S,c.material.uniforms.backgroundIntensity.value=y.backgroundIntensity,c.material.toneMapped=gn.getTransfer(S.colorSpace)!==Tn,S.matrixAutoUpdate===!0&&S.updateMatrix(),c.material.uniforms.uvTransform.value.copy(S.matrix),(d!==S||f!==S.version||h!==t.toneMapping)&&(c.material.needsUpdate=!0,d=S,f=S.version,h=t.toneMapping),c.layers.enableAll(),v.unshift(c,c.geometry,c.material,0,0,null))}function x(v,y){v.getRGB(zv,A5(t)),r.buffers.color.setClear(zv.r,zv.g,zv.b,y,o)}return{getClearColor:function(){return a},setClearColor:function(v,y=1){a.set(v),l=y,x(a,l)},getClearAlpha:function(){return l},setClearAlpha:function(v){l=v,x(a,l)},render:p}}function $de(t,e){const n=t.getParameter(t.MAX_VERTEX_ATTRIBS),r={},i=f(null);let s=i,o=!1;function a(M,P,B,F,U){let j=!1;const Z=d(F,B,P);s!==Z&&(s=Z,c(s.object)),j=h(M,F,B,U),j&&p(M,F,B,U),U!==null&&e.update(U,t.ELEMENT_ARRAY_BUFFER),(j||o)&&(o=!1,w(M,P,B,F),U!==null&&t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,e.get(U).buffer))}function l(){return t.createVertexArray()}function c(M){return t.bindVertexArray(M)}function u(M){return t.deleteVertexArray(M)}function d(M,P,B){const F=B.wireframe===!0;let U=r[M.id];U===void 0&&(U={},r[M.id]=U);let j=U[P.id];j===void 0&&(j={},U[P.id]=j);let Z=j[F];return Z===void 0&&(Z=f(l()),j[F]=Z),Z}function f(M){const P=[],B=[],F=[];for(let U=0;U<n;U++)P[U]=0,B[U]=0,F[U]=0;return{geometry:null,program:null,wireframe:!1,newAttributes:P,enabledAttributes:B,attributeDivisors:F,object:M,attributes:{},index:null}}function h(M,P,B,F){const U=s.attributes,j=P.attributes;let Z=0;const ne=B.getAttributes();for(const O in ne)if(ne[O].location>=0){const q=U[O];let se=j[O];if(se===void 0&&(O==="instanceMatrix"&&M.instanceMatrix&&(se=M.instanceMatrix),O==="instanceColor"&&M.instanceColor&&(se=M.instanceColor)),q===void 0||q.attribute!==se||se&&q.data!==se.data)return!0;Z++}return s.attributesNum!==Z||s.index!==F}function p(M,P,B,F){const U={},j=P.attributes;let Z=0;const ne=B.getAttributes();for(const O in ne)if(ne[O].location>=0){let q=j[O];q===void 0&&(O==="instanceMatrix"&&M.instanceMatrix&&(q=M.instanceMatrix),O==="instanceColor"&&M.instanceColor&&(q=M.instanceColor));const se={};se.attribute=q,q&&q.data&&(se.data=q.data),U[O]=se,Z++}s.attributes=U,s.attributesNum=Z,s.index=F}function x(){const M=s.newAttributes;for(let P=0,B=M.length;P<B;P++)M[P]=0}function v(M){y(M,0)}function y(M,P){const B=s.newAttributes,F=s.enabledAttributes,U=s.attributeDivisors;B[M]=1,F[M]===0&&(t.enableVertexAttribArray(M),F[M]=1),U[M]!==P&&(t.vertexAttribDivisor(M,P),U[M]=P)}function b(){const M=s.newAttributes,P=s.enabledAttributes;for(let B=0,F=P.length;B<F;B++)P[B]!==M[B]&&(t.disableVertexAttribArray(B),P[B]=0)}function S(M,P,B,F,U,j,Z){Z===!0?t.vertexAttribIPointer(M,P,B,U,j):t.vertexAttribPointer(M,P,B,F,U,j)}function w(M,P,B,F){x();const U=F.attributes,j=B.getAttributes(),Z=P.defaultAttributeValues;for(const ne in j){const O=j[ne];if(O.location>=0){let G=U[ne];if(G===void 0&&(ne==="instanceMatrix"&&M.instanceMatrix&&(G=M.instanceMatrix),ne==="instanceColor"&&M.instanceColor&&(G=M.instanceColor)),G!==void 0){const q=G.normalized,se=G.itemSize,he=e.get(G);if(he===void 0)continue;const ke=he.buffer,re=he.type,pe=he.bytesPerElement,fe=re===t.INT||re===t.UNSIGNED_INT||G.gpuType===yR;if(G.isInterleavedBufferAttribute){const Ee=G.data,We=Ee.stride,je=G.offset;if(Ee.isInstancedInterleavedBuffer){for(let Je=0;Je<O.locationSize;Je++)y(O.location+Je,Ee.meshPerAttribute);M.isInstancedMesh!==!0&&F._maxInstanceCount===void 0&&(F._maxInstanceCount=Ee.meshPerAttribute*Ee.count)}else for(let Je=0;Je<O.locationSize;Je++)v(O.location+Je);t.bindBuffer(t.ARRAY_BUFFER,ke);for(let Je=0;Je<O.locationSize;Je++)S(O.location+Je,se/O.locationSize,re,q,We*pe,(je+se/O.locationSize*Je)*pe,fe)}else{if(G.isInstancedBufferAttribute){for(let Ee=0;Ee<O.locationSize;Ee++)y(O.location+Ee,G.meshPerAttribute);M.isInstancedMesh!==!0&&F._maxInstanceCount===void 0&&(F._maxInstanceCount=G.meshPerAttribute*G.count)}else for(let Ee=0;Ee<O.locationSize;Ee++)v(O.location+Ee);t.bindBuffer(t.ARRAY_BUFFER,ke);for(let Ee=0;Ee<O.locationSize;Ee++)S(O.location+Ee,se/O.locationSize,re,q,se*pe,se/O.locationSize*Ee*pe,fe)}}else if(Z!==void 0){const q=Z[ne];if(q!==void 0)switch(q.length){case 2:t.vertexAttrib2fv(O.location,q);break;case 3:t.vertexAttrib3fv(O.location,q);break;case 4:t.vertexAttrib4fv(O.location,q);break;default:t.vertexAttrib1fv(O.location,q)}}}}b()}function E(){I();for(const M in r){const P=r[M];for(const B in P){const F=P[B];for(const U in F)u(F[U].object),delete F[U];delete P[B]}delete r[M]}}function A(M){if(r[M.id]===void 0)return;const P=r[M.id];for(const B in P){const F=P[B];for(const U in F)u(F[U].object),delete F[U];delete P[B]}delete r[M.id]}function T(M){for(const P in r){const B=r[P];if(B[M.id]===void 0)continue;const F=B[M.id];for(const U in F)u(F[U].object),delete F[U];delete B[M.id]}}function I(){N(),o=!0,s!==i&&(s=i,c(s.object))}function N(){i.geometry=null,i.program=null,i.wireframe=!1}return{setup:a,reset:I,resetDefaultState:N,dispose:E,releaseStatesOfGeometry:A,releaseStatesOfProgram:T,initAttributes:x,enableAttribute:v,disableUnusedAttributes:b}}function Ude(t,e,n){let r;function i(l){r=l}function s(l,c){t.drawArrays(r,l,c),n.update(c,r,1)}function o(l,c,u){u!==0&&(t.drawArraysInstanced(r,l,c,u),n.update(c,r,u))}function a(l,c,u){if(u===0)return;const d=e.get("WEBGL_multi_draw");if(d===null)for(let f=0;f<u;f++)this.render(l[f],c[f]);else{d.multiDrawArraysWEBGL(r,l,0,c,0,u);let f=0;for(let h=0;h<u;h++)f+=c[h];n.update(f,r,1)}}this.setMode=i,this.render=s,this.renderInstances=o,this.renderMultiDraw=a}function zde(t,e,n){let r;function i(){if(r!==void 0)return r;if(e.has("EXT_texture_filter_anisotropic")===!0){const S=e.get("EXT_texture_filter_anisotropic");r=t.getParameter(S.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else r=0;return r}function s(S){if(S==="highp"){if(t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.HIGH_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.HIGH_FLOAT).precision>0)return"highp";S="mediump"}return S==="mediump"&&t.getShaderPrecisionFormat(t.VERTEX_SHADER,t.MEDIUM_FLOAT).precision>0&&t.getShaderPrecisionFormat(t.FRAGMENT_SHADER,t.MEDIUM_FLOAT).precision>0?"mediump":"lowp"}let o=n.precision!==void 0?n.precision:"highp";const a=s(o);a!==o&&(console.warn("THREE.WebGLRenderer:",o,"not supported, using",a,"instead."),o=a);const l=n.logarithmicDepthBuffer===!0,c=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS),u=t.getParameter(t.MAX_VERTEX_TEXTURE_IMAGE_UNITS),d=t.getParameter(t.MAX_TEXTURE_SIZE),f=t.getParameter(t.MAX_CUBE_MAP_TEXTURE_SIZE),h=t.getParameter(t.MAX_VERTEX_ATTRIBS),p=t.getParameter(t.MAX_VERTEX_UNIFORM_VECTORS),x=t.getParameter(t.MAX_VARYING_VECTORS),v=t.getParameter(t.MAX_FRAGMENT_UNIFORM_VECTORS),y=u>0,b=t.getParameter(t.MAX_SAMPLES);return{isWebGL2:!0,getMaxAnisotropy:i,getMaxPrecision:s,precision:o,logarithmicDepthBuffer:l,maxTextures:c,maxVertexTextures:u,maxTextureSize:d,maxCubemapSize:f,maxAttributes:h,maxVertexUniforms:p,maxVaryings:x,maxFragmentUniforms:v,vertexTextures:y,maxSamples:b}}function Gde(t){const e=this;let n=null,r=0,i=!1,s=!1;const o=new Ya,a=new $t,l={value:null,needsUpdate:!1};this.uniform=l,this.numPlanes=0,this.numIntersection=0,this.init=function(d,f){const h=d.length!==0||f||r!==0||i;return i=f,r=d.length,h},this.beginShadows=function(){s=!0,u(null)},this.endShadows=function(){s=!1},this.setGlobalState=function(d,f){n=u(d,f,0)},this.setState=function(d,f,h){const p=d.clippingPlanes,x=d.clipIntersection,v=d.clipShadows,y=t.get(d);if(!i||p===null||p.length===0||s&&!v)s?u(null):c();else{const b=s?0:r,S=b*4;let w=y.clippingState||null;l.value=w,w=u(p,f,S,h);for(let E=0;E!==S;++E)w[E]=n[E];y.clippingState=w,this.numIntersection=x?this.numPlanes:0,this.numPlanes+=b}};function c(){l.value!==n&&(l.value=n,l.needsUpdate=r>0),e.numPlanes=r,e.numIntersection=0}function u(d,f,h,p){const x=d!==null?d.length:0;let v=null;if(x!==0){if(v=l.value,p!==!0||v===null){const y=h+x*4,b=f.matrixWorldInverse;a.getNormalMatrix(b),(v===null||v.length<y)&&(v=new Float32Array(y));for(let S=0,w=h;S!==x;++S,w+=4)o.copy(d[S]).applyMatrix4(b,a),o.normal.toArray(v,w),v[w+3]=o.constant}l.value=v,l.needsUpdate=!0}return e.numPlanes=x,e.numIntersection=0,v}}function Hde(t){let e=new WeakMap;function n(o,a){return a===Og?o.mapping=xl:a===Lg&&(o.mapping=Ac),o}function r(o){if(o&&o.isTexture){const a=o.mapping;if(a===Og||a===Lg)if(e.has(o)){const l=e.get(o).texture;return n(l,o.mapping)}else{const l=o.image;if(l&&l.height>0){const c=new R5(l.height);return c.fromEquirectangularTexture(t,o),e.set(o,c),o.addEventListener("dispose",i),n(c.texture,o.mapping)}else return null}}return o}function i(o){const a=o.target;a.removeEventListener("dispose",i);const l=e.get(a);l!==void 0&&(e.delete(a),l.dispose())}function s(){e=new WeakMap}return{get:r,dispose:s}}class ba extends T0{constructor(e=-1,n=1,r=1,i=-1,s=.1,o=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=e,this.right=n,this.top=r,this.bottom=i,this.near=s,this.far=o,this.updateProjectionMatrix()}copy(e,n){return super.copy(e,n),this.left=e.left,this.right=e.right,this.top=e.top,this.bottom=e.bottom,this.near=e.near,this.far=e.far,this.zoom=e.zoom,this.view=e.view===null?null:Object.assign({},e.view),this}setViewOffset(e,n,r,i,s,o){this.view===null&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=e,this.view.fullHeight=n,this.view.offsetX=r,this.view.offsetY=i,this.view.width=s,this.view.height=o,this.updateProjectionMatrix()}clearViewOffset(){this.view!==null&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const e=(this.right-this.left)/(2*this.zoom),n=(this.top-this.bottom)/(2*this.zoom),r=(this.right+this.left)/2,i=(this.top+this.bottom)/2;let s=r-e,o=r+e,a=i+n,l=i-n;if(this.view!==null&&this.view.enabled){const c=(this.right-this.left)/this.view.fullWidth/this.zoom,u=(this.top-this.bottom)/this.view.fullHeight/this.zoom;s+=c*this.view.offsetX,o=s+c*this.view.width,a-=u*this.view.offsetY,l=a-u*this.view.height}this.projectionMatrix.makeOrthographic(s,o,a,l,this.near,this.far,this.coordinateSystem),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(e){const n=super.toJSON(e);return n.object.zoom=this.zoom,n.object.left=this.left,n.object.right=this.right,n.object.top=this.top,n.object.bottom=this.bottom,n.object.near=this.near,n.object.far=this.far,this.view!==null&&(n.object.view=Object.assign({},this.view)),n}}const ah=4,YD=[.125,.215,.35,.446,.526,.582],Au=20,HC=new ba,QD=new Qe;let VC=null,WC=0,jC=0,XC=!1;const wu=(1+Math.sqrt(5))/2,Af=1/wu,ZD=[new K(1,1,1),new K(-1,1,1),new K(1,1,-1),new K(-1,1,-1),new K(0,wu,Af),new K(0,wu,-Af),new K(Af,0,wu),new K(-Af,0,wu),new K(wu,Af,0),new K(-wu,Af,0)];class D2{constructor(e){this._renderer=e,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._lodPlanes=[],this._sizeLods=[],this._sigmas=[],this._blurMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._compileMaterial(this._blurMaterial)}fromScene(e,n=0,r=.1,i=100){VC=this._renderer.getRenderTarget(),WC=this._renderer.getActiveCubeFace(),jC=this._renderer.getActiveMipmapLevel(),XC=this._renderer.xr.enabled,this._renderer.xr.enabled=!1,this._setSize(256);const s=this._allocateTargets();return s.depthBuffer=!0,this._sceneToCubeUV(e,r,i,s),n>0&&this._blur(s,0,0,n),this._applyPMREM(s),this._cleanup(s),s}fromEquirectangular(e,n=null){return this._fromTexture(e,n)}fromCubemap(e,n=null){return this._fromTexture(e,n)}compileCubemapShader(){this._cubemapMaterial===null&&(this._cubemapMaterial=nO(),this._compileMaterial(this._cubemapMaterial))}compileEquirectangularShader(){this._equirectMaterial===null&&(this._equirectMaterial=tO(),this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),this._cubemapMaterial!==null&&this._cubemapMaterial.dispose(),this._equirectMaterial!==null&&this._equirectMaterial.dispose()}_setSize(e){this._lodMax=Math.floor(Math.log2(e)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){this._blurMaterial!==null&&this._blurMaterial.dispose(),this._pingPongRenderTarget!==null&&this._pingPongRenderTarget.dispose();for(let e=0;e<this._lodPlanes.length;e++)this._lodPlanes[e].dispose()}_cleanup(e){this._renderer.setRenderTarget(VC,WC,jC),this._renderer.xr.enabled=XC,e.scissorTest=!1,Gv(e,0,0,e.width,e.height)}_fromTexture(e,n){e.mapping===xl||e.mapping===Ac?this._setSize(e.image.length===0?16:e.image[0].width||e.image[0].image.width):this._setSize(e.image.width/4),VC=this._renderer.getRenderTarget(),WC=this._renderer.getActiveCubeFace(),jC=this._renderer.getActiveMipmapLevel(),XC=this._renderer.xr.enabled,this._renderer.xr.enabled=!1;const r=n||this._allocateTargets();return this._textureToCubeUV(e,r),this._applyPMREM(r),this._cleanup(r),r}_allocateTargets(){const e=3*Math.max(this._cubeSize,112),n=4*this._cubeSize,r={magFilter:or,minFilter:or,generateMipmaps:!1,type:Bg,format:Yi,colorSpace:Ml,depthBuffer:!1},i=eO(e,n,r);if(this._pingPongRenderTarget===null||this._pingPongRenderTarget.width!==e||this._pingPongRenderTarget.height!==n){this._pingPongRenderTarget!==null&&this._dispose(),this._pingPongRenderTarget=eO(e,n,r);const{_lodMax:s}=this;({sizeLods:this._sizeLods,lodPlanes:this._lodPlanes,sigmas:this._sigmas}=Vde(s)),this._blurMaterial=Wde(s,e,n)}return i}_compileMaterial(e){const n=new lr(this._lodPlanes[0],e);this._renderer.compile(n,HC)}_sceneToCubeUV(e,n,r,i){const a=new Hn(90,1,n,r),l=[1,-1,1,1,1,1],c=[1,1,1,-1,-1,-1],u=this._renderer,d=u.autoClear,f=u.toneMapping;u.getClearColor(QD),u.toneMapping=Ca,u.autoClear=!1;const h=new Qi({name:"PMREM.Background",side:Fi,depthWrite:!1,depthTest:!1}),p=new lr(new Pd,h);let x=!1;const v=e.background;v?v.isColor&&(h.color.copy(v),e.background=null,x=!0):(h.color.copy(QD),x=!0);for(let y=0;y<6;y++){const b=y%3;b===0?(a.up.set(0,l[y],0),a.lookAt(c[y],0,0)):b===1?(a.up.set(0,0,l[y]),a.lookAt(0,c[y],0)):(a.up.set(0,l[y],0),a.lookAt(0,0,c[y]));const S=this._cubeSize;Gv(i,b*S,y>2?S:0,S,S),u.setRenderTarget(i),x&&u.render(p,a),u.render(e,a)}p.geometry.dispose(),p.material.dispose(),u.toneMapping=f,u.autoClear=d,e.background=v}_textureToCubeUV(e,n){const r=this._renderer,i=e.mapping===xl||e.mapping===Ac;i?(this._cubemapMaterial===null&&(this._cubemapMaterial=nO()),this._cubemapMaterial.uniforms.flipEnvMap.value=e.isRenderTargetTexture===!1?-1:1):this._equirectMaterial===null&&(this._equirectMaterial=tO());const s=i?this._cubemapMaterial:this._equirectMaterial,o=new lr(this._lodPlanes[0],s),a=s.uniforms;a.envMap.value=e;const l=this._cubeSize;Gv(n,0,0,3*l,2*l),r.setRenderTarget(n),r.render(o,HC)}_applyPMREM(e){const n=this._renderer,r=n.autoClear;n.autoClear=!1;for(let i=1;i<this._lodPlanes.length;i++){const s=Math.sqrt(this._sigmas[i]*this._sigmas[i]-this._sigmas[i-1]*this._sigmas[i-1]),o=ZD[(i-1)%ZD.length];this._blur(e,i-1,i,s,o)}n.autoClear=r}_blur(e,n,r,i,s){const o=this._pingPongRenderTarget;this._halfBlur(e,o,n,r,i,"latitudinal",s),this._halfBlur(o,e,r,r,i,"longitudinal",s)}_halfBlur(e,n,r,i,s,o,a){const l=this._renderer,c=this._blurMaterial;o!=="latitudinal"&&o!=="longitudinal"&&console.error("blur direction must be either latitudinal or longitudinal!");const u=3,d=new lr(this._lodPlanes[i],c),f=c.uniforms,h=this._sizeLods[r]-1,p=isFinite(s)?Math.PI/(2*h):2*Math.PI/(2*Au-1),x=s/p,v=isFinite(s)?1+Math.floor(u*x):Au;v>Au&&console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${Au}`);const y=[];let b=0;for(let T=0;T<Au;++T){const I=T/x,N=Math.exp(-I*I/2);y.push(N),T===0?b+=N:T<v&&(b+=2*N)}for(let T=0;T<y.length;T++)y[T]=y[T]/b;f.envMap.value=e.texture,f.samples.value=v,f.weights.value=y,f.latitudinal.value=o==="latitudinal",a&&(f.poleAxis.value=a);const{_lodMax:S}=this;f.dTheta.value=p,f.mipInt.value=S-r;const w=this._sizeLods[i],E=3*w*(i>S-ah?i-S+ah:0),A=4*(this._cubeSize-w);Gv(n,E,A,3*w,2*w),l.setRenderTarget(n),l.render(d,HC)}}function Vde(t){const e=[],n=[],r=[];let i=t;const s=t-ah+1+YD.length;for(let o=0;o<s;o++){const a=Math.pow(2,i);n.push(a);let l=1/a;o>t-ah?l=YD[o-t+ah-1]:o===0&&(l=0),r.push(l);const c=1/(a-2),u=-c,d=1+c,f=[u,u,d,u,d,d,u,u,d,d,u,d],h=6,p=6,x=3,v=2,y=1,b=new Float32Array(x*p*h),S=new Float32Array(v*p*h),w=new Float32Array(y*p*h);for(let A=0;A<h;A++){const T=A%3*2/3-1,I=A>2?0:-1,N=[T,I,0,T+2/3,I,0,T+2/3,I+1,0,T,I,0,T+2/3,I+1,0,T,I+1,0];b.set(N,x*p*A),S.set(f,v*p*A);const M=[A,A,A,A,A,A];w.set(M,y*p*A)}const E=new Lt;E.setAttribute("position",new en(b,x)),E.setAttribute("uv",new en(S,v)),E.setAttribute("faceIndex",new en(w,y)),e.push(E),i>ah&&i--}return{lodPlanes:e,sizeLods:n,sigmas:r}}function eO(t,e,n){const r=new Xo(t,e,n);return r.texture.mapping=yp,r.texture.name="PMREM.cubeUv",r.scissorTest=!0,r}function Gv(t,e,n,r,i){t.viewport.set(e,n,r,i),t.scissor.set(e,n,r,i)}function Wde(t,e,n){const r=new Float32Array(Au),i=new K(0,1,0);return new Ko({name:"SphericalGaussianBlur",defines:{n:Au,CUBEUV_TEXEL_WIDTH:1/e,CUBEUV_TEXEL_HEIGHT:1/n,CUBEUV_MAX_MIP:`${t}.0`},uniforms:{envMap:{value:null},samples:{value:1},weights:{value:r},latitudinal:{value:!1},dTheta:{value:0},mipInt:{value:0},poleAxis:{value:i}},vertexShader:PR(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,blending:cl,depthTest:!1,depthWrite:!1})}function tO(){return new Ko({name:"EquirectangularToCubeUV",uniforms:{envMap:{value:null}},vertexShader:PR(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,blending:cl,depthTest:!1,depthWrite:!1})}function nO(){return new Ko({name:"CubemapToCubeUV",uniforms:{envMap:{value:null},flipEnvMap:{value:-1}},vertexShader:PR(),fragmentShader:`

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,blending:cl,depthTest:!1,depthWrite:!1})}function PR(){return`

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`}function jde(t){let e=new WeakMap,n=null;function r(a){if(a&&a.isTexture){const l=a.mapping,c=l===Og||l===Lg,u=l===xl||l===Ac;if(c||u){let d=e.get(a);const f=d!==void 0?d.texture.pmremVersion:0;if(a.isRenderTargetTexture&&a.pmremVersion!==f)return n===null&&(n=new D2(t)),d=c?n.fromEquirectangular(a,d):n.fromCubemap(a,d),d.texture.pmremVersion=a.pmremVersion,e.set(a,d),d.texture;if(d!==void 0)return d.texture;{const h=a.image;return c&&h&&h.height>0||u&&h&&i(h)?(n===null&&(n=new D2(t)),d=c?n.fromEquirectangular(a):n.fromCubemap(a),d.texture.pmremVersion=a.pmremVersion,e.set(a,d),a.addEventListener("dispose",s),d.texture):null}}}return a}function i(a){let l=0;const c=6;for(let u=0;u<c;u++)a[u]!==void 0&&l++;return l===c}function s(a){const l=a.target;l.removeEventListener("dispose",s);const c=e.get(l);c!==void 0&&(e.delete(l),c.dispose())}function o(){e=new WeakMap,n!==null&&(n.dispose(),n=null)}return{get:r,dispose:o}}function Xde(t){const e={};function n(r){if(e[r]!==void 0)return e[r];let i;switch(r){case"WEBGL_depth_texture":i=t.getExtension("WEBGL_depth_texture")||t.getExtension("MOZ_WEBGL_depth_texture")||t.getExtension("WEBKIT_WEBGL_depth_texture");break;case"EXT_texture_filter_anisotropic":i=t.getExtension("EXT_texture_filter_anisotropic")||t.getExtension("MOZ_EXT_texture_filter_anisotropic")||t.getExtension("WEBKIT_EXT_texture_filter_anisotropic");break;case"WEBGL_compressed_texture_s3tc":i=t.getExtension("WEBGL_compressed_texture_s3tc")||t.getExtension("MOZ_WEBGL_compressed_texture_s3tc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");break;case"WEBGL_compressed_texture_pvrtc":i=t.getExtension("WEBGL_compressed_texture_pvrtc")||t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");break;default:i=t.getExtension(r)}return e[r]=i,i}return{has:function(r){return n(r)!==null},init:function(){n("EXT_color_buffer_float"),n("WEBGL_clip_cull_distance"),n("OES_texture_float_linear"),n("EXT_color_buffer_half_float"),n("WEBGL_multisampled_render_to_texture"),n("WEBGL_render_shared_exponent")},get:function(r){const i=n(r);return i===null&&console.warn("THREE.WebGLRenderer: "+r+" extension not supported."),i}}}function Kde(t,e,n,r){const i={},s=new WeakMap;function o(d){const f=d.target;f.index!==null&&e.remove(f.index);for(const p in f.attributes)e.remove(f.attributes[p]);for(const p in f.morphAttributes){const x=f.morphAttributes[p];for(let v=0,y=x.length;v<y;v++)e.remove(x[v])}f.removeEventListener("dispose",o),delete i[f.id];const h=s.get(f);h&&(e.remove(h),s.delete(f)),r.releaseStatesOfGeometry(f),f.isInstancedBufferGeometry===!0&&delete f._maxInstanceCount,n.memory.geometries--}function a(d,f){return i[f.id]===!0||(f.addEventListener("dispose",o),i[f.id]=!0,n.memory.geometries++),f}function l(d){const f=d.attributes;for(const p in f)e.update(f[p],t.ARRAY_BUFFER);const h=d.morphAttributes;for(const p in h){const x=h[p];for(let v=0,y=x.length;v<y;v++)e.update(x[v],t.ARRAY_BUFFER)}}function c(d){const f=[],h=d.index,p=d.attributes.position;let x=0;if(h!==null){const b=h.array;x=h.version;for(let S=0,w=b.length;S<w;S+=3){const E=b[S+0],A=b[S+1],T=b[S+2];f.push(E,A,A,T,T,E)}}else if(p!==void 0){const b=p.array;x=p.version;for(let S=0,w=b.length/3-1;S<w;S+=3){const E=S+0,A=S+1,T=S+2;f.push(E,A,A,T,T,E)}}else return;const v=new(b5(f)?NR:IR)(f,1);v.version=x;const y=s.get(d);y&&e.remove(y),s.set(d,v)}function u(d){const f=s.get(d);if(f){const h=d.index;h!==null&&f.version<h.version&&c(d)}else c(d);return s.get(d)}return{get:a,update:l,getWireframeAttribute:u}}function qde(t,e,n){let r;function i(d){r=d}let s,o;function a(d){s=d.type,o=d.bytesPerElement}function l(d,f){t.drawElements(r,f,s,d*o),n.update(f,r,1)}function c(d,f,h){h!==0&&(t.drawElementsInstanced(r,f,s,d*o,h),n.update(f,r,h))}function u(d,f,h){if(h===0)return;const p=e.get("WEBGL_multi_draw");if(p===null)for(let x=0;x<h;x++)this.render(d[x]/o,f[x]);else{p.multiDrawElementsWEBGL(r,f,0,s,d,0,h);let x=0;for(let v=0;v<h;v++)x+=f[v];n.update(x,r,1)}}this.setMode=i,this.setIndex=a,this.render=l,this.renderInstances=c,this.renderMultiDraw=u}function Jde(t){const e={geometries:0,textures:0},n={frame:0,calls:0,triangles:0,points:0,lines:0};function r(s,o,a){switch(n.calls++,o){case t.TRIANGLES:n.triangles+=a*(s/3);break;case t.LINES:n.lines+=a*(s/2);break;case t.LINE_STRIP:n.lines+=a*(s-1);break;case t.LINE_LOOP:n.lines+=a*s;break;case t.POINTS:n.points+=a*s;break;default:console.error("THREE.WebGLInfo: Unknown draw mode:",o);break}}function i(){n.calls=0,n.triangles=0,n.points=0,n.lines=0}return{memory:e,render:n,programs:null,autoReset:!0,reset:i,update:r}}function Yde(t,e,n){const r=new WeakMap,i=new vn;function s(o,a,l){const c=o.morphTargetInfluences,u=a.morphAttributes.position||a.morphAttributes.normal||a.morphAttributes.color,d=u!==void 0?u.length:0;let f=r.get(a);if(f===void 0||f.count!==d){let N=function(){T.dispose(),r.delete(a),a.removeEventListener("dispose",N)};f!==void 0&&f.texture.dispose();const h=a.morphAttributes.position!==void 0,p=a.morphAttributes.normal!==void 0,x=a.morphAttributes.color!==void 0,v=a.morphAttributes.position||[],y=a.morphAttributes.normal||[],b=a.morphAttributes.color||[];let S=0;h===!0&&(S=1),p===!0&&(S=2),x===!0&&(S=3);let w=a.attributes.position.count*S,E=1;w>e.maxTextureSize&&(E=Math.ceil(w/e.maxTextureSize),w=e.maxTextureSize);const A=new Float32Array(w*E*4*d),T=new RS(A,w,E,d);T.type=lo,T.needsUpdate=!0;const I=S*4;for(let M=0;M<d;M++){const P=v[M],B=y[M],F=b[M],U=w*E*4*M;for(let j=0;j<P.count;j++){const Z=j*I;h===!0&&(i.fromBufferAttribute(P,j),A[U+Z+0]=i.x,A[U+Z+1]=i.y,A[U+Z+2]=i.z,A[U+Z+3]=0),p===!0&&(i.fromBufferAttribute(B,j),A[U+Z+4]=i.x,A[U+Z+5]=i.y,A[U+Z+6]=i.z,A[U+Z+7]=0),x===!0&&(i.fromBufferAttribute(F,j),A[U+Z+8]=i.x,A[U+Z+9]=i.y,A[U+Z+10]=i.z,A[U+Z+11]=F.itemSize===4?i.w:1)}}f={count:d,texture:T,size:new Re(w,E)},r.set(a,f),a.addEventListener("dispose",N)}if(o.isInstancedMesh===!0&&o.morphTexture!==null)l.getUniforms().setValue(t,"morphTexture",o.morphTexture,n);else{let h=0;for(let x=0;x<c.length;x++)h+=c[x];const p=a.morphTargetsRelative?1:1-h;l.getUniforms().setValue(t,"morphTargetBaseInfluence",p),l.getUniforms().setValue(t,"morphTargetInfluences",c)}l.getUniforms().setValue(t,"morphTargetsTexture",f.texture,n),l.getUniforms().setValue(t,"morphTargetsTextureSize",f.size)}return{update:s}}function Qde(t,e,n,r){let i=new WeakMap;function s(l){const c=r.render.frame,u=l.geometry,d=e.get(l,u);if(i.get(d)!==c&&(e.update(d),i.set(d,c)),l.isInstancedMesh&&(l.hasEventListener("dispose",a)===!1&&l.addEventListener("dispose",a),i.get(l)!==c&&(n.update(l.instanceMatrix,t.ARRAY_BUFFER),l.instanceColor!==null&&n.update(l.instanceColor,t.ARRAY_BUFFER),i.set(l,c))),l.isSkinnedMesh){const f=l.skeleton;i.get(f)!==c&&(f.update(),i.set(f,c))}return d}function o(){i=new WeakMap}function a(l){const c=l.target;c.removeEventListener("dispose",a),n.remove(c.instanceMatrix),c.instanceColor!==null&&n.remove(c.instanceColor)}return{update:s,dispose:o}}class kR extends Bn{constructor(e,n,r,i,s,o,a,l,c,u){if(u=u!==void 0?u:Ju,u!==Ju&&u!==Uh)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");r===void 0&&u===Ju&&(r=pd),r===void 0&&u===Uh&&(r=vp),super(null,i,s,o,a,l,u,r,c),this.isDepthTexture=!0,this.image={width:e,height:n},this.magFilter=a!==void 0?a:Nr,this.minFilter=l!==void 0?l:Nr,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(e){return super.copy(e),this.compareFunction=e.compareFunction,this}toJSON(e){const n=super.toJSON(e);return this.compareFunction!==null&&(n.compareFunction=this.compareFunction),n}}const N5=new Bn,P5=new kR(1,1);P5.compareFunction=TR;const k5=new RS,D5=new RR,O5=new M0,rO=[],iO=[],sO=new Float32Array(16),oO=new Float32Array(9),aO=new Float32Array(4);function xp(t,e,n){const r=t[0];if(r<=0||r>0)return t;const i=e*n;let s=rO[i];if(s===void 0&&(s=new Float32Array(i),rO[i]=s),e!==0){r.toArray(s,0);for(let o=1,a=0;o!==e;++o)a+=n,t[o].toArray(s,a)}return s}function Pr(t,e){if(t.length!==e.length)return!1;for(let n=0,r=t.length;n<r;n++)if(t[n]!==e[n])return!1;return!0}function kr(t,e){for(let n=0,r=e.length;n<r;n++)t[n]=e[n]}function IS(t,e){let n=iO[e];n===void 0&&(n=new Int32Array(e),iO[e]=n);for(let r=0;r!==e;++r)n[r]=t.allocateTextureUnit();return n}function Zde(t,e){const n=this.cache;n[0]!==e&&(t.uniform1f(this.addr,e),n[0]=e)}function efe(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y)&&(t.uniform2f(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Pr(n,e))return;t.uniform2fv(this.addr,e),kr(n,e)}}function tfe(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z)&&(t.uniform3f(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else if(e.r!==void 0)(n[0]!==e.r||n[1]!==e.g||n[2]!==e.b)&&(t.uniform3f(this.addr,e.r,e.g,e.b),n[0]=e.r,n[1]=e.g,n[2]=e.b);else{if(Pr(n,e))return;t.uniform3fv(this.addr,e),kr(n,e)}}function nfe(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z||n[3]!==e.w)&&(t.uniform4f(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Pr(n,e))return;t.uniform4fv(this.addr,e),kr(n,e)}}function rfe(t,e){const n=this.cache,r=e.elements;if(r===void 0){if(Pr(n,e))return;t.uniformMatrix2fv(this.addr,!1,e),kr(n,e)}else{if(Pr(n,r))return;aO.set(r),t.uniformMatrix2fv(this.addr,!1,aO),kr(n,r)}}function ife(t,e){const n=this.cache,r=e.elements;if(r===void 0){if(Pr(n,e))return;t.uniformMatrix3fv(this.addr,!1,e),kr(n,e)}else{if(Pr(n,r))return;oO.set(r),t.uniformMatrix3fv(this.addr,!1,oO),kr(n,r)}}function sfe(t,e){const n=this.cache,r=e.elements;if(r===void 0){if(Pr(n,e))return;t.uniformMatrix4fv(this.addr,!1,e),kr(n,e)}else{if(Pr(n,r))return;sO.set(r),t.uniformMatrix4fv(this.addr,!1,sO),kr(n,r)}}function ofe(t,e){const n=this.cache;n[0]!==e&&(t.uniform1i(this.addr,e),n[0]=e)}function afe(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y)&&(t.uniform2i(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Pr(n,e))return;t.uniform2iv(this.addr,e),kr(n,e)}}function lfe(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z)&&(t.uniform3i(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(Pr(n,e))return;t.uniform3iv(this.addr,e),kr(n,e)}}function cfe(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z||n[3]!==e.w)&&(t.uniform4i(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Pr(n,e))return;t.uniform4iv(this.addr,e),kr(n,e)}}function ufe(t,e){const n=this.cache;n[0]!==e&&(t.uniform1ui(this.addr,e),n[0]=e)}function dfe(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y)&&(t.uniform2ui(this.addr,e.x,e.y),n[0]=e.x,n[1]=e.y);else{if(Pr(n,e))return;t.uniform2uiv(this.addr,e),kr(n,e)}}function ffe(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z)&&(t.uniform3ui(this.addr,e.x,e.y,e.z),n[0]=e.x,n[1]=e.y,n[2]=e.z);else{if(Pr(n,e))return;t.uniform3uiv(this.addr,e),kr(n,e)}}function hfe(t,e){const n=this.cache;if(e.x!==void 0)(n[0]!==e.x||n[1]!==e.y||n[2]!==e.z||n[3]!==e.w)&&(t.uniform4ui(this.addr,e.x,e.y,e.z,e.w),n[0]=e.x,n[1]=e.y,n[2]=e.z,n[3]=e.w);else{if(Pr(n,e))return;t.uniform4uiv(this.addr,e),kr(n,e)}}function pfe(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i);const s=this.type===t.SAMPLER_2D_SHADOW?P5:N5;n.setTexture2D(e||s,i)}function mfe(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTexture3D(e||D5,i)}function gfe(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTextureCube(e||O5,i)}function yfe(t,e,n){const r=this.cache,i=n.allocateTextureUnit();r[0]!==i&&(t.uniform1i(this.addr,i),r[0]=i),n.setTexture2DArray(e||k5,i)}function vfe(t){switch(t){case 5126:return Zde;case 35664:return efe;case 35665:return tfe;case 35666:return nfe;case 35674:return rfe;case 35675:return ife;case 35676:return sfe;case 5124:case 35670:return ofe;case 35667:case 35671:return afe;case 35668:case 35672:return lfe;case 35669:case 35673:return cfe;case 5125:return ufe;case 36294:return dfe;case 36295:return ffe;case 36296:return hfe;case 35678:case 36198:case 36298:case 36306:case 35682:return pfe;case 35679:case 36299:case 36307:return mfe;case 35680:case 36300:case 36308:case 36293:return gfe;case 36289:case 36303:case 36311:case 36292:return yfe}}function xfe(t,e){t.uniform1fv(this.addr,e)}function bfe(t,e){const n=xp(e,this.size,2);t.uniform2fv(this.addr,n)}function Sfe(t,e){const n=xp(e,this.size,3);t.uniform3fv(this.addr,n)}function _fe(t,e){const n=xp(e,this.size,4);t.uniform4fv(this.addr,n)}function wfe(t,e){const n=xp(e,this.size,4);t.uniformMatrix2fv(this.addr,!1,n)}function Cfe(t,e){const n=xp(e,this.size,9);t.uniformMatrix3fv(this.addr,!1,n)}function Efe(t,e){const n=xp(e,this.size,16);t.uniformMatrix4fv(this.addr,!1,n)}function Afe(t,e){t.uniform1iv(this.addr,e)}function Tfe(t,e){t.uniform2iv(this.addr,e)}function Mfe(t,e){t.uniform3iv(this.addr,e)}function Rfe(t,e){t.uniform4iv(this.addr,e)}function Ife(t,e){t.uniform1uiv(this.addr,e)}function Nfe(t,e){t.uniform2uiv(this.addr,e)}function Pfe(t,e){t.uniform3uiv(this.addr,e)}function kfe(t,e){t.uniform4uiv(this.addr,e)}function Dfe(t,e,n){const r=this.cache,i=e.length,s=IS(n,i);Pr(r,s)||(t.uniform1iv(this.addr,s),kr(r,s));for(let o=0;o!==i;++o)n.setTexture2D(e[o]||N5,s[o])}function Ofe(t,e,n){const r=this.cache,i=e.length,s=IS(n,i);Pr(r,s)||(t.uniform1iv(this.addr,s),kr(r,s));for(let o=0;o!==i;++o)n.setTexture3D(e[o]||D5,s[o])}function Lfe(t,e,n){const r=this.cache,i=e.length,s=IS(n,i);Pr(r,s)||(t.uniform1iv(this.addr,s),kr(r,s));for(let o=0;o!==i;++o)n.setTextureCube(e[o]||O5,s[o])}function Bfe(t,e,n){const r=this.cache,i=e.length,s=IS(n,i);Pr(r,s)||(t.uniform1iv(this.addr,s),kr(r,s));for(let o=0;o!==i;++o)n.setTexture2DArray(e[o]||k5,s[o])}function Ffe(t){switch(t){case 5126:return xfe;case 35664:return bfe;case 35665:return Sfe;case 35666:return _fe;case 35674:return wfe;case 35675:return Cfe;case 35676:return Efe;case 5124:case 35670:return Afe;case 35667:case 35671:return Tfe;case 35668:case 35672:return Mfe;case 35669:case 35673:return Rfe;case 5125:return Ife;case 36294:return Nfe;case 36295:return Pfe;case 36296:return kfe;case 35678:case 36198:case 36298:case 36306:case 35682:return Dfe;case 35679:case 36299:case 36307:return Ofe;case 35680:case 36300:case 36308:case 36293:return Lfe;case 36289:case 36303:case 36311:case 36292:return Bfe}}class $fe{constructor(e,n,r){this.id=e,this.addr=r,this.cache=[],this.type=n.type,this.setValue=vfe(n.type)}}class Ufe{constructor(e,n,r){this.id=e,this.addr=r,this.cache=[],this.type=n.type,this.size=n.size,this.setValue=Ffe(n.type)}}class zfe{constructor(e){this.id=e,this.seq=[],this.map={}}setValue(e,n,r){const i=this.seq;for(let s=0,o=i.length;s!==o;++s){const a=i[s];a.setValue(e,n[a.id],r)}}}const KC=/(\w+)(\])?(\[|\.)?/g;function lO(t,e){t.seq.push(e),t.map[e.id]=e}function Gfe(t,e,n){const r=t.name,i=r.length;for(KC.lastIndex=0;;){const s=KC.exec(r),o=KC.lastIndex;let a=s[1];const l=s[2]==="]",c=s[3];if(l&&(a=a|0),c===void 0||c==="["&&o+2===i){lO(n,c===void 0?new $fe(a,t,e):new Ufe(a,t,e));break}else{let d=n.map[a];d===void 0&&(d=new zfe(a),lO(n,d)),n=d}}}class Zx{constructor(e,n){this.seq=[],this.map={};const r=e.getProgramParameter(n,e.ACTIVE_UNIFORMS);for(let i=0;i<r;++i){const s=e.getActiveUniform(n,i),o=e.getUniformLocation(n,s.name);Gfe(s,o,this)}}setValue(e,n,r,i){const s=this.map[n];s!==void 0&&s.setValue(e,r,i)}setOptional(e,n,r){const i=n[r];i!==void 0&&this.setValue(e,r,i)}static upload(e,n,r,i){for(let s=0,o=n.length;s!==o;++s){const a=n[s],l=r[a.id];l.needsUpdate!==!1&&a.setValue(e,l.value,i)}}static seqWithValue(e,n){const r=[];for(let i=0,s=e.length;i!==s;++i){const o=e[i];o.id in n&&r.push(o)}return r}}function cO(t,e,n){const r=t.createShader(e);return t.shaderSource(r,n),t.compileShader(r),r}const Hfe=37297;let Vfe=0;function Wfe(t,e){const n=t.split(`
`),r=[],i=Math.max(e-6,0),s=Math.min(e+6,n.length);for(let o=i;o<s;o++){const a=o+1;r.push(`${a===e?">":" "} ${a}: ${n[o]}`)}return r.join(`
`)}function jfe(t){const e=gn.getPrimaries(gn.workingColorSpace),n=gn.getPrimaries(t);let r;switch(e===n?r="":e===zg&&n===Ug?r="LinearDisplayP3ToLinearSRGB":e===Ug&&n===zg&&(r="LinearSRGBToLinearDisplayP3"),t){case Ml:case A0:return[r,"LinearTransferOETF"];case xs:case MS:return[r,"sRGBTransferOETF"];default:return console.warn("THREE.WebGLProgram: Unsupported color space:",t),[r,"LinearTransferOETF"]}}function uO(t,e,n){const r=t.getShaderParameter(e,t.COMPILE_STATUS),i=t.getShaderInfoLog(e).trim();if(r&&i==="")return"";const s=/ERROR: 0:(\d+)/.exec(i);if(s){const o=parseInt(s[1]);return n.toUpperCase()+`

`+i+`

`+Wfe(t.getShaderSource(e),o)}else return i}function Xfe(t,e){const n=jfe(e);return`vec4 ${t}( vec4 value ) { return ${n[0]}( ${n[1]}( value ) ); }`}function Kfe(t,e){let n;switch(e){case H9:n="Linear";break;case V9:n="Reinhard";break;case W9:n="OptimizedCineon";break;case mR:n="ACESFilmic";break;case X9:n="AgX";break;case K9:n="Neutral";break;case j9:n="Custom";break;default:console.warn("THREE.WebGLProgram: Unsupported toneMapping:",e),n="Linear"}return"vec3 "+t+"( vec3 color ) { return "+n+"ToneMapping( color ); }"}function qfe(t){return[t.extensionClipCullDistance?"#extension GL_ANGLE_clip_cull_distance : require":"",t.extensionMultiDraw?"#extension GL_ANGLE_multi_draw : require":""].filter(zm).join(`
`)}function Jfe(t){const e=[];for(const n in t){const r=t[n];r!==!1&&e.push("#define "+n+" "+r)}return e.join(`
`)}function Yfe(t,e){const n={},r=t.getProgramParameter(e,t.ACTIVE_ATTRIBUTES);for(let i=0;i<r;i++){const s=t.getActiveAttrib(e,i),o=s.name;let a=1;s.type===t.FLOAT_MAT2&&(a=2),s.type===t.FLOAT_MAT3&&(a=3),s.type===t.FLOAT_MAT4&&(a=4),n[o]={type:s.type,location:t.getAttribLocation(e,o),locationSize:a}}return n}function zm(t){return t!==""}function dO(t,e){const n=e.numSpotLightShadows+e.numSpotLightMaps-e.numSpotLightShadowsWithMaps;return t.replace(/NUM_DIR_LIGHTS/g,e.numDirLights).replace(/NUM_SPOT_LIGHTS/g,e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g,e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g,n).replace(/NUM_RECT_AREA_LIGHTS/g,e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g,e.numPointLights).replace(/NUM_HEMI_LIGHTS/g,e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g,e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g,e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g,e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g,e.numPointLightShadows)}function fO(t,e){return t.replace(/NUM_CLIPPING_PLANES/g,e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g,e.numClippingPlanes-e.numClipIntersection)}const Qfe=/^[ \t]*#include +<([\w\d./]+)>/gm;function O2(t){return t.replace(Qfe,ehe)}const Zfe=new Map([["encodings_fragment","colorspace_fragment"],["encodings_pars_fragment","colorspace_pars_fragment"],["output_fragment","opaque_fragment"]]);function ehe(t,e){let n=Gt[e];if(n===void 0){const r=Zfe.get(e);if(r!==void 0)n=Gt[r],console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',e,r);else throw new Error("Can not resolve #include <"+e+">")}return O2(n)}const the=/#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;function hO(t){return t.replace(the,nhe)}function nhe(t,e,n,r){let i="";for(let s=parseInt(e);s<parseInt(n);s++)i+=r.replace(/\[\s*i\s*\]/g,"[ "+s+" ]").replace(/UNROLLED_LOOP_INDEX/g,s);return i}function pO(t){let e=`precision ${t.precision} float;
	precision ${t.precision} int;
	precision ${t.precision} sampler2D;
	precision ${t.precision} samplerCube;
	precision ${t.precision} sampler3D;
	precision ${t.precision} sampler2DArray;
	precision ${t.precision} sampler2DShadow;
	precision ${t.precision} samplerCubeShadow;
	precision ${t.precision} sampler2DArrayShadow;
	precision ${t.precision} isampler2D;
	precision ${t.precision} isampler3D;
	precision ${t.precision} isamplerCube;
	precision ${t.precision} isampler2DArray;
	precision ${t.precision} usampler2D;
	precision ${t.precision} usampler3D;
	precision ${t.precision} usamplerCube;
	precision ${t.precision} usampler2DArray;
	`;return t.precision==="highp"?e+=`
#define HIGH_PRECISION`:t.precision==="mediump"?e+=`
#define MEDIUM_PRECISION`:t.precision==="lowp"&&(e+=`
#define LOW_PRECISION`),e}function rhe(t){let e="SHADOWMAP_TYPE_BASIC";return t.shadowMapType===CS?e="SHADOWMAP_TYPE_PCF":t.shadowMapType===ig?e="SHADOWMAP_TYPE_PCF_SOFT":t.shadowMapType===ko&&(e="SHADOWMAP_TYPE_VSM"),e}function ihe(t){let e="ENVMAP_TYPE_CUBE";if(t.envMap)switch(t.envMapMode){case xl:case Ac:e="ENVMAP_TYPE_CUBE";break;case yp:e="ENVMAP_TYPE_CUBE_UV";break}return e}function she(t){let e="ENVMAP_MODE_REFLECTION";if(t.envMap)switch(t.envMapMode){case Ac:e="ENVMAP_MODE_REFRACTION";break}return e}function ohe(t){let e="ENVMAP_BLENDING_NONE";if(t.envMap)switch(t.combine){case E0:e="ENVMAP_BLENDING_MULTIPLY";break;case z9:e="ENVMAP_BLENDING_MIX";break;case G9:e="ENVMAP_BLENDING_ADD";break}return e}function ahe(t){const e=t.envMapCubeUVHeight;if(e===null)return null;const n=Math.log2(e)-2,r=1/e;return{texelWidth:1/(3*Math.max(Math.pow(2,n),7*16)),texelHeight:r,maxMip:n}}function lhe(t,e,n,r){const i=t.getContext(),s=n.defines;let o=n.vertexShader,a=n.fragmentShader;const l=rhe(n),c=ihe(n),u=she(n),d=ohe(n),f=ahe(n),h=qfe(n),p=Jfe(s),x=i.createProgram();let v,y,b=n.glslVersion?"#version "+n.glslVersion+`
`:"";n.isRawShaderMaterial?(v=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,p].filter(zm).join(`
`),v.length>0&&(v+=`
`),y=["#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,p].filter(zm).join(`
`),y.length>0&&(y+=`
`)):(v=[pO(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,p,n.extensionClipCullDistance?"#define USE_CLIP_DISTANCE":"",n.batching?"#define USE_BATCHING":"",n.instancing?"#define USE_INSTANCING":"",n.instancingColor?"#define USE_INSTANCING_COLOR":"",n.instancingMorph?"#define USE_INSTANCING_MORPH":"",n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.map?"#define USE_MAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+u:"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.displacementMap?"#define USE_DISPLACEMENTMAP":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.mapUv?"#define MAP_UV "+n.mapUv:"",n.alphaMapUv?"#define ALPHAMAP_UV "+n.alphaMapUv:"",n.lightMapUv?"#define LIGHTMAP_UV "+n.lightMapUv:"",n.aoMapUv?"#define AOMAP_UV "+n.aoMapUv:"",n.emissiveMapUv?"#define EMISSIVEMAP_UV "+n.emissiveMapUv:"",n.bumpMapUv?"#define BUMPMAP_UV "+n.bumpMapUv:"",n.normalMapUv?"#define NORMALMAP_UV "+n.normalMapUv:"",n.displacementMapUv?"#define DISPLACEMENTMAP_UV "+n.displacementMapUv:"",n.metalnessMapUv?"#define METALNESSMAP_UV "+n.metalnessMapUv:"",n.roughnessMapUv?"#define ROUGHNESSMAP_UV "+n.roughnessMapUv:"",n.anisotropyMapUv?"#define ANISOTROPYMAP_UV "+n.anisotropyMapUv:"",n.clearcoatMapUv?"#define CLEARCOATMAP_UV "+n.clearcoatMapUv:"",n.clearcoatNormalMapUv?"#define CLEARCOAT_NORMALMAP_UV "+n.clearcoatNormalMapUv:"",n.clearcoatRoughnessMapUv?"#define CLEARCOAT_ROUGHNESSMAP_UV "+n.clearcoatRoughnessMapUv:"",n.iridescenceMapUv?"#define IRIDESCENCEMAP_UV "+n.iridescenceMapUv:"",n.iridescenceThicknessMapUv?"#define IRIDESCENCE_THICKNESSMAP_UV "+n.iridescenceThicknessMapUv:"",n.sheenColorMapUv?"#define SHEEN_COLORMAP_UV "+n.sheenColorMapUv:"",n.sheenRoughnessMapUv?"#define SHEEN_ROUGHNESSMAP_UV "+n.sheenRoughnessMapUv:"",n.specularMapUv?"#define SPECULARMAP_UV "+n.specularMapUv:"",n.specularColorMapUv?"#define SPECULAR_COLORMAP_UV "+n.specularColorMapUv:"",n.specularIntensityMapUv?"#define SPECULAR_INTENSITYMAP_UV "+n.specularIntensityMapUv:"",n.transmissionMapUv?"#define TRANSMISSIONMAP_UV "+n.transmissionMapUv:"",n.thicknessMapUv?"#define THICKNESSMAP_UV "+n.thicknessMapUv:"",n.vertexTangents&&n.flatShading===!1?"#define USE_TANGENT":"",n.vertexColors?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.flatShading?"#define FLAT_SHADED":"",n.skinning?"#define USE_SKINNING":"",n.morphTargets?"#define USE_MORPHTARGETS":"",n.morphNormals&&n.flatShading===!1?"#define USE_MORPHNORMALS":"",n.morphColors?"#define USE_MORPHCOLORS":"",n.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE":"",n.morphTargetsCount>0?"#define MORPHTARGETS_TEXTURE_STRIDE "+n.morphTextureStride:"",n.morphTargetsCount>0?"#define MORPHTARGETS_COUNT "+n.morphTargetsCount:"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.sizeAttenuation?"#define USE_SIZEATTENUATION":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.useLegacyLights?"#define LEGACY_LIGHTS":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 modelMatrix;","uniform mat4 modelViewMatrix;","uniform mat4 projectionMatrix;","uniform mat4 viewMatrix;","uniform mat3 normalMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;","#ifdef USE_INSTANCING","	attribute mat4 instanceMatrix;","#endif","#ifdef USE_INSTANCING_COLOR","	attribute vec3 instanceColor;","#endif","#ifdef USE_INSTANCING_MORPH","	uniform sampler2D morphTexture;","#endif","attribute vec3 position;","attribute vec3 normal;","attribute vec2 uv;","#ifdef USE_UV1","	attribute vec2 uv1;","#endif","#ifdef USE_UV2","	attribute vec2 uv2;","#endif","#ifdef USE_UV3","	attribute vec2 uv3;","#endif","#ifdef USE_TANGENT","	attribute vec4 tangent;","#endif","#if defined( USE_COLOR_ALPHA )","	attribute vec4 color;","#elif defined( USE_COLOR )","	attribute vec3 color;","#endif","#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )","	attribute vec3 morphTarget0;","	attribute vec3 morphTarget1;","	attribute vec3 morphTarget2;","	attribute vec3 morphTarget3;","	#ifdef USE_MORPHNORMALS","		attribute vec3 morphNormal0;","		attribute vec3 morphNormal1;","		attribute vec3 morphNormal2;","		attribute vec3 morphNormal3;","	#else","		attribute vec3 morphTarget4;","		attribute vec3 morphTarget5;","		attribute vec3 morphTarget6;","		attribute vec3 morphTarget7;","	#endif","#endif","#ifdef USE_SKINNING","	attribute vec4 skinIndex;","	attribute vec4 skinWeight;","#endif",`
`].filter(zm).join(`
`),y=[pO(n),"#define SHADER_TYPE "+n.shaderType,"#define SHADER_NAME "+n.shaderName,p,n.useFog&&n.fog?"#define USE_FOG":"",n.useFog&&n.fogExp2?"#define FOG_EXP2":"",n.alphaToCoverage?"#define ALPHA_TO_COVERAGE":"",n.map?"#define USE_MAP":"",n.matcap?"#define USE_MATCAP":"",n.envMap?"#define USE_ENVMAP":"",n.envMap?"#define "+c:"",n.envMap?"#define "+u:"",n.envMap?"#define "+d:"",f?"#define CUBEUV_TEXEL_WIDTH "+f.texelWidth:"",f?"#define CUBEUV_TEXEL_HEIGHT "+f.texelHeight:"",f?"#define CUBEUV_MAX_MIP "+f.maxMip+".0":"",n.lightMap?"#define USE_LIGHTMAP":"",n.aoMap?"#define USE_AOMAP":"",n.bumpMap?"#define USE_BUMPMAP":"",n.normalMap?"#define USE_NORMALMAP":"",n.normalMapObjectSpace?"#define USE_NORMALMAP_OBJECTSPACE":"",n.normalMapTangentSpace?"#define USE_NORMALMAP_TANGENTSPACE":"",n.emissiveMap?"#define USE_EMISSIVEMAP":"",n.anisotropy?"#define USE_ANISOTROPY":"",n.anisotropyMap?"#define USE_ANISOTROPYMAP":"",n.clearcoat?"#define USE_CLEARCOAT":"",n.clearcoatMap?"#define USE_CLEARCOATMAP":"",n.clearcoatRoughnessMap?"#define USE_CLEARCOAT_ROUGHNESSMAP":"",n.clearcoatNormalMap?"#define USE_CLEARCOAT_NORMALMAP":"",n.iridescence?"#define USE_IRIDESCENCE":"",n.iridescenceMap?"#define USE_IRIDESCENCEMAP":"",n.iridescenceThicknessMap?"#define USE_IRIDESCENCE_THICKNESSMAP":"",n.specularMap?"#define USE_SPECULARMAP":"",n.specularColorMap?"#define USE_SPECULAR_COLORMAP":"",n.specularIntensityMap?"#define USE_SPECULAR_INTENSITYMAP":"",n.roughnessMap?"#define USE_ROUGHNESSMAP":"",n.metalnessMap?"#define USE_METALNESSMAP":"",n.alphaMap?"#define USE_ALPHAMAP":"",n.alphaTest?"#define USE_ALPHATEST":"",n.alphaHash?"#define USE_ALPHAHASH":"",n.sheen?"#define USE_SHEEN":"",n.sheenColorMap?"#define USE_SHEEN_COLORMAP":"",n.sheenRoughnessMap?"#define USE_SHEEN_ROUGHNESSMAP":"",n.transmission?"#define USE_TRANSMISSION":"",n.transmissionMap?"#define USE_TRANSMISSIONMAP":"",n.thicknessMap?"#define USE_THICKNESSMAP":"",n.vertexTangents&&n.flatShading===!1?"#define USE_TANGENT":"",n.vertexColors||n.instancingColor?"#define USE_COLOR":"",n.vertexAlphas?"#define USE_COLOR_ALPHA":"",n.vertexUv1s?"#define USE_UV1":"",n.vertexUv2s?"#define USE_UV2":"",n.vertexUv3s?"#define USE_UV3":"",n.pointsUvs?"#define USE_POINTS_UV":"",n.gradientMap?"#define USE_GRADIENTMAP":"",n.flatShading?"#define FLAT_SHADED":"",n.doubleSided?"#define DOUBLE_SIDED":"",n.flipSided?"#define FLIP_SIDED":"",n.shadowMapEnabled?"#define USE_SHADOWMAP":"",n.shadowMapEnabled?"#define "+l:"",n.premultipliedAlpha?"#define PREMULTIPLIED_ALPHA":"",n.numLightProbes>0?"#define USE_LIGHT_PROBES":"",n.useLegacyLights?"#define LEGACY_LIGHTS":"",n.decodeVideoTexture?"#define DECODE_VIDEO_TEXTURE":"",n.logarithmicDepthBuffer?"#define USE_LOGDEPTHBUF":"","uniform mat4 viewMatrix;","uniform vec3 cameraPosition;","uniform bool isOrthographic;",n.toneMapping!==Ca?"#define TONE_MAPPING":"",n.toneMapping!==Ca?Gt.tonemapping_pars_fragment:"",n.toneMapping!==Ca?Kfe("toneMapping",n.toneMapping):"",n.dithering?"#define DITHERING":"",n.opaque?"#define OPAQUE":"",Gt.colorspace_pars_fragment,Xfe("linearToOutputTexel",n.outputColorSpace),n.useDepthPacking?"#define DEPTH_PACKING "+n.depthPacking:"",`
`].filter(zm).join(`
`)),o=O2(o),o=dO(o,n),o=fO(o,n),a=O2(a),a=dO(a,n),a=fO(a,n),o=hO(o),a=hO(a),n.isRawShaderMaterial!==!0&&(b=`#version 300 es
`,v=[h,"#define attribute in","#define varying out","#define texture2D texture"].join(`
`)+`
`+v,y=["#define varying in",n.glslVersion===k2?"":"layout(location = 0) out highp vec4 pc_fragColor;",n.glslVersion===k2?"":"#define gl_FragColor pc_fragColor","#define gl_FragDepthEXT gl_FragDepth","#define texture2D texture","#define textureCube texture","#define texture2DProj textureProj","#define texture2DLodEXT textureLod","#define texture2DProjLodEXT textureProjLod","#define textureCubeLodEXT textureLod","#define texture2DGradEXT textureGrad","#define texture2DProjGradEXT textureProjGrad","#define textureCubeGradEXT textureGrad"].join(`
`)+`
`+y);const S=b+v+o,w=b+y+a,E=cO(i,i.VERTEX_SHADER,S),A=cO(i,i.FRAGMENT_SHADER,w);i.attachShader(x,E),i.attachShader(x,A),n.index0AttributeName!==void 0?i.bindAttribLocation(x,0,n.index0AttributeName):n.morphTargets===!0&&i.bindAttribLocation(x,0,"position"),i.linkProgram(x);function T(P){if(t.debug.checkShaderErrors){const B=i.getProgramInfoLog(x).trim(),F=i.getShaderInfoLog(E).trim(),U=i.getShaderInfoLog(A).trim();let j=!0,Z=!0;if(i.getProgramParameter(x,i.LINK_STATUS)===!1)if(j=!1,typeof t.debug.onShaderError=="function")t.debug.onShaderError(i,x,E,A);else{const ne=uO(i,E,"vertex"),O=uO(i,A,"fragment");console.error("THREE.WebGLProgram: Shader Error "+i.getError()+" - VALIDATE_STATUS "+i.getProgramParameter(x,i.VALIDATE_STATUS)+`

Material Name: `+P.name+`
Material Type: `+P.type+`

Program Info Log: `+B+`
`+ne+`
`+O)}else B!==""?console.warn("THREE.WebGLProgram: Program Info Log:",B):(F===""||U==="")&&(Z=!1);Z&&(P.diagnostics={runnable:j,programLog:B,vertexShader:{log:F,prefix:v},fragmentShader:{log:U,prefix:y}})}i.deleteShader(E),i.deleteShader(A),I=new Zx(i,x),N=Yfe(i,x)}let I;this.getUniforms=function(){return I===void 0&&T(this),I};let N;this.getAttributes=function(){return N===void 0&&T(this),N};let M=n.rendererExtensionParallelShaderCompile===!1;return this.isReady=function(){return M===!1&&(M=i.getProgramParameter(x,Hfe)),M},this.destroy=function(){r.releaseStatesOfProgram(this),i.deleteProgram(x),this.program=void 0},this.type=n.shaderType,this.name=n.shaderName,this.id=Vfe++,this.cacheKey=e,this.usedTimes=1,this.program=x,this.vertexShader=E,this.fragmentShader=A,this}let che=0;class uhe{constructor(){this.shaderCache=new Map,this.materialCache=new Map}update(e){const n=e.vertexShader,r=e.fragmentShader,i=this._getShaderStage(n),s=this._getShaderStage(r),o=this._getShaderCacheForMaterial(e);return o.has(i)===!1&&(o.add(i),i.usedTimes++),o.has(s)===!1&&(o.add(s),s.usedTimes++),this}remove(e){const n=this.materialCache.get(e);for(const r of n)r.usedTimes--,r.usedTimes===0&&this.shaderCache.delete(r.code);return this.materialCache.delete(e),this}getVertexShaderID(e){return this._getShaderStage(e.vertexShader).id}getFragmentShaderID(e){return this._getShaderStage(e.fragmentShader).id}dispose(){this.shaderCache.clear(),this.materialCache.clear()}_getShaderCacheForMaterial(e){const n=this.materialCache;let r=n.get(e);return r===void 0&&(r=new Set,n.set(e,r)),r}_getShaderStage(e){const n=this.shaderCache;let r=n.get(e);return r===void 0&&(r=new dhe(e),n.set(e,r)),r}}class dhe{constructor(e){this.id=che++,this.code=e,this.usedTimes=0}}function fhe(t,e,n,r,i,s,o){const a=new Qu,l=new uhe,c=new Set,u=[],d=i.logarithmicDepthBuffer,f=i.vertexTextures;let h=i.precision;const p={MeshDepthMaterial:"depth",MeshDistanceMaterial:"distanceRGBA",MeshNormalMaterial:"normal",MeshBasicMaterial:"basic",MeshLambertMaterial:"lambert",MeshPhongMaterial:"phong",MeshToonMaterial:"toon",MeshStandardMaterial:"physical",MeshPhysicalMaterial:"physical",MeshMatcapMaterial:"matcap",LineBasicMaterial:"basic",LineDashedMaterial:"dashed",PointsMaterial:"points",ShadowMaterial:"shadow",SpriteMaterial:"sprite"};function x(N){return c.add(N),N===0?"uv":`uv${N}`}function v(N,M,P,B,F){const U=B.fog,j=F.geometry,Z=N.isMeshStandardMaterial?B.environment:null,ne=(N.isMeshStandardMaterial?n:e).get(N.envMap||Z),O=ne&&ne.mapping===yp?ne.image.height:null,G=p[N.type];N.precision!==null&&(h=i.getMaxPrecision(N.precision),h!==N.precision&&console.warn("THREE.WebGLProgram.getParameters:",N.precision,"not supported, using",h,"instead."));const q=j.morphAttributes.position||j.morphAttributes.normal||j.morphAttributes.color,se=q!==void 0?q.length:0;let he=0;j.morphAttributes.position!==void 0&&(he=1),j.morphAttributes.normal!==void 0&&(he=2),j.morphAttributes.color!==void 0&&(he=3);let ke,re,pe,fe;if(G){const _n=Bo[G];ke=_n.vertexShader,re=_n.fragmentShader}else ke=N.vertexShader,re=N.fragmentShader,l.update(N),pe=l.getVertexShaderID(N),fe=l.getFragmentShaderID(N);const Ee=t.getRenderTarget(),We=F.isInstancedMesh===!0,je=F.isBatchedMesh===!0,Je=!!N.map,te=!!N.matcap,be=!!ne,ce=!!N.aoMap,Me=!!N.lightMap,Ie=!!N.bumpMap,Oe=!!N.normalMap,V=!!N.displacementMap,$=!!N.emissiveMap,ue=!!N.metalnessMap,ye=!!N.roughnessMap,ve=N.anisotropy>0,Ne=N.clearcoat>0,nt=N.iridescence>0,Ae=N.sheen>0,st=N.transmission>0,ht=ve&&!!N.anisotropyMap,Ue=Ne&&!!N.clearcoatMap,Fe=Ne&&!!N.clearcoatNormalMap,$e=Ne&&!!N.clearcoatRoughnessMap,Ze=nt&&!!N.iridescenceMap,ot=nt&&!!N.iridescenceThicknessMap,Pt=Ae&&!!N.sheenColorMap,Ge=Ae&&!!N.sheenRoughnessMap,yt=!!N.specularMap,_t=!!N.specularColorMap,ie=!!N.specularIntensityMap,_e=st&&!!N.transmissionMap,J=st&&!!N.thicknessMap,De=!!N.gradientMap,Be=!!N.alphaMap,ut=N.alphaTest>0,pt=!!N.alphaHash,mn=!!N.extensions;let hn=Ca;N.toneMapped&&(Ee===null||Ee.isXRRenderTarget===!0)&&(hn=t.toneMapping);const jt={shaderID:G,shaderType:N.type,shaderName:N.name,vertexShader:ke,fragmentShader:re,defines:N.defines,customVertexShaderID:pe,customFragmentShaderID:fe,isRawShaderMaterial:N.isRawShaderMaterial===!0,glslVersion:N.glslVersion,precision:h,batching:je,instancing:We,instancingColor:We&&F.instanceColor!==null,instancingMorph:We&&F.morphTexture!==null,supportsVertexTextures:f,outputColorSpace:Ee===null?t.outputColorSpace:Ee.isXRRenderTarget===!0?Ee.texture.colorSpace:Ml,alphaToCoverage:!!N.alphaToCoverage,map:Je,matcap:te,envMap:be,envMapMode:be&&ne.mapping,envMapCubeUVHeight:O,aoMap:ce,lightMap:Me,bumpMap:Ie,normalMap:Oe,displacementMap:f&&V,emissiveMap:$,normalMapObjectSpace:Oe&&N.normalMapType===d5,normalMapTangentSpace:Oe&&N.normalMapType===Bc,metalnessMap:ue,roughnessMap:ye,anisotropy:ve,anisotropyMap:ht,clearcoat:Ne,clearcoatMap:Ue,clearcoatNormalMap:Fe,clearcoatRoughnessMap:$e,iridescence:nt,iridescenceMap:Ze,iridescenceThicknessMap:ot,sheen:Ae,sheenColorMap:Pt,sheenRoughnessMap:Ge,specularMap:yt,specularColorMap:_t,specularIntensityMap:ie,transmission:st,transmissionMap:_e,thicknessMap:J,gradientMap:De,opaque:N.transparent===!1&&N.blending===qu&&N.alphaToCoverage===!1,alphaMap:Be,alphaTest:ut,alphaHash:pt,combine:N.combine,mapUv:Je&&x(N.map.channel),aoMapUv:ce&&x(N.aoMap.channel),lightMapUv:Me&&x(N.lightMap.channel),bumpMapUv:Ie&&x(N.bumpMap.channel),normalMapUv:Oe&&x(N.normalMap.channel),displacementMapUv:V&&x(N.displacementMap.channel),emissiveMapUv:$&&x(N.emissiveMap.channel),metalnessMapUv:ue&&x(N.metalnessMap.channel),roughnessMapUv:ye&&x(N.roughnessMap.channel),anisotropyMapUv:ht&&x(N.anisotropyMap.channel),clearcoatMapUv:Ue&&x(N.clearcoatMap.channel),clearcoatNormalMapUv:Fe&&x(N.clearcoatNormalMap.channel),clearcoatRoughnessMapUv:$e&&x(N.clearcoatRoughnessMap.channel),iridescenceMapUv:Ze&&x(N.iridescenceMap.channel),iridescenceThicknessMapUv:ot&&x(N.iridescenceThicknessMap.channel),sheenColorMapUv:Pt&&x(N.sheenColorMap.channel),sheenRoughnessMapUv:Ge&&x(N.sheenRoughnessMap.channel),specularMapUv:yt&&x(N.specularMap.channel),specularColorMapUv:_t&&x(N.specularColorMap.channel),specularIntensityMapUv:ie&&x(N.specularIntensityMap.channel),transmissionMapUv:_e&&x(N.transmissionMap.channel),thicknessMapUv:J&&x(N.thicknessMap.channel),alphaMapUv:Be&&x(N.alphaMap.channel),vertexTangents:!!j.attributes.tangent&&(Oe||ve),vertexColors:N.vertexColors,vertexAlphas:N.vertexColors===!0&&!!j.attributes.color&&j.attributes.color.itemSize===4,pointsUvs:F.isPoints===!0&&!!j.attributes.uv&&(Je||Be),fog:!!U,useFog:N.fog===!0,fogExp2:!!U&&U.isFogExp2,flatShading:N.flatShading===!0,sizeAttenuation:N.sizeAttenuation===!0,logarithmicDepthBuffer:d,skinning:F.isSkinnedMesh===!0,morphTargets:j.morphAttributes.position!==void 0,morphNormals:j.morphAttributes.normal!==void 0,morphColors:j.morphAttributes.color!==void 0,morphTargetsCount:se,morphTextureStride:he,numDirLights:M.directional.length,numPointLights:M.point.length,numSpotLights:M.spot.length,numSpotLightMaps:M.spotLightMap.length,numRectAreaLights:M.rectArea.length,numHemiLights:M.hemi.length,numDirLightShadows:M.directionalShadowMap.length,numPointLightShadows:M.pointShadowMap.length,numSpotLightShadows:M.spotShadowMap.length,numSpotLightShadowsWithMaps:M.numSpotLightShadowsWithMaps,numLightProbes:M.numLightProbes,numClippingPlanes:o.numPlanes,numClipIntersection:o.numIntersection,dithering:N.dithering,shadowMapEnabled:t.shadowMap.enabled&&P.length>0,shadowMapType:t.shadowMap.type,toneMapping:hn,useLegacyLights:t._useLegacyLights,decodeVideoTexture:Je&&N.map.isVideoTexture===!0&&gn.getTransfer(N.map.colorSpace)===Tn,premultipliedAlpha:N.premultipliedAlpha,doubleSided:N.side===Uo,flipSided:N.side===Fi,useDepthPacking:N.depthPacking>=0,depthPacking:N.depthPacking||0,index0AttributeName:N.index0AttributeName,extensionClipCullDistance:mn&&N.extensions.clipCullDistance===!0&&r.has("WEBGL_clip_cull_distance"),extensionMultiDraw:mn&&N.extensions.multiDraw===!0&&r.has("WEBGL_multi_draw"),rendererExtensionParallelShaderCompile:r.has("KHR_parallel_shader_compile"),customProgramCacheKey:N.customProgramCacheKey()};return jt.vertexUv1s=c.has(1),jt.vertexUv2s=c.has(2),jt.vertexUv3s=c.has(3),c.clear(),jt}function y(N){const M=[];if(N.shaderID?M.push(N.shaderID):(M.push(N.customVertexShaderID),M.push(N.customFragmentShaderID)),N.defines!==void 0)for(const P in N.defines)M.push(P),M.push(N.defines[P]);return N.isRawShaderMaterial===!1&&(b(M,N),S(M,N),M.push(t.outputColorSpace)),M.push(N.customProgramCacheKey),M.join()}function b(N,M){N.push(M.precision),N.push(M.outputColorSpace),N.push(M.envMapMode),N.push(M.envMapCubeUVHeight),N.push(M.mapUv),N.push(M.alphaMapUv),N.push(M.lightMapUv),N.push(M.aoMapUv),N.push(M.bumpMapUv),N.push(M.normalMapUv),N.push(M.displacementMapUv),N.push(M.emissiveMapUv),N.push(M.metalnessMapUv),N.push(M.roughnessMapUv),N.push(M.anisotropyMapUv),N.push(M.clearcoatMapUv),N.push(M.clearcoatNormalMapUv),N.push(M.clearcoatRoughnessMapUv),N.push(M.iridescenceMapUv),N.push(M.iridescenceThicknessMapUv),N.push(M.sheenColorMapUv),N.push(M.sheenRoughnessMapUv),N.push(M.specularMapUv),N.push(M.specularColorMapUv),N.push(M.specularIntensityMapUv),N.push(M.transmissionMapUv),N.push(M.thicknessMapUv),N.push(M.combine),N.push(M.fogExp2),N.push(M.sizeAttenuation),N.push(M.morphTargetsCount),N.push(M.morphAttributeCount),N.push(M.numDirLights),N.push(M.numPointLights),N.push(M.numSpotLights),N.push(M.numSpotLightMaps),N.push(M.numHemiLights),N.push(M.numRectAreaLights),N.push(M.numDirLightShadows),N.push(M.numPointLightShadows),N.push(M.numSpotLightShadows),N.push(M.numSpotLightShadowsWithMaps),N.push(M.numLightProbes),N.push(M.shadowMapType),N.push(M.toneMapping),N.push(M.numClippingPlanes),N.push(M.numClipIntersection),N.push(M.depthPacking)}function S(N,M){a.disableAll(),M.supportsVertexTextures&&a.enable(0),M.instancing&&a.enable(1),M.instancingColor&&a.enable(2),M.instancingMorph&&a.enable(3),M.matcap&&a.enable(4),M.envMap&&a.enable(5),M.normalMapObjectSpace&&a.enable(6),M.normalMapTangentSpace&&a.enable(7),M.clearcoat&&a.enable(8),M.iridescence&&a.enable(9),M.alphaTest&&a.enable(10),M.vertexColors&&a.enable(11),M.vertexAlphas&&a.enable(12),M.vertexUv1s&&a.enable(13),M.vertexUv2s&&a.enable(14),M.vertexUv3s&&a.enable(15),M.vertexTangents&&a.enable(16),M.anisotropy&&a.enable(17),M.alphaHash&&a.enable(18),M.batching&&a.enable(19),N.push(a.mask),a.disableAll(),M.fog&&a.enable(0),M.useFog&&a.enable(1),M.flatShading&&a.enable(2),M.logarithmicDepthBuffer&&a.enable(3),M.skinning&&a.enable(4),M.morphTargets&&a.enable(5),M.morphNormals&&a.enable(6),M.morphColors&&a.enable(7),M.premultipliedAlpha&&a.enable(8),M.shadowMapEnabled&&a.enable(9),M.useLegacyLights&&a.enable(10),M.doubleSided&&a.enable(11),M.flipSided&&a.enable(12),M.useDepthPacking&&a.enable(13),M.dithering&&a.enable(14),M.transmission&&a.enable(15),M.sheen&&a.enable(16),M.opaque&&a.enable(17),M.pointsUvs&&a.enable(18),M.decodeVideoTexture&&a.enable(19),M.alphaToCoverage&&a.enable(20),N.push(a.mask)}function w(N){const M=p[N.type];let P;if(M){const B=Bo[M];P=T5.clone(B.uniforms)}else P=N.uniforms;return P}function E(N,M){let P;for(let B=0,F=u.length;B<F;B++){const U=u[B];if(U.cacheKey===M){P=U,++P.usedTimes;break}}return P===void 0&&(P=new lhe(t,M,N,s),u.push(P)),P}function A(N){if(--N.usedTimes===0){const M=u.indexOf(N);u[M]=u[u.length-1],u.pop(),N.destroy()}}function T(N){l.remove(N)}function I(){l.dispose()}return{getParameters:v,getProgramCacheKey:y,getUniforms:w,acquireProgram:E,releaseProgram:A,releaseShaderCache:T,programs:u,dispose:I}}function hhe(){let t=new WeakMap;function e(s){let o=t.get(s);return o===void 0&&(o={},t.set(s,o)),o}function n(s){t.delete(s)}function r(s,o,a){t.get(s)[o]=a}function i(){t=new WeakMap}return{get:e,remove:n,update:r,dispose:i}}function phe(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.material.id!==e.material.id?t.material.id-e.material.id:t.z!==e.z?t.z-e.z:t.id-e.id}function mO(t,e){return t.groupOrder!==e.groupOrder?t.groupOrder-e.groupOrder:t.renderOrder!==e.renderOrder?t.renderOrder-e.renderOrder:t.z!==e.z?e.z-t.z:t.id-e.id}function gO(){const t=[];let e=0;const n=[],r=[],i=[];function s(){e=0,n.length=0,r.length=0,i.length=0}function o(d,f,h,p,x,v){let y=t[e];return y===void 0?(y={id:d.id,object:d,geometry:f,material:h,groupOrder:p,renderOrder:d.renderOrder,z:x,group:v},t[e]=y):(y.id=d.id,y.object=d,y.geometry=f,y.material=h,y.groupOrder=p,y.renderOrder=d.renderOrder,y.z=x,y.group=v),e++,y}function a(d,f,h,p,x,v){const y=o(d,f,h,p,x,v);h.transmission>0?r.push(y):h.transparent===!0?i.push(y):n.push(y)}function l(d,f,h,p,x,v){const y=o(d,f,h,p,x,v);h.transmission>0?r.unshift(y):h.transparent===!0?i.unshift(y):n.unshift(y)}function c(d,f){n.length>1&&n.sort(d||phe),r.length>1&&r.sort(f||mO),i.length>1&&i.sort(f||mO)}function u(){for(let d=e,f=t.length;d<f;d++){const h=t[d];if(h.id===null)break;h.id=null,h.object=null,h.geometry=null,h.material=null,h.group=null}}return{opaque:n,transmissive:r,transparent:i,init:s,push:a,unshift:l,finish:u,sort:c}}function mhe(){let t=new WeakMap;function e(r,i){const s=t.get(r);let o;return s===void 0?(o=new gO,t.set(r,[o])):i>=s.length?(o=new gO,s.push(o)):o=s[i],o}function n(){t=new WeakMap}return{get:e,dispose:n}}function ghe(){const t={};return{get:function(e){if(t[e.id]!==void 0)return t[e.id];let n;switch(e.type){case"DirectionalLight":n={direction:new K,color:new Qe};break;case"SpotLight":n={position:new K,direction:new K,color:new Qe,distance:0,coneCos:0,penumbraCos:0,decay:0};break;case"PointLight":n={position:new K,color:new Qe,distance:0,decay:0};break;case"HemisphereLight":n={direction:new K,skyColor:new Qe,groundColor:new Qe};break;case"RectAreaLight":n={color:new Qe,position:new K,halfWidth:new K,halfHeight:new K};break}return t[e.id]=n,n}}}function yhe(){const t={};return{get:function(e){if(t[e.id]!==void 0)return t[e.id];let n;switch(e.type){case"DirectionalLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Re};break;case"SpotLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Re};break;case"PointLight":n={shadowBias:0,shadowNormalBias:0,shadowRadius:1,shadowMapSize:new Re,shadowCameraNear:1,shadowCameraFar:1e3};break}return t[e.id]=n,n}}}let vhe=0;function xhe(t,e){return(e.castShadow?2:0)-(t.castShadow?2:0)+(e.map?1:0)-(t.map?1:0)}function bhe(t){const e=new ghe,n=yhe(),r={version:0,hash:{directionalLength:-1,pointLength:-1,spotLength:-1,rectAreaLength:-1,hemiLength:-1,numDirectionalShadows:-1,numPointShadows:-1,numSpotShadows:-1,numSpotMaps:-1,numLightProbes:-1},ambient:[0,0,0],probe:[],directional:[],directionalShadow:[],directionalShadowMap:[],directionalShadowMatrix:[],spot:[],spotLightMap:[],spotShadow:[],spotShadowMap:[],spotLightMatrix:[],rectArea:[],rectAreaLTC1:null,rectAreaLTC2:null,point:[],pointShadow:[],pointShadowMap:[],pointShadowMatrix:[],hemi:[],numSpotLightShadowsWithMaps:0,numLightProbes:0};for(let c=0;c<9;c++)r.probe.push(new K);const i=new K,s=new St,o=new St;function a(c,u){let d=0,f=0,h=0;for(let P=0;P<9;P++)r.probe[P].set(0,0,0);let p=0,x=0,v=0,y=0,b=0,S=0,w=0,E=0,A=0,T=0,I=0;c.sort(xhe);const N=u===!0?Math.PI:1;for(let P=0,B=c.length;P<B;P++){const F=c[P],U=F.color,j=F.intensity,Z=F.distance,ne=F.shadow&&F.shadow.map?F.shadow.map.texture:null;if(F.isAmbientLight)d+=U.r*j*N,f+=U.g*j*N,h+=U.b*j*N;else if(F.isLightProbe){for(let O=0;O<9;O++)r.probe[O].addScaledVector(F.sh.coefficients[O],j);I++}else if(F.isDirectionalLight){const O=e.get(F);if(O.color.copy(F.color).multiplyScalar(F.intensity*N),F.castShadow){const G=F.shadow,q=n.get(F);q.shadowBias=G.bias,q.shadowNormalBias=G.normalBias,q.shadowRadius=G.radius,q.shadowMapSize=G.mapSize,r.directionalShadow[p]=q,r.directionalShadowMap[p]=ne,r.directionalShadowMatrix[p]=F.shadow.matrix,S++}r.directional[p]=O,p++}else if(F.isSpotLight){const O=e.get(F);O.position.setFromMatrixPosition(F.matrixWorld),O.color.copy(U).multiplyScalar(j*N),O.distance=Z,O.coneCos=Math.cos(F.angle),O.penumbraCos=Math.cos(F.angle*(1-F.penumbra)),O.decay=F.decay,r.spot[v]=O;const G=F.shadow;if(F.map&&(r.spotLightMap[A]=F.map,A++,G.updateMatrices(F),F.castShadow&&T++),r.spotLightMatrix[v]=G.matrix,F.castShadow){const q=n.get(F);q.shadowBias=G.bias,q.shadowNormalBias=G.normalBias,q.shadowRadius=G.radius,q.shadowMapSize=G.mapSize,r.spotShadow[v]=q,r.spotShadowMap[v]=ne,E++}v++}else if(F.isRectAreaLight){const O=e.get(F);O.color.copy(U).multiplyScalar(j),O.halfWidth.set(F.width*.5,0,0),O.halfHeight.set(0,F.height*.5,0),r.rectArea[y]=O,y++}else if(F.isPointLight){const O=e.get(F);if(O.color.copy(F.color).multiplyScalar(F.intensity*N),O.distance=F.distance,O.decay=F.decay,F.castShadow){const G=F.shadow,q=n.get(F);q.shadowBias=G.bias,q.shadowNormalBias=G.normalBias,q.shadowRadius=G.radius,q.shadowMapSize=G.mapSize,q.shadowCameraNear=G.camera.near,q.shadowCameraFar=G.camera.far,r.pointShadow[x]=q,r.pointShadowMap[x]=ne,r.pointShadowMatrix[x]=F.shadow.matrix,w++}r.point[x]=O,x++}else if(F.isHemisphereLight){const O=e.get(F);O.skyColor.copy(F.color).multiplyScalar(j*N),O.groundColor.copy(F.groundColor).multiplyScalar(j*N),r.hemi[b]=O,b++}}y>0&&(t.has("OES_texture_float_linear")===!0?(r.rectAreaLTC1=Ye.LTC_FLOAT_1,r.rectAreaLTC2=Ye.LTC_FLOAT_2):(r.rectAreaLTC1=Ye.LTC_HALF_1,r.rectAreaLTC2=Ye.LTC_HALF_2)),r.ambient[0]=d,r.ambient[1]=f,r.ambient[2]=h;const M=r.hash;(M.directionalLength!==p||M.pointLength!==x||M.spotLength!==v||M.rectAreaLength!==y||M.hemiLength!==b||M.numDirectionalShadows!==S||M.numPointShadows!==w||M.numSpotShadows!==E||M.numSpotMaps!==A||M.numLightProbes!==I)&&(r.directional.length=p,r.spot.length=v,r.rectArea.length=y,r.point.length=x,r.hemi.length=b,r.directionalShadow.length=S,r.directionalShadowMap.length=S,r.pointShadow.length=w,r.pointShadowMap.length=w,r.spotShadow.length=E,r.spotShadowMap.length=E,r.directionalShadowMatrix.length=S,r.pointShadowMatrix.length=w,r.spotLightMatrix.length=E+A-T,r.spotLightMap.length=A,r.numSpotLightShadowsWithMaps=T,r.numLightProbes=I,M.directionalLength=p,M.pointLength=x,M.spotLength=v,M.rectAreaLength=y,M.hemiLength=b,M.numDirectionalShadows=S,M.numPointShadows=w,M.numSpotShadows=E,M.numSpotMaps=A,M.numLightProbes=I,r.version=vhe++)}function l(c,u){let d=0,f=0,h=0,p=0,x=0;const v=u.matrixWorldInverse;for(let y=0,b=c.length;y<b;y++){const S=c[y];if(S.isDirectionalLight){const w=r.directional[d];w.direction.setFromMatrixPosition(S.matrixWorld),i.setFromMatrixPosition(S.target.matrixWorld),w.direction.sub(i),w.direction.transformDirection(v),d++}else if(S.isSpotLight){const w=r.spot[h];w.position.setFromMatrixPosition(S.matrixWorld),w.position.applyMatrix4(v),w.direction.setFromMatrixPosition(S.matrixWorld),i.setFromMatrixPosition(S.target.matrixWorld),w.direction.sub(i),w.direction.transformDirection(v),h++}else if(S.isRectAreaLight){const w=r.rectArea[p];w.position.setFromMatrixPosition(S.matrixWorld),w.position.applyMatrix4(v),o.identity(),s.copy(S.matrixWorld),s.premultiply(v),o.extractRotation(s),w.halfWidth.set(S.width*.5,0,0),w.halfHeight.set(0,S.height*.5,0),w.halfWidth.applyMatrix4(o),w.halfHeight.applyMatrix4(o),p++}else if(S.isPointLight){const w=r.point[f];w.position.setFromMatrixPosition(S.matrixWorld),w.position.applyMatrix4(v),f++}else if(S.isHemisphereLight){const w=r.hemi[x];w.direction.setFromMatrixPosition(S.matrixWorld),w.direction.transformDirection(v),x++}}}return{setup:a,setupView:l,state:r}}function yO(t){const e=new bhe(t),n=[],r=[];function i(){n.length=0,r.length=0}function s(u){n.push(u)}function o(u){r.push(u)}function a(u){e.setup(n,u)}function l(u){e.setupView(n,u)}return{init:i,state:{lightsArray:n,shadowsArray:r,lights:e,transmissionRenderTarget:null},setupLights:a,setupLightsView:l,pushLight:s,pushShadow:o}}function She(t){let e=new WeakMap;function n(i,s=0){const o=e.get(i);let a;return o===void 0?(a=new yO(t),e.set(i,[a])):s>=o.length?(a=new yO(t),o.push(a)):a=o[s],a}function r(){e=new WeakMap}return{get:n,dispose:r}}class DR extends wr{constructor(e){super(),this.isMeshDepthMaterial=!0,this.type="MeshDepthMaterial",this.depthPacking=c5,this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.setValues(e)}copy(e){return super.copy(e),this.depthPacking=e.depthPacking,this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this}}class OR extends wr{constructor(e){super(),this.isMeshDistanceMaterial=!0,this.type="MeshDistanceMaterial",this.map=null,this.alphaMap=null,this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.setValues(e)}copy(e){return super.copy(e),this.map=e.map,this.alphaMap=e.alphaMap,this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this}}const _he=`void main() {
	gl_Position = vec4( position, 1.0 );
}`,whe=`uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;function Che(t,e,n){let r=new R0;const i=new Re,s=new Re,o=new vn,a=new DR({depthPacking:u5}),l=new OR,c={},u=n.maxTextureSize,d={[Ia]:Fi,[Fi]:Ia,[Uo]:Uo},f=new Ko({defines:{VSM_SAMPLES:8},uniforms:{shadow_pass:{value:null},resolution:{value:new Re},radius:{value:4}},vertexShader:_he,fragmentShader:whe}),h=f.clone();h.defines.HORIZONTAL_PASS=1;const p=new Lt;p.setAttribute("position",new en(new Float32Array([-1,-1,.5,3,-1,.5,-1,3,.5]),3));const x=new lr(p,f),v=this;this.enabled=!1,this.autoUpdate=!0,this.needsUpdate=!1,this.type=CS;let y=this.type;this.render=function(A,T,I){if(v.enabled===!1||v.autoUpdate===!1&&v.needsUpdate===!1||A.length===0)return;const N=t.getRenderTarget(),M=t.getActiveCubeFace(),P=t.getActiveMipmapLevel(),B=t.state;B.setBlending(cl),B.buffers.color.setClear(1,1,1,1),B.buffers.depth.setTest(!0),B.setScissorTest(!1);const F=y!==ko&&this.type===ko,U=y===ko&&this.type!==ko;for(let j=0,Z=A.length;j<Z;j++){const ne=A[j],O=ne.shadow;if(O===void 0){console.warn("THREE.WebGLShadowMap:",ne,"has no shadow.");continue}if(O.autoUpdate===!1&&O.needsUpdate===!1)continue;i.copy(O.mapSize);const G=O.getFrameExtents();if(i.multiply(G),s.copy(O.mapSize),(i.x>u||i.y>u)&&(i.x>u&&(s.x=Math.floor(u/G.x),i.x=s.x*G.x,O.mapSize.x=s.x),i.y>u&&(s.y=Math.floor(u/G.y),i.y=s.y*G.y,O.mapSize.y=s.y)),O.map===null||F===!0||U===!0){const se=this.type!==ko?{minFilter:Nr,magFilter:Nr}:{};O.map!==null&&O.map.dispose(),O.map=new Xo(i.x,i.y,se),O.map.texture.name=ne.name+".shadowMap",O.camera.updateProjectionMatrix()}t.setRenderTarget(O.map),t.clear();const q=O.getViewportCount();for(let se=0;se<q;se++){const he=O.getViewport(se);o.set(s.x*he.x,s.y*he.y,s.x*he.z,s.y*he.w),B.viewport(o),O.updateMatrices(ne,se),r=O.getFrustum(),w(T,I,O.camera,ne,this.type)}O.isPointLightShadow!==!0&&this.type===ko&&b(O,I),O.needsUpdate=!1}y=this.type,v.needsUpdate=!1,t.setRenderTarget(N,M,P)};function b(A,T){const I=e.update(x);f.defines.VSM_SAMPLES!==A.blurSamples&&(f.defines.VSM_SAMPLES=A.blurSamples,h.defines.VSM_SAMPLES=A.blurSamples,f.needsUpdate=!0,h.needsUpdate=!0),A.mapPass===null&&(A.mapPass=new Xo(i.x,i.y)),f.uniforms.shadow_pass.value=A.map.texture,f.uniforms.resolution.value=A.mapSize,f.uniforms.radius.value=A.radius,t.setRenderTarget(A.mapPass),t.clear(),t.renderBufferDirect(T,null,I,f,x,null),h.uniforms.shadow_pass.value=A.mapPass.texture,h.uniforms.resolution.value=A.mapSize,h.uniforms.radius.value=A.radius,t.setRenderTarget(A.map),t.clear(),t.renderBufferDirect(T,null,I,h,x,null)}function S(A,T,I,N){let M=null;const P=I.isPointLight===!0?A.customDistanceMaterial:A.customDepthMaterial;if(P!==void 0)M=P;else if(M=I.isPointLight===!0?l:a,t.localClippingEnabled&&T.clipShadows===!0&&Array.isArray(T.clippingPlanes)&&T.clippingPlanes.length!==0||T.displacementMap&&T.displacementScale!==0||T.alphaMap&&T.alphaTest>0||T.map&&T.alphaTest>0){const B=M.uuid,F=T.uuid;let U=c[B];U===void 0&&(U={},c[B]=U);let j=U[F];j===void 0&&(j=M.clone(),U[F]=j,T.addEventListener("dispose",E)),M=j}if(M.visible=T.visible,M.wireframe=T.wireframe,N===ko?M.side=T.shadowSide!==null?T.shadowSide:T.side:M.side=T.shadowSide!==null?T.shadowSide:d[T.side],M.alphaMap=T.alphaMap,M.alphaTest=T.alphaTest,M.map=T.map,M.clipShadows=T.clipShadows,M.clippingPlanes=T.clippingPlanes,M.clipIntersection=T.clipIntersection,M.displacementMap=T.displacementMap,M.displacementScale=T.displacementScale,M.displacementBias=T.displacementBias,M.wireframeLinewidth=T.wireframeLinewidth,M.linewidth=T.linewidth,I.isPointLight===!0&&M.isMeshDistanceMaterial===!0){const B=t.properties.get(M);B.light=I}return M}function w(A,T,I,N,M){if(A.visible===!1)return;if(A.layers.test(T.layers)&&(A.isMesh||A.isLine||A.isPoints)&&(A.castShadow||A.receiveShadow&&M===ko)&&(!A.frustumCulled||r.intersectsObject(A))){A.modelViewMatrix.multiplyMatrices(I.matrixWorldInverse,A.matrixWorld);const F=e.update(A),U=A.material;if(Array.isArray(U)){const j=F.groups;for(let Z=0,ne=j.length;Z<ne;Z++){const O=j[Z],G=U[O.materialIndex];if(G&&G.visible){const q=S(A,G,N,M);A.onBeforeShadow(t,A,T,I,F,q,O),t.renderBufferDirect(I,null,F,q,A,O),A.onAfterShadow(t,A,T,I,F,q,O)}}}else if(U.visible){const j=S(A,U,N,M);A.onBeforeShadow(t,A,T,I,F,j,null),t.renderBufferDirect(I,null,F,j,A,null),A.onAfterShadow(t,A,T,I,F,j,null)}}const B=A.children;for(let F=0,U=B.length;F<U;F++)w(B[F],T,I,N,M)}function E(A){A.target.removeEventListener("dispose",E);for(const I in c){const N=c[I],M=A.target.uuid;M in N&&(N[M].dispose(),delete N[M])}}}function Ehe(t){function e(){let J=!1;const De=new vn;let Be=null;const ut=new vn(0,0,0,0);return{setMask:function(pt){Be!==pt&&!J&&(t.colorMask(pt,pt,pt,pt),Be=pt)},setLocked:function(pt){J=pt},setClear:function(pt,mn,hn,jt,_n){_n===!0&&(pt*=jt,mn*=jt,hn*=jt),De.set(pt,mn,hn,jt),ut.equals(De)===!1&&(t.clearColor(pt,mn,hn,jt),ut.copy(De))},reset:function(){J=!1,Be=null,ut.set(-1,0,0,0)}}}function n(){let J=!1,De=null,Be=null,ut=null;return{setTest:function(pt){pt?fe(t.DEPTH_TEST):Ee(t.DEPTH_TEST)},setMask:function(pt){De!==pt&&!J&&(t.depthMask(pt),De=pt)},setFunc:function(pt){if(Be!==pt){switch(pt){case D9:t.depthFunc(t.NEVER);break;case O9:t.depthFunc(t.ALWAYS);break;case L9:t.depthFunc(t.LESS);break;case Dg:t.depthFunc(t.LEQUAL);break;case B9:t.depthFunc(t.EQUAL);break;case F9:t.depthFunc(t.GEQUAL);break;case $9:t.depthFunc(t.GREATER);break;case U9:t.depthFunc(t.NOTEQUAL);break;default:t.depthFunc(t.LEQUAL)}Be=pt}},setLocked:function(pt){J=pt},setClear:function(pt){ut!==pt&&(t.clearDepth(pt),ut=pt)},reset:function(){J=!1,De=null,Be=null,ut=null}}}function r(){let J=!1,De=null,Be=null,ut=null,pt=null,mn=null,hn=null,jt=null,_n=null;return{setTest:function(Jt){J||(Jt?fe(t.STENCIL_TEST):Ee(t.STENCIL_TEST))},setMask:function(Jt){De!==Jt&&!J&&(t.stencilMask(Jt),De=Jt)},setFunc:function(Jt,Cr,Er){(Be!==Jt||ut!==Cr||pt!==Er)&&(t.stencilFunc(Jt,Cr,Er),Be=Jt,ut=Cr,pt=Er)},setOp:function(Jt,Cr,Er){(mn!==Jt||hn!==Cr||jt!==Er)&&(t.stencilOp(Jt,Cr,Er),mn=Jt,hn=Cr,jt=Er)},setLocked:function(Jt){J=Jt},setClear:function(Jt){_n!==Jt&&(t.clearStencil(Jt),_n=Jt)},reset:function(){J=!1,De=null,Be=null,ut=null,pt=null,mn=null,hn=null,jt=null,_n=null}}}const i=new e,s=new n,o=new r,a=new WeakMap,l=new WeakMap;let c={},u={},d=new WeakMap,f=[],h=null,p=!1,x=null,v=null,y=null,b=null,S=null,w=null,E=null,A=new Qe(0,0,0),T=0,I=!1,N=null,M=null,P=null,B=null,F=null;const U=t.getParameter(t.MAX_COMBINED_TEXTURE_IMAGE_UNITS);let j=!1,Z=0;const ne=t.getParameter(t.VERSION);ne.indexOf("WebGL")!==-1?(Z=parseFloat(/^WebGL (\d)/.exec(ne)[1]),j=Z>=1):ne.indexOf("OpenGL ES")!==-1&&(Z=parseFloat(/^OpenGL ES (\d)/.exec(ne)[1]),j=Z>=2);let O=null,G={};const q=t.getParameter(t.SCISSOR_BOX),se=t.getParameter(t.VIEWPORT),he=new vn().fromArray(q),ke=new vn().fromArray(se);function re(J,De,Be,ut){const pt=new Uint8Array(4),mn=t.createTexture();t.bindTexture(J,mn),t.texParameteri(J,t.TEXTURE_MIN_FILTER,t.NEAREST),t.texParameteri(J,t.TEXTURE_MAG_FILTER,t.NEAREST);for(let hn=0;hn<Be;hn++)J===t.TEXTURE_3D||J===t.TEXTURE_2D_ARRAY?t.texImage3D(De,0,t.RGBA,1,1,ut,0,t.RGBA,t.UNSIGNED_BYTE,pt):t.texImage2D(De+hn,0,t.RGBA,1,1,0,t.RGBA,t.UNSIGNED_BYTE,pt);return mn}const pe={};pe[t.TEXTURE_2D]=re(t.TEXTURE_2D,t.TEXTURE_2D,1),pe[t.TEXTURE_CUBE_MAP]=re(t.TEXTURE_CUBE_MAP,t.TEXTURE_CUBE_MAP_POSITIVE_X,6),pe[t.TEXTURE_2D_ARRAY]=re(t.TEXTURE_2D_ARRAY,t.TEXTURE_2D_ARRAY,1,1),pe[t.TEXTURE_3D]=re(t.TEXTURE_3D,t.TEXTURE_3D,1,1),i.setClear(0,0,0,1),s.setClear(1),o.setClear(0),fe(t.DEPTH_TEST),s.setFunc(Dg),Ie(!1),Oe(n2),fe(t.CULL_FACE),ce(cl);function fe(J){c[J]!==!0&&(t.enable(J),c[J]=!0)}function Ee(J){c[J]!==!1&&(t.disable(J),c[J]=!1)}function We(J,De){return u[J]!==De?(t.bindFramebuffer(J,De),u[J]=De,J===t.DRAW_FRAMEBUFFER&&(u[t.FRAMEBUFFER]=De),J===t.FRAMEBUFFER&&(u[t.DRAW_FRAMEBUFFER]=De),!0):!1}function je(J,De){let Be=f,ut=!1;if(J){Be=d.get(De),Be===void 0&&(Be=[],d.set(De,Be));const pt=J.textures;if(Be.length!==pt.length||Be[0]!==t.COLOR_ATTACHMENT0){for(let mn=0,hn=pt.length;mn<hn;mn++)Be[mn]=t.COLOR_ATTACHMENT0+mn;Be.length=pt.length,ut=!0}}else Be[0]!==t.BACK&&(Be[0]=t.BACK,ut=!0);ut&&t.drawBuffers(Be)}function Je(J){return h!==J?(t.useProgram(J),h=J,!0):!1}const te={[sc]:t.FUNC_ADD,[y9]:t.FUNC_SUBTRACT,[v9]:t.FUNC_REVERSE_SUBTRACT};te[x9]=t.MIN,te[b9]=t.MAX;const be={[S9]:t.ZERO,[_9]:t.ONE,[w9]:t.SRC_COLOR,[$1]:t.SRC_ALPHA,[R9]:t.SRC_ALPHA_SATURATE,[T9]:t.DST_COLOR,[E9]:t.DST_ALPHA,[C9]:t.ONE_MINUS_SRC_COLOR,[U1]:t.ONE_MINUS_SRC_ALPHA,[M9]:t.ONE_MINUS_DST_COLOR,[A9]:t.ONE_MINUS_DST_ALPHA,[I9]:t.CONSTANT_COLOR,[N9]:t.ONE_MINUS_CONSTANT_COLOR,[P9]:t.CONSTANT_ALPHA,[k9]:t.ONE_MINUS_CONSTANT_ALPHA};function ce(J,De,Be,ut,pt,mn,hn,jt,_n,Jt){if(J===cl){p===!0&&(Ee(t.BLEND),p=!1);return}if(p===!1&&(fe(t.BLEND),p=!0),J!==g9){if(J!==x||Jt!==I){if((v!==sc||S!==sc)&&(t.blendEquation(t.FUNC_ADD),v=sc,S=sc),Jt)switch(J){case qu:t.blendFuncSeparate(t.ONE,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case r2:t.blendFunc(t.ONE,t.ONE);break;case i2:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case s2:t.blendFuncSeparate(t.ZERO,t.SRC_COLOR,t.ZERO,t.SRC_ALPHA);break;default:console.error("THREE.WebGLState: Invalid blending: ",J);break}else switch(J){case qu:t.blendFuncSeparate(t.SRC_ALPHA,t.ONE_MINUS_SRC_ALPHA,t.ONE,t.ONE_MINUS_SRC_ALPHA);break;case r2:t.blendFunc(t.SRC_ALPHA,t.ONE);break;case i2:t.blendFuncSeparate(t.ZERO,t.ONE_MINUS_SRC_COLOR,t.ZERO,t.ONE);break;case s2:t.blendFunc(t.ZERO,t.SRC_COLOR);break;default:console.error("THREE.WebGLState: Invalid blending: ",J);break}y=null,b=null,w=null,E=null,A.set(0,0,0),T=0,x=J,I=Jt}return}pt=pt||De,mn=mn||Be,hn=hn||ut,(De!==v||pt!==S)&&(t.blendEquationSeparate(te[De],te[pt]),v=De,S=pt),(Be!==y||ut!==b||mn!==w||hn!==E)&&(t.blendFuncSeparate(be[Be],be[ut],be[mn],be[hn]),y=Be,b=ut,w=mn,E=hn),(jt.equals(A)===!1||_n!==T)&&(t.blendColor(jt.r,jt.g,jt.b,_n),A.copy(jt),T=_n),x=J,I=!1}function Me(J,De){J.side===Uo?Ee(t.CULL_FACE):fe(t.CULL_FACE);let Be=J.side===Fi;De&&(Be=!Be),Ie(Be),J.blending===qu&&J.transparent===!1?ce(cl):ce(J.blending,J.blendEquation,J.blendSrc,J.blendDst,J.blendEquationAlpha,J.blendSrcAlpha,J.blendDstAlpha,J.blendColor,J.blendAlpha,J.premultipliedAlpha),s.setFunc(J.depthFunc),s.setTest(J.depthTest),s.setMask(J.depthWrite),i.setMask(J.colorWrite);const ut=J.stencilWrite;o.setTest(ut),ut&&(o.setMask(J.stencilWriteMask),o.setFunc(J.stencilFunc,J.stencilRef,J.stencilFuncMask),o.setOp(J.stencilFail,J.stencilZFail,J.stencilZPass)),$(J.polygonOffset,J.polygonOffsetFactor,J.polygonOffsetUnits),J.alphaToCoverage===!0?fe(t.SAMPLE_ALPHA_TO_COVERAGE):Ee(t.SAMPLE_ALPHA_TO_COVERAGE)}function Ie(J){N!==J&&(J?t.frontFace(t.CW):t.frontFace(t.CCW),N=J)}function Oe(J){J!==h9?(fe(t.CULL_FACE),J!==M&&(J===n2?t.cullFace(t.BACK):J===p9?t.cullFace(t.FRONT):t.cullFace(t.FRONT_AND_BACK))):Ee(t.CULL_FACE),M=J}function V(J){J!==P&&(j&&t.lineWidth(J),P=J)}function $(J,De,Be){J?(fe(t.POLYGON_OFFSET_FILL),(B!==De||F!==Be)&&(t.polygonOffset(De,Be),B=De,F=Be)):Ee(t.POLYGON_OFFSET_FILL)}function ue(J){J?fe(t.SCISSOR_TEST):Ee(t.SCISSOR_TEST)}function ye(J){J===void 0&&(J=t.TEXTURE0+U-1),O!==J&&(t.activeTexture(J),O=J)}function ve(J,De,Be){Be===void 0&&(O===null?Be=t.TEXTURE0+U-1:Be=O);let ut=G[Be];ut===void 0&&(ut={type:void 0,texture:void 0},G[Be]=ut),(ut.type!==J||ut.texture!==De)&&(O!==Be&&(t.activeTexture(Be),O=Be),t.bindTexture(J,De||pe[J]),ut.type=J,ut.texture=De)}function Ne(){const J=G[O];J!==void 0&&J.type!==void 0&&(t.bindTexture(J.type,null),J.type=void 0,J.texture=void 0)}function nt(){try{t.compressedTexImage2D.apply(t,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function Ae(){try{t.compressedTexImage3D.apply(t,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function st(){try{t.texSubImage2D.apply(t,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function ht(){try{t.texSubImage3D.apply(t,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function Ue(){try{t.compressedTexSubImage2D.apply(t,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function Fe(){try{t.compressedTexSubImage3D.apply(t,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function $e(){try{t.texStorage2D.apply(t,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function Ze(){try{t.texStorage3D.apply(t,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function ot(){try{t.texImage2D.apply(t,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function Pt(){try{t.texImage3D.apply(t,arguments)}catch(J){console.error("THREE.WebGLState:",J)}}function Ge(J){he.equals(J)===!1&&(t.scissor(J.x,J.y,J.z,J.w),he.copy(J))}function yt(J){ke.equals(J)===!1&&(t.viewport(J.x,J.y,J.z,J.w),ke.copy(J))}function _t(J,De){let Be=l.get(De);Be===void 0&&(Be=new WeakMap,l.set(De,Be));let ut=Be.get(J);ut===void 0&&(ut=t.getUniformBlockIndex(De,J.name),Be.set(J,ut))}function ie(J,De){const ut=l.get(De).get(J);a.get(De)!==ut&&(t.uniformBlockBinding(De,ut,J.__bindingPointIndex),a.set(De,ut))}function _e(){t.disable(t.BLEND),t.disable(t.CULL_FACE),t.disable(t.DEPTH_TEST),t.disable(t.POLYGON_OFFSET_FILL),t.disable(t.SCISSOR_TEST),t.disable(t.STENCIL_TEST),t.disable(t.SAMPLE_ALPHA_TO_COVERAGE),t.blendEquation(t.FUNC_ADD),t.blendFunc(t.ONE,t.ZERO),t.blendFuncSeparate(t.ONE,t.ZERO,t.ONE,t.ZERO),t.blendColor(0,0,0,0),t.colorMask(!0,!0,!0,!0),t.clearColor(0,0,0,0),t.depthMask(!0),t.depthFunc(t.LESS),t.clearDepth(1),t.stencilMask(4294967295),t.stencilFunc(t.ALWAYS,0,4294967295),t.stencilOp(t.KEEP,t.KEEP,t.KEEP),t.clearStencil(0),t.cullFace(t.BACK),t.frontFace(t.CCW),t.polygonOffset(0,0),t.activeTexture(t.TEXTURE0),t.bindFramebuffer(t.FRAMEBUFFER,null),t.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),t.bindFramebuffer(t.READ_FRAMEBUFFER,null),t.useProgram(null),t.lineWidth(1),t.scissor(0,0,t.canvas.width,t.canvas.height),t.viewport(0,0,t.canvas.width,t.canvas.height),c={},O=null,G={},u={},d=new WeakMap,f=[],h=null,p=!1,x=null,v=null,y=null,b=null,S=null,w=null,E=null,A=new Qe(0,0,0),T=0,I=!1,N=null,M=null,P=null,B=null,F=null,he.set(0,0,t.canvas.width,t.canvas.height),ke.set(0,0,t.canvas.width,t.canvas.height),i.reset(),s.reset(),o.reset()}return{buffers:{color:i,depth:s,stencil:o},enable:fe,disable:Ee,bindFramebuffer:We,drawBuffers:je,useProgram:Je,setBlending:ce,setMaterial:Me,setFlipSided:Ie,setCullFace:Oe,setLineWidth:V,setPolygonOffset:$,setScissorTest:ue,activeTexture:ye,bindTexture:ve,unbindTexture:Ne,compressedTexImage2D:nt,compressedTexImage3D:Ae,texImage2D:ot,texImage3D:Pt,updateUBOMapping:_t,uniformBlockBinding:ie,texStorage2D:$e,texStorage3D:Ze,texSubImage2D:st,texSubImage3D:ht,compressedTexSubImage2D:Ue,compressedTexSubImage3D:Fe,scissor:Ge,viewport:yt,reset:_e}}function Ahe(t,e,n,r,i,s,o){const a=e.has("WEBGL_multisampled_render_to_texture")?e.get("WEBGL_multisampled_render_to_texture"):null,l=typeof navigator>"u"?!1:/OculusBrowser/g.test(navigator.userAgent),c=new Re,u=new WeakMap;let d;const f=new WeakMap;let h=!1;try{h=typeof OffscreenCanvas<"u"&&new OffscreenCanvas(1,1).getContext("2d")!==null}catch{}function p(V,$){return h?new OffscreenCanvas(V,$):Vg("canvas")}function x(V,$,ue){let ye=1;const ve=Oe(V);if((ve.width>ue||ve.height>ue)&&(ye=ue/Math.max(ve.width,ve.height)),ye<1)if(typeof HTMLImageElement<"u"&&V instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&V instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&V instanceof ImageBitmap||typeof VideoFrame<"u"&&V instanceof VideoFrame){const Ne=Math.floor(ye*ve.width),nt=Math.floor(ye*ve.height);d===void 0&&(d=p(Ne,nt));const Ae=$?p(Ne,nt):d;return Ae.width=Ne,Ae.height=nt,Ae.getContext("2d").drawImage(V,0,0,Ne,nt),console.warn("THREE.WebGLRenderer: Texture has been resized from ("+ve.width+"x"+ve.height+") to ("+Ne+"x"+nt+")."),Ae}else return"data"in V&&console.warn("THREE.WebGLRenderer: Image in DataTexture is too big ("+ve.width+"x"+ve.height+")."),V;return V}function v(V){return V.generateMipmaps&&V.minFilter!==Nr&&V.minFilter!==or}function y(V){t.generateMipmap(V)}function b(V,$,ue,ye,ve=!1){if(V!==null){if(t[V]!==void 0)return t[V];console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '"+V+"'")}let Ne=$;if($===t.RED&&(ue===t.FLOAT&&(Ne=t.R32F),ue===t.HALF_FLOAT&&(Ne=t.R16F),ue===t.UNSIGNED_BYTE&&(Ne=t.R8)),$===t.RED_INTEGER&&(ue===t.UNSIGNED_BYTE&&(Ne=t.R8UI),ue===t.UNSIGNED_SHORT&&(Ne=t.R16UI),ue===t.UNSIGNED_INT&&(Ne=t.R32UI),ue===t.BYTE&&(Ne=t.R8I),ue===t.SHORT&&(Ne=t.R16I),ue===t.INT&&(Ne=t.R32I)),$===t.RG&&(ue===t.FLOAT&&(Ne=t.RG32F),ue===t.HALF_FLOAT&&(Ne=t.RG16F),ue===t.UNSIGNED_BYTE&&(Ne=t.RG8)),$===t.RG_INTEGER&&(ue===t.UNSIGNED_BYTE&&(Ne=t.RG8UI),ue===t.UNSIGNED_SHORT&&(Ne=t.RG16UI),ue===t.UNSIGNED_INT&&(Ne=t.RG32UI),ue===t.BYTE&&(Ne=t.RG8I),ue===t.SHORT&&(Ne=t.RG16I),ue===t.INT&&(Ne=t.RG32I)),$===t.RGB&&ue===t.UNSIGNED_INT_5_9_9_9_REV&&(Ne=t.RGB9_E5),$===t.RGBA){const nt=ve?$g:gn.getTransfer(ye);ue===t.FLOAT&&(Ne=t.RGBA32F),ue===t.HALF_FLOAT&&(Ne=t.RGBA16F),ue===t.UNSIGNED_BYTE&&(Ne=nt===Tn?t.SRGB8_ALPHA8:t.RGBA8),ue===t.UNSIGNED_SHORT_4_4_4_4&&(Ne=t.RGBA4),ue===t.UNSIGNED_SHORT_5_5_5_1&&(Ne=t.RGB5_A1)}return(Ne===t.R16F||Ne===t.R32F||Ne===t.RG16F||Ne===t.RG32F||Ne===t.RGBA16F||Ne===t.RGBA32F)&&e.get("EXT_color_buffer_float"),Ne}function S(V,$){return v(V)===!0||V.isFramebufferTexture&&V.minFilter!==Nr&&V.minFilter!==or?Math.log2(Math.max($.width,$.height))+1:V.mipmaps!==void 0&&V.mipmaps.length>0?V.mipmaps.length:V.isCompressedTexture&&Array.isArray(V.image)?$.mipmaps.length:1}function w(V){const $=V.target;$.removeEventListener("dispose",w),A($),$.isVideoTexture&&u.delete($)}function E(V){const $=V.target;$.removeEventListener("dispose",E),I($)}function A(V){const $=r.get(V);if($.__webglInit===void 0)return;const ue=V.source,ye=f.get(ue);if(ye){const ve=ye[$.__cacheKey];ve.usedTimes--,ve.usedTimes===0&&T(V),Object.keys(ye).length===0&&f.delete(ue)}r.remove(V)}function T(V){const $=r.get(V);t.deleteTexture($.__webglTexture);const ue=V.source,ye=f.get(ue);delete ye[$.__cacheKey],o.memory.textures--}function I(V){const $=r.get(V);if(V.depthTexture&&V.depthTexture.dispose(),V.isWebGLCubeRenderTarget)for(let ye=0;ye<6;ye++){if(Array.isArray($.__webglFramebuffer[ye]))for(let ve=0;ve<$.__webglFramebuffer[ye].length;ve++)t.deleteFramebuffer($.__webglFramebuffer[ye][ve]);else t.deleteFramebuffer($.__webglFramebuffer[ye]);$.__webglDepthbuffer&&t.deleteRenderbuffer($.__webglDepthbuffer[ye])}else{if(Array.isArray($.__webglFramebuffer))for(let ye=0;ye<$.__webglFramebuffer.length;ye++)t.deleteFramebuffer($.__webglFramebuffer[ye]);else t.deleteFramebuffer($.__webglFramebuffer);if($.__webglDepthbuffer&&t.deleteRenderbuffer($.__webglDepthbuffer),$.__webglMultisampledFramebuffer&&t.deleteFramebuffer($.__webglMultisampledFramebuffer),$.__webglColorRenderbuffer)for(let ye=0;ye<$.__webglColorRenderbuffer.length;ye++)$.__webglColorRenderbuffer[ye]&&t.deleteRenderbuffer($.__webglColorRenderbuffer[ye]);$.__webglDepthRenderbuffer&&t.deleteRenderbuffer($.__webglDepthRenderbuffer)}const ue=V.textures;for(let ye=0,ve=ue.length;ye<ve;ye++){const Ne=r.get(ue[ye]);Ne.__webglTexture&&(t.deleteTexture(Ne.__webglTexture),o.memory.textures--),r.remove(ue[ye])}r.remove(V)}let N=0;function M(){N=0}function P(){const V=N;return V>=i.maxTextures&&console.warn("THREE.WebGLTextures: Trying to use "+V+" texture units while this GPU supports only "+i.maxTextures),N+=1,V}function B(V){const $=[];return $.push(V.wrapS),$.push(V.wrapT),$.push(V.wrapR||0),$.push(V.magFilter),$.push(V.minFilter),$.push(V.anisotropy),$.push(V.internalFormat),$.push(V.format),$.push(V.type),$.push(V.generateMipmaps),$.push(V.premultiplyAlpha),$.push(V.flipY),$.push(V.unpackAlignment),$.push(V.colorSpace),$.join()}function F(V,$){const ue=r.get(V);if(V.isVideoTexture&&Me(V),V.isRenderTargetTexture===!1&&V.version>0&&ue.__version!==V.version){const ye=V.image;if(ye===null)console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");else if(ye.complete===!1)console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");else{he(ue,V,$);return}}n.bindTexture(t.TEXTURE_2D,ue.__webglTexture,t.TEXTURE0+$)}function U(V,$){const ue=r.get(V);if(V.version>0&&ue.__version!==V.version){he(ue,V,$);return}n.bindTexture(t.TEXTURE_2D_ARRAY,ue.__webglTexture,t.TEXTURE0+$)}function j(V,$){const ue=r.get(V);if(V.version>0&&ue.__version!==V.version){he(ue,V,$);return}n.bindTexture(t.TEXTURE_3D,ue.__webglTexture,t.TEXTURE0+$)}function Z(V,$){const ue=r.get(V);if(V.version>0&&ue.__version!==V.version){ke(ue,V,$);return}n.bindTexture(t.TEXTURE_CUBE_MAP,ue.__webglTexture,t.TEXTURE0+$)}const ne={[Tc]:t.REPEAT,[ws]:t.CLAMP_TO_EDGE,[$h]:t.MIRRORED_REPEAT},O={[Nr]:t.NEAREST,[AS]:t.NEAREST_MIPMAP_NEAREST,[Du]:t.NEAREST_MIPMAP_LINEAR,[or]:t.LINEAR,[Sh]:t.LINEAR_MIPMAP_NEAREST,[ao]:t.LINEAR_MIPMAP_LINEAR},G={[f5]:t.NEVER,[v5]:t.ALWAYS,[h5]:t.LESS,[TR]:t.LEQUAL,[p5]:t.EQUAL,[y5]:t.GEQUAL,[m5]:t.GREATER,[g5]:t.NOTEQUAL};function q(V,$){if($.type===lo&&e.has("OES_texture_float_linear")===!1&&($.magFilter===or||$.magFilter===Sh||$.magFilter===Du||$.magFilter===ao||$.minFilter===or||$.minFilter===Sh||$.minFilter===Du||$.minFilter===ao)&&console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),t.texParameteri(V,t.TEXTURE_WRAP_S,ne[$.wrapS]),t.texParameteri(V,t.TEXTURE_WRAP_T,ne[$.wrapT]),(V===t.TEXTURE_3D||V===t.TEXTURE_2D_ARRAY)&&t.texParameteri(V,t.TEXTURE_WRAP_R,ne[$.wrapR]),t.texParameteri(V,t.TEXTURE_MAG_FILTER,O[$.magFilter]),t.texParameteri(V,t.TEXTURE_MIN_FILTER,O[$.minFilter]),$.compareFunction&&(t.texParameteri(V,t.TEXTURE_COMPARE_MODE,t.COMPARE_REF_TO_TEXTURE),t.texParameteri(V,t.TEXTURE_COMPARE_FUNC,G[$.compareFunction])),e.has("EXT_texture_filter_anisotropic")===!0){if($.magFilter===Nr||$.minFilter!==Du&&$.minFilter!==ao||$.type===lo&&e.has("OES_texture_float_linear")===!1)return;if($.anisotropy>1||r.get($).__currentAnisotropy){const ue=e.get("EXT_texture_filter_anisotropic");t.texParameterf(V,ue.TEXTURE_MAX_ANISOTROPY_EXT,Math.min($.anisotropy,i.getMaxAnisotropy())),r.get($).__currentAnisotropy=$.anisotropy}}}function se(V,$){let ue=!1;V.__webglInit===void 0&&(V.__webglInit=!0,$.addEventListener("dispose",w));const ye=$.source;let ve=f.get(ye);ve===void 0&&(ve={},f.set(ye,ve));const Ne=B($);if(Ne!==V.__cacheKey){ve[Ne]===void 0&&(ve[Ne]={texture:t.createTexture(),usedTimes:0},o.memory.textures++,ue=!0),ve[Ne].usedTimes++;const nt=ve[V.__cacheKey];nt!==void 0&&(ve[V.__cacheKey].usedTimes--,nt.usedTimes===0&&T($)),V.__cacheKey=Ne,V.__webglTexture=ve[Ne].texture}return ue}function he(V,$,ue){let ye=t.TEXTURE_2D;($.isDataArrayTexture||$.isCompressedArrayTexture)&&(ye=t.TEXTURE_2D_ARRAY),$.isData3DTexture&&(ye=t.TEXTURE_3D);const ve=se(V,$),Ne=$.source;n.bindTexture(ye,V.__webglTexture,t.TEXTURE0+ue);const nt=r.get(Ne);if(Ne.version!==nt.__version||ve===!0){n.activeTexture(t.TEXTURE0+ue);const Ae=gn.getPrimaries(gn.workingColorSpace),st=$.colorSpace===tl?null:gn.getPrimaries($.colorSpace),ht=$.colorSpace===tl||Ae===st?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,$.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,$.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,$.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,ht);let Ue=x($.image,!1,i.maxTextureSize);Ue=Ie($,Ue);const Fe=s.convert($.format,$.colorSpace),$e=s.convert($.type);let Ze=b($.internalFormat,Fe,$e,$.colorSpace,$.isVideoTexture);q(ye,$);let ot;const Pt=$.mipmaps,Ge=$.isVideoTexture!==!0&&Ze!==CR,yt=nt.__version===void 0||ve===!0,_t=Ne.dataReady,ie=S($,Ue);if($.isDepthTexture)Ze=t.DEPTH_COMPONENT16,$.type===lo?Ze=t.DEPTH_COMPONENT32F:$.type===pd?Ze=t.DEPTH_COMPONENT24:$.type===vp&&(Ze=t.DEPTH24_STENCIL8),yt&&(Ge?n.texStorage2D(t.TEXTURE_2D,1,Ze,Ue.width,Ue.height):n.texImage2D(t.TEXTURE_2D,0,Ze,Ue.width,Ue.height,0,Fe,$e,null));else if($.isDataTexture)if(Pt.length>0){Ge&&yt&&n.texStorage2D(t.TEXTURE_2D,ie,Ze,Pt[0].width,Pt[0].height);for(let _e=0,J=Pt.length;_e<J;_e++)ot=Pt[_e],Ge?_t&&n.texSubImage2D(t.TEXTURE_2D,_e,0,0,ot.width,ot.height,Fe,$e,ot.data):n.texImage2D(t.TEXTURE_2D,_e,Ze,ot.width,ot.height,0,Fe,$e,ot.data);$.generateMipmaps=!1}else Ge?(yt&&n.texStorage2D(t.TEXTURE_2D,ie,Ze,Ue.width,Ue.height),_t&&n.texSubImage2D(t.TEXTURE_2D,0,0,0,Ue.width,Ue.height,Fe,$e,Ue.data)):n.texImage2D(t.TEXTURE_2D,0,Ze,Ue.width,Ue.height,0,Fe,$e,Ue.data);else if($.isCompressedTexture)if($.isCompressedArrayTexture){Ge&&yt&&n.texStorage3D(t.TEXTURE_2D_ARRAY,ie,Ze,Pt[0].width,Pt[0].height,Ue.depth);for(let _e=0,J=Pt.length;_e<J;_e++)ot=Pt[_e],$.format!==Yi?Fe!==null?Ge?_t&&n.compressedTexSubImage3D(t.TEXTURE_2D_ARRAY,_e,0,0,0,ot.width,ot.height,Ue.depth,Fe,ot.data,0,0):n.compressedTexImage3D(t.TEXTURE_2D_ARRAY,_e,Ze,ot.width,ot.height,Ue.depth,0,ot.data,0,0):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Ge?_t&&n.texSubImage3D(t.TEXTURE_2D_ARRAY,_e,0,0,0,ot.width,ot.height,Ue.depth,Fe,$e,ot.data):n.texImage3D(t.TEXTURE_2D_ARRAY,_e,Ze,ot.width,ot.height,Ue.depth,0,Fe,$e,ot.data)}else{Ge&&yt&&n.texStorage2D(t.TEXTURE_2D,ie,Ze,Pt[0].width,Pt[0].height);for(let _e=0,J=Pt.length;_e<J;_e++)ot=Pt[_e],$.format!==Yi?Fe!==null?Ge?_t&&n.compressedTexSubImage2D(t.TEXTURE_2D,_e,0,0,ot.width,ot.height,Fe,ot.data):n.compressedTexImage2D(t.TEXTURE_2D,_e,Ze,ot.width,ot.height,0,ot.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"):Ge?_t&&n.texSubImage2D(t.TEXTURE_2D,_e,0,0,ot.width,ot.height,Fe,$e,ot.data):n.texImage2D(t.TEXTURE_2D,_e,Ze,ot.width,ot.height,0,Fe,$e,ot.data)}else if($.isDataArrayTexture)Ge?(yt&&n.texStorage3D(t.TEXTURE_2D_ARRAY,ie,Ze,Ue.width,Ue.height,Ue.depth),_t&&n.texSubImage3D(t.TEXTURE_2D_ARRAY,0,0,0,0,Ue.width,Ue.height,Ue.depth,Fe,$e,Ue.data)):n.texImage3D(t.TEXTURE_2D_ARRAY,0,Ze,Ue.width,Ue.height,Ue.depth,0,Fe,$e,Ue.data);else if($.isData3DTexture)Ge?(yt&&n.texStorage3D(t.TEXTURE_3D,ie,Ze,Ue.width,Ue.height,Ue.depth),_t&&n.texSubImage3D(t.TEXTURE_3D,0,0,0,0,Ue.width,Ue.height,Ue.depth,Fe,$e,Ue.data)):n.texImage3D(t.TEXTURE_3D,0,Ze,Ue.width,Ue.height,Ue.depth,0,Fe,$e,Ue.data);else if($.isFramebufferTexture){if(yt)if(Ge)n.texStorage2D(t.TEXTURE_2D,ie,Ze,Ue.width,Ue.height);else{let _e=Ue.width,J=Ue.height;for(let De=0;De<ie;De++)n.texImage2D(t.TEXTURE_2D,De,Ze,_e,J,0,Fe,$e,null),_e>>=1,J>>=1}}else if(Pt.length>0){if(Ge&&yt){const _e=Oe(Pt[0]);n.texStorage2D(t.TEXTURE_2D,ie,Ze,_e.width,_e.height)}for(let _e=0,J=Pt.length;_e<J;_e++)ot=Pt[_e],Ge?_t&&n.texSubImage2D(t.TEXTURE_2D,_e,0,0,Fe,$e,ot):n.texImage2D(t.TEXTURE_2D,_e,Ze,Fe,$e,ot);$.generateMipmaps=!1}else if(Ge){if(yt){const _e=Oe(Ue);n.texStorage2D(t.TEXTURE_2D,ie,Ze,_e.width,_e.height)}_t&&n.texSubImage2D(t.TEXTURE_2D,0,0,0,Fe,$e,Ue)}else n.texImage2D(t.TEXTURE_2D,0,Ze,Fe,$e,Ue);v($)&&y(ye),nt.__version=Ne.version,$.onUpdate&&$.onUpdate($)}V.__version=$.version}function ke(V,$,ue){if($.image.length!==6)return;const ye=se(V,$),ve=$.source;n.bindTexture(t.TEXTURE_CUBE_MAP,V.__webglTexture,t.TEXTURE0+ue);const Ne=r.get(ve);if(ve.version!==Ne.__version||ye===!0){n.activeTexture(t.TEXTURE0+ue);const nt=gn.getPrimaries(gn.workingColorSpace),Ae=$.colorSpace===tl?null:gn.getPrimaries($.colorSpace),st=$.colorSpace===tl||nt===Ae?t.NONE:t.BROWSER_DEFAULT_WEBGL;t.pixelStorei(t.UNPACK_FLIP_Y_WEBGL,$.flipY),t.pixelStorei(t.UNPACK_PREMULTIPLY_ALPHA_WEBGL,$.premultiplyAlpha),t.pixelStorei(t.UNPACK_ALIGNMENT,$.unpackAlignment),t.pixelStorei(t.UNPACK_COLORSPACE_CONVERSION_WEBGL,st);const ht=$.isCompressedTexture||$.image[0].isCompressedTexture,Ue=$.image[0]&&$.image[0].isDataTexture,Fe=[];for(let J=0;J<6;J++)!ht&&!Ue?Fe[J]=x($.image[J],!0,i.maxCubemapSize):Fe[J]=Ue?$.image[J].image:$.image[J],Fe[J]=Ie($,Fe[J]);const $e=Fe[0],Ze=s.convert($.format,$.colorSpace),ot=s.convert($.type),Pt=b($.internalFormat,Ze,ot,$.colorSpace),Ge=$.isVideoTexture!==!0,yt=Ne.__version===void 0||ye===!0,_t=ve.dataReady;let ie=S($,$e);q(t.TEXTURE_CUBE_MAP,$);let _e;if(ht){Ge&&yt&&n.texStorage2D(t.TEXTURE_CUBE_MAP,ie,Pt,$e.width,$e.height);for(let J=0;J<6;J++){_e=Fe[J].mipmaps;for(let De=0;De<_e.length;De++){const Be=_e[De];$.format!==Yi?Ze!==null?Ge?_t&&n.compressedTexSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+J,De,0,0,Be.width,Be.height,Ze,Be.data):n.compressedTexImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+J,De,Pt,Be.width,Be.height,0,Be.data):console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"):Ge?_t&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+J,De,0,0,Be.width,Be.height,Ze,ot,Be.data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+J,De,Pt,Be.width,Be.height,0,Ze,ot,Be.data)}}}else{if(_e=$.mipmaps,Ge&&yt){_e.length>0&&ie++;const J=Oe(Fe[0]);n.texStorage2D(t.TEXTURE_CUBE_MAP,ie,Pt,J.width,J.height)}for(let J=0;J<6;J++)if(Ue){Ge?_t&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+J,0,0,0,Fe[J].width,Fe[J].height,Ze,ot,Fe[J].data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+J,0,Pt,Fe[J].width,Fe[J].height,0,Ze,ot,Fe[J].data);for(let De=0;De<_e.length;De++){const ut=_e[De].image[J].image;Ge?_t&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+J,De+1,0,0,ut.width,ut.height,Ze,ot,ut.data):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+J,De+1,Pt,ut.width,ut.height,0,Ze,ot,ut.data)}}else{Ge?_t&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+J,0,0,0,Ze,ot,Fe[J]):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+J,0,Pt,Ze,ot,Fe[J]);for(let De=0;De<_e.length;De++){const Be=_e[De];Ge?_t&&n.texSubImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+J,De+1,0,0,Ze,ot,Be.image[J]):n.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X+J,De+1,Pt,Ze,ot,Be.image[J])}}}v($)&&y(t.TEXTURE_CUBE_MAP),Ne.__version=ve.version,$.onUpdate&&$.onUpdate($)}V.__version=$.version}function re(V,$,ue,ye,ve,Ne){const nt=s.convert(ue.format,ue.colorSpace),Ae=s.convert(ue.type),st=b(ue.internalFormat,nt,Ae,ue.colorSpace);if(!r.get($).__hasExternalTextures){const Ue=Math.max(1,$.width>>Ne),Fe=Math.max(1,$.height>>Ne);ve===t.TEXTURE_3D||ve===t.TEXTURE_2D_ARRAY?n.texImage3D(ve,Ne,st,Ue,Fe,$.depth,0,nt,Ae,null):n.texImage2D(ve,Ne,st,Ue,Fe,0,nt,Ae,null)}n.bindFramebuffer(t.FRAMEBUFFER,V),ce($)?a.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,ye,ve,r.get(ue).__webglTexture,0,be($)):(ve===t.TEXTURE_2D||ve>=t.TEXTURE_CUBE_MAP_POSITIVE_X&&ve<=t.TEXTURE_CUBE_MAP_NEGATIVE_Z)&&t.framebufferTexture2D(t.FRAMEBUFFER,ye,ve,r.get(ue).__webglTexture,Ne),n.bindFramebuffer(t.FRAMEBUFFER,null)}function pe(V,$,ue){if(t.bindRenderbuffer(t.RENDERBUFFER,V),$.depthBuffer&&!$.stencilBuffer){let ye=t.DEPTH_COMPONENT24;if(ue||ce($)){const ve=$.depthTexture;ve&&ve.isDepthTexture&&(ve.type===lo?ye=t.DEPTH_COMPONENT32F:ve.type===pd&&(ye=t.DEPTH_COMPONENT24));const Ne=be($);ce($)?a.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,Ne,ye,$.width,$.height):t.renderbufferStorageMultisample(t.RENDERBUFFER,Ne,ye,$.width,$.height)}else t.renderbufferStorage(t.RENDERBUFFER,ye,$.width,$.height);t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.RENDERBUFFER,V)}else if($.depthBuffer&&$.stencilBuffer){const ye=be($);ue&&ce($)===!1?t.renderbufferStorageMultisample(t.RENDERBUFFER,ye,t.DEPTH24_STENCIL8,$.width,$.height):ce($)?a.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,ye,t.DEPTH24_STENCIL8,$.width,$.height):t.renderbufferStorage(t.RENDERBUFFER,t.DEPTH_STENCIL,$.width,$.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.RENDERBUFFER,V)}else{const ye=$.textures;for(let ve=0;ve<ye.length;ve++){const Ne=ye[ve],nt=s.convert(Ne.format,Ne.colorSpace),Ae=s.convert(Ne.type),st=b(Ne.internalFormat,nt,Ae,Ne.colorSpace),ht=be($);ue&&ce($)===!1?t.renderbufferStorageMultisample(t.RENDERBUFFER,ht,st,$.width,$.height):ce($)?a.renderbufferStorageMultisampleEXT(t.RENDERBUFFER,ht,st,$.width,$.height):t.renderbufferStorage(t.RENDERBUFFER,st,$.width,$.height)}}t.bindRenderbuffer(t.RENDERBUFFER,null)}function fe(V,$){if($&&$.isWebGLCubeRenderTarget)throw new Error("Depth Texture with cube render targets is not supported");if(n.bindFramebuffer(t.FRAMEBUFFER,V),!($.depthTexture&&$.depthTexture.isDepthTexture))throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");(!r.get($.depthTexture).__webglTexture||$.depthTexture.image.width!==$.width||$.depthTexture.image.height!==$.height)&&($.depthTexture.image.width=$.width,$.depthTexture.image.height=$.height,$.depthTexture.needsUpdate=!0),F($.depthTexture,0);const ye=r.get($.depthTexture).__webglTexture,ve=be($);if($.depthTexture.format===Ju)ce($)?a.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,ye,0,ve):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_ATTACHMENT,t.TEXTURE_2D,ye,0);else if($.depthTexture.format===Uh)ce($)?a.framebufferTexture2DMultisampleEXT(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,ye,0,ve):t.framebufferTexture2D(t.FRAMEBUFFER,t.DEPTH_STENCIL_ATTACHMENT,t.TEXTURE_2D,ye,0);else throw new Error("Unknown depthTexture format")}function Ee(V){const $=r.get(V),ue=V.isWebGLCubeRenderTarget===!0;if(V.depthTexture&&!$.__autoAllocateDepthBuffer){if(ue)throw new Error("target.depthTexture not supported in Cube render targets");fe($.__webglFramebuffer,V)}else if(ue){$.__webglDepthbuffer=[];for(let ye=0;ye<6;ye++)n.bindFramebuffer(t.FRAMEBUFFER,$.__webglFramebuffer[ye]),$.__webglDepthbuffer[ye]=t.createRenderbuffer(),pe($.__webglDepthbuffer[ye],V,!1)}else n.bindFramebuffer(t.FRAMEBUFFER,$.__webglFramebuffer),$.__webglDepthbuffer=t.createRenderbuffer(),pe($.__webglDepthbuffer,V,!1);n.bindFramebuffer(t.FRAMEBUFFER,null)}function We(V,$,ue){const ye=r.get(V);$!==void 0&&re(ye.__webglFramebuffer,V,V.texture,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,0),ue!==void 0&&Ee(V)}function je(V){const $=V.texture,ue=r.get(V),ye=r.get($);V.addEventListener("dispose",E);const ve=V.textures,Ne=V.isWebGLCubeRenderTarget===!0,nt=ve.length>1;if(nt||(ye.__webglTexture===void 0&&(ye.__webglTexture=t.createTexture()),ye.__version=$.version,o.memory.textures++),Ne){ue.__webglFramebuffer=[];for(let Ae=0;Ae<6;Ae++)if($.mipmaps&&$.mipmaps.length>0){ue.__webglFramebuffer[Ae]=[];for(let st=0;st<$.mipmaps.length;st++)ue.__webglFramebuffer[Ae][st]=t.createFramebuffer()}else ue.__webglFramebuffer[Ae]=t.createFramebuffer()}else{if($.mipmaps&&$.mipmaps.length>0){ue.__webglFramebuffer=[];for(let Ae=0;Ae<$.mipmaps.length;Ae++)ue.__webglFramebuffer[Ae]=t.createFramebuffer()}else ue.__webglFramebuffer=t.createFramebuffer();if(nt)for(let Ae=0,st=ve.length;Ae<st;Ae++){const ht=r.get(ve[Ae]);ht.__webglTexture===void 0&&(ht.__webglTexture=t.createTexture(),o.memory.textures++)}if(V.samples>0&&ce(V)===!1){ue.__webglMultisampledFramebuffer=t.createFramebuffer(),ue.__webglColorRenderbuffer=[],n.bindFramebuffer(t.FRAMEBUFFER,ue.__webglMultisampledFramebuffer);for(let Ae=0;Ae<ve.length;Ae++){const st=ve[Ae];ue.__webglColorRenderbuffer[Ae]=t.createRenderbuffer(),t.bindRenderbuffer(t.RENDERBUFFER,ue.__webglColorRenderbuffer[Ae]);const ht=s.convert(st.format,st.colorSpace),Ue=s.convert(st.type),Fe=b(st.internalFormat,ht,Ue,st.colorSpace,V.isXRRenderTarget===!0),$e=be(V);t.renderbufferStorageMultisample(t.RENDERBUFFER,$e,Fe,V.width,V.height),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+Ae,t.RENDERBUFFER,ue.__webglColorRenderbuffer[Ae])}t.bindRenderbuffer(t.RENDERBUFFER,null),V.depthBuffer&&(ue.__webglDepthRenderbuffer=t.createRenderbuffer(),pe(ue.__webglDepthRenderbuffer,V,!0)),n.bindFramebuffer(t.FRAMEBUFFER,null)}}if(Ne){n.bindTexture(t.TEXTURE_CUBE_MAP,ye.__webglTexture),q(t.TEXTURE_CUBE_MAP,$);for(let Ae=0;Ae<6;Ae++)if($.mipmaps&&$.mipmaps.length>0)for(let st=0;st<$.mipmaps.length;st++)re(ue.__webglFramebuffer[Ae][st],V,$,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+Ae,st);else re(ue.__webglFramebuffer[Ae],V,$,t.COLOR_ATTACHMENT0,t.TEXTURE_CUBE_MAP_POSITIVE_X+Ae,0);v($)&&y(t.TEXTURE_CUBE_MAP),n.unbindTexture()}else if(nt){for(let Ae=0,st=ve.length;Ae<st;Ae++){const ht=ve[Ae],Ue=r.get(ht);n.bindTexture(t.TEXTURE_2D,Ue.__webglTexture),q(t.TEXTURE_2D,ht),re(ue.__webglFramebuffer,V,ht,t.COLOR_ATTACHMENT0+Ae,t.TEXTURE_2D,0),v(ht)&&y(t.TEXTURE_2D)}n.unbindTexture()}else{let Ae=t.TEXTURE_2D;if((V.isWebGL3DRenderTarget||V.isWebGLArrayRenderTarget)&&(Ae=V.isWebGL3DRenderTarget?t.TEXTURE_3D:t.TEXTURE_2D_ARRAY),n.bindTexture(Ae,ye.__webglTexture),q(Ae,$),$.mipmaps&&$.mipmaps.length>0)for(let st=0;st<$.mipmaps.length;st++)re(ue.__webglFramebuffer[st],V,$,t.COLOR_ATTACHMENT0,Ae,st);else re(ue.__webglFramebuffer,V,$,t.COLOR_ATTACHMENT0,Ae,0);v($)&&y(Ae),n.unbindTexture()}V.depthBuffer&&Ee(V)}function Je(V){const $=V.textures;for(let ue=0,ye=$.length;ue<ye;ue++){const ve=$[ue];if(v(ve)){const Ne=V.isWebGLCubeRenderTarget?t.TEXTURE_CUBE_MAP:t.TEXTURE_2D,nt=r.get(ve).__webglTexture;n.bindTexture(Ne,nt),y(Ne),n.unbindTexture()}}}function te(V){if(V.samples>0&&ce(V)===!1){const $=V.textures,ue=V.width,ye=V.height;let ve=t.COLOR_BUFFER_BIT;const Ne=[],nt=V.stencilBuffer?t.DEPTH_STENCIL_ATTACHMENT:t.DEPTH_ATTACHMENT,Ae=r.get(V),st=$.length>1;if(st)for(let ht=0;ht<$.length;ht++)n.bindFramebuffer(t.FRAMEBUFFER,Ae.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+ht,t.RENDERBUFFER,null),n.bindFramebuffer(t.FRAMEBUFFER,Ae.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+ht,t.TEXTURE_2D,null,0);n.bindFramebuffer(t.READ_FRAMEBUFFER,Ae.__webglMultisampledFramebuffer),n.bindFramebuffer(t.DRAW_FRAMEBUFFER,Ae.__webglFramebuffer);for(let ht=0;ht<$.length;ht++){Ne.push(t.COLOR_ATTACHMENT0+ht),V.depthBuffer&&Ne.push(nt);const Ue=Ae.__ignoreDepthValues!==void 0?Ae.__ignoreDepthValues:!1;if(Ue===!1&&(V.depthBuffer&&(ve|=t.DEPTH_BUFFER_BIT),V.stencilBuffer&&Ae.__isTransmissionRenderTarget!==!0&&(ve|=t.STENCIL_BUFFER_BIT)),st&&t.framebufferRenderbuffer(t.READ_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.RENDERBUFFER,Ae.__webglColorRenderbuffer[ht]),Ue===!0&&(t.invalidateFramebuffer(t.READ_FRAMEBUFFER,[nt]),t.invalidateFramebuffer(t.DRAW_FRAMEBUFFER,[nt])),st){const Fe=r.get($[ht]).__webglTexture;t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,Fe,0)}t.blitFramebuffer(0,0,ue,ye,0,0,ue,ye,ve,t.NEAREST),l&&t.invalidateFramebuffer(t.READ_FRAMEBUFFER,Ne)}if(n.bindFramebuffer(t.READ_FRAMEBUFFER,null),n.bindFramebuffer(t.DRAW_FRAMEBUFFER,null),st)for(let ht=0;ht<$.length;ht++){n.bindFramebuffer(t.FRAMEBUFFER,Ae.__webglMultisampledFramebuffer),t.framebufferRenderbuffer(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0+ht,t.RENDERBUFFER,Ae.__webglColorRenderbuffer[ht]);const Ue=r.get($[ht]).__webglTexture;n.bindFramebuffer(t.FRAMEBUFFER,Ae.__webglFramebuffer),t.framebufferTexture2D(t.DRAW_FRAMEBUFFER,t.COLOR_ATTACHMENT0+ht,t.TEXTURE_2D,Ue,0)}n.bindFramebuffer(t.DRAW_FRAMEBUFFER,Ae.__webglMultisampledFramebuffer)}}function be(V){return Math.min(i.maxSamples,V.samples)}function ce(V){const $=r.get(V);return V.samples>0&&e.has("WEBGL_multisampled_render_to_texture")===!0&&$.__useRenderToTexture!==!1}function Me(V){const $=o.render.frame;u.get(V)!==$&&(u.set(V,$),V.update())}function Ie(V,$){const ue=V.colorSpace,ye=V.format,ve=V.type;return V.isCompressedTexture===!0||V.isVideoTexture===!0||ue!==Ml&&ue!==tl&&(gn.getTransfer(ue)===Tn?(ye!==Yi||ve!==Ea)&&console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."):console.error("THREE.WebGLTextures: Unsupported texture color space:",ue)),$}function Oe(V){return typeof HTMLImageElement<"u"&&V instanceof HTMLImageElement?(c.width=V.naturalWidth||V.width,c.height=V.naturalHeight||V.height):typeof VideoFrame<"u"&&V instanceof VideoFrame?(c.width=V.displayWidth,c.height=V.displayHeight):(c.width=V.width,c.height=V.height),c}this.allocateTextureUnit=P,this.resetTextureUnits=M,this.setTexture2D=F,this.setTexture2DArray=U,this.setTexture3D=j,this.setTextureCube=Z,this.rebindTextures=We,this.setupRenderTarget=je,this.updateRenderTargetMipmap=Je,this.updateMultisampleRenderTarget=te,this.setupDepthRenderbuffer=Ee,this.setupFrameBufferTexture=re,this.useMultisampledRTT=ce}function L5(t,e){function n(r,i=tl){let s;const o=gn.getTransfer(i);if(r===Ea)return t.UNSIGNED_BYTE;if(r===vR)return t.UNSIGNED_SHORT_4_4_4_4;if(r===xR)return t.UNSIGNED_SHORT_5_5_5_1;if(r===Q9)return t.UNSIGNED_INT_5_9_9_9_REV;if(r===J9)return t.BYTE;if(r===Y9)return t.SHORT;if(r===gR)return t.UNSIGNED_SHORT;if(r===yR)return t.INT;if(r===pd)return t.UNSIGNED_INT;if(r===lo)return t.FLOAT;if(r===Bg)return t.HALF_FLOAT;if(r===Z9)return t.ALPHA;if(r===e5)return t.RGB;if(r===Yi)return t.RGBA;if(r===t5)return t.LUMINANCE;if(r===n5)return t.LUMINANCE_ALPHA;if(r===Ju)return t.DEPTH_COMPONENT;if(r===Uh)return t.DEPTH_STENCIL;if(r===bR)return t.RED;if(r===SR)return t.RED_INTEGER;if(r===r5)return t.RG;if(r===_R)return t.RG_INTEGER;if(r===wR)return t.RGBA_INTEGER;if(r===Xx||r===Kx||r===qx||r===Jx)if(o===Tn)if(s=e.get("WEBGL_compressed_texture_s3tc_srgb"),s!==null){if(r===Xx)return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(r===Kx)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(r===qx)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(r===Jx)return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else return null;else if(s=e.get("WEBGL_compressed_texture_s3tc"),s!==null){if(r===Xx)return s.COMPRESSED_RGB_S3TC_DXT1_EXT;if(r===Kx)return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(r===qx)return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(r===Jx)return s.COMPRESSED_RGBA_S3TC_DXT5_EXT}else return null;if(r===a2||r===l2||r===c2||r===u2)if(s=e.get("WEBGL_compressed_texture_pvrtc"),s!==null){if(r===a2)return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(r===l2)return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(r===c2)return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(r===u2)return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}else return null;if(r===CR)return s=e.get("WEBGL_compressed_texture_etc1"),s!==null?s.COMPRESSED_RGB_ETC1_WEBGL:null;if(r===d2||r===f2)if(s=e.get("WEBGL_compressed_texture_etc"),s!==null){if(r===d2)return o===Tn?s.COMPRESSED_SRGB8_ETC2:s.COMPRESSED_RGB8_ETC2;if(r===f2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:s.COMPRESSED_RGBA8_ETC2_EAC}else return null;if(r===h2||r===p2||r===m2||r===g2||r===y2||r===v2||r===x2||r===b2||r===S2||r===_2||r===w2||r===C2||r===E2||r===A2)if(s=e.get("WEBGL_compressed_texture_astc"),s!==null){if(r===h2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:s.COMPRESSED_RGBA_ASTC_4x4_KHR;if(r===p2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:s.COMPRESSED_RGBA_ASTC_5x4_KHR;if(r===m2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:s.COMPRESSED_RGBA_ASTC_5x5_KHR;if(r===g2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:s.COMPRESSED_RGBA_ASTC_6x5_KHR;if(r===y2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:s.COMPRESSED_RGBA_ASTC_6x6_KHR;if(r===v2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:s.COMPRESSED_RGBA_ASTC_8x5_KHR;if(r===x2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:s.COMPRESSED_RGBA_ASTC_8x6_KHR;if(r===b2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:s.COMPRESSED_RGBA_ASTC_8x8_KHR;if(r===S2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:s.COMPRESSED_RGBA_ASTC_10x5_KHR;if(r===_2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:s.COMPRESSED_RGBA_ASTC_10x6_KHR;if(r===w2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:s.COMPRESSED_RGBA_ASTC_10x8_KHR;if(r===C2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:s.COMPRESSED_RGBA_ASTC_10x10_KHR;if(r===E2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:s.COMPRESSED_RGBA_ASTC_12x10_KHR;if(r===A2)return o===Tn?s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:s.COMPRESSED_RGBA_ASTC_12x12_KHR}else return null;if(r===Yx||r===T2||r===M2)if(s=e.get("EXT_texture_compression_bptc"),s!==null){if(r===Yx)return o===Tn?s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:s.COMPRESSED_RGBA_BPTC_UNORM_EXT;if(r===T2)return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;if(r===M2)return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT}else return null;if(r===i5||r===R2||r===I2||r===N2)if(s=e.get("EXT_texture_compression_rgtc"),s!==null){if(r===Yx)return s.COMPRESSED_RED_RGTC1_EXT;if(r===R2)return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(r===I2)return s.COMPRESSED_RED_GREEN_RGTC2_EXT;if(r===N2)return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}else return null;return r===vp?t.UNSIGNED_INT_24_8:t[r]!==void 0?t[r]:null}return{convert:n}}class B5 extends Hn{constructor(e=[]){super(),this.isArrayCamera=!0,this.cameras=e}}class Ho extends Zt{constructor(){super(),this.isGroup=!0,this.type="Group"}}const The={type:"move"};class qC{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return this._hand===null&&(this._hand=new Ho,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return this._targetRay===null&&(this._targetRay=new Ho,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new K,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new K),this._targetRay}getGripSpace(){return this._grip===null&&(this._grip=new Ho,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new K,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new K),this._grip}dispatchEvent(e){return this._targetRay!==null&&this._targetRay.dispatchEvent(e),this._grip!==null&&this._grip.dispatchEvent(e),this._hand!==null&&this._hand.dispatchEvent(e),this}connect(e){if(e&&e.hand){const n=this._hand;if(n)for(const r of e.hand.values())this._getHandJoint(n,r)}return this.dispatchEvent({type:"connected",data:e}),this}disconnect(e){return this.dispatchEvent({type:"disconnected",data:e}),this._targetRay!==null&&(this._targetRay.visible=!1),this._grip!==null&&(this._grip.visible=!1),this._hand!==null&&(this._hand.visible=!1),this}update(e,n,r){let i=null,s=null,o=null;const a=this._targetRay,l=this._grip,c=this._hand;if(e&&n.session.visibilityState!=="visible-blurred"){if(c&&e.hand){o=!0;for(const x of e.hand.values()){const v=n.getJointPose(x,r),y=this._getHandJoint(c,x);v!==null&&(y.matrix.fromArray(v.transform.matrix),y.matrix.decompose(y.position,y.rotation,y.scale),y.matrixWorldNeedsUpdate=!0,y.jointRadius=v.radius),y.visible=v!==null}const u=c.joints["index-finger-tip"],d=c.joints["thumb-tip"],f=u.position.distanceTo(d.position),h=.02,p=.005;c.inputState.pinching&&f>h+p?(c.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:e.handedness,target:this})):!c.inputState.pinching&&f<=h-p&&(c.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:e.handedness,target:this}))}else l!==null&&e.gripSpace&&(s=n.getPose(e.gripSpace,r),s!==null&&(l.matrix.fromArray(s.transform.matrix),l.matrix.decompose(l.position,l.rotation,l.scale),l.matrixWorldNeedsUpdate=!0,s.linearVelocity?(l.hasLinearVelocity=!0,l.linearVelocity.copy(s.linearVelocity)):l.hasLinearVelocity=!1,s.angularVelocity?(l.hasAngularVelocity=!0,l.angularVelocity.copy(s.angularVelocity)):l.hasAngularVelocity=!1));a!==null&&(i=n.getPose(e.targetRaySpace,r),i===null&&s!==null&&(i=s),i!==null&&(a.matrix.fromArray(i.transform.matrix),a.matrix.decompose(a.position,a.rotation,a.scale),a.matrixWorldNeedsUpdate=!0,i.linearVelocity?(a.hasLinearVelocity=!0,a.linearVelocity.copy(i.linearVelocity)):a.hasLinearVelocity=!1,i.angularVelocity?(a.hasAngularVelocity=!0,a.angularVelocity.copy(i.angularVelocity)):a.hasAngularVelocity=!1,this.dispatchEvent(The)))}return a!==null&&(a.visible=i!==null),l!==null&&(l.visible=s!==null),c!==null&&(c.visible=o!==null),this}_getHandJoint(e,n){if(e.joints[n.jointName]===void 0){const r=new Ho;r.matrixAutoUpdate=!1,r.visible=!1,e.joints[n.jointName]=r,e.add(r)}return e.joints[n.jointName]}}const Mhe=`
void main() {

	gl_Position = vec4( position, 1.0 );

}`,Rhe=`
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;class Ihe{constructor(){this.texture=null,this.mesh=null,this.depthNear=0,this.depthFar=0}init(e,n,r){if(this.texture===null){const i=new Bn,s=e.properties.get(i);s.__webglTexture=n.texture,(n.depthNear!=r.depthNear||n.depthFar!=r.depthFar)&&(this.depthNear=n.depthNear,this.depthFar=n.depthFar),this.texture=i}}render(e,n){if(this.texture!==null){if(this.mesh===null){const r=n.cameras[0].viewport,i=new Ko({vertexShader:Mhe,fragmentShader:Rhe,uniforms:{depthColor:{value:this.texture},depthWidth:{value:r.z},depthHeight:{value:r.w}}});this.mesh=new lr(new kd(20,20),i)}e.render(this.mesh,n)}}reset(){this.texture=null,this.mesh=null}}class Nhe extends ka{constructor(e,n){super();const r=this;let i=null,s=1,o=null,a="local-floor",l=1,c=null,u=null,d=null,f=null,h=null,p=null;const x=new Ihe,v=n.getContextAttributes();let y=null,b=null;const S=[],w=[],E=new Re;let A=null;const T=new Hn;T.layers.enable(1),T.viewport=new vn;const I=new Hn;I.layers.enable(2),I.viewport=new vn;const N=[T,I],M=new B5;M.layers.enable(1),M.layers.enable(2);let P=null,B=null;this.cameraAutoUpdate=!0,this.enabled=!1,this.isPresenting=!1,this.getController=function(re){let pe=S[re];return pe===void 0&&(pe=new qC,S[re]=pe),pe.getTargetRaySpace()},this.getControllerGrip=function(re){let pe=S[re];return pe===void 0&&(pe=new qC,S[re]=pe),pe.getGripSpace()},this.getHand=function(re){let pe=S[re];return pe===void 0&&(pe=new qC,S[re]=pe),pe.getHandSpace()};function F(re){const pe=w.indexOf(re.inputSource);if(pe===-1)return;const fe=S[pe];fe!==void 0&&(fe.update(re.inputSource,re.frame,c||o),fe.dispatchEvent({type:re.type,data:re.inputSource}))}function U(){i.removeEventListener("select",F),i.removeEventListener("selectstart",F),i.removeEventListener("selectend",F),i.removeEventListener("squeeze",F),i.removeEventListener("squeezestart",F),i.removeEventListener("squeezeend",F),i.removeEventListener("end",U),i.removeEventListener("inputsourceschange",j);for(let re=0;re<S.length;re++){const pe=w[re];pe!==null&&(w[re]=null,S[re].disconnect(pe))}P=null,B=null,x.reset(),e.setRenderTarget(y),h=null,f=null,d=null,i=null,b=null,ke.stop(),r.isPresenting=!1,e.setPixelRatio(A),e.setSize(E.width,E.height,!1),r.dispatchEvent({type:"sessionend"})}this.setFramebufferScaleFactor=function(re){s=re,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")},this.setReferenceSpaceType=function(re){a=re,r.isPresenting===!0&&console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")},this.getReferenceSpace=function(){return c||o},this.setReferenceSpace=function(re){c=re},this.getBaseLayer=function(){return f!==null?f:h},this.getBinding=function(){return d},this.getFrame=function(){return p},this.getSession=function(){return i},this.setSession=async function(re){if(i=re,i!==null){if(y=e.getRenderTarget(),i.addEventListener("select",F),i.addEventListener("selectstart",F),i.addEventListener("selectend",F),i.addEventListener("squeeze",F),i.addEventListener("squeezestart",F),i.addEventListener("squeezeend",F),i.addEventListener("end",U),i.addEventListener("inputsourceschange",j),v.xrCompatible!==!0&&await n.makeXRCompatible(),A=e.getPixelRatio(),e.getSize(E),i.renderState.layers===void 0){const pe={antialias:v.antialias,alpha:!0,depth:v.depth,stencil:v.stencil,framebufferScaleFactor:s};h=new XRWebGLLayer(i,n,pe),i.updateRenderState({baseLayer:h}),e.setPixelRatio(1),e.setSize(h.framebufferWidth,h.framebufferHeight,!1),b=new Xo(h.framebufferWidth,h.framebufferHeight,{format:Yi,type:Ea,colorSpace:e.outputColorSpace,stencilBuffer:v.stencil})}else{let pe=null,fe=null,Ee=null;v.depth&&(Ee=v.stencil?n.DEPTH24_STENCIL8:n.DEPTH_COMPONENT24,pe=v.stencil?Uh:Ju,fe=v.stencil?vp:pd);const We={colorFormat:n.RGBA8,depthFormat:Ee,scaleFactor:s};d=new XRWebGLBinding(i,n),f=d.createProjectionLayer(We),i.updateRenderState({layers:[f]}),e.setPixelRatio(1),e.setSize(f.textureWidth,f.textureHeight,!1),b=new Xo(f.textureWidth,f.textureHeight,{format:Yi,type:Ea,depthTexture:new kR(f.textureWidth,f.textureHeight,fe,void 0,void 0,void 0,void 0,void 0,void 0,pe),stencilBuffer:v.stencil,colorSpace:e.outputColorSpace,samples:v.antialias?4:0});const je=e.properties.get(b);je.__ignoreDepthValues=f.ignoreDepthValues}b.isXRRenderTarget=!0,this.setFoveation(l),c=null,o=await i.requestReferenceSpace(a),ke.setContext(i),ke.start(),r.isPresenting=!0,r.dispatchEvent({type:"sessionstart"})}},this.getEnvironmentBlendMode=function(){if(i!==null)return i.environmentBlendMode};function j(re){for(let pe=0;pe<re.removed.length;pe++){const fe=re.removed[pe],Ee=w.indexOf(fe);Ee>=0&&(w[Ee]=null,S[Ee].disconnect(fe))}for(let pe=0;pe<re.added.length;pe++){const fe=re.added[pe];let Ee=w.indexOf(fe);if(Ee===-1){for(let je=0;je<S.length;je++)if(je>=w.length){w.push(fe),Ee=je;break}else if(w[je]===null){w[je]=fe,Ee=je;break}if(Ee===-1)break}const We=S[Ee];We&&We.connect(fe)}}const Z=new K,ne=new K;function O(re,pe,fe){Z.setFromMatrixPosition(pe.matrixWorld),ne.setFromMatrixPosition(fe.matrixWorld);const Ee=Z.distanceTo(ne),We=pe.projectionMatrix.elements,je=fe.projectionMatrix.elements,Je=We[14]/(We[10]-1),te=We[14]/(We[10]+1),be=(We[9]+1)/We[5],ce=(We[9]-1)/We[5],Me=(We[8]-1)/We[0],Ie=(je[8]+1)/je[0],Oe=Je*Me,V=Je*Ie,$=Ee/(-Me+Ie),ue=$*-Me;pe.matrixWorld.decompose(re.position,re.quaternion,re.scale),re.translateX(ue),re.translateZ($),re.matrixWorld.compose(re.position,re.quaternion,re.scale),re.matrixWorldInverse.copy(re.matrixWorld).invert();const ye=Je+$,ve=te+$,Ne=Oe-ue,nt=V+(Ee-ue),Ae=be*te/ve*ye,st=ce*te/ve*ye;re.projectionMatrix.makePerspective(Ne,nt,Ae,st,ye,ve),re.projectionMatrixInverse.copy(re.projectionMatrix).invert()}function G(re,pe){pe===null?re.matrixWorld.copy(re.matrix):re.matrixWorld.multiplyMatrices(pe.matrixWorld,re.matrix),re.matrixWorldInverse.copy(re.matrixWorld).invert()}this.updateCamera=function(re){if(i===null)return;x.texture!==null&&(re.near=x.depthNear,re.far=x.depthFar),M.near=I.near=T.near=re.near,M.far=I.far=T.far=re.far,(P!==M.near||B!==M.far)&&(i.updateRenderState({depthNear:M.near,depthFar:M.far}),P=M.near,B=M.far,T.near=P,T.far=B,I.near=P,I.far=B,T.updateProjectionMatrix(),I.updateProjectionMatrix(),re.updateProjectionMatrix());const pe=re.parent,fe=M.cameras;G(M,pe);for(let Ee=0;Ee<fe.length;Ee++)G(fe[Ee],pe);fe.length===2?O(M,T,I):M.projectionMatrix.copy(T.projectionMatrix),q(re,M,pe)};function q(re,pe,fe){fe===null?re.matrix.copy(pe.matrixWorld):(re.matrix.copy(fe.matrixWorld),re.matrix.invert(),re.matrix.multiply(pe.matrixWorld)),re.matrix.decompose(re.position,re.quaternion,re.scale),re.updateMatrixWorld(!0),re.projectionMatrix.copy(pe.projectionMatrix),re.projectionMatrixInverse.copy(pe.projectionMatrixInverse),re.isPerspectiveCamera&&(re.fov=Gh*2*Math.atan(1/re.projectionMatrix.elements[5]),re.zoom=1)}this.getCamera=function(){return M},this.getFoveation=function(){if(!(f===null&&h===null))return l},this.setFoveation=function(re){l=re,f!==null&&(f.fixedFoveation=re),h!==null&&h.fixedFoveation!==void 0&&(h.fixedFoveation=re)},this.hasDepthSensing=function(){return x.texture!==null};let se=null;function he(re,pe){if(u=pe.getViewerPose(c||o),p=pe,u!==null){const fe=u.views;h!==null&&(e.setRenderTargetFramebuffer(b,h.framebuffer),e.setRenderTarget(b));let Ee=!1;fe.length!==M.cameras.length&&(M.cameras.length=0,Ee=!0);for(let je=0;je<fe.length;je++){const Je=fe[je];let te=null;if(h!==null)te=h.getViewport(Je);else{const ce=d.getViewSubImage(f,Je);te=ce.viewport,je===0&&(e.setRenderTargetTextures(b,ce.colorTexture,f.ignoreDepthValues?void 0:ce.depthStencilTexture),e.setRenderTarget(b))}let be=N[je];be===void 0&&(be=new Hn,be.layers.enable(je),be.viewport=new vn,N[je]=be),be.matrix.fromArray(Je.transform.matrix),be.matrix.decompose(be.position,be.quaternion,be.scale),be.projectionMatrix.fromArray(Je.projectionMatrix),be.projectionMatrixInverse.copy(be.projectionMatrix).invert(),be.viewport.set(te.x,te.y,te.width,te.height),je===0&&(M.matrix.copy(be.matrix),M.matrix.decompose(M.position,M.quaternion,M.scale)),Ee===!0&&M.cameras.push(be)}const We=i.enabledFeatures;if(We&&We.includes("depth-sensing")){const je=d.getDepthInformation(fe[0]);je&&je.isValid&&je.texture&&x.init(e,je,i.renderState)}}for(let fe=0;fe<S.length;fe++){const Ee=w[fe],We=S[fe];Ee!==null&&We!==void 0&&We.update(Ee,pe,c||o)}x.render(e,M),se&&se(re,pe),pe.detectedPlanes&&r.dispatchEvent({type:"planesdetected",data:pe}),p=null}const ke=new I5;ke.setAnimationLoop(he),this.setAnimationLoop=function(re){se=re},this.dispose=function(){}}}const ou=new Is,Phe=new St;function khe(t,e){function n(v,y){v.matrixAutoUpdate===!0&&v.updateMatrix(),y.value.copy(v.matrix)}function r(v,y){y.color.getRGB(v.fogColor.value,A5(t)),y.isFog?(v.fogNear.value=y.near,v.fogFar.value=y.far):y.isFogExp2&&(v.fogDensity.value=y.density)}function i(v,y,b,S,w){y.isMeshBasicMaterial||y.isMeshLambertMaterial?s(v,y):y.isMeshToonMaterial?(s(v,y),d(v,y)):y.isMeshPhongMaterial?(s(v,y),u(v,y)):y.isMeshStandardMaterial?(s(v,y),f(v,y),y.isMeshPhysicalMaterial&&h(v,y,w)):y.isMeshMatcapMaterial?(s(v,y),p(v,y)):y.isMeshDepthMaterial?s(v,y):y.isMeshDistanceMaterial?(s(v,y),x(v,y)):y.isMeshNormalMaterial?s(v,y):y.isLineBasicMaterial?(o(v,y),y.isLineDashedMaterial&&a(v,y)):y.isPointsMaterial?l(v,y,b,S):y.isSpriteMaterial?c(v,y):y.isShadowMaterial?(v.color.value.copy(y.color),v.opacity.value=y.opacity):y.isShaderMaterial&&(y.uniformsNeedUpdate=!1)}function s(v,y){v.opacity.value=y.opacity,y.color&&v.diffuse.value.copy(y.color),y.emissive&&v.emissive.value.copy(y.emissive).multiplyScalar(y.emissiveIntensity),y.map&&(v.map.value=y.map,n(y.map,v.mapTransform)),y.alphaMap&&(v.alphaMap.value=y.alphaMap,n(y.alphaMap,v.alphaMapTransform)),y.bumpMap&&(v.bumpMap.value=y.bumpMap,n(y.bumpMap,v.bumpMapTransform),v.bumpScale.value=y.bumpScale,y.side===Fi&&(v.bumpScale.value*=-1)),y.normalMap&&(v.normalMap.value=y.normalMap,n(y.normalMap,v.normalMapTransform),v.normalScale.value.copy(y.normalScale),y.side===Fi&&v.normalScale.value.negate()),y.displacementMap&&(v.displacementMap.value=y.displacementMap,n(y.displacementMap,v.displacementMapTransform),v.displacementScale.value=y.displacementScale,v.displacementBias.value=y.displacementBias),y.emissiveMap&&(v.emissiveMap.value=y.emissiveMap,n(y.emissiveMap,v.emissiveMapTransform)),y.specularMap&&(v.specularMap.value=y.specularMap,n(y.specularMap,v.specularMapTransform)),y.alphaTest>0&&(v.alphaTest.value=y.alphaTest);const b=e.get(y),S=b.envMap,w=b.envMapRotation;if(S&&(v.envMap.value=S,ou.copy(w),ou.x*=-1,ou.y*=-1,ou.z*=-1,S.isCubeTexture&&S.isRenderTargetTexture===!1&&(ou.y*=-1,ou.z*=-1),v.envMapRotation.value.setFromMatrix4(Phe.makeRotationFromEuler(ou)),v.flipEnvMap.value=S.isCubeTexture&&S.isRenderTargetTexture===!1?-1:1,v.reflectivity.value=y.reflectivity,v.ior.value=y.ior,v.refractionRatio.value=y.refractionRatio),y.lightMap){v.lightMap.value=y.lightMap;const E=t._useLegacyLights===!0?Math.PI:1;v.lightMapIntensity.value=y.lightMapIntensity*E,n(y.lightMap,v.lightMapTransform)}y.aoMap&&(v.aoMap.value=y.aoMap,v.aoMapIntensity.value=y.aoMapIntensity,n(y.aoMap,v.aoMapTransform))}function o(v,y){v.diffuse.value.copy(y.color),v.opacity.value=y.opacity,y.map&&(v.map.value=y.map,n(y.map,v.mapTransform))}function a(v,y){v.dashSize.value=y.dashSize,v.totalSize.value=y.dashSize+y.gapSize,v.scale.value=y.scale}function l(v,y,b,S){v.diffuse.value.copy(y.color),v.opacity.value=y.opacity,v.size.value=y.size*b,v.scale.value=S*.5,y.map&&(v.map.value=y.map,n(y.map,v.uvTransform)),y.alphaMap&&(v.alphaMap.value=y.alphaMap,n(y.alphaMap,v.alphaMapTransform)),y.alphaTest>0&&(v.alphaTest.value=y.alphaTest)}function c(v,y){v.diffuse.value.copy(y.color),v.opacity.value=y.opacity,v.rotation.value=y.rotation,y.map&&(v.map.value=y.map,n(y.map,v.mapTransform)),y.alphaMap&&(v.alphaMap.value=y.alphaMap,n(y.alphaMap,v.alphaMapTransform)),y.alphaTest>0&&(v.alphaTest.value=y.alphaTest)}function u(v,y){v.specular.value.copy(y.specular),v.shininess.value=Math.max(y.shininess,1e-4)}function d(v,y){y.gradientMap&&(v.gradientMap.value=y.gradientMap)}function f(v,y){v.metalness.value=y.metalness,y.metalnessMap&&(v.metalnessMap.value=y.metalnessMap,n(y.metalnessMap,v.metalnessMapTransform)),v.roughness.value=y.roughness,y.roughnessMap&&(v.roughnessMap.value=y.roughnessMap,n(y.roughnessMap,v.roughnessMapTransform)),y.envMap&&(v.envMapIntensity.value=y.envMapIntensity)}function h(v,y,b){v.ior.value=y.ior,y.sheen>0&&(v.sheenColor.value.copy(y.sheenColor).multiplyScalar(y.sheen),v.sheenRoughness.value=y.sheenRoughness,y.sheenColorMap&&(v.sheenColorMap.value=y.sheenColorMap,n(y.sheenColorMap,v.sheenColorMapTransform)),y.sheenRoughnessMap&&(v.sheenRoughnessMap.value=y.sheenRoughnessMap,n(y.sheenRoughnessMap,v.sheenRoughnessMapTransform))),y.clearcoat>0&&(v.clearcoat.value=y.clearcoat,v.clearcoatRoughness.value=y.clearcoatRoughness,y.clearcoatMap&&(v.clearcoatMap.value=y.clearcoatMap,n(y.clearcoatMap,v.clearcoatMapTransform)),y.clearcoatRoughnessMap&&(v.clearcoatRoughnessMap.value=y.clearcoatRoughnessMap,n(y.clearcoatRoughnessMap,v.clearcoatRoughnessMapTransform)),y.clearcoatNormalMap&&(v.clearcoatNormalMap.value=y.clearcoatNormalMap,n(y.clearcoatNormalMap,v.clearcoatNormalMapTransform),v.clearcoatNormalScale.value.copy(y.clearcoatNormalScale),y.side===Fi&&v.clearcoatNormalScale.value.negate())),y.iridescence>0&&(v.iridescence.value=y.iridescence,v.iridescenceIOR.value=y.iridescenceIOR,v.iridescenceThicknessMinimum.value=y.iridescenceThicknessRange[0],v.iridescenceThicknessMaximum.value=y.iridescenceThicknessRange[1],y.iridescenceMap&&(v.iridescenceMap.value=y.iridescenceMap,n(y.iridescenceMap,v.iridescenceMapTransform)),y.iridescenceThicknessMap&&(v.iridescenceThicknessMap.value=y.iridescenceThicknessMap,n(y.iridescenceThicknessMap,v.iridescenceThicknessMapTransform))),y.transmission>0&&(v.transmission.value=y.transmission,v.transmissionSamplerMap.value=b.texture,v.transmissionSamplerSize.value.set(b.width,b.height),y.transmissionMap&&(v.transmissionMap.value=y.transmissionMap,n(y.transmissionMap,v.transmissionMapTransform)),v.thickness.value=y.thickness,y.thicknessMap&&(v.thicknessMap.value=y.thicknessMap,n(y.thicknessMap,v.thicknessMapTransform)),v.attenuationDistance.value=y.attenuationDistance,v.attenuationColor.value.copy(y.attenuationColor)),y.anisotropy>0&&(v.anisotropyVector.value.set(y.anisotropy*Math.cos(y.anisotropyRotation),y.anisotropy*Math.sin(y.anisotropyRotation)),y.anisotropyMap&&(v.anisotropyMap.value=y.anisotropyMap,n(y.anisotropyMap,v.anisotropyMapTransform))),v.specularIntensity.value=y.specularIntensity,v.specularColor.value.copy(y.specularColor),y.specularColorMap&&(v.specularColorMap.value=y.specularColorMap,n(y.specularColorMap,v.specularColorMapTransform)),y.specularIntensityMap&&(v.specularIntensityMap.value=y.specularIntensityMap,n(y.specularIntensityMap,v.specularIntensityMapTransform))}function p(v,y){y.matcap&&(v.matcap.value=y.matcap)}function x(v,y){const b=e.get(y).light;v.referencePosition.value.setFromMatrixPosition(b.matrixWorld),v.nearDistance.value=b.shadow.camera.near,v.farDistance.value=b.shadow.camera.far}return{refreshFogUniforms:r,refreshMaterialUniforms:i}}function Dhe(t,e,n,r){let i={},s={},o=[];const a=t.getParameter(t.MAX_UNIFORM_BUFFER_BINDINGS);function l(b,S){const w=S.program;r.uniformBlockBinding(b,w)}function c(b,S){let w=i[b.id];w===void 0&&(p(b),w=u(b),i[b.id]=w,b.addEventListener("dispose",v));const E=S.program;r.updateUBOMapping(b,E);const A=e.render.frame;s[b.id]!==A&&(f(b),s[b.id]=A)}function u(b){const S=d();b.__bindingPointIndex=S;const w=t.createBuffer(),E=b.__size,A=b.usage;return t.bindBuffer(t.UNIFORM_BUFFER,w),t.bufferData(t.UNIFORM_BUFFER,E,A),t.bindBuffer(t.UNIFORM_BUFFER,null),t.bindBufferBase(t.UNIFORM_BUFFER,S,w),w}function d(){for(let b=0;b<a;b++)if(o.indexOf(b)===-1)return o.push(b),b;return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),0}function f(b){const S=i[b.id],w=b.uniforms,E=b.__cache;t.bindBuffer(t.UNIFORM_BUFFER,S);for(let A=0,T=w.length;A<T;A++){const I=Array.isArray(w[A])?w[A]:[w[A]];for(let N=0,M=I.length;N<M;N++){const P=I[N];if(h(P,A,N,E)===!0){const B=P.__offset,F=Array.isArray(P.value)?P.value:[P.value];let U=0;for(let j=0;j<F.length;j++){const Z=F[j],ne=x(Z);typeof Z=="number"||typeof Z=="boolean"?(P.__data[0]=Z,t.bufferSubData(t.UNIFORM_BUFFER,B+U,P.__data)):Z.isMatrix3?(P.__data[0]=Z.elements[0],P.__data[1]=Z.elements[1],P.__data[2]=Z.elements[2],P.__data[3]=0,P.__data[4]=Z.elements[3],P.__data[5]=Z.elements[4],P.__data[6]=Z.elements[5],P.__data[7]=0,P.__data[8]=Z.elements[6],P.__data[9]=Z.elements[7],P.__data[10]=Z.elements[8],P.__data[11]=0):(Z.toArray(P.__data,U),U+=ne.storage/Float32Array.BYTES_PER_ELEMENT)}t.bufferSubData(t.UNIFORM_BUFFER,B,P.__data)}}}t.bindBuffer(t.UNIFORM_BUFFER,null)}function h(b,S,w,E){const A=b.value,T=S+"_"+w;if(E[T]===void 0)return typeof A=="number"||typeof A=="boolean"?E[T]=A:E[T]=A.clone(),!0;{const I=E[T];if(typeof A=="number"||typeof A=="boolean"){if(I!==A)return E[T]=A,!0}else if(I.equals(A)===!1)return I.copy(A),!0}return!1}function p(b){const S=b.uniforms;let w=0;const E=16;for(let T=0,I=S.length;T<I;T++){const N=Array.isArray(S[T])?S[T]:[S[T]];for(let M=0,P=N.length;M<P;M++){const B=N[M],F=Array.isArray(B.value)?B.value:[B.value];for(let U=0,j=F.length;U<j;U++){const Z=F[U],ne=x(Z),O=w%E;O!==0&&E-O<ne.boundary&&(w+=E-O),B.__data=new Float32Array(ne.storage/Float32Array.BYTES_PER_ELEMENT),B.__offset=w,w+=ne.storage}}}const A=w%E;return A>0&&(w+=E-A),b.__size=w,b.__cache={},this}function x(b){const S={boundary:0,storage:0};return typeof b=="number"||typeof b=="boolean"?(S.boundary=4,S.storage=4):b.isVector2?(S.boundary=8,S.storage=8):b.isVector3||b.isColor?(S.boundary=16,S.storage=12):b.isVector4?(S.boundary=16,S.storage=16):b.isMatrix3?(S.boundary=48,S.storage=48):b.isMatrix4?(S.boundary=64,S.storage=64):b.isTexture?console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."):console.warn("THREE.WebGLRenderer: Unsupported uniform value type.",b),S}function v(b){const S=b.target;S.removeEventListener("dispose",v);const w=o.indexOf(S.__bindingPointIndex);o.splice(w,1),t.deleteBuffer(i[S.id]),delete i[S.id],delete s[S.id]}function y(){for(const b in i)t.deleteBuffer(i[b]);o=[],i={},s={}}return{bind:l,update:c,dispose:y}}class LR{constructor(e={}){const{canvas:n=S5(),context:r=null,depth:i=!0,stencil:s=!1,alpha:o=!1,antialias:a=!1,premultipliedAlpha:l=!0,preserveDrawingBuffer:c=!1,powerPreference:u="default",failIfMajorPerformanceCaveat:d=!1}=e;this.isWebGLRenderer=!0;let f;if(r!==null){if(typeof WebGLRenderingContext<"u"&&r instanceof WebGLRenderingContext)throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");f=r.getContextAttributes().alpha}else f=o;const h=new Uint32Array(4),p=new Int32Array(4);let x=null,v=null;const y=[],b=[];this.domElement=n,this.debug={checkShaderErrors:!0,onShaderError:null},this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.sortObjects=!0,this.clippingPlanes=[],this.localClippingEnabled=!1,this._outputColorSpace=xs,this._useLegacyLights=!1,this.toneMapping=Ca,this.toneMappingExposure=1;const S=this;let w=!1,E=0,A=0,T=null,I=-1,N=null;const M=new vn,P=new vn;let B=null;const F=new Qe(0);let U=0,j=n.width,Z=n.height,ne=1,O=null,G=null;const q=new vn(0,0,j,Z),se=new vn(0,0,j,Z);let he=!1;const ke=new R0;let re=!1,pe=!1;const fe=new St,Ee=new Re,We=new K,je={background:null,fog:null,environment:null,overrideMaterial:null,isScene:!0};function Je(){return T===null?ne:1}let te=r;function be(W,de){const Se=n.getContext(W,de);return Se!==null?Se:null}try{const W={alpha:!0,depth:i,stencil:s,antialias:a,premultipliedAlpha:l,preserveDrawingBuffer:c,powerPreference:u,failIfMajorPerformanceCaveat:d};if("setAttribute"in n&&n.setAttribute("data-engine",`three.js r${C0}`),n.addEventListener("webglcontextlost",De,!1),n.addEventListener("webglcontextrestored",Be,!1),n.addEventListener("webglcontextcreationerror",ut,!1),te===null){const de="webgl2";if(te=be(de,W),te===null)throw be(de)?new Error("Error creating WebGL context with your selected attributes."):new Error("Error creating WebGL context.")}}catch(W){throw console.error("THREE.WebGLRenderer: "+W.message),W}let ce,Me,Ie,Oe,V,$,ue,ye,ve,Ne,nt,Ae,st,ht,Ue,Fe,$e,Ze,ot,Pt,Ge,yt,_t,ie;function _e(){ce=new Xde(te),ce.init(),Me=new zde(te,ce,e),yt=new L5(te,ce),Ie=new Ehe(te),Oe=new Jde(te),V=new hhe,$=new Ahe(te,ce,Ie,V,Me,yt,Oe),ue=new Hde(S),ye=new jde(S),ve=new nce(te),_t=new $de(te,ve),Ne=new Kde(te,ve,Oe,_t),nt=new Qde(te,Ne,ve,Oe),ot=new Yde(te,Me,$),Fe=new Gde(V),Ae=new fhe(S,ue,ye,ce,Me,_t,Fe),st=new khe(S,V),ht=new mhe,Ue=new She(ce),Ze=new Fde(S,ue,ye,Ie,nt,f,l),$e=new Che(S,nt,Me),ie=new Dhe(te,Oe,Me,Ie),Pt=new Ude(te,ce,Oe),Ge=new qde(te,ce,Oe),Oe.programs=Ae.programs,S.capabilities=Me,S.extensions=ce,S.properties=V,S.renderLists=ht,S.shadowMap=$e,S.state=Ie,S.info=Oe}_e();const J=new Nhe(S,te);this.xr=J,this.getContext=function(){return te},this.getContextAttributes=function(){return te.getContextAttributes()},this.forceContextLoss=function(){const W=ce.get("WEBGL_lose_context");W&&W.loseContext()},this.forceContextRestore=function(){const W=ce.get("WEBGL_lose_context");W&&W.restoreContext()},this.getPixelRatio=function(){return ne},this.setPixelRatio=function(W){W!==void 0&&(ne=W,this.setSize(j,Z,!1))},this.getSize=function(W){return W.set(j,Z)},this.setSize=function(W,de,Se=!0){if(J.isPresenting){console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");return}j=W,Z=de,n.width=Math.floor(W*ne),n.height=Math.floor(de*ne),Se===!0&&(n.style.width=W+"px",n.style.height=de+"px"),this.setViewport(0,0,W,de)},this.getDrawingBufferSize=function(W){return W.set(j*ne,Z*ne).floor()},this.setDrawingBufferSize=function(W,de,Se){j=W,Z=de,ne=Se,n.width=Math.floor(W*Se),n.height=Math.floor(de*Se),this.setViewport(0,0,W,de)},this.getCurrentViewport=function(W){return W.copy(M)},this.getViewport=function(W){return W.copy(q)},this.setViewport=function(W,de,Se,we){W.isVector4?q.set(W.x,W.y,W.z,W.w):q.set(W,de,Se,we),Ie.viewport(M.copy(q).multiplyScalar(ne).round())},this.getScissor=function(W){return W.copy(se)},this.setScissor=function(W,de,Se,we){W.isVector4?se.set(W.x,W.y,W.z,W.w):se.set(W,de,Se,we),Ie.scissor(P.copy(se).multiplyScalar(ne).round())},this.getScissorTest=function(){return he},this.setScissorTest=function(W){Ie.setScissorTest(he=W)},this.setOpaqueSort=function(W){O=W},this.setTransparentSort=function(W){G=W},this.getClearColor=function(W){return W.copy(Ze.getClearColor())},this.setClearColor=function(){Ze.setClearColor.apply(Ze,arguments)},this.getClearAlpha=function(){return Ze.getClearAlpha()},this.setClearAlpha=function(){Ze.setClearAlpha.apply(Ze,arguments)},this.clear=function(W=!0,de=!0,Se=!0){let we=0;if(W){let xe=!1;if(T!==null){const tt=T.texture.format;xe=tt===wR||tt===_R||tt===SR}if(xe){const tt=T.texture.type,xt=tt===Ea||tt===pd||tt===gR||tt===vp||tt===vR||tt===xR,Ct=Ze.getClearColor(),Tt=Ze.getClearAlpha(),It=Ct.r,At=Ct.g,Nt=Ct.b;xt?(h[0]=It,h[1]=At,h[2]=Nt,h[3]=Tt,te.clearBufferuiv(te.COLOR,0,h)):(p[0]=It,p[1]=At,p[2]=Nt,p[3]=Tt,te.clearBufferiv(te.COLOR,0,p))}else we|=te.COLOR_BUFFER_BIT}de&&(we|=te.DEPTH_BUFFER_BIT),Se&&(we|=te.STENCIL_BUFFER_BIT,this.state.buffers.stencil.setMask(4294967295)),te.clear(we)},this.clearColor=function(){this.clear(!0,!1,!1)},this.clearDepth=function(){this.clear(!1,!0,!1)},this.clearStencil=function(){this.clear(!1,!1,!0)},this.dispose=function(){n.removeEventListener("webglcontextlost",De,!1),n.removeEventListener("webglcontextrestored",Be,!1),n.removeEventListener("webglcontextcreationerror",ut,!1),ht.dispose(),Ue.dispose(),V.dispose(),ue.dispose(),ye.dispose(),nt.dispose(),_t.dispose(),ie.dispose(),Ae.dispose(),J.dispose(),J.removeEventListener("sessionstart",Cr),J.removeEventListener("sessionend",Er),zi.stop()};function De(W){W.preventDefault(),console.log("THREE.WebGLRenderer: Context Lost."),w=!0}function Be(){console.log("THREE.WebGLRenderer: Context Restored."),w=!1;const W=Oe.autoReset,de=$e.enabled,Se=$e.autoUpdate,we=$e.needsUpdate,xe=$e.type;_e(),Oe.autoReset=W,$e.enabled=de,$e.autoUpdate=Se,$e.needsUpdate=we,$e.type=xe}function ut(W){console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",W.statusMessage)}function pt(W){const de=W.target;de.removeEventListener("dispose",pt),mn(de)}function mn(W){hn(W),V.remove(W)}function hn(W){const de=V.get(W).programs;de!==void 0&&(de.forEach(function(Se){Ae.releaseProgram(Se)}),W.isShaderMaterial&&Ae.releaseShaderCache(W))}this.renderBufferDirect=function(W,de,Se,we,xe,tt){de===null&&(de=je);const xt=xe.isMesh&&xe.matrixWorld.determinant()<0,Ct=b_(W,de,Se,we,xe);Ie.setMaterial(we,xt);let Tt=Se.index,It=1;if(we.wireframe===!0){if(Tt=Ne.getWireframeAttribute(Se),Tt===void 0)return;It=2}const At=Se.drawRange,Nt=Se.attributes.position;let kn=At.start*It,Ei=(At.start+At.count)*It;tt!==null&&(kn=Math.max(kn,tt.start*It),Ei=Math.min(Ei,(tt.start+tt.count)*It)),Tt!==null?(kn=Math.max(kn,0),Ei=Math.min(Ei,Tt.count)):Nt!=null&&(kn=Math.max(kn,0),Ei=Math.min(Ei,Nt.count));const Zn=Ei-kn;if(Zn<0||Zn===1/0)return;_t.setup(xe,we,Ct,Se,Tt);let ni,rn=Pt;if(Tt!==null&&(ni=ve.get(Tt),rn=Ge,rn.setIndex(ni)),xe.isMesh)we.wireframe===!0?(Ie.setLineWidth(we.wireframeLinewidth*Je()),rn.setMode(te.LINES)):rn.setMode(te.TRIANGLES);else if(xe.isLine){let at=we.linewidth;at===void 0&&(at=1),Ie.setLineWidth(at*Je()),xe.isLineSegments?rn.setMode(te.LINES):xe.isLineLoop?rn.setMode(te.LINE_LOOP):rn.setMode(te.LINE_STRIP)}else xe.isPoints?rn.setMode(te.POINTS):xe.isSprite&&rn.setMode(te.TRIANGLES);if(xe.isBatchedMesh)rn.renderMultiDraw(xe._multiDrawStarts,xe._multiDrawCounts,xe._multiDrawCount);else if(xe.isInstancedMesh)rn.renderInstances(kn,Zn,xe.count);else if(Se.isInstancedBufferGeometry){const at=Se._maxInstanceCount!==void 0?Se._maxInstanceCount:1/0,pn=Math.min(Se.instanceCount,at);rn.renderInstances(kn,Zn,pn)}else rn.render(kn,Zn)};function jt(W,de,Se){W.transparent===!0&&W.side===Uo&&W.forceSinglePass===!1?(W.side=Fi,W.needsUpdate=!0,na(W,de,Se),W.side=Ia,W.needsUpdate=!0,na(W,de,Se),W.side=Uo):na(W,de,Se)}this.compile=function(W,de,Se=null){Se===null&&(Se=W),v=Ue.get(Se),v.init(),b.push(v),Se.traverseVisible(function(xe){xe.isLight&&xe.layers.test(de.layers)&&(v.pushLight(xe),xe.castShadow&&v.pushShadow(xe))}),W!==Se&&W.traverseVisible(function(xe){xe.isLight&&xe.layers.test(de.layers)&&(v.pushLight(xe),xe.castShadow&&v.pushShadow(xe))}),v.setupLights(S._useLegacyLights);const we=new Set;return W.traverse(function(xe){const tt=xe.material;if(tt)if(Array.isArray(tt))for(let xt=0;xt<tt.length;xt++){const Ct=tt[xt];jt(Ct,Se,xe),we.add(Ct)}else jt(tt,Se,xe),we.add(tt)}),b.pop(),v=null,we},this.compileAsync=function(W,de,Se=null){const we=this.compile(W,de,Se);return new Promise(xe=>{function tt(){if(we.forEach(function(xt){V.get(xt).currentProgram.isReady()&&we.delete(xt)}),we.size===0){xe(W);return}setTimeout(tt,10)}ce.get("KHR_parallel_shader_compile")!==null?tt():setTimeout(tt,10)})};let _n=null;function Jt(W){_n&&_n(W)}function Cr(){zi.stop()}function Er(){zi.start()}const zi=new I5;zi.setAnimationLoop(Jt),typeof self<"u"&&zi.setContext(self),this.setAnimationLoop=function(W){_n=W,J.setAnimationLoop(W),W===null?zi.stop():zi.start()},J.addEventListener("sessionstart",Cr),J.addEventListener("sessionend",Er),this.render=function(W,de){if(de!==void 0&&de.isCamera!==!0){console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");return}if(w===!0)return;W.matrixWorldAutoUpdate===!0&&W.updateMatrixWorld(),de.parent===null&&de.matrixWorldAutoUpdate===!0&&de.updateMatrixWorld(),J.enabled===!0&&J.isPresenting===!0&&(J.cameraAutoUpdate===!0&&J.updateCamera(de),de=J.getCamera()),W.isScene===!0&&W.onBeforeRender(S,W,de,T),v=Ue.get(W,b.length),v.init(),b.push(v),fe.multiplyMatrices(de.projectionMatrix,de.matrixWorldInverse),ke.setFromProjectionMatrix(fe),pe=this.localClippingEnabled,re=Fe.init(this.clippingPlanes,pe),x=ht.get(W,y.length),x.init(),y.push(x),q0(W,de,0,S.sortObjects),x.finish(),S.sortObjects===!0&&x.sort(O,G),this.info.render.frame++,re===!0&&Fe.beginShadows();const Se=v.state.shadowsArray;if($e.render(Se,W,de),re===!0&&Fe.endShadows(),this.info.autoReset===!0&&this.info.reset(),(J.enabled===!1||J.isPresenting===!1||J.hasDepthSensing()===!1)&&Ze.render(x,W),v.setupLights(S._useLegacyLights),de.isArrayCamera){const we=de.cameras;for(let xe=0,tt=we.length;xe<tt;xe++){const xt=we[xe];J0(x,W,xt,xt.viewport)}}else J0(x,W,de);T!==null&&($.updateMultisampleRenderTarget(T),$.updateRenderTargetMipmap(T)),W.isScene===!0&&W.onAfterRender(S,W,de),_t.resetDefaultState(),I=-1,N=null,b.pop(),b.length>0?v=b[b.length-1]:v=null,y.pop(),y.length>0?x=y[y.length-1]:x=null};function q0(W,de,Se,we){if(W.visible===!1)return;if(W.layers.test(de.layers)){if(W.isGroup)Se=W.renderOrder;else if(W.isLOD)W.autoUpdate===!0&&W.update(de);else if(W.isLight)v.pushLight(W),W.castShadow&&v.pushShadow(W);else if(W.isSprite){if(!W.frustumCulled||ke.intersectsSprite(W)){we&&We.setFromMatrixPosition(W.matrixWorld).applyMatrix4(fe);const xt=nt.update(W),Ct=W.material;Ct.visible&&x.push(W,xt,Ct,Se,We.z,null)}}else if((W.isMesh||W.isLine||W.isPoints)&&(!W.frustumCulled||ke.intersectsObject(W))){const xt=nt.update(W),Ct=W.material;if(we&&(W.boundingSphere!==void 0?(W.boundingSphere===null&&W.computeBoundingSphere(),We.copy(W.boundingSphere.center)):(xt.boundingSphere===null&&xt.computeBoundingSphere(),We.copy(xt.boundingSphere.center)),We.applyMatrix4(W.matrixWorld).applyMatrix4(fe)),Array.isArray(Ct)){const Tt=xt.groups;for(let It=0,At=Tt.length;It<At;It++){const Nt=Tt[It],kn=Ct[Nt.materialIndex];kn&&kn.visible&&x.push(W,xt,kn,Se,We.z,Nt)}}else Ct.visible&&x.push(W,xt,Ct,Se,We.z,null)}}const tt=W.children;for(let xt=0,Ct=tt.length;xt<Ct;xt++)q0(tt[xt],de,Se,we)}function J0(W,de,Se,we){const xe=W.opaque,tt=W.transmissive,xt=W.transparent;v.setupLightsView(Se),re===!0&&Fe.setGlobalState(S.clippingPlanes,Se),tt.length>0&&Y0(xe,tt,de,Se),we&&Ie.viewport(M.copy(we)),xe.length>0&&Pl(xe,de,Se),tt.length>0&&Pl(tt,de,Se),xt.length>0&&Pl(xt,de,Se),Ie.buffers.depth.setTest(!0),Ie.buffers.depth.setMask(!0),Ie.buffers.color.setMask(!0),Ie.setPolygonOffset(!1)}function Y0(W,de,Se,we){if((Se.isScene===!0?Se.overrideMaterial:null)!==null)return;if(v.state.transmissionRenderTarget===null){v.state.transmissionRenderTarget=new Xo(1,1,{generateMipmaps:!0,type:ce.has("EXT_color_buffer_half_float")||ce.has("EXT_color_buffer_float")?Bg:Ea,minFilter:ao,samples:4,stencilBuffer:s});const It=V.get(v.state.transmissionRenderTarget);It.__isTransmissionRenderTarget=!0}const tt=v.state.transmissionRenderTarget;S.getDrawingBufferSize(Ee),tt.setSize(Ee.x,Ee.y);const xt=S.getRenderTarget();S.setRenderTarget(tt),S.getClearColor(F),U=S.getClearAlpha(),U<1&&S.setClearColor(16777215,.5),S.clear();const Ct=S.toneMapping;S.toneMapping=Ca,Pl(W,Se,we),$.updateMultisampleRenderTarget(tt),$.updateRenderTargetMipmap(tt);let Tt=!1;for(let It=0,At=de.length;It<At;It++){const Nt=de[It],kn=Nt.object,Ei=Nt.geometry,Zn=Nt.material,ni=Nt.group;if(Zn.side===Uo&&kn.layers.test(we.layers)){const rn=Zn.side;Zn.side=Fi,Zn.needsUpdate=!0,Q0(kn,Se,we,Ei,Zn,ni),Zn.side=rn,Zn.needsUpdate=!0,Tt=!0}}Tt===!0&&($.updateMultisampleRenderTarget(tt),$.updateRenderTargetMipmap(tt)),S.setRenderTarget(xt),S.setClearColor(F,U),S.toneMapping=Ct}function Pl(W,de,Se){const we=de.isScene===!0?de.overrideMaterial:null;for(let xe=0,tt=W.length;xe<tt;xe++){const xt=W[xe],Ct=xt.object,Tt=xt.geometry,It=we===null?xt.material:we,At=xt.group;Ct.layers.test(Se.layers)&&Q0(Ct,de,Se,Tt,It,At)}}function Q0(W,de,Se,we,xe,tt){W.onBeforeRender(S,de,Se,we,xe,tt),W.modelViewMatrix.multiplyMatrices(Se.matrixWorldInverse,W.matrixWorld),W.normalMatrix.getNormalMatrix(W.modelViewMatrix),xe.onBeforeRender(S,de,Se,we,W,tt),xe.transparent===!0&&xe.side===Uo&&xe.forceSinglePass===!1?(xe.side=Fi,xe.needsUpdate=!0,S.renderBufferDirect(Se,de,we,xe,W,tt),xe.side=Ia,xe.needsUpdate=!0,S.renderBufferDirect(Se,de,we,xe,W,tt),xe.side=Uo):S.renderBufferDirect(Se,de,we,xe,W,tt),W.onAfterRender(S,de,Se,we,xe,tt)}function na(W,de,Se){de.isScene!==!0&&(de=je);const we=V.get(W),xe=v.state.lights,tt=v.state.shadowsArray,xt=xe.state.version,Ct=Ae.getParameters(W,xe.state,tt,de,Se),Tt=Ae.getProgramCacheKey(Ct);let It=we.programs;we.environment=W.isMeshStandardMaterial?de.environment:null,we.fog=de.fog,we.envMap=(W.isMeshStandardMaterial?ye:ue).get(W.envMap||we.environment),we.envMapRotation=we.environment!==null&&W.envMap===null?de.environmentRotation:W.envMapRotation,It===void 0&&(W.addEventListener("dispose",pt),It=new Map,we.programs=It);let At=It.get(Tt);if(At!==void 0){if(we.currentProgram===At&&we.lightsStateVersion===xt)return ey(W,Ct),At}else Ct.uniforms=Ae.getUniforms(W),W.onBuild(Se,Ct,S),W.onBeforeCompile(Ct,S),At=Ae.acquireProgram(Ct,Tt),It.set(Tt,At),we.uniforms=Ct.uniforms;const Nt=we.uniforms;return(!W.isShaderMaterial&&!W.isRawShaderMaterial||W.clipping===!0)&&(Nt.clippingPlanes=Fe.uniform),ey(W,Ct),we.needsLights=__(W),we.lightsStateVersion=xt,we.needsLights&&(Nt.ambientLightColor.value=xe.state.ambient,Nt.lightProbe.value=xe.state.probe,Nt.directionalLights.value=xe.state.directional,Nt.directionalLightShadows.value=xe.state.directionalShadow,Nt.spotLights.value=xe.state.spot,Nt.spotLightShadows.value=xe.state.spotShadow,Nt.rectAreaLights.value=xe.state.rectArea,Nt.ltc_1.value=xe.state.rectAreaLTC1,Nt.ltc_2.value=xe.state.rectAreaLTC2,Nt.pointLights.value=xe.state.point,Nt.pointLightShadows.value=xe.state.pointShadow,Nt.hemisphereLights.value=xe.state.hemi,Nt.directionalShadowMap.value=xe.state.directionalShadowMap,Nt.directionalShadowMatrix.value=xe.state.directionalShadowMatrix,Nt.spotShadowMap.value=xe.state.spotShadowMap,Nt.spotLightMatrix.value=xe.state.spotLightMatrix,Nt.spotLightMap.value=xe.state.spotLightMap,Nt.pointShadowMap.value=xe.state.pointShadowMap,Nt.pointShadowMatrix.value=xe.state.pointShadowMatrix),we.currentProgram=At,we.uniformsList=null,At}function Z0(W){if(W.uniformsList===null){const de=W.currentProgram.getUniforms();W.uniformsList=Zx.seqWithValue(de.seq,W.uniforms)}return W.uniformsList}function ey(W,de){const Se=V.get(W);Se.outputColorSpace=de.outputColorSpace,Se.batching=de.batching,Se.instancing=de.instancing,Se.instancingColor=de.instancingColor,Se.instancingMorph=de.instancingMorph,Se.skinning=de.skinning,Se.morphTargets=de.morphTargets,Se.morphNormals=de.morphNormals,Se.morphColors=de.morphColors,Se.morphTargetsCount=de.morphTargetsCount,Se.numClippingPlanes=de.numClippingPlanes,Se.numIntersection=de.numClipIntersection,Se.vertexAlphas=de.vertexAlphas,Se.vertexTangents=de.vertexTangents,Se.toneMapping=de.toneMapping}function b_(W,de,Se,we,xe){de.isScene!==!0&&(de=je),$.resetTextureUnits();const tt=de.fog,xt=we.isMeshStandardMaterial?de.environment:null,Ct=T===null?S.outputColorSpace:T.isXRRenderTarget===!0?T.texture.colorSpace:Ml,Tt=(we.isMeshStandardMaterial?ye:ue).get(we.envMap||xt),It=we.vertexColors===!0&&!!Se.attributes.color&&Se.attributes.color.itemSize===4,At=!!Se.attributes.tangent&&(!!we.normalMap||we.anisotropy>0),Nt=!!Se.morphAttributes.position,kn=!!Se.morphAttributes.normal,Ei=!!Se.morphAttributes.color;let Zn=Ca;we.toneMapped&&(T===null||T.isXRRenderTarget===!0)&&(Zn=S.toneMapping);const ni=Se.morphAttributes.position||Se.morphAttributes.normal||Se.morphAttributes.color,rn=ni!==void 0?ni.length:0,at=V.get(we),pn=v.state.lights;if(re===!0&&(pe===!0||W!==N)){const Ai=W===N&&we.id===I;Fe.setState(we,W,Ai)}let tn=!1;we.version===at.__version?(at.needsLights&&at.lightsStateVersion!==pn.state.version||at.outputColorSpace!==Ct||xe.isBatchedMesh&&at.batching===!1||!xe.isBatchedMesh&&at.batching===!0||xe.isInstancedMesh&&at.instancing===!1||!xe.isInstancedMesh&&at.instancing===!0||xe.isSkinnedMesh&&at.skinning===!1||!xe.isSkinnedMesh&&at.skinning===!0||xe.isInstancedMesh&&at.instancingColor===!0&&xe.instanceColor===null||xe.isInstancedMesh&&at.instancingColor===!1&&xe.instanceColor!==null||xe.isInstancedMesh&&at.instancingMorph===!0&&xe.morphTexture===null||xe.isInstancedMesh&&at.instancingMorph===!1&&xe.morphTexture!==null||at.envMap!==Tt||we.fog===!0&&at.fog!==tt||at.numClippingPlanes!==void 0&&(at.numClippingPlanes!==Fe.numPlanes||at.numIntersection!==Fe.numIntersection)||at.vertexAlphas!==It||at.vertexTangents!==At||at.morphTargets!==Nt||at.morphNormals!==kn||at.morphColors!==Ei||at.toneMapping!==Zn||at.morphTargetsCount!==rn)&&(tn=!0):(tn=!0,at.__version=we.version);let Fn=at.currentProgram;tn===!0&&(Fn=na(we,de,xe));let Kr=!1,cs=!1,ra=!1;const cn=Fn.getUniforms(),us=at.uniforms;if(Ie.useProgram(Fn.program)&&(Kr=!0,cs=!0,ra=!0),we.id!==I&&(I=we.id,cs=!0),Kr||N!==W){cn.setValue(te,"projectionMatrix",W.projectionMatrix),cn.setValue(te,"viewMatrix",W.matrixWorldInverse);const Ai=cn.map.cameraPosition;Ai!==void 0&&Ai.setValue(te,We.setFromMatrixPosition(W.matrixWorld)),Me.logarithmicDepthBuffer&&cn.setValue(te,"logDepthBufFC",2/(Math.log(W.far+1)/Math.LN2)),(we.isMeshPhongMaterial||we.isMeshToonMaterial||we.isMeshLambertMaterial||we.isMeshBasicMaterial||we.isMeshStandardMaterial||we.isShaderMaterial)&&cn.setValue(te,"isOrthographic",W.isOrthographicCamera===!0),N!==W&&(N=W,cs=!0,ra=!0)}if(xe.isSkinnedMesh){cn.setOptional(te,xe,"bindMatrix"),cn.setOptional(te,xe,"bindMatrixInverse");const Ai=xe.skeleton;Ai&&(Ai.boneTexture===null&&Ai.computeBoneTexture(),cn.setValue(te,"boneTexture",Ai.boneTexture,$))}xe.isBatchedMesh&&(cn.setOptional(te,xe,"batchingTexture"),cn.setValue(te,"batchingTexture",xe._matricesTexture,$));const Vd=Se.morphAttributes;if((Vd.position!==void 0||Vd.normal!==void 0||Vd.color!==void 0)&&ot.update(xe,Se,Fn),(cs||at.receiveShadow!==xe.receiveShadow)&&(at.receiveShadow=xe.receiveShadow,cn.setValue(te,"receiveShadow",xe.receiveShadow)),we.isMeshGouraudMaterial&&we.envMap!==null&&(us.envMap.value=Tt,us.flipEnvMap.value=Tt.isCubeTexture&&Tt.isRenderTargetTexture===!1?-1:1),we.isMeshStandardMaterial&&we.envMap===null&&de.environment!==null&&(us.envMapIntensity.value=de.environmentIntensity),cs&&(cn.setValue(te,"toneMappingExposure",S.toneMappingExposure),at.needsLights&&S_(us,ra),tt&&we.fog===!0&&st.refreshFogUniforms(us,tt),st.refreshMaterialUniforms(us,we,ne,Z,v.state.transmissionRenderTarget),Zx.upload(te,Z0(at),us,$)),we.isShaderMaterial&&we.uniformsNeedUpdate===!0&&(Zx.upload(te,Z0(at),us,$),we.uniformsNeedUpdate=!1),we.isSpriteMaterial&&cn.setValue(te,"center",xe.center),cn.setValue(te,"modelViewMatrix",xe.modelViewMatrix),cn.setValue(te,"normalMatrix",xe.normalMatrix),cn.setValue(te,"modelMatrix",xe.matrixWorld),we.isShaderMaterial||we.isRawShaderMaterial){const Ai=we.uniformsGroups;for(let kl=0,ty=Ai.length;kl<ty;kl++){const Gi=Ai[kl];ie.update(Gi,Fn),ie.bind(Gi,Fn)}}return Fn}function S_(W,de){W.ambientLightColor.needsUpdate=de,W.lightProbe.needsUpdate=de,W.directionalLights.needsUpdate=de,W.directionalLightShadows.needsUpdate=de,W.pointLights.needsUpdate=de,W.pointLightShadows.needsUpdate=de,W.spotLights.needsUpdate=de,W.spotLightShadows.needsUpdate=de,W.rectAreaLights.needsUpdate=de,W.hemisphereLights.needsUpdate=de}function __(W){return W.isMeshLambertMaterial||W.isMeshToonMaterial||W.isMeshPhongMaterial||W.isMeshStandardMaterial||W.isShadowMaterial||W.isShaderMaterial&&W.lights===!0}this.getActiveCubeFace=function(){return E},this.getActiveMipmapLevel=function(){return A},this.getRenderTarget=function(){return T},this.setRenderTargetTextures=function(W,de,Se){V.get(W.texture).__webglTexture=de,V.get(W.depthTexture).__webglTexture=Se;const we=V.get(W);we.__hasExternalTextures=!0,we.__autoAllocateDepthBuffer=Se===void 0,we.__autoAllocateDepthBuffer||ce.has("WEBGL_multisampled_render_to_texture")===!0&&(console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),we.__useRenderToTexture=!1)},this.setRenderTargetFramebuffer=function(W,de){const Se=V.get(W);Se.__webglFramebuffer=de,Se.__useDefaultFramebuffer=de===void 0},this.setRenderTarget=function(W,de=0,Se=0){T=W,E=de,A=Se;let we=!0,xe=null,tt=!1,xt=!1;if(W){const Tt=V.get(W);Tt.__useDefaultFramebuffer!==void 0?(Ie.bindFramebuffer(te.FRAMEBUFFER,null),we=!1):Tt.__webglFramebuffer===void 0?$.setupRenderTarget(W):Tt.__hasExternalTextures&&$.rebindTextures(W,V.get(W.texture).__webglTexture,V.get(W.depthTexture).__webglTexture);const It=W.texture;(It.isData3DTexture||It.isDataArrayTexture||It.isCompressedArrayTexture)&&(xt=!0);const At=V.get(W).__webglFramebuffer;W.isWebGLCubeRenderTarget?(Array.isArray(At[de])?xe=At[de][Se]:xe=At[de],tt=!0):W.samples>0&&$.useMultisampledRTT(W)===!1?xe=V.get(W).__webglMultisampledFramebuffer:Array.isArray(At)?xe=At[Se]:xe=At,M.copy(W.viewport),P.copy(W.scissor),B=W.scissorTest}else M.copy(q).multiplyScalar(ne).floor(),P.copy(se).multiplyScalar(ne).floor(),B=he;if(Ie.bindFramebuffer(te.FRAMEBUFFER,xe)&&we&&Ie.drawBuffers(W,xe),Ie.viewport(M),Ie.scissor(P),Ie.setScissorTest(B),tt){const Tt=V.get(W.texture);te.framebufferTexture2D(te.FRAMEBUFFER,te.COLOR_ATTACHMENT0,te.TEXTURE_CUBE_MAP_POSITIVE_X+de,Tt.__webglTexture,Se)}else if(xt){const Tt=V.get(W.texture),It=de||0;te.framebufferTextureLayer(te.FRAMEBUFFER,te.COLOR_ATTACHMENT0,Tt.__webglTexture,Se||0,It)}I=-1},this.readRenderTargetPixels=function(W,de,Se,we,xe,tt,xt){if(!(W&&W.isWebGLRenderTarget)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");return}let Ct=V.get(W).__webglFramebuffer;if(W.isWebGLCubeRenderTarget&&xt!==void 0&&(Ct=Ct[xt]),Ct){Ie.bindFramebuffer(te.FRAMEBUFFER,Ct);try{const Tt=W.texture,It=Tt.format,At=Tt.type;if(It!==Yi&&yt.convert(It)!==te.getParameter(te.IMPLEMENTATION_COLOR_READ_FORMAT)){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");return}const Nt=At===Bg&&(ce.has("EXT_color_buffer_half_float")||ce.has("EXT_color_buffer_float"));if(At!==Ea&&yt.convert(At)!==te.getParameter(te.IMPLEMENTATION_COLOR_READ_TYPE)&&At!==lo&&!Nt){console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");return}de>=0&&de<=W.width-we&&Se>=0&&Se<=W.height-xe&&te.readPixels(de,Se,we,xe,yt.convert(It),yt.convert(At),tt)}finally{const Tt=T!==null?V.get(T).__webglFramebuffer:null;Ie.bindFramebuffer(te.FRAMEBUFFER,Tt)}}},this.copyFramebufferToTexture=function(W,de,Se=0){const we=Math.pow(2,-Se),xe=Math.floor(de.image.width*we),tt=Math.floor(de.image.height*we);$.setTexture2D(de,0),te.copyTexSubImage2D(te.TEXTURE_2D,Se,0,0,W.x,W.y,xe,tt),Ie.unbindTexture()},this.copyTextureToTexture=function(W,de,Se,we=0){const xe=de.image.width,tt=de.image.height,xt=yt.convert(Se.format),Ct=yt.convert(Se.type);$.setTexture2D(Se,0),te.pixelStorei(te.UNPACK_FLIP_Y_WEBGL,Se.flipY),te.pixelStorei(te.UNPACK_PREMULTIPLY_ALPHA_WEBGL,Se.premultiplyAlpha),te.pixelStorei(te.UNPACK_ALIGNMENT,Se.unpackAlignment),de.isDataTexture?te.texSubImage2D(te.TEXTURE_2D,we,W.x,W.y,xe,tt,xt,Ct,de.image.data):de.isCompressedTexture?te.compressedTexSubImage2D(te.TEXTURE_2D,we,W.x,W.y,de.mipmaps[0].width,de.mipmaps[0].height,xt,de.mipmaps[0].data):te.texSubImage2D(te.TEXTURE_2D,we,W.x,W.y,xt,Ct,de.image),we===0&&Se.generateMipmaps&&te.generateMipmap(te.TEXTURE_2D),Ie.unbindTexture()},this.copyTextureToTexture3D=function(W,de,Se,we,xe=0){const tt=Math.round(W.max.x-W.min.x),xt=Math.round(W.max.y-W.min.y),Ct=W.max.z-W.min.z+1,Tt=yt.convert(we.format),It=yt.convert(we.type);let At;if(we.isData3DTexture)$.setTexture3D(we,0),At=te.TEXTURE_3D;else if(we.isDataArrayTexture||we.isCompressedArrayTexture)$.setTexture2DArray(we,0),At=te.TEXTURE_2D_ARRAY;else{console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");return}te.pixelStorei(te.UNPACK_FLIP_Y_WEBGL,we.flipY),te.pixelStorei(te.UNPACK_PREMULTIPLY_ALPHA_WEBGL,we.premultiplyAlpha),te.pixelStorei(te.UNPACK_ALIGNMENT,we.unpackAlignment);const Nt=te.getParameter(te.UNPACK_ROW_LENGTH),kn=te.getParameter(te.UNPACK_IMAGE_HEIGHT),Ei=te.getParameter(te.UNPACK_SKIP_PIXELS),Zn=te.getParameter(te.UNPACK_SKIP_ROWS),ni=te.getParameter(te.UNPACK_SKIP_IMAGES),rn=Se.isCompressedTexture?Se.mipmaps[xe]:Se.image;te.pixelStorei(te.UNPACK_ROW_LENGTH,rn.width),te.pixelStorei(te.UNPACK_IMAGE_HEIGHT,rn.height),te.pixelStorei(te.UNPACK_SKIP_PIXELS,W.min.x),te.pixelStorei(te.UNPACK_SKIP_ROWS,W.min.y),te.pixelStorei(te.UNPACK_SKIP_IMAGES,W.min.z),Se.isDataTexture||Se.isData3DTexture?te.texSubImage3D(At,xe,de.x,de.y,de.z,tt,xt,Ct,Tt,It,rn.data):we.isCompressedArrayTexture?te.compressedTexSubImage3D(At,xe,de.x,de.y,de.z,tt,xt,Ct,Tt,rn.data):te.texSubImage3D(At,xe,de.x,de.y,de.z,tt,xt,Ct,Tt,It,rn),te.pixelStorei(te.UNPACK_ROW_LENGTH,Nt),te.pixelStorei(te.UNPACK_IMAGE_HEIGHT,kn),te.pixelStorei(te.UNPACK_SKIP_PIXELS,Ei),te.pixelStorei(te.UNPACK_SKIP_ROWS,Zn),te.pixelStorei(te.UNPACK_SKIP_IMAGES,ni),xe===0&&we.generateMipmaps&&te.generateMipmap(At),Ie.unbindTexture()},this.initTexture=function(W){W.isCubeTexture?$.setTextureCube(W,0):W.isData3DTexture?$.setTexture3D(W,0):W.isDataArrayTexture||W.isCompressedArrayTexture?$.setTexture2DArray(W,0):$.setTexture2D(W,0),Ie.unbindTexture()},this.resetState=function(){E=0,A=0,T=null,Ie.reset(),_t.reset()},typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}get coordinateSystem(){return xa}get outputColorSpace(){return this._outputColorSpace}set outputColorSpace(e){this._outputColorSpace=e;const n=this.getContext();n.drawingBufferColorSpace=e===MS?"display-p3":"srgb",n.unpackColorSpace=gn.workingColorSpace===A0?"display-p3":"srgb"}get useLegacyLights(){return console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights}set useLegacyLights(e){console.warn("THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."),this._useLegacyLights=e}}class NS{constructor(e,n=25e-5){this.isFogExp2=!0,this.name="",this.color=new Qe(e),this.density=n}clone(){return new NS(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class PS{constructor(e,n=1,r=1e3){this.isFog=!0,this.name="",this.color=new Qe(e),this.near=n,this.far=r}clone(){return new PS(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class Wg extends Zt{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Is,this.environmentIntensity=1,this.environmentRotation=new Is,this.overrideMaterial=null,typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(e,n){return super.copy(e,n),e.background!==null&&(this.background=e.background.clone()),e.environment!==null&&(this.environment=e.environment.clone()),e.fog!==null&&(this.fog=e.fog.clone()),this.backgroundBlurriness=e.backgroundBlurriness,this.backgroundIntensity=e.backgroundIntensity,this.backgroundRotation.copy(e.backgroundRotation),this.environmentIntensity=e.environmentIntensity,this.environmentRotation.copy(e.environmentRotation),e.overrideMaterial!==null&&(this.overrideMaterial=e.overrideMaterial.clone()),this.matrixAutoUpdate=e.matrixAutoUpdate,this}toJSON(e){const n=super.toJSON(e);return this.fog!==null&&(n.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(n.object.backgroundBlurriness=this.backgroundBlurriness),this.backgroundIntensity!==1&&(n.object.backgroundIntensity=this.backgroundIntensity),n.object.backgroundRotation=this.backgroundRotation.toArray(),this.environmentIntensity!==1&&(n.object.environmentIntensity=this.environmentIntensity),n.object.environmentRotation=this.environmentRotation.toArray(),n}}class I0{constructor(e,n){this.isInterleavedBuffer=!0,this.array=e,this.stride=n,this.count=e!==void 0?e.length/n:0,this.usage=Gg,this._updateRange={offset:0,count:-1},this.updateRanges=[],this.version=0,this.uuid=Ms()}onUploadCallback(){}set needsUpdate(e){e===!0&&this.version++}get updateRange(){return _5("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),this._updateRange}setUsage(e){return this.usage=e,this}addUpdateRange(e,n){this.updateRanges.push({start:e,count:n})}clearUpdateRanges(){this.updateRanges.length=0}copy(e){return this.array=new e.array.constructor(e.array),this.count=e.count,this.stride=e.stride,this.usage=e.usage,this}copyAt(e,n,r){e*=this.stride,r*=n.stride;for(let i=0,s=this.stride;i<s;i++)this.array[e+i]=n.array[r+i];return this}set(e,n=0){return this.array.set(e,n),this}clone(e){e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ms()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const n=new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),r=new this.constructor(n,this.stride);return r.setUsage(this.usage),r}onUpload(e){return this.onUploadCallback=e,this}toJSON(e){return e.arrayBuffers===void 0&&(e.arrayBuffers={}),this.array.buffer._uuid===void 0&&(this.array.buffer._uuid=Ms()),e.arrayBuffers[this.array.buffer._uuid]===void 0&&(e.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const Ri=new K;class Mc{constructor(e,n,r,i=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=e,this.itemSize=n,this.offset=r,this.normalized=i}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(e){this.data.needsUpdate=e}applyMatrix4(e){for(let n=0,r=this.data.count;n<r;n++)Ri.fromBufferAttribute(this,n),Ri.applyMatrix4(e),this.setXYZ(n,Ri.x,Ri.y,Ri.z);return this}applyNormalMatrix(e){for(let n=0,r=this.count;n<r;n++)Ri.fromBufferAttribute(this,n),Ri.applyNormalMatrix(e),this.setXYZ(n,Ri.x,Ri.y,Ri.z);return this}transformDirection(e){for(let n=0,r=this.count;n<r;n++)Ri.fromBufferAttribute(this,n),Ri.transformDirection(e),this.setXYZ(n,Ri.x,Ri.y,Ri.z);return this}getComponent(e,n){let r=this.array[e*this.data.stride+this.offset+n];return this.normalized&&(r=Pi(r,this.array)),r}setComponent(e,n,r){return this.normalized&&(r=Ut(r,this.array)),this.data.array[e*this.data.stride+this.offset+n]=r,this}setX(e,n){return this.normalized&&(n=Ut(n,this.array)),this.data.array[e*this.data.stride+this.offset]=n,this}setY(e,n){return this.normalized&&(n=Ut(n,this.array)),this.data.array[e*this.data.stride+this.offset+1]=n,this}setZ(e,n){return this.normalized&&(n=Ut(n,this.array)),this.data.array[e*this.data.stride+this.offset+2]=n,this}setW(e,n){return this.normalized&&(n=Ut(n,this.array)),this.data.array[e*this.data.stride+this.offset+3]=n,this}getX(e){let n=this.data.array[e*this.data.stride+this.offset];return this.normalized&&(n=Pi(n,this.array)),n}getY(e){let n=this.data.array[e*this.data.stride+this.offset+1];return this.normalized&&(n=Pi(n,this.array)),n}getZ(e){let n=this.data.array[e*this.data.stride+this.offset+2];return this.normalized&&(n=Pi(n,this.array)),n}getW(e){let n=this.data.array[e*this.data.stride+this.offset+3];return this.normalized&&(n=Pi(n,this.array)),n}setXY(e,n,r){return e=e*this.data.stride+this.offset,this.normalized&&(n=Ut(n,this.array),r=Ut(r,this.array)),this.data.array[e+0]=n,this.data.array[e+1]=r,this}setXYZ(e,n,r,i){return e=e*this.data.stride+this.offset,this.normalized&&(n=Ut(n,this.array),r=Ut(r,this.array),i=Ut(i,this.array)),this.data.array[e+0]=n,this.data.array[e+1]=r,this.data.array[e+2]=i,this}setXYZW(e,n,r,i,s){return e=e*this.data.stride+this.offset,this.normalized&&(n=Ut(n,this.array),r=Ut(r,this.array),i=Ut(i,this.array),s=Ut(s,this.array)),this.data.array[e+0]=n,this.data.array[e+1]=r,this.data.array[e+2]=i,this.data.array[e+3]=s,this}clone(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const n=[];for(let r=0;r<this.count;r++){const i=r*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)n.push(this.data.array[i+s])}return new en(new this.array.constructor(n),this.itemSize,this.normalized)}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.clone(e)),new Mc(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(e){if(e===void 0){console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const n=[];for(let r=0;r<this.count;r++){const i=r*this.data.stride+this.offset;for(let s=0;s<this.itemSize;s++)n.push(this.data.array[i+s])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:n,normalized:this.normalized}}else return e.interleavedBuffers===void 0&&(e.interleavedBuffers={}),e.interleavedBuffers[this.data.uuid]===void 0&&(e.interleavedBuffers[this.data.uuid]=this.data.toJSON(e)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}class BR extends wr{constructor(e){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Qe(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.rotation=e.rotation,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}let Tf;const Sm=new K,Mf=new K,Rf=new K,If=new Re,_m=new Re,F5=new St,Hv=new K,wm=new K,Vv=new K,vO=new Re,JC=new Re,xO=new Re;class $5 extends Zt{constructor(e=new BR){if(super(),this.isSprite=!0,this.type="Sprite",Tf===void 0){Tf=new Lt;const n=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),r=new I0(n,5);Tf.setIndex([0,1,2,0,2,3]),Tf.setAttribute("position",new Mc(r,3,0,!1)),Tf.setAttribute("uv",new Mc(r,2,3,!1))}this.geometry=Tf,this.material=e,this.center=new Re(.5,.5)}raycast(e,n){e.camera===null&&console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),Mf.setFromMatrixScale(this.matrixWorld),F5.copy(e.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse,this.matrixWorld),Rf.setFromMatrixPosition(this.modelViewMatrix),e.camera.isPerspectiveCamera&&this.material.sizeAttenuation===!1&&Mf.multiplyScalar(-Rf.z);const r=this.material.rotation;let i,s;r!==0&&(s=Math.cos(r),i=Math.sin(r));const o=this.center;Wv(Hv.set(-.5,-.5,0),Rf,o,Mf,i,s),Wv(wm.set(.5,-.5,0),Rf,o,Mf,i,s),Wv(Vv.set(.5,.5,0),Rf,o,Mf,i,s),vO.set(0,0),JC.set(1,0),xO.set(1,1);let a=e.ray.intersectTriangle(Hv,wm,Vv,!1,Sm);if(a===null&&(Wv(wm.set(-.5,.5,0),Rf,o,Mf,i,s),JC.set(0,1),a=e.ray.intersectTriangle(Hv,Vv,wm,!1,Sm),a===null))return;const l=e.ray.origin.distanceTo(Sm);l<e.near||l>e.far||n.push({distance:l,point:Sm.clone(),uv:Ss.getInterpolation(Sm,Hv,wm,Vv,vO,JC,xO,new Re),face:null,object:this})}copy(e,n){return super.copy(e,n),e.center!==void 0&&this.center.copy(e.center),this.material=e.material,this}}function Wv(t,e,n,r,i,s){If.subVectors(t,n).addScalar(.5).multiply(r),i!==void 0?(_m.x=s*If.x-i*If.y,_m.y=i*If.x+s*If.y):_m.copy(If),t.copy(e),t.x+=_m.x,t.y+=_m.y,t.applyMatrix4(F5)}const jv=new K,bO=new K;class U5 extends Zt{constructor(){super(),this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]},isLOD:{value:!0}}),this.autoUpdate=!0}copy(e){super.copy(e,!1);const n=e.levels;for(let r=0,i=n.length;r<i;r++){const s=n[r];this.addLevel(s.object.clone(),s.distance,s.hysteresis)}return this.autoUpdate=e.autoUpdate,this}addLevel(e,n=0,r=0){n=Math.abs(n);const i=this.levels;let s;for(s=0;s<i.length&&!(n<i[s].distance);s++);return i.splice(s,0,{distance:n,hysteresis:r,object:e}),this.add(e),this}getCurrentLevel(){return this._currentLevel}getObjectForDistance(e){const n=this.levels;if(n.length>0){let r,i;for(r=1,i=n.length;r<i;r++){let s=n[r].distance;if(n[r].object.visible&&(s-=s*n[r].hysteresis),e<s)break}return n[r-1].object}return null}raycast(e,n){if(this.levels.length>0){jv.setFromMatrixPosition(this.matrixWorld);const i=e.ray.origin.distanceTo(jv);this.getObjectForDistance(i).raycast(e,n)}}update(e){const n=this.levels;if(n.length>1){jv.setFromMatrixPosition(e.matrixWorld),bO.setFromMatrixPosition(this.matrixWorld);const r=jv.distanceTo(bO)/e.zoom;n[0].object.visible=!0;let i,s;for(i=1,s=n.length;i<s;i++){let o=n[i].distance;if(n[i].object.visible&&(o-=o*n[i].hysteresis),r>=o)n[i-1].object.visible=!1,n[i].object.visible=!0;else break}for(this._currentLevel=i-1;i<s;i++)n[i].object.visible=!1}}toJSON(e){const n=super.toJSON(e);this.autoUpdate===!1&&(n.object.autoUpdate=!1),n.object.levels=[];const r=this.levels;for(let i=0,s=r.length;i<s;i++){const o=r[i];n.object.levels.push({object:o.object.uuid,distance:o.distance,hysteresis:o.hysteresis})}return n}}const SO=new K,_O=new vn,wO=new vn,Ohe=new K,CO=new St,Xv=new K,YC=new Zr,EO=new St,QC=new Nd;class FR extends lr{constructor(e,n){super(e,n),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode=o2,this.bindMatrix=new St,this.bindMatrixInverse=new St,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const e=this.geometry;this.boundingBox===null&&(this.boundingBox=new vi),this.boundingBox.makeEmpty();const n=e.getAttribute("position");for(let r=0;r<n.count;r++)this.getVertexPosition(r,Xv),this.boundingBox.expandByPoint(Xv)}computeBoundingSphere(){const e=this.geometry;this.boundingSphere===null&&(this.boundingSphere=new Zr),this.boundingSphere.makeEmpty();const n=e.getAttribute("position");for(let r=0;r<n.count;r++)this.getVertexPosition(r,Xv),this.boundingSphere.expandByPoint(Xv)}copy(e,n){return super.copy(e,n),this.bindMode=e.bindMode,this.bindMatrix.copy(e.bindMatrix),this.bindMatrixInverse.copy(e.bindMatrixInverse),this.skeleton=e.skeleton,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}raycast(e,n){const r=this.material,i=this.matrixWorld;r!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),YC.copy(this.boundingSphere),YC.applyMatrix4(i),e.ray.intersectsSphere(YC)!==!1&&(EO.copy(i).invert(),QC.copy(e.ray).applyMatrix4(EO),!(this.boundingBox!==null&&QC.intersectsBox(this.boundingBox)===!1)&&this._computeIntersections(e,n,QC)))}getVertexPosition(e,n){return super.getVertexPosition(e,n),this.applyBoneTransform(e,n),n}bind(e,n){this.skeleton=e,n===void 0&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),n=this.matrixWorld),this.bindMatrix.copy(n),this.bindMatrixInverse.copy(n).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const e=new vn,n=this.geometry.attributes.skinWeight;for(let r=0,i=n.count;r<i;r++){e.fromBufferAttribute(n,r);const s=1/e.manhattanLength();s!==1/0?e.multiplyScalar(s):e.set(1,0,0,0),n.setXYZW(r,e.x,e.y,e.z,e.w)}}updateMatrixWorld(e){super.updateMatrixWorld(e),this.bindMode===o2?this.bindMatrixInverse.copy(this.matrixWorld).invert():this.bindMode===q9?this.bindMatrixInverse.copy(this.bindMatrix).invert():console.warn("THREE.SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(e,n){const r=this.skeleton,i=this.geometry;_O.fromBufferAttribute(i.attributes.skinIndex,e),wO.fromBufferAttribute(i.attributes.skinWeight,e),SO.copy(n).applyMatrix4(this.bindMatrix),n.set(0,0,0);for(let s=0;s<4;s++){const o=wO.getComponent(s);if(o!==0){const a=_O.getComponent(s);CO.multiplyMatrices(r.bones[a].matrixWorld,r.boneInverses[a]),n.addScaledVector(Ohe.copy(SO).applyMatrix4(CO),o)}}return n.applyMatrix4(this.bindMatrixInverse)}}class kS extends Zt{constructor(){super(),this.isBone=!0,this.type="Bone"}}class bc extends Bn{constructor(e=null,n=1,r=1,i,s,o,a,l,c=Nr,u=Nr,d,f){super(null,o,a,l,c,u,i,s,d,f),this.isDataTexture=!0,this.image={data:e,width:n,height:r},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const AO=new St,Lhe=new St;class N0{constructor(e=[],n=[]){this.uuid=Ms(),this.bones=e.slice(0),this.boneInverses=n,this.boneMatrices=null,this.boneTexture=null,this.init()}init(){const e=this.bones,n=this.boneInverses;if(this.boneMatrices=new Float32Array(e.length*16),n.length===0)this.calculateInverses();else if(e.length!==n.length){console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let r=0,i=this.bones.length;r<i;r++)this.boneInverses.push(new St)}}calculateInverses(){this.boneInverses.length=0;for(let e=0,n=this.bones.length;e<n;e++){const r=new St;this.bones[e]&&r.copy(this.bones[e].matrixWorld).invert(),this.boneInverses.push(r)}}pose(){for(let e=0,n=this.bones.length;e<n;e++){const r=this.bones[e];r&&r.matrixWorld.copy(this.boneInverses[e]).invert()}for(let e=0,n=this.bones.length;e<n;e++){const r=this.bones[e];r&&(r.parent&&r.parent.isBone?(r.matrix.copy(r.parent.matrixWorld).invert(),r.matrix.multiply(r.matrixWorld)):r.matrix.copy(r.matrixWorld),r.matrix.decompose(r.position,r.quaternion,r.scale))}}update(){const e=this.bones,n=this.boneInverses,r=this.boneMatrices,i=this.boneTexture;for(let s=0,o=e.length;s<o;s++){const a=e[s]?e[s].matrixWorld:Lhe;AO.multiplyMatrices(a,n[s]),AO.toArray(r,s*16)}i!==null&&(i.needsUpdate=!0)}clone(){return new N0(this.bones,this.boneInverses)}computeBoneTexture(){let e=Math.sqrt(this.bones.length*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const n=new Float32Array(e*e*4);n.set(this.boneMatrices);const r=new bc(n,e,e,Yi,lo);return r.needsUpdate=!0,this.boneMatrices=n,this.boneTexture=r,this}getBoneByName(e){for(let n=0,r=this.bones.length;n<r;n++){const i=this.bones[n];if(i.name===e)return i}}dispose(){this.boneTexture!==null&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(e,n){this.uuid=e.uuid;for(let r=0,i=e.bones.length;r<i;r++){const s=e.bones[r];let o=n[s];o===void 0&&(console.warn("THREE.Skeleton: No bone found with UUID:",s),o=new kS),this.bones.push(o),this.boneInverses.push(new St().fromArray(e.boneInverses[r]))}return this.init(),this}toJSON(){const e={metadata:{version:4.6,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};e.uuid=this.uuid;const n=this.bones,r=this.boneInverses;for(let i=0,s=n.length;i<s;i++){const o=n[i];e.bones.push(o.uuid);const a=r[i];e.boneInverses.push(a.toArray())}return e}}class Vh extends en{constructor(e,n,r,i=1){super(e,n,r),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=i}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}toJSON(){const e=super.toJSON();return e.meshPerAttribute=this.meshPerAttribute,e.isInstancedBufferAttribute=!0,e}}const Nf=new St,TO=new St,Kv=[],MO=new vi,Bhe=new St,Cm=new lr,Em=new Zr;class $R extends lr{constructor(e,n,r){super(e,n),this.isInstancedMesh=!0,this.instanceMatrix=new Vh(new Float32Array(r*16),16),this.instanceColor=null,this.morphTexture=null,this.count=r,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<r;i++)this.setMatrixAt(i,Bhe)}computeBoundingBox(){const e=this.geometry,n=this.count;this.boundingBox===null&&(this.boundingBox=new vi),e.boundingBox===null&&e.computeBoundingBox(),this.boundingBox.makeEmpty();for(let r=0;r<n;r++)this.getMatrixAt(r,Nf),MO.copy(e.boundingBox).applyMatrix4(Nf),this.boundingBox.union(MO)}computeBoundingSphere(){const e=this.geometry,n=this.count;this.boundingSphere===null&&(this.boundingSphere=new Zr),e.boundingSphere===null&&e.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let r=0;r<n;r++)this.getMatrixAt(r,Nf),Em.copy(e.boundingSphere).applyMatrix4(Nf),this.boundingSphere.union(Em)}copy(e,n){return super.copy(e,n),this.instanceMatrix.copy(e.instanceMatrix),e.morphTexture!==null&&(this.morphTexture=e.morphTexture.clone()),e.instanceColor!==null&&(this.instanceColor=e.instanceColor.clone()),this.count=e.count,e.boundingBox!==null&&(this.boundingBox=e.boundingBox.clone()),e.boundingSphere!==null&&(this.boundingSphere=e.boundingSphere.clone()),this}getColorAt(e,n){n.fromArray(this.instanceColor.array,e*3)}getMatrixAt(e,n){n.fromArray(this.instanceMatrix.array,e*16)}getMorphAt(e,n){const r=n.morphTargetInfluences,i=this.morphTexture.source.data.data,s=r.length+1,o=e*s+1;for(let a=0;a<r.length;a++)r[a]=i[o+a]}raycast(e,n){const r=this.matrixWorld,i=this.count;if(Cm.geometry=this.geometry,Cm.material=this.material,Cm.material!==void 0&&(this.boundingSphere===null&&this.computeBoundingSphere(),Em.copy(this.boundingSphere),Em.applyMatrix4(r),e.ray.intersectsSphere(Em)!==!1))for(let s=0;s<i;s++){this.getMatrixAt(s,Nf),TO.multiplyMatrices(r,Nf),Cm.matrixWorld=TO,Cm.raycast(e,Kv);for(let o=0,a=Kv.length;o<a;o++){const l=Kv[o];l.instanceId=s,l.object=this,n.push(l)}Kv.length=0}}setColorAt(e,n){this.instanceColor===null&&(this.instanceColor=new Vh(new Float32Array(this.instanceMatrix.count*3),3)),n.toArray(this.instanceColor.array,e*3)}setMatrixAt(e,n){n.toArray(this.instanceMatrix.array,e*16)}setMorphAt(e,n){const r=n.morphTargetInfluences,i=r.length+1;this.morphTexture===null&&(this.morphTexture=new bc(new Float32Array(i*this.count),i,this.count,bR,lo));const s=this.morphTexture.source.data.data;let o=0;for(let c=0;c<r.length;c++)o+=r[c];const a=this.geometry.morphTargetsRelative?1:1-o,l=i*e;s[l]=a,s.set(r,l+1)}updateMorphTargets(){}dispose(){return this.dispatchEvent({type:"dispose"}),this.morphTexture!==null&&(this.morphTexture.dispose(),this.morphTexture=null),this}}function Fhe(t,e){return t.z-e.z}function $he(t,e){return e.z-t.z}class Uhe{constructor(){this.index=0,this.pool=[],this.list=[]}push(e,n){const r=this.pool,i=this.list;this.index>=r.length&&r.push({start:-1,count:-1,z:-1});const s=r[this.index];i.push(s),this.index++,s.start=e.start,s.count=e.count,s.z=n}reset(){this.list.length=0,this.index=0}}const Pf="batchId",Yl=new St,RO=new St,zhe=new St,IO=new St,ZC=new R0,qv=new vi,au=new Zr,Am=new K,eE=new Uhe,di=new lr,Jv=[];function Ghe(t,e,n=0){const r=e.itemSize;if(t.isInterleavedBufferAttribute||t.array.constructor!==e.array.constructor){const i=t.count;for(let s=0;s<i;s++)for(let o=0;o<r;o++)e.setComponent(s+n,o,t.getComponent(s,o))}else e.array.set(t.array,n*r);e.needsUpdate=!0}class z5 extends lr{get maxGeometryCount(){return this._maxGeometryCount}constructor(e,n,r=n*2,i){super(new Lt,i),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._drawRanges=[],this._reservedRanges=[],this._visibility=[],this._active=[],this._bounds=[],this._maxGeometryCount=e,this._maxVertexCount=n,this._maxIndexCount=r,this._geometryInitialized=!1,this._geometryCount=0,this._multiDrawCounts=new Int32Array(e),this._multiDrawStarts=new Int32Array(e),this._multiDrawCount=0,this._visibilityChanged=!0,this._matricesTexture=null,this._initMatricesTexture()}_initMatricesTexture(){let e=Math.sqrt(this._maxGeometryCount*4);e=Math.ceil(e/4)*4,e=Math.max(e,4);const n=new Float32Array(e*e*4),r=new bc(n,e,e,Yi,lo);this._matricesTexture=r}_initializeGeometry(e){const n=this.geometry,r=this._maxVertexCount,i=this._maxGeometryCount,s=this._maxIndexCount;if(this._geometryInitialized===!1){for(const a in e.attributes){const l=e.getAttribute(a),{array:c,itemSize:u,normalized:d}=l,f=new c.constructor(r*u),h=new en(f,u,d);n.setAttribute(a,h)}if(e.getIndex()!==null){const a=r>65536?new Uint32Array(s):new Uint16Array(s);n.setIndex(new en(a,1))}const o=i>65536?new Uint32Array(r):new Uint16Array(r);n.setAttribute(Pf,new en(o,1)),this._geometryInitialized=!0}}_validateGeometry(e){if(e.getAttribute(Pf))throw new Error(`BatchedMesh: Geometry cannot use attribute "${Pf}"`);const n=this.geometry;if(!!e.getIndex()!=!!n.getIndex())throw new Error('BatchedMesh: All geometries must consistently have "index".');for(const r in n.attributes){if(r===Pf)continue;if(!e.hasAttribute(r))throw new Error(`BatchedMesh: Added geometry missing "${r}". All geometries must have consistent attributes.`);const i=e.getAttribute(r),s=n.getAttribute(r);if(i.itemSize!==s.itemSize||i.normalized!==s.normalized)throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}setCustomSort(e){return this.customSort=e,this}computeBoundingBox(){this.boundingBox===null&&(this.boundingBox=new vi);const e=this._geometryCount,n=this.boundingBox,r=this._active;n.makeEmpty();for(let i=0;i<e;i++)r[i]!==!1&&(this.getMatrixAt(i,Yl),this.getBoundingBoxAt(i,qv).applyMatrix4(Yl),n.union(qv))}computeBoundingSphere(){this.boundingSphere===null&&(this.boundingSphere=new Zr);const e=this._geometryCount,n=this.boundingSphere,r=this._active;n.makeEmpty();for(let i=0;i<e;i++)r[i]!==!1&&(this.getMatrixAt(i,Yl),this.getBoundingSphereAt(i,au).applyMatrix4(Yl),n.union(au))}addGeometry(e,n=-1,r=-1){if(this._initializeGeometry(e),this._validateGeometry(e),this._geometryCount>=this._maxGeometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");const i={vertexStart:-1,vertexCount:-1,indexStart:-1,indexCount:-1};let s=null;const o=this._reservedRanges,a=this._drawRanges,l=this._bounds;this._geometryCount!==0&&(s=o[o.length-1]),n===-1?i.vertexCount=e.getAttribute("position").count:i.vertexCount=n,s===null?i.vertexStart=0:i.vertexStart=s.vertexStart+s.vertexCount;const c=e.getIndex(),u=c!==null;if(u&&(r===-1?i.indexCount=c.count:i.indexCount=r,s===null?i.indexStart=0:i.indexStart=s.indexStart+s.indexCount),i.indexStart!==-1&&i.indexStart+i.indexCount>this._maxIndexCount||i.vertexStart+i.vertexCount>this._maxVertexCount)throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");const d=this._visibility,f=this._active,h=this._matricesTexture,p=this._matricesTexture.image.data;d.push(!0),f.push(!0);const x=this._geometryCount;this._geometryCount++,zhe.toArray(p,x*16),h.needsUpdate=!0,o.push(i),a.push({start:u?i.indexStart:i.vertexStart,count:-1}),l.push({boxInitialized:!1,box:new vi,sphereInitialized:!1,sphere:new Zr});const v=this.geometry.getAttribute(Pf);for(let y=0;y<i.vertexCount;y++)v.setX(i.vertexStart+y,x);return v.needsUpdate=!0,this.setGeometryAt(x,e),x}setGeometryAt(e,n){if(e>=this._geometryCount)throw new Error("BatchedMesh: Maximum geometry count reached.");this._validateGeometry(n);const r=this.geometry,i=r.getIndex()!==null,s=r.getIndex(),o=n.getIndex(),a=this._reservedRanges[e];if(i&&o.count>a.indexCount||n.attributes.position.count>a.vertexCount)throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");const l=a.vertexStart,c=a.vertexCount;for(const h in r.attributes){if(h===Pf)continue;const p=n.getAttribute(h),x=r.getAttribute(h);Ghe(p,x,l);const v=p.itemSize;for(let y=p.count,b=c;y<b;y++){const S=l+y;for(let w=0;w<v;w++)x.setComponent(S,w,0)}x.needsUpdate=!0,x.addUpdateRange(l*v,c*v)}if(i){const h=a.indexStart;for(let p=0;p<o.count;p++)s.setX(h+p,l+o.getX(p));for(let p=o.count,x=a.indexCount;p<x;p++)s.setX(h+p,l);s.needsUpdate=!0,s.addUpdateRange(h,a.indexCount)}const u=this._bounds[e];n.boundingBox!==null?(u.box.copy(n.boundingBox),u.boxInitialized=!0):u.boxInitialized=!1,n.boundingSphere!==null?(u.sphere.copy(n.boundingSphere),u.sphereInitialized=!0):u.sphereInitialized=!1;const d=this._drawRanges[e],f=n.getAttribute("position");return d.count=i?o.count:f.count,this._visibilityChanged=!0,e}deleteGeometry(e){const n=this._active;return e>=n.length||n[e]===!1?this:(n[e]=!1,this._visibilityChanged=!0,this)}getBoundingBoxAt(e,n){if(this._active[e]===!1)return null;const i=this._bounds[e],s=i.box,o=this.geometry;if(i.boxInitialized===!1){s.makeEmpty();const a=o.index,l=o.attributes.position,c=this._drawRanges[e];for(let u=c.start,d=c.start+c.count;u<d;u++){let f=u;a&&(f=a.getX(f)),s.expandByPoint(Am.fromBufferAttribute(l,f))}i.boxInitialized=!0}return n.copy(s),n}getBoundingSphereAt(e,n){if(this._active[e]===!1)return null;const i=this._bounds[e],s=i.sphere,o=this.geometry;if(i.sphereInitialized===!1){s.makeEmpty(),this.getBoundingBoxAt(e,qv),qv.getCenter(s.center);const a=o.index,l=o.attributes.position,c=this._drawRanges[e];let u=0;for(let d=c.start,f=c.start+c.count;d<f;d++){let h=d;a&&(h=a.getX(h)),Am.fromBufferAttribute(l,h),u=Math.max(u,s.center.distanceToSquared(Am))}s.radius=Math.sqrt(u),i.sphereInitialized=!0}return n.copy(s),n}setMatrixAt(e,n){const r=this._active,i=this._matricesTexture,s=this._matricesTexture.image.data,o=this._geometryCount;return e>=o||r[e]===!1?this:(n.toArray(s,e*16),i.needsUpdate=!0,this)}getMatrixAt(e,n){const r=this._active,i=this._matricesTexture.image.data,s=this._geometryCount;return e>=s||r[e]===!1?null:n.fromArray(i,e*16)}setVisibleAt(e,n){const r=this._visibility,i=this._active,s=this._geometryCount;return e>=s||i[e]===!1||r[e]===n?this:(r[e]=n,this._visibilityChanged=!0,this)}getVisibleAt(e){const n=this._visibility,r=this._active,i=this._geometryCount;return e>=i||r[e]===!1?!1:n[e]}raycast(e,n){const r=this._visibility,i=this._active,s=this._drawRanges,o=this._geometryCount,a=this.matrixWorld,l=this.geometry;di.material=this.material,di.geometry.index=l.index,di.geometry.attributes=l.attributes,di.geometry.boundingBox===null&&(di.geometry.boundingBox=new vi),di.geometry.boundingSphere===null&&(di.geometry.boundingSphere=new Zr);for(let c=0;c<o;c++){if(!r[c]||!i[c])continue;const u=s[c];di.geometry.setDrawRange(u.start,u.count),this.getMatrixAt(c,di.matrixWorld).premultiply(a),this.getBoundingBoxAt(c,di.geometry.boundingBox),this.getBoundingSphereAt(c,di.geometry.boundingSphere),di.raycast(e,Jv);for(let d=0,f=Jv.length;d<f;d++){const h=Jv[d];h.object=this,h.batchId=c,n.push(h)}Jv.length=0}di.material=null,di.geometry.index=null,di.geometry.attributes={},di.geometry.setDrawRange(0,1/0)}copy(e){return super.copy(e),this.geometry=e.geometry.clone(),this.perObjectFrustumCulled=e.perObjectFrustumCulled,this.sortObjects=e.sortObjects,this.boundingBox=e.boundingBox!==null?e.boundingBox.clone():null,this.boundingSphere=e.boundingSphere!==null?e.boundingSphere.clone():null,this._drawRanges=e._drawRanges.map(n=>({...n})),this._reservedRanges=e._reservedRanges.map(n=>({...n})),this._visibility=e._visibility.slice(),this._active=e._active.slice(),this._bounds=e._bounds.map(n=>({boxInitialized:n.boxInitialized,box:n.box.clone(),sphereInitialized:n.sphereInitialized,sphere:n.sphere.clone()})),this._maxGeometryCount=e._maxGeometryCount,this._maxVertexCount=e._maxVertexCount,this._maxIndexCount=e._maxIndexCount,this._geometryInitialized=e._geometryInitialized,this._geometryCount=e._geometryCount,this._multiDrawCounts=e._multiDrawCounts.slice(),this._multiDrawStarts=e._multiDrawStarts.slice(),this._matricesTexture=e._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.slice(),this}dispose(){return this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this}onBeforeRender(e,n,r,i,s){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const o=i.getIndex(),a=o===null?1:o.array.BYTES_PER_ELEMENT,l=this._active,c=this._visibility,u=this._multiDrawStarts,d=this._multiDrawCounts,f=this._drawRanges,h=this.perObjectFrustumCulled;h&&(IO.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse).multiply(this.matrixWorld),ZC.setFromProjectionMatrix(IO,e.coordinateSystem));let p=0;if(this.sortObjects){RO.copy(this.matrixWorld).invert(),Am.setFromMatrixPosition(r.matrixWorld).applyMatrix4(RO);for(let y=0,b=c.length;y<b;y++)if(c[y]&&l[y]){this.getMatrixAt(y,Yl),this.getBoundingSphereAt(y,au).applyMatrix4(Yl);let S=!1;if(h&&(S=!ZC.intersectsSphere(au)),!S){const w=Am.distanceTo(au.center);eE.push(f[y],w)}}const x=eE.list,v=this.customSort;v===null?x.sort(s.transparent?$he:Fhe):v.call(this,x,r);for(let y=0,b=x.length;y<b;y++){const S=x[y];u[p]=S.start*a,d[p]=S.count,p++}eE.reset()}else for(let x=0,v=c.length;x<v;x++)if(c[x]&&l[x]){let y=!1;if(h&&(this.getMatrixAt(x,Yl),this.getBoundingSphereAt(x,au).applyMatrix4(Yl),y=!ZC.intersectsSphere(au)),!y){const b=f[x];u[p]=b.start*a,d[p]=b.count,p++}}this._multiDrawCount=p,this._visibilityChanged=!1}onBeforeShadow(e,n,r,i,s,o){this.onBeforeRender(e,null,i,s,o)}}class Si extends wr{constructor(e){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Qe(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.linewidth=e.linewidth,this.linecap=e.linecap,this.linejoin=e.linejoin,this.fog=e.fog,this}}const NO=new K,PO=new K,kO=new St,tE=new Nd,Yv=new Zr;class bl extends Zt{constructor(e=new Lt,n=new Si){super(),this.isLine=!0,this.type="Line",this.geometry=e,this.material=n,this.updateMorphTargets()}copy(e,n){return super.copy(e,n),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}computeLineDistances(){const e=this.geometry;if(e.index===null){const n=e.attributes.position,r=[0];for(let i=1,s=n.count;i<s;i++)NO.fromBufferAttribute(n,i-1),PO.fromBufferAttribute(n,i),r[i]=r[i-1],r[i]+=NO.distanceTo(PO);e.setAttribute("lineDistance",new mt(r,1))}else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(e,n){const r=this.geometry,i=this.matrixWorld,s=e.params.Line.threshold,o=r.drawRange;if(r.boundingSphere===null&&r.computeBoundingSphere(),Yv.copy(r.boundingSphere),Yv.applyMatrix4(i),Yv.radius+=s,e.ray.intersectsSphere(Yv)===!1)return;kO.copy(i).invert(),tE.copy(e.ray).applyMatrix4(kO);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=new K,u=new K,d=new K,f=new K,h=this.isLineSegments?2:1,p=r.index,v=r.attributes.position;if(p!==null){const y=Math.max(0,o.start),b=Math.min(p.count,o.start+o.count);for(let S=y,w=b-1;S<w;S+=h){const E=p.getX(S),A=p.getX(S+1);if(c.fromBufferAttribute(v,E),u.fromBufferAttribute(v,A),tE.distanceSqToSegment(c,u,f,d)>l)continue;f.applyMatrix4(this.matrixWorld);const I=e.ray.origin.distanceTo(f);I<e.near||I>e.far||n.push({distance:I,point:d.clone().applyMatrix4(this.matrixWorld),index:S,face:null,faceIndex:null,object:this})}}else{const y=Math.max(0,o.start),b=Math.min(v.count,o.start+o.count);for(let S=y,w=b-1;S<w;S+=h){if(c.fromBufferAttribute(v,S),u.fromBufferAttribute(v,S+1),tE.distanceSqToSegment(c,u,f,d)>l)continue;f.applyMatrix4(this.matrixWorld);const A=e.ray.origin.distanceTo(f);A<e.near||A>e.far||n.push({distance:A,point:d.clone().applyMatrix4(this.matrixWorld),index:S,face:null,faceIndex:null,object:this})}}}updateMorphTargets(){const n=this.geometry.morphAttributes,r=Object.keys(n);if(r.length>0){const i=n[r[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}const DO=new K,OO=new K;class Yo extends bl{constructor(e,n){super(e,n),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const e=this.geometry;if(e.index===null){const n=e.attributes.position,r=[];for(let i=0,s=n.count;i<s;i+=2)DO.fromBufferAttribute(n,i),OO.fromBufferAttribute(n,i+1),r[i]=i===0?0:r[i-1],r[i+1]=r[i]+DO.distanceTo(OO);e.setAttribute("lineDistance",new mt(r,1))}else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class UR extends bl{constructor(e,n){super(e,n),this.isLineLoop=!0,this.type="LineLoop"}}class DS extends wr{constructor(e){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Qe(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.alphaMap=e.alphaMap,this.size=e.size,this.sizeAttenuation=e.sizeAttenuation,this.fog=e.fog,this}}const LO=new St,L2=new Nd,Qv=new Zr,Zv=new K;class zR extends Zt{constructor(e=new Lt,n=new DS){super(),this.isPoints=!0,this.type="Points",this.geometry=e,this.material=n,this.updateMorphTargets()}copy(e,n){return super.copy(e,n),this.material=Array.isArray(e.material)?e.material.slice():e.material,this.geometry=e.geometry,this}raycast(e,n){const r=this.geometry,i=this.matrixWorld,s=e.params.Points.threshold,o=r.drawRange;if(r.boundingSphere===null&&r.computeBoundingSphere(),Qv.copy(r.boundingSphere),Qv.applyMatrix4(i),Qv.radius+=s,e.ray.intersectsSphere(Qv)===!1)return;LO.copy(i).invert(),L2.copy(e.ray).applyMatrix4(LO);const a=s/((this.scale.x+this.scale.y+this.scale.z)/3),l=a*a,c=r.index,d=r.attributes.position;if(c!==null){const f=Math.max(0,o.start),h=Math.min(c.count,o.start+o.count);for(let p=f,x=h;p<x;p++){const v=c.getX(p);Zv.fromBufferAttribute(d,v),BO(Zv,v,l,i,e,n,this)}}else{const f=Math.max(0,o.start),h=Math.min(d.count,o.start+o.count);for(let p=f,x=h;p<x;p++)Zv.fromBufferAttribute(d,p),BO(Zv,p,l,i,e,n,this)}}updateMorphTargets(){const n=this.geometry.morphAttributes,r=Object.keys(n);if(r.length>0){const i=n[r[0]];if(i!==void 0){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let s=0,o=i.length;s<o;s++){const a=i[s].name||String(s);this.morphTargetInfluences.push(0),this.morphTargetDictionary[a]=s}}}}}function BO(t,e,n,r,i,s,o){const a=L2.distanceSqToPoint(t);if(a<n){const l=new K;L2.closestPointToPoint(t,l),l.applyMatrix4(r);const c=i.ray.origin.distanceTo(l);if(c<i.near||c>i.far)return;s.push({distance:c,distanceToRay:Math.sqrt(a),point:l,index:e,face:null,object:o})}}class Hhe extends Bn{constructor(e,n,r,i,s,o,a,l,c){super(e,n,r,i,s,o,a,l,c),this.isVideoTexture=!0,this.minFilter=o!==void 0?o:or,this.magFilter=s!==void 0?s:or,this.generateMipmaps=!1;const u=this;function d(){u.needsUpdate=!0,e.requestVideoFrameCallback(d)}"requestVideoFrameCallback"in e&&e.requestVideoFrameCallback(d)}clone(){return new this.constructor(this.image).copy(this)}update(){const e=this.image;"requestVideoFrameCallback"in e===!1&&e.readyState>=e.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}}class Vhe extends Bn{constructor(e,n){super({width:e,height:n}),this.isFramebufferTexture=!0,this.magFilter=Nr,this.minFilter=Nr,this.generateMipmaps=!1,this.needsUpdate=!0}}class OS extends Bn{constructor(e,n,r,i,s,o,a,l,c,u,d,f){super(null,o,a,l,c,u,i,s,d,f),this.isCompressedTexture=!0,this.image={width:n,height:r},this.mipmaps=e,this.flipY=!1,this.generateMipmaps=!1}}class Whe extends OS{constructor(e,n,r,i,s,o){super(e,n,r,s,o),this.isCompressedArrayTexture=!0,this.image.depth=i,this.wrapR=ws}}class jhe extends OS{constructor(e,n,r){super(void 0,e[0].width,e[0].height,n,r,xl),this.isCompressedCubeTexture=!0,this.isCubeTexture=!0,this.image=e}}class Xhe extends Bn{constructor(e,n,r,i,s,o,a,l,c){super(e,n,r,i,s,o,a,l,c),this.isCanvasTexture=!0,this.needsUpdate=!0}}class Qo{constructor(){this.type="Curve",this.arcLengthDivisions=200}getPoint(){return console.warn("THREE.Curve: .getPoint() not implemented."),null}getPointAt(e,n){const r=this.getUtoTmapping(e);return this.getPoint(r,n)}getPoints(e=5){const n=[];for(let r=0;r<=e;r++)n.push(this.getPoint(r/e));return n}getSpacedPoints(e=5){const n=[];for(let r=0;r<=e;r++)n.push(this.getPointAt(r/e));return n}getLength(){const e=this.getLengths();return e[e.length-1]}getLengths(e=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===e+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const n=[];let r,i=this.getPoint(0),s=0;n.push(0);for(let o=1;o<=e;o++)r=this.getPoint(o/e),s+=r.distanceTo(i),n.push(s),i=r;return this.cacheArcLengths=n,n}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(e,n){const r=this.getLengths();let i=0;const s=r.length;let o;n?o=n:o=e*r[s-1];let a=0,l=s-1,c;for(;a<=l;)if(i=Math.floor(a+(l-a)/2),c=r[i]-o,c<0)a=i+1;else if(c>0)l=i-1;else{l=i;break}if(i=l,r[i]===o)return i/(s-1);const u=r[i],f=r[i+1]-u,h=(o-u)/f;return(i+h)/(s-1)}getTangent(e,n){let i=e-1e-4,s=e+1e-4;i<0&&(i=0),s>1&&(s=1);const o=this.getPoint(i),a=this.getPoint(s),l=n||(o.isVector2?new Re:new K);return l.copy(a).sub(o).normalize(),l}getTangentAt(e,n){const r=this.getUtoTmapping(e);return this.getTangent(r,n)}computeFrenetFrames(e,n){const r=new K,i=[],s=[],o=[],a=new K,l=new St;for(let h=0;h<=e;h++){const p=h/e;i[h]=this.getTangentAt(p,new K)}s[0]=new K,o[0]=new K;let c=Number.MAX_VALUE;const u=Math.abs(i[0].x),d=Math.abs(i[0].y),f=Math.abs(i[0].z);u<=c&&(c=u,r.set(1,0,0)),d<=c&&(c=d,r.set(0,1,0)),f<=c&&r.set(0,0,1),a.crossVectors(i[0],r).normalize(),s[0].crossVectors(i[0],a),o[0].crossVectors(i[0],s[0]);for(let h=1;h<=e;h++){if(s[h]=s[h-1].clone(),o[h]=o[h-1].clone(),a.crossVectors(i[h-1],i[h]),a.length()>Number.EPSILON){a.normalize();const p=Math.acos(sr(i[h-1].dot(i[h]),-1,1));s[h].applyMatrix4(l.makeRotationAxis(a,p))}o[h].crossVectors(i[h],s[h])}if(n===!0){let h=Math.acos(sr(s[0].dot(s[e]),-1,1));h/=e,i[0].dot(a.crossVectors(s[0],s[e]))>0&&(h=-h);for(let p=1;p<=e;p++)s[p].applyMatrix4(l.makeRotationAxis(i[p],h*p)),o[p].crossVectors(i[p],s[p])}return{tangents:i,normals:s,binormals:o}}clone(){return new this.constructor().copy(this)}copy(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}toJSON(){const e={metadata:{version:4.6,type:"Curve",generator:"Curve.toJSON"}};return e.arcLengthDivisions=this.arcLengthDivisions,e.type=this.type,e}fromJSON(e){return this.arcLengthDivisions=e.arcLengthDivisions,this}}class LS extends Qo{constructor(e=0,n=0,r=1,i=1,s=0,o=Math.PI*2,a=!1,l=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=e,this.aY=n,this.xRadius=r,this.yRadius=i,this.aStartAngle=s,this.aEndAngle=o,this.aClockwise=a,this.aRotation=l}getPoint(e,n=new Re){const r=n,i=Math.PI*2;let s=this.aEndAngle-this.aStartAngle;const o=Math.abs(s)<Number.EPSILON;for(;s<0;)s+=i;for(;s>i;)s-=i;s<Number.EPSILON&&(o?s=0:s=i),this.aClockwise===!0&&!o&&(s===i?s=-i:s=s-i);const a=this.aStartAngle+e*s;let l=this.aX+this.xRadius*Math.cos(a),c=this.aY+this.yRadius*Math.sin(a);if(this.aRotation!==0){const u=Math.cos(this.aRotation),d=Math.sin(this.aRotation),f=l-this.aX,h=c-this.aY;l=f*u-h*d+this.aX,c=f*d+h*u+this.aY}return r.set(l,c)}copy(e){return super.copy(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}toJSON(){const e=super.toJSON();return e.aX=this.aX,e.aY=this.aY,e.xRadius=this.xRadius,e.yRadius=this.yRadius,e.aStartAngle=this.aStartAngle,e.aEndAngle=this.aEndAngle,e.aClockwise=this.aClockwise,e.aRotation=this.aRotation,e}fromJSON(e){return super.fromJSON(e),this.aX=e.aX,this.aY=e.aY,this.xRadius=e.xRadius,this.yRadius=e.yRadius,this.aStartAngle=e.aStartAngle,this.aEndAngle=e.aEndAngle,this.aClockwise=e.aClockwise,this.aRotation=e.aRotation,this}}class G5 extends LS{constructor(e,n,r,i,s,o){super(e,n,r,r,i,s,o),this.isArcCurve=!0,this.type="ArcCurve"}}function GR(){let t=0,e=0,n=0,r=0;function i(s,o,a,l){t=s,e=a,n=-3*s+3*o-2*a-l,r=2*s-2*o+a+l}return{initCatmullRom:function(s,o,a,l,c){i(o,a,c*(a-s),c*(l-o))},initNonuniformCatmullRom:function(s,o,a,l,c,u,d){let f=(o-s)/c-(a-s)/(c+u)+(a-o)/u,h=(a-o)/u-(l-o)/(u+d)+(l-a)/d;f*=u,h*=u,i(o,a,f,h)},calc:function(s){const o=s*s,a=o*s;return t+e*s+n*o+r*a}}}const ex=new K,nE=new GR,rE=new GR,iE=new GR;class H5 extends Qo{constructor(e=[],n=!1,r="centripetal",i=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=e,this.closed=n,this.curveType=r,this.tension=i}getPoint(e,n=new K){const r=n,i=this.points,s=i.length,o=(s-(this.closed?0:1))*e;let a=Math.floor(o),l=o-a;this.closed?a+=a>0?0:(Math.floor(Math.abs(a)/s)+1)*s:l===0&&a===s-1&&(a=s-2,l=1);let c,u;this.closed||a>0?c=i[(a-1)%s]:(ex.subVectors(i[0],i[1]).add(i[0]),c=ex);const d=i[a%s],f=i[(a+1)%s];if(this.closed||a+2<s?u=i[(a+2)%s]:(ex.subVectors(i[s-1],i[s-2]).add(i[s-1]),u=ex),this.curveType==="centripetal"||this.curveType==="chordal"){const h=this.curveType==="chordal"?.5:.25;let p=Math.pow(c.distanceToSquared(d),h),x=Math.pow(d.distanceToSquared(f),h),v=Math.pow(f.distanceToSquared(u),h);x<1e-4&&(x=1),p<1e-4&&(p=x),v<1e-4&&(v=x),nE.initNonuniformCatmullRom(c.x,d.x,f.x,u.x,p,x,v),rE.initNonuniformCatmullRom(c.y,d.y,f.y,u.y,p,x,v),iE.initNonuniformCatmullRom(c.z,d.z,f.z,u.z,p,x,v)}else this.curveType==="catmullrom"&&(nE.initCatmullRom(c.x,d.x,f.x,u.x,this.tension),rE.initCatmullRom(c.y,d.y,f.y,u.y,this.tension),iE.initCatmullRom(c.z,d.z,f.z,u.z,this.tension));return r.set(nE.calc(l),rE.calc(l),iE.calc(l)),r}copy(e){super.copy(e),this.points=[];for(let n=0,r=e.points.length;n<r;n++){const i=e.points[n];this.points.push(i.clone())}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}toJSON(){const e=super.toJSON();e.points=[];for(let n=0,r=this.points.length;n<r;n++){const i=this.points[n];e.points.push(i.toArray())}return e.closed=this.closed,e.curveType=this.curveType,e.tension=this.tension,e}fromJSON(e){super.fromJSON(e),this.points=[];for(let n=0,r=e.points.length;n<r;n++){const i=e.points[n];this.points.push(new K().fromArray(i))}return this.closed=e.closed,this.curveType=e.curveType,this.tension=e.tension,this}}function FO(t,e,n,r,i){const s=(r-e)*.5,o=(i-n)*.5,a=t*t,l=t*a;return(2*n-2*r+s+o)*l+(-3*n+3*r-2*s-o)*a+s*t+n}function Khe(t,e){const n=1-t;return n*n*e}function qhe(t,e){return 2*(1-t)*t*e}function Jhe(t,e){return t*t*e}function og(t,e,n,r){return Khe(t,e)+qhe(t,n)+Jhe(t,r)}function Yhe(t,e){const n=1-t;return n*n*n*e}function Qhe(t,e){const n=1-t;return 3*n*n*t*e}function Zhe(t,e){return 3*(1-t)*t*t*e}function epe(t,e){return t*t*t*e}function ag(t,e,n,r,i){return Yhe(t,e)+Qhe(t,n)+Zhe(t,r)+epe(t,i)}class HR extends Qo{constructor(e=new Re,n=new Re,r=new Re,i=new Re){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=e,this.v1=n,this.v2=r,this.v3=i}getPoint(e,n=new Re){const r=n,i=this.v0,s=this.v1,o=this.v2,a=this.v3;return r.set(ag(e,i.x,s.x,o.x,a.x),ag(e,i.y,s.y,o.y,a.y)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class V5 extends Qo{constructor(e=new K,n=new K,r=new K,i=new K){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=e,this.v1=n,this.v2=r,this.v3=i}getPoint(e,n=new K){const r=n,i=this.v0,s=this.v1,o=this.v2,a=this.v3;return r.set(ag(e,i.x,s.x,o.x,a.x),ag(e,i.y,s.y,o.y,a.y),ag(e,i.z,s.z,o.z,a.z)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this.v3.copy(e.v3),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e.v3=this.v3.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this.v3.fromArray(e.v3),this}}class VR extends Qo{constructor(e=new Re,n=new Re){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=e,this.v2=n}getPoint(e,n=new Re){const r=n;return e===1?r.copy(this.v2):(r.copy(this.v2).sub(this.v1),r.multiplyScalar(e).add(this.v1)),r}getPointAt(e,n){return this.getPoint(e,n)}getTangent(e,n=new Re){return n.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,n){return this.getTangent(e,n)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class W5 extends Qo{constructor(e=new K,n=new K){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=e,this.v2=n}getPoint(e,n=new K){const r=n;return e===1?r.copy(this.v2):(r.copy(this.v2).sub(this.v1),r.multiplyScalar(e).add(this.v1)),r}getPointAt(e,n){return this.getPoint(e,n)}getTangent(e,n=new K){return n.subVectors(this.v2,this.v1).normalize()}getTangentAt(e,n){return this.getTangent(e,n)}copy(e){return super.copy(e),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class WR extends Qo{constructor(e=new Re,n=new Re,r=new Re){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=e,this.v1=n,this.v2=r}getPoint(e,n=new Re){const r=n,i=this.v0,s=this.v1,o=this.v2;return r.set(og(e,i.x,s.x,o.x),og(e,i.y,s.y,o.y)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class jR extends Qo{constructor(e=new K,n=new K,r=new K){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=e,this.v1=n,this.v2=r}getPoint(e,n=new K){const r=n,i=this.v0,s=this.v1,o=this.v2;return r.set(og(e,i.x,s.x,o.x),og(e,i.y,s.y,o.y),og(e,i.z,s.z,o.z)),r}copy(e){return super.copy(e),this.v0.copy(e.v0),this.v1.copy(e.v1),this.v2.copy(e.v2),this}toJSON(){const e=super.toJSON();return e.v0=this.v0.toArray(),e.v1=this.v1.toArray(),e.v2=this.v2.toArray(),e}fromJSON(e){return super.fromJSON(e),this.v0.fromArray(e.v0),this.v1.fromArray(e.v1),this.v2.fromArray(e.v2),this}}class XR extends Qo{constructor(e=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=e}getPoint(e,n=new Re){const r=n,i=this.points,s=(i.length-1)*e,o=Math.floor(s),a=s-o,l=i[o===0?o:o-1],c=i[o],u=i[o>i.length-2?i.length-1:o+1],d=i[o>i.length-3?i.length-1:o+2];return r.set(FO(a,l.x,c.x,u.x,d.x),FO(a,l.y,c.y,u.y,d.y)),r}copy(e){super.copy(e),this.points=[];for(let n=0,r=e.points.length;n<r;n++){const i=e.points[n];this.points.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.points=[];for(let n=0,r=this.points.length;n<r;n++){const i=this.points[n];e.points.push(i.toArray())}return e}fromJSON(e){super.fromJSON(e),this.points=[];for(let n=0,r=e.points.length;n<r;n++){const i=e.points[n];this.points.push(new Re().fromArray(i))}return this}}var G1=Object.freeze({__proto__:null,ArcCurve:G5,CatmullRomCurve3:H5,CubicBezierCurve:HR,CubicBezierCurve3:V5,EllipseCurve:LS,LineCurve:VR,LineCurve3:W5,QuadraticBezierCurve:WR,QuadraticBezierCurve3:jR,SplineCurve:XR});class j5 extends Qo{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(e){this.curves.push(e)}closePath(){const e=this.curves[0].getPoint(0),n=this.curves[this.curves.length-1].getPoint(1);if(!e.equals(n)){const r=e.isVector2===!0?"LineCurve":"LineCurve3";this.curves.push(new G1[r](n,e))}return this}getPoint(e,n){const r=e*this.getLength(),i=this.getCurveLengths();let s=0;for(;s<i.length;){if(i[s]>=r){const o=i[s]-r,a=this.curves[s],l=a.getLength(),c=l===0?0:1-o/l;return a.getPointAt(c,n)}s++}return null}getLength(){const e=this.getCurveLengths();return e[e.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const e=[];let n=0;for(let r=0,i=this.curves.length;r<i;r++)n+=this.curves[r].getLength(),e.push(n);return this.cacheLengths=e,e}getSpacedPoints(e=40){const n=[];for(let r=0;r<=e;r++)n.push(this.getPoint(r/e));return this.autoClose&&n.push(n[0]),n}getPoints(e=12){const n=[];let r;for(let i=0,s=this.curves;i<s.length;i++){const o=s[i],a=o.isEllipseCurve?e*2:o.isLineCurve||o.isLineCurve3?1:o.isSplineCurve?e*o.points.length:e,l=o.getPoints(a);for(let c=0;c<l.length;c++){const u=l[c];r&&r.equals(u)||(n.push(u),r=u)}}return this.autoClose&&n.length>1&&!n[n.length-1].equals(n[0])&&n.push(n[0]),n}copy(e){super.copy(e),this.curves=[];for(let n=0,r=e.curves.length;n<r;n++){const i=e.curves[n];this.curves.push(i.clone())}return this.autoClose=e.autoClose,this}toJSON(){const e=super.toJSON();e.autoClose=this.autoClose,e.curves=[];for(let n=0,r=this.curves.length;n<r;n++){const i=this.curves[n];e.curves.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.autoClose=e.autoClose,this.curves=[];for(let n=0,r=e.curves.length;n<r;n++){const i=e.curves[n];this.curves.push(new G1[i.type]().fromJSON(i))}return this}}class jg extends j5{constructor(e){super(),this.type="Path",this.currentPoint=new Re,e&&this.setFromPoints(e)}setFromPoints(e){this.moveTo(e[0].x,e[0].y);for(let n=1,r=e.length;n<r;n++)this.lineTo(e[n].x,e[n].y);return this}moveTo(e,n){return this.currentPoint.set(e,n),this}lineTo(e,n){const r=new VR(this.currentPoint.clone(),new Re(e,n));return this.curves.push(r),this.currentPoint.set(e,n),this}quadraticCurveTo(e,n,r,i){const s=new WR(this.currentPoint.clone(),new Re(e,n),new Re(r,i));return this.curves.push(s),this.currentPoint.set(r,i),this}bezierCurveTo(e,n,r,i,s,o){const a=new HR(this.currentPoint.clone(),new Re(e,n),new Re(r,i),new Re(s,o));return this.curves.push(a),this.currentPoint.set(s,o),this}splineThru(e){const n=[this.currentPoint.clone()].concat(e),r=new XR(n);return this.curves.push(r),this.currentPoint.copy(e[e.length-1]),this}arc(e,n,r,i,s,o){const a=this.currentPoint.x,l=this.currentPoint.y;return this.absarc(e+a,n+l,r,i,s,o),this}absarc(e,n,r,i,s,o){return this.absellipse(e,n,r,r,i,s,o),this}ellipse(e,n,r,i,s,o,a,l){const c=this.currentPoint.x,u=this.currentPoint.y;return this.absellipse(e+c,n+u,r,i,s,o,a,l),this}absellipse(e,n,r,i,s,o,a,l){const c=new LS(e,n,r,i,s,o,a,l);if(this.curves.length>0){const d=c.getPoint(0);d.equals(this.currentPoint)||this.lineTo(d.x,d.y)}this.curves.push(c);const u=c.getPoint(1);return this.currentPoint.copy(u),this}copy(e){return super.copy(e),this.currentPoint.copy(e.currentPoint),this}toJSON(){const e=super.toJSON();return e.currentPoint=this.currentPoint.toArray(),e}fromJSON(e){return super.fromJSON(e),this.currentPoint.fromArray(e.currentPoint),this}}class P0 extends Lt{constructor(e=[new Re(0,-.5),new Re(.5,0),new Re(0,.5)],n=12,r=0,i=Math.PI*2){super(),this.type="LatheGeometry",this.parameters={points:e,segments:n,phiStart:r,phiLength:i},n=Math.floor(n),i=sr(i,0,Math.PI*2);const s=[],o=[],a=[],l=[],c=[],u=1/n,d=new K,f=new Re,h=new K,p=new K,x=new K;let v=0,y=0;for(let b=0;b<=e.length-1;b++)switch(b){case 0:v=e[b+1].x-e[b].x,y=e[b+1].y-e[b].y,h.x=y*1,h.y=-v,h.z=y*0,x.copy(h),h.normalize(),l.push(h.x,h.y,h.z);break;case e.length-1:l.push(x.x,x.y,x.z);break;default:v=e[b+1].x-e[b].x,y=e[b+1].y-e[b].y,h.x=y*1,h.y=-v,h.z=y*0,p.copy(h),h.x+=x.x,h.y+=x.y,h.z+=x.z,h.normalize(),l.push(h.x,h.y,h.z),x.copy(p)}for(let b=0;b<=n;b++){const S=r+b*u*i,w=Math.sin(S),E=Math.cos(S);for(let A=0;A<=e.length-1;A++){d.x=e[A].x*w,d.y=e[A].y,d.z=e[A].x*E,o.push(d.x,d.y,d.z),f.x=b/n,f.y=A/(e.length-1),a.push(f.x,f.y);const T=l[3*A+0]*w,I=l[3*A+1],N=l[3*A+0]*E;c.push(T,I,N)}}for(let b=0;b<n;b++)for(let S=0;S<e.length-1;S++){const w=S+b*e.length,E=w,A=w+e.length,T=w+e.length+1,I=w+1;s.push(E,A,I),s.push(T,I,A)}this.setIndex(s),this.setAttribute("position",new mt(o,3)),this.setAttribute("uv",new mt(a,2)),this.setAttribute("normal",new mt(c,3))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new P0(e.points,e.segments,e.phiStart,e.phiLength)}}class BS extends P0{constructor(e=1,n=1,r=4,i=8){const s=new jg;s.absarc(0,-n/2,e,Math.PI*1.5,0),s.absarc(0,n/2,e,0,Math.PI*.5),super(s.getPoints(r),i),this.type="CapsuleGeometry",this.parameters={radius:e,length:n,capSegments:r,radialSegments:i}}static fromJSON(e){return new BS(e.radius,e.length,e.capSegments,e.radialSegments)}}class FS extends Lt{constructor(e=1,n=32,r=0,i=Math.PI*2){super(),this.type="CircleGeometry",this.parameters={radius:e,segments:n,thetaStart:r,thetaLength:i},n=Math.max(3,n);const s=[],o=[],a=[],l=[],c=new K,u=new Re;o.push(0,0,0),a.push(0,0,1),l.push(.5,.5);for(let d=0,f=3;d<=n;d++,f+=3){const h=r+d/n*i;c.x=e*Math.cos(h),c.y=e*Math.sin(h),o.push(c.x,c.y,c.z),a.push(0,0,1),u.x=(o[f]/e+1)/2,u.y=(o[f+1]/e+1)/2,l.push(u.x,u.y)}for(let d=1;d<=n;d++)s.push(d,d+1,0);this.setIndex(s),this.setAttribute("position",new mt(o,3)),this.setAttribute("normal",new mt(a,3)),this.setAttribute("uv",new mt(l,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new FS(e.radius,e.segments,e.thetaStart,e.thetaLength)}}class bp extends Lt{constructor(e=1,n=1,r=1,i=32,s=1,o=!1,a=0,l=Math.PI*2){super(),this.type="CylinderGeometry",this.parameters={radiusTop:e,radiusBottom:n,height:r,radialSegments:i,heightSegments:s,openEnded:o,thetaStart:a,thetaLength:l};const c=this;i=Math.floor(i),s=Math.floor(s);const u=[],d=[],f=[],h=[];let p=0;const x=[],v=r/2;let y=0;b(),o===!1&&(e>0&&S(!0),n>0&&S(!1)),this.setIndex(u),this.setAttribute("position",new mt(d,3)),this.setAttribute("normal",new mt(f,3)),this.setAttribute("uv",new mt(h,2));function b(){const w=new K,E=new K;let A=0;const T=(n-e)/r;for(let I=0;I<=s;I++){const N=[],M=I/s,P=M*(n-e)+e;for(let B=0;B<=i;B++){const F=B/i,U=F*l+a,j=Math.sin(U),Z=Math.cos(U);E.x=P*j,E.y=-M*r+v,E.z=P*Z,d.push(E.x,E.y,E.z),w.set(j,T,Z).normalize(),f.push(w.x,w.y,w.z),h.push(F,1-M),N.push(p++)}x.push(N)}for(let I=0;I<i;I++)for(let N=0;N<s;N++){const M=x[N][I],P=x[N+1][I],B=x[N+1][I+1],F=x[N][I+1];u.push(M,P,F),u.push(P,B,F),A+=6}c.addGroup(y,A,0),y+=A}function S(w){const E=p,A=new Re,T=new K;let I=0;const N=w===!0?e:n,M=w===!0?1:-1;for(let B=1;B<=i;B++)d.push(0,v*M,0),f.push(0,M,0),h.push(.5,.5),p++;const P=p;for(let B=0;B<=i;B++){const U=B/i*l+a,j=Math.cos(U),Z=Math.sin(U);T.x=N*Z,T.y=v*M,T.z=N*j,d.push(T.x,T.y,T.z),f.push(0,M,0),A.x=j*.5+.5,A.y=Z*.5*M+.5,h.push(A.x,A.y),p++}for(let B=0;B<i;B++){const F=E+B,U=P+B;w===!0?u.push(U,U+1,F):u.push(U+1,U,F),I+=3}c.addGroup(y,I,w===!0?1:2),y+=I}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new bp(e.radiusTop,e.radiusBottom,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class $S extends bp{constructor(e=1,n=1,r=32,i=1,s=!1,o=0,a=Math.PI*2){super(0,e,n,r,i,s,o,a),this.type="ConeGeometry",this.parameters={radius:e,height:n,radialSegments:r,heightSegments:i,openEnded:s,thetaStart:o,thetaLength:a}}static fromJSON(e){return new $S(e.radius,e.height,e.radialSegments,e.heightSegments,e.openEnded,e.thetaStart,e.thetaLength)}}class Fc extends Lt{constructor(e=[],n=[],r=1,i=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:e,indices:n,radius:r,detail:i};const s=[],o=[];a(i),c(r),u(),this.setAttribute("position",new mt(s,3)),this.setAttribute("normal",new mt(s.slice(),3)),this.setAttribute("uv",new mt(o,2)),i===0?this.computeVertexNormals():this.normalizeNormals();function a(b){const S=new K,w=new K,E=new K;for(let A=0;A<n.length;A+=3)h(n[A+0],S),h(n[A+1],w),h(n[A+2],E),l(S,w,E,b)}function l(b,S,w,E){const A=E+1,T=[];for(let I=0;I<=A;I++){T[I]=[];const N=b.clone().lerp(w,I/A),M=S.clone().lerp(w,I/A),P=A-I;for(let B=0;B<=P;B++)B===0&&I===A?T[I][B]=N:T[I][B]=N.clone().lerp(M,B/P)}for(let I=0;I<A;I++)for(let N=0;N<2*(A-I)-1;N++){const M=Math.floor(N/2);N%2===0?(f(T[I][M+1]),f(T[I+1][M]),f(T[I][M])):(f(T[I][M+1]),f(T[I+1][M+1]),f(T[I+1][M]))}}function c(b){const S=new K;for(let w=0;w<s.length;w+=3)S.x=s[w+0],S.y=s[w+1],S.z=s[w+2],S.normalize().multiplyScalar(b),s[w+0]=S.x,s[w+1]=S.y,s[w+2]=S.z}function u(){const b=new K;for(let S=0;S<s.length;S+=3){b.x=s[S+0],b.y=s[S+1],b.z=s[S+2];const w=v(b)/2/Math.PI+.5,E=y(b)/Math.PI+.5;o.push(w,1-E)}p(),d()}function d(){for(let b=0;b<o.length;b+=6){const S=o[b+0],w=o[b+2],E=o[b+4],A=Math.max(S,w,E),T=Math.min(S,w,E);A>.9&&T<.1&&(S<.2&&(o[b+0]+=1),w<.2&&(o[b+2]+=1),E<.2&&(o[b+4]+=1))}}function f(b){s.push(b.x,b.y,b.z)}function h(b,S){const w=b*3;S.x=e[w+0],S.y=e[w+1],S.z=e[w+2]}function p(){const b=new K,S=new K,w=new K,E=new K,A=new Re,T=new Re,I=new Re;for(let N=0,M=0;N<s.length;N+=9,M+=6){b.set(s[N+0],s[N+1],s[N+2]),S.set(s[N+3],s[N+4],s[N+5]),w.set(s[N+6],s[N+7],s[N+8]),A.set(o[M+0],o[M+1]),T.set(o[M+2],o[M+3]),I.set(o[M+4],o[M+5]),E.copy(b).add(S).add(w).divideScalar(3);const P=v(E);x(A,M+0,b,P),x(T,M+2,S,P),x(I,M+4,w,P)}}function x(b,S,w,E){E<0&&b.x===1&&(o[S]=b.x-1),w.x===0&&w.z===0&&(o[S]=E/2/Math.PI+.5)}function v(b){return Math.atan2(b.z,-b.x)}function y(b){return Math.atan2(-b.y,Math.sqrt(b.x*b.x+b.z*b.z))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new Fc(e.vertices,e.indices,e.radius,e.details)}}class US extends Fc{constructor(e=1,n=0){const r=(1+Math.sqrt(5))/2,i=1/r,s=[-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-i,-r,0,-i,r,0,i,-r,0,i,r,-i,-r,0,-i,r,0,i,-r,0,i,r,0,-r,0,-i,r,0,-i,-r,0,i,r,0,i],o=[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9];super(s,o,e,n),this.type="DodecahedronGeometry",this.parameters={radius:e,detail:n}}static fromJSON(e){return new US(e.radius,e.detail)}}const tx=new K,nx=new K,sE=new K,rx=new Ss;class X5 extends Lt{constructor(e=null,n=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:e,thresholdAngle:n},e!==null){const i=Math.pow(10,4),s=Math.cos(Yu*n),o=e.getIndex(),a=e.getAttribute("position"),l=o?o.count:a.count,c=[0,0,0],u=["a","b","c"],d=new Array(3),f={},h=[];for(let p=0;p<l;p+=3){o?(c[0]=o.getX(p),c[1]=o.getX(p+1),c[2]=o.getX(p+2)):(c[0]=p,c[1]=p+1,c[2]=p+2);const{a:x,b:v,c:y}=rx;if(x.fromBufferAttribute(a,c[0]),v.fromBufferAttribute(a,c[1]),y.fromBufferAttribute(a,c[2]),rx.getNormal(sE),d[0]=`${Math.round(x.x*i)},${Math.round(x.y*i)},${Math.round(x.z*i)}`,d[1]=`${Math.round(v.x*i)},${Math.round(v.y*i)},${Math.round(v.z*i)}`,d[2]=`${Math.round(y.x*i)},${Math.round(y.y*i)},${Math.round(y.z*i)}`,!(d[0]===d[1]||d[1]===d[2]||d[2]===d[0]))for(let b=0;b<3;b++){const S=(b+1)%3,w=d[b],E=d[S],A=rx[u[b]],T=rx[u[S]],I=`${w}_${E}`,N=`${E}_${w}`;N in f&&f[N]?(sE.dot(f[N].normal)<=s&&(h.push(A.x,A.y,A.z),h.push(T.x,T.y,T.z)),f[N]=null):I in f||(f[I]={index0:c[b],index1:c[S],normal:sE.clone()})}}for(const p in f)if(f[p]){const{index0:x,index1:v}=f[p];tx.fromBufferAttribute(a,x),nx.fromBufferAttribute(a,v),h.push(tx.x,tx.y,tx.z),h.push(nx.x,nx.y,nx.z)}this.setAttribute("position",new mt(h,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}class Zu extends jg{constructor(e){super(e),this.uuid=Ms(),this.type="Shape",this.holes=[]}getPointsHoles(e){const n=[];for(let r=0,i=this.holes.length;r<i;r++)n[r]=this.holes[r].getPoints(e);return n}extractPoints(e){return{shape:this.getPoints(e),holes:this.getPointsHoles(e)}}copy(e){super.copy(e),this.holes=[];for(let n=0,r=e.holes.length;n<r;n++){const i=e.holes[n];this.holes.push(i.clone())}return this}toJSON(){const e=super.toJSON();e.uuid=this.uuid,e.holes=[];for(let n=0,r=this.holes.length;n<r;n++){const i=this.holes[n];e.holes.push(i.toJSON())}return e}fromJSON(e){super.fromJSON(e),this.uuid=e.uuid,this.holes=[];for(let n=0,r=e.holes.length;n<r;n++){const i=e.holes[n];this.holes.push(new jg().fromJSON(i))}return this}}const tpe={triangulate:function(t,e,n=2){const r=e&&e.length,i=r?e[0]*n:t.length;let s=K5(t,0,i,n,!0);const o=[];if(!s||s.next===s.prev)return o;let a,l,c,u,d,f,h;if(r&&(s=ope(t,e,s,n)),t.length>80*n){a=c=t[0],l=u=t[1];for(let p=n;p<i;p+=n)d=t[p],f=t[p+1],d<a&&(a=d),f<l&&(l=f),d>c&&(c=d),f>u&&(u=f);h=Math.max(c-a,u-l),h=h!==0?32767/h:0}return Xg(s,o,n,a,l,h,0),o}};function K5(t,e,n,r,i){let s,o;if(i===ype(t,e,n,r)>0)for(s=e;s<n;s+=r)o=$O(s,t[s],t[s+1],o);else for(s=n-r;s>=e;s-=r)o=$O(s,t[s],t[s+1],o);return o&&zS(o,o.next)&&(qg(o),o=o.next),o}function gd(t,e){if(!t)return t;e||(e=t);let n=t,r;do if(r=!1,!n.steiner&&(zS(n,n.next)||Xn(n.prev,n,n.next)===0)){if(qg(n),n=e=n.prev,n===n.next)break;r=!0}else n=n.next;while(r||n!==e);return e}function Xg(t,e,n,r,i,s,o){if(!t)return;!o&&s&&dpe(t,r,i,s);let a=t,l,c;for(;t.prev!==t.next;){if(l=t.prev,c=t.next,s?rpe(t,r,i,s):npe(t)){e.push(l.i/n|0),e.push(t.i/n|0),e.push(c.i/n|0),qg(t),t=c.next,a=c.next;continue}if(t=c,t===a){o?o===1?(t=ipe(gd(t),e,n),Xg(t,e,n,r,i,s,2)):o===2&&spe(t,e,n,r,i,s):Xg(gd(t),e,n,r,i,s,1);break}}}function npe(t){const e=t.prev,n=t,r=t.next;if(Xn(e,n,r)>=0)return!1;const i=e.x,s=n.x,o=r.x,a=e.y,l=n.y,c=r.y,u=i<s?i<o?i:o:s<o?s:o,d=a<l?a<c?a:c:l<c?l:c,f=i>s?i>o?i:o:s>o?s:o,h=a>l?a>c?a:c:l>c?l:c;let p=r.next;for(;p!==e;){if(p.x>=u&&p.x<=f&&p.y>=d&&p.y<=h&&lh(i,a,s,l,o,c,p.x,p.y)&&Xn(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function rpe(t,e,n,r){const i=t.prev,s=t,o=t.next;if(Xn(i,s,o)>=0)return!1;const a=i.x,l=s.x,c=o.x,u=i.y,d=s.y,f=o.y,h=a<l?a<c?a:c:l<c?l:c,p=u<d?u<f?u:f:d<f?d:f,x=a>l?a>c?a:c:l>c?l:c,v=u>d?u>f?u:f:d>f?d:f,y=B2(h,p,e,n,r),b=B2(x,v,e,n,r);let S=t.prevZ,w=t.nextZ;for(;S&&S.z>=y&&w&&w.z<=b;){if(S.x>=h&&S.x<=x&&S.y>=p&&S.y<=v&&S!==i&&S!==o&&lh(a,u,l,d,c,f,S.x,S.y)&&Xn(S.prev,S,S.next)>=0||(S=S.prevZ,w.x>=h&&w.x<=x&&w.y>=p&&w.y<=v&&w!==i&&w!==o&&lh(a,u,l,d,c,f,w.x,w.y)&&Xn(w.prev,w,w.next)>=0))return!1;w=w.nextZ}for(;S&&S.z>=y;){if(S.x>=h&&S.x<=x&&S.y>=p&&S.y<=v&&S!==i&&S!==o&&lh(a,u,l,d,c,f,S.x,S.y)&&Xn(S.prev,S,S.next)>=0)return!1;S=S.prevZ}for(;w&&w.z<=b;){if(w.x>=h&&w.x<=x&&w.y>=p&&w.y<=v&&w!==i&&w!==o&&lh(a,u,l,d,c,f,w.x,w.y)&&Xn(w.prev,w,w.next)>=0)return!1;w=w.nextZ}return!0}function ipe(t,e,n){let r=t;do{const i=r.prev,s=r.next.next;!zS(i,s)&&q5(i,r,r.next,s)&&Kg(i,s)&&Kg(s,i)&&(e.push(i.i/n|0),e.push(r.i/n|0),e.push(s.i/n|0),qg(r),qg(r.next),r=t=s),r=r.next}while(r!==t);return gd(r)}function spe(t,e,n,r,i,s){let o=t;do{let a=o.next.next;for(;a!==o.prev;){if(o.i!==a.i&&ppe(o,a)){let l=J5(o,a);o=gd(o,o.next),l=gd(l,l.next),Xg(o,e,n,r,i,s,0),Xg(l,e,n,r,i,s,0);return}a=a.next}o=o.next}while(o!==t)}function ope(t,e,n,r){const i=[];let s,o,a,l,c;for(s=0,o=e.length;s<o;s++)a=e[s]*r,l=s<o-1?e[s+1]*r:t.length,c=K5(t,a,l,r,!1),c===c.next&&(c.steiner=!0),i.push(hpe(c));for(i.sort(ape),s=0;s<i.length;s++)n=lpe(i[s],n);return n}function ape(t,e){return t.x-e.x}function lpe(t,e){const n=cpe(t,e);if(!n)return e;const r=J5(n,t);return gd(r,r.next),gd(n,n.next)}function cpe(t,e){let n=e,r=-1/0,i;const s=t.x,o=t.y;do{if(o<=n.y&&o>=n.next.y&&n.next.y!==n.y){const f=n.x+(o-n.y)*(n.next.x-n.x)/(n.next.y-n.y);if(f<=s&&f>r&&(r=f,i=n.x<n.next.x?n:n.next,f===s))return i}n=n.next}while(n!==e);if(!i)return null;const a=i,l=i.x,c=i.y;let u=1/0,d;n=i;do s>=n.x&&n.x>=l&&s!==n.x&&lh(o<c?s:r,o,l,c,o<c?r:s,o,n.x,n.y)&&(d=Math.abs(o-n.y)/(s-n.x),Kg(n,t)&&(d<u||d===u&&(n.x>i.x||n.x===i.x&&upe(i,n)))&&(i=n,u=d)),n=n.next;while(n!==a);return i}function upe(t,e){return Xn(t.prev,t,e.prev)<0&&Xn(e.next,t,t.next)<0}function dpe(t,e,n,r){let i=t;do i.z===0&&(i.z=B2(i.x,i.y,e,n,r)),i.prevZ=i.prev,i.nextZ=i.next,i=i.next;while(i!==t);i.prevZ.nextZ=null,i.prevZ=null,fpe(i)}function fpe(t){let e,n,r,i,s,o,a,l,c=1;do{for(n=t,t=null,s=null,o=0;n;){for(o++,r=n,a=0,e=0;e<c&&(a++,r=r.nextZ,!!r);e++);for(l=c;a>0||l>0&&r;)a!==0&&(l===0||!r||n.z<=r.z)?(i=n,n=n.nextZ,a--):(i=r,r=r.nextZ,l--),s?s.nextZ=i:t=i,i.prevZ=s,s=i;n=r}s.nextZ=null,c*=2}while(o>1);return t}function B2(t,e,n,r,i){return t=(t-n)*i|0,e=(e-r)*i|0,t=(t|t<<8)&16711935,t=(t|t<<4)&252645135,t=(t|t<<2)&858993459,t=(t|t<<1)&1431655765,e=(e|e<<8)&16711935,e=(e|e<<4)&252645135,e=(e|e<<2)&858993459,e=(e|e<<1)&1431655765,t|e<<1}function hpe(t){let e=t,n=t;do(e.x<n.x||e.x===n.x&&e.y<n.y)&&(n=e),e=e.next;while(e!==t);return n}function lh(t,e,n,r,i,s,o,a){return(i-o)*(e-a)>=(t-o)*(s-a)&&(t-o)*(r-a)>=(n-o)*(e-a)&&(n-o)*(s-a)>=(i-o)*(r-a)}function ppe(t,e){return t.next.i!==e.i&&t.prev.i!==e.i&&!mpe(t,e)&&(Kg(t,e)&&Kg(e,t)&&gpe(t,e)&&(Xn(t.prev,t,e.prev)||Xn(t,e.prev,e))||zS(t,e)&&Xn(t.prev,t,t.next)>0&&Xn(e.prev,e,e.next)>0)}function Xn(t,e,n){return(e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y)}function zS(t,e){return t.x===e.x&&t.y===e.y}function q5(t,e,n,r){const i=sx(Xn(t,e,n)),s=sx(Xn(t,e,r)),o=sx(Xn(n,r,t)),a=sx(Xn(n,r,e));return!!(i!==s&&o!==a||i===0&&ix(t,n,e)||s===0&&ix(t,r,e)||o===0&&ix(n,t,r)||a===0&&ix(n,e,r))}function ix(t,e,n){return e.x<=Math.max(t.x,n.x)&&e.x>=Math.min(t.x,n.x)&&e.y<=Math.max(t.y,n.y)&&e.y>=Math.min(t.y,n.y)}function sx(t){return t>0?1:t<0?-1:0}function mpe(t,e){let n=t;do{if(n.i!==t.i&&n.next.i!==t.i&&n.i!==e.i&&n.next.i!==e.i&&q5(n,n.next,t,e))return!0;n=n.next}while(n!==t);return!1}function Kg(t,e){return Xn(t.prev,t,t.next)<0?Xn(t,e,t.next)>=0&&Xn(t,t.prev,e)>=0:Xn(t,e,t.prev)<0||Xn(t,t.next,e)<0}function gpe(t,e){let n=t,r=!1;const i=(t.x+e.x)/2,s=(t.y+e.y)/2;do n.y>s!=n.next.y>s&&n.next.y!==n.y&&i<(n.next.x-n.x)*(s-n.y)/(n.next.y-n.y)+n.x&&(r=!r),n=n.next;while(n!==t);return r}function J5(t,e){const n=new F2(t.i,t.x,t.y),r=new F2(e.i,e.x,e.y),i=t.next,s=e.prev;return t.next=e,e.prev=t,n.next=i,i.prev=n,r.next=n,n.prev=r,s.next=r,r.prev=s,r}function $O(t,e,n,r){const i=new F2(t,e,n);return r?(i.next=r.next,i.prev=r,r.next.prev=i,r.next=i):(i.prev=i,i.next=i),i}function qg(t){t.next.prev=t.prev,t.prev.next=t.next,t.prevZ&&(t.prevZ.nextZ=t.nextZ),t.nextZ&&(t.nextZ.prevZ=t.prevZ)}function F2(t,e,n){this.i=t,this.x=e,this.y=n,this.prev=null,this.next=null,this.z=0,this.prevZ=null,this.nextZ=null,this.steiner=!1}function ype(t,e,n,r){let i=0;for(let s=e,o=n-r;s<n;s+=r)i+=(t[o]-t[s])*(t[s+1]+t[o+1]),o=s;return i}class Aa{static area(e){const n=e.length;let r=0;for(let i=n-1,s=0;s<n;i=s++)r+=e[i].x*e[s].y-e[s].x*e[i].y;return r*.5}static isClockWise(e){return Aa.area(e)<0}static triangulateShape(e,n){const r=[],i=[],s=[];UO(e),zO(r,e);let o=e.length;n.forEach(UO);for(let l=0;l<n.length;l++)i.push(o),o+=n[l].length,zO(r,n[l]);const a=tpe.triangulate(r,i);for(let l=0;l<a.length;l+=3)s.push(a.slice(l,l+3));return s}}function UO(t){const e=t.length;e>2&&t[e-1].equals(t[0])&&t.pop()}function zO(t,e){for(let n=0;n<e.length;n++)t.push(e[n].x),t.push(e[n].y)}class GS extends Lt{constructor(e=new Zu([new Re(.5,.5),new Re(-.5,.5),new Re(-.5,-.5),new Re(.5,-.5)]),n={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:e,options:n},e=Array.isArray(e)?e:[e];const r=this,i=[],s=[];for(let a=0,l=e.length;a<l;a++){const c=e[a];o(c)}this.setAttribute("position",new mt(i,3)),this.setAttribute("uv",new mt(s,2)),this.computeVertexNormals();function o(a){const l=[],c=n.curveSegments!==void 0?n.curveSegments:12,u=n.steps!==void 0?n.steps:1,d=n.depth!==void 0?n.depth:1;let f=n.bevelEnabled!==void 0?n.bevelEnabled:!0,h=n.bevelThickness!==void 0?n.bevelThickness:.2,p=n.bevelSize!==void 0?n.bevelSize:h-.1,x=n.bevelOffset!==void 0?n.bevelOffset:0,v=n.bevelSegments!==void 0?n.bevelSegments:3;const y=n.extrudePath,b=n.UVGenerator!==void 0?n.UVGenerator:vpe;let S,w=!1,E,A,T,I;y&&(S=y.getSpacedPoints(u),w=!0,f=!1,E=y.computeFrenetFrames(u,!1),A=new K,T=new K,I=new K),f||(v=0,h=0,p=0,x=0);const N=a.extractPoints(c);let M=N.shape;const P=N.holes;if(!Aa.isClockWise(M)){M=M.reverse();for(let be=0,ce=P.length;be<ce;be++){const Me=P[be];Aa.isClockWise(Me)&&(P[be]=Me.reverse())}}const F=Aa.triangulateShape(M,P),U=M;for(let be=0,ce=P.length;be<ce;be++){const Me=P[be];M=M.concat(Me)}function j(be,ce,Me){return ce||console.error("THREE.ExtrudeGeometry: vec does not exist"),be.clone().addScaledVector(ce,Me)}const Z=M.length,ne=F.length;function O(be,ce,Me){let Ie,Oe,V;const $=be.x-ce.x,ue=be.y-ce.y,ye=Me.x-be.x,ve=Me.y-be.y,Ne=$*$+ue*ue,nt=$*ve-ue*ye;if(Math.abs(nt)>Number.EPSILON){const Ae=Math.sqrt(Ne),st=Math.sqrt(ye*ye+ve*ve),ht=ce.x-ue/Ae,Ue=ce.y+$/Ae,Fe=Me.x-ve/st,$e=Me.y+ye/st,Ze=((Fe-ht)*ve-($e-Ue)*ye)/($*ve-ue*ye);Ie=ht+$*Ze-be.x,Oe=Ue+ue*Ze-be.y;const ot=Ie*Ie+Oe*Oe;if(ot<=2)return new Re(Ie,Oe);V=Math.sqrt(ot/2)}else{let Ae=!1;$>Number.EPSILON?ye>Number.EPSILON&&(Ae=!0):$<-Number.EPSILON?ye<-Number.EPSILON&&(Ae=!0):Math.sign(ue)===Math.sign(ve)&&(Ae=!0),Ae?(Ie=-ue,Oe=$,V=Math.sqrt(Ne)):(Ie=$,Oe=ue,V=Math.sqrt(Ne/2))}return new Re(Ie/V,Oe/V)}const G=[];for(let be=0,ce=U.length,Me=ce-1,Ie=be+1;be<ce;be++,Me++,Ie++)Me===ce&&(Me=0),Ie===ce&&(Ie=0),G[be]=O(U[be],U[Me],U[Ie]);const q=[];let se,he=G.concat();for(let be=0,ce=P.length;be<ce;be++){const Me=P[be];se=[];for(let Ie=0,Oe=Me.length,V=Oe-1,$=Ie+1;Ie<Oe;Ie++,V++,$++)V===Oe&&(V=0),$===Oe&&($=0),se[Ie]=O(Me[Ie],Me[V],Me[$]);q.push(se),he=he.concat(se)}for(let be=0;be<v;be++){const ce=be/v,Me=h*Math.cos(ce*Math.PI/2),Ie=p*Math.sin(ce*Math.PI/2)+x;for(let Oe=0,V=U.length;Oe<V;Oe++){const $=j(U[Oe],G[Oe],Ie);Ee($.x,$.y,-Me)}for(let Oe=0,V=P.length;Oe<V;Oe++){const $=P[Oe];se=q[Oe];for(let ue=0,ye=$.length;ue<ye;ue++){const ve=j($[ue],se[ue],Ie);Ee(ve.x,ve.y,-Me)}}}const ke=p+x;for(let be=0;be<Z;be++){const ce=f?j(M[be],he[be],ke):M[be];w?(T.copy(E.normals[0]).multiplyScalar(ce.x),A.copy(E.binormals[0]).multiplyScalar(ce.y),I.copy(S[0]).add(T).add(A),Ee(I.x,I.y,I.z)):Ee(ce.x,ce.y,0)}for(let be=1;be<=u;be++)for(let ce=0;ce<Z;ce++){const Me=f?j(M[ce],he[ce],ke):M[ce];w?(T.copy(E.normals[be]).multiplyScalar(Me.x),A.copy(E.binormals[be]).multiplyScalar(Me.y),I.copy(S[be]).add(T).add(A),Ee(I.x,I.y,I.z)):Ee(Me.x,Me.y,d/u*be)}for(let be=v-1;be>=0;be--){const ce=be/v,Me=h*Math.cos(ce*Math.PI/2),Ie=p*Math.sin(ce*Math.PI/2)+x;for(let Oe=0,V=U.length;Oe<V;Oe++){const $=j(U[Oe],G[Oe],Ie);Ee($.x,$.y,d+Me)}for(let Oe=0,V=P.length;Oe<V;Oe++){const $=P[Oe];se=q[Oe];for(let ue=0,ye=$.length;ue<ye;ue++){const ve=j($[ue],se[ue],Ie);w?Ee(ve.x,ve.y+S[u-1].y,S[u-1].x+Me):Ee(ve.x,ve.y,d+Me)}}}re(),pe();function re(){const be=i.length/3;if(f){let ce=0,Me=Z*ce;for(let Ie=0;Ie<ne;Ie++){const Oe=F[Ie];We(Oe[2]+Me,Oe[1]+Me,Oe[0]+Me)}ce=u+v*2,Me=Z*ce;for(let Ie=0;Ie<ne;Ie++){const Oe=F[Ie];We(Oe[0]+Me,Oe[1]+Me,Oe[2]+Me)}}else{for(let ce=0;ce<ne;ce++){const Me=F[ce];We(Me[2],Me[1],Me[0])}for(let ce=0;ce<ne;ce++){const Me=F[ce];We(Me[0]+Z*u,Me[1]+Z*u,Me[2]+Z*u)}}r.addGroup(be,i.length/3-be,0)}function pe(){const be=i.length/3;let ce=0;fe(U,ce),ce+=U.length;for(let Me=0,Ie=P.length;Me<Ie;Me++){const Oe=P[Me];fe(Oe,ce),ce+=Oe.length}r.addGroup(be,i.length/3-be,1)}function fe(be,ce){let Me=be.length;for(;--Me>=0;){const Ie=Me;let Oe=Me-1;Oe<0&&(Oe=be.length-1);for(let V=0,$=u+v*2;V<$;V++){const ue=Z*V,ye=Z*(V+1),ve=ce+Ie+ue,Ne=ce+Oe+ue,nt=ce+Oe+ye,Ae=ce+Ie+ye;je(ve,Ne,nt,Ae)}}}function Ee(be,ce,Me){l.push(be),l.push(ce),l.push(Me)}function We(be,ce,Me){Je(be),Je(ce),Je(Me);const Ie=i.length/3,Oe=b.generateTopUV(r,i,Ie-3,Ie-2,Ie-1);te(Oe[0]),te(Oe[1]),te(Oe[2])}function je(be,ce,Me,Ie){Je(be),Je(ce),Je(Ie),Je(ce),Je(Me),Je(Ie);const Oe=i.length/3,V=b.generateSideWallUV(r,i,Oe-6,Oe-3,Oe-2,Oe-1);te(V[0]),te(V[1]),te(V[3]),te(V[1]),te(V[2]),te(V[3])}function Je(be){i.push(l[be*3+0]),i.push(l[be*3+1]),i.push(l[be*3+2])}function te(be){s.push(be.x),s.push(be.y)}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),n=this.parameters.shapes,r=this.parameters.options;return xpe(n,r,e)}static fromJSON(e,n){const r=[];for(let s=0,o=e.shapes.length;s<o;s++){const a=n[e.shapes[s]];r.push(a)}const i=e.options.extrudePath;return i!==void 0&&(e.options.extrudePath=new G1[i.type]().fromJSON(i)),new GS(r,e.options)}}const vpe={generateTopUV:function(t,e,n,r,i){const s=e[n*3],o=e[n*3+1],a=e[r*3],l=e[r*3+1],c=e[i*3],u=e[i*3+1];return[new Re(s,o),new Re(a,l),new Re(c,u)]},generateSideWallUV:function(t,e,n,r,i,s){const o=e[n*3],a=e[n*3+1],l=e[n*3+2],c=e[r*3],u=e[r*3+1],d=e[r*3+2],f=e[i*3],h=e[i*3+1],p=e[i*3+2],x=e[s*3],v=e[s*3+1],y=e[s*3+2];return Math.abs(a-u)<Math.abs(o-c)?[new Re(o,1-l),new Re(c,1-d),new Re(f,1-p),new Re(x,1-y)]:[new Re(a,1-l),new Re(u,1-d),new Re(h,1-p),new Re(v,1-y)]}};function xpe(t,e,n){if(n.shapes=[],Array.isArray(t))for(let r=0,i=t.length;r<i;r++){const s=t[r];n.shapes.push(s.uuid)}else n.shapes.push(t.uuid);return n.options=Object.assign({},e),e.extrudePath!==void 0&&(n.options.extrudePath=e.extrudePath.toJSON()),n}class HS extends Fc{constructor(e=1,n=0){const r=(1+Math.sqrt(5))/2,i=[-1,r,0,1,r,0,-1,-r,0,1,-r,0,0,-1,r,0,1,r,0,-1,-r,0,1,-r,r,0,-1,r,0,1,-r,0,-1,-r,0,1],s=[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1];super(i,s,e,n),this.type="IcosahedronGeometry",this.parameters={radius:e,detail:n}}static fromJSON(e){return new HS(e.radius,e.detail)}}class k0 extends Fc{constructor(e=1,n=0){const r=[1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],i=[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2];super(r,i,e,n),this.type="OctahedronGeometry",this.parameters={radius:e,detail:n}}static fromJSON(e){return new k0(e.radius,e.detail)}}class VS extends Lt{constructor(e=.5,n=1,r=32,i=1,s=0,o=Math.PI*2){super(),this.type="RingGeometry",this.parameters={innerRadius:e,outerRadius:n,thetaSegments:r,phiSegments:i,thetaStart:s,thetaLength:o},r=Math.max(3,r),i=Math.max(1,i);const a=[],l=[],c=[],u=[];let d=e;const f=(n-e)/i,h=new K,p=new Re;for(let x=0;x<=i;x++){for(let v=0;v<=r;v++){const y=s+v/r*o;h.x=d*Math.cos(y),h.y=d*Math.sin(y),l.push(h.x,h.y,h.z),c.push(0,0,1),p.x=(h.x/n+1)/2,p.y=(h.y/n+1)/2,u.push(p.x,p.y)}d+=f}for(let x=0;x<i;x++){const v=x*(r+1);for(let y=0;y<r;y++){const b=y+v,S=b,w=b+r+1,E=b+r+2,A=b+1;a.push(S,w,A),a.push(w,E,A)}}this.setIndex(a),this.setAttribute("position",new mt(l,3)),this.setAttribute("normal",new mt(c,3)),this.setAttribute("uv",new mt(u,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new VS(e.innerRadius,e.outerRadius,e.thetaSegments,e.phiSegments,e.thetaStart,e.thetaLength)}}class WS extends Lt{constructor(e=new Zu([new Re(0,.5),new Re(-.5,-.5),new Re(.5,-.5)]),n=12){super(),this.type="ShapeGeometry",this.parameters={shapes:e,curveSegments:n};const r=[],i=[],s=[],o=[];let a=0,l=0;if(Array.isArray(e)===!1)c(e);else for(let u=0;u<e.length;u++)c(e[u]),this.addGroup(a,l,u),a+=l,l=0;this.setIndex(r),this.setAttribute("position",new mt(i,3)),this.setAttribute("normal",new mt(s,3)),this.setAttribute("uv",new mt(o,2));function c(u){const d=i.length/3,f=u.extractPoints(n);let h=f.shape;const p=f.holes;Aa.isClockWise(h)===!1&&(h=h.reverse());for(let v=0,y=p.length;v<y;v++){const b=p[v];Aa.isClockWise(b)===!0&&(p[v]=b.reverse())}const x=Aa.triangulateShape(h,p);for(let v=0,y=p.length;v<y;v++){const b=p[v];h=h.concat(b)}for(let v=0,y=h.length;v<y;v++){const b=h[v];i.push(b.x,b.y,0),s.push(0,0,1),o.push(b.x,b.y)}for(let v=0,y=x.length;v<y;v++){const b=x[v],S=b[0]+d,w=b[1]+d,E=b[2]+d;r.push(S,w,E),l+=3}}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON(),n=this.parameters.shapes;return bpe(n,e)}static fromJSON(e,n){const r=[];for(let i=0,s=e.shapes.length;i<s;i++){const o=n[e.shapes[i]];r.push(o)}return new WS(r,e.curveSegments)}}function bpe(t,e){if(e.shapes=[],Array.isArray(t))for(let n=0,r=t.length;n<r;n++){const i=t[n];e.shapes.push(i.uuid)}else e.shapes.push(t.uuid);return e}class D0 extends Lt{constructor(e=1,n=32,r=16,i=0,s=Math.PI*2,o=0,a=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:e,widthSegments:n,heightSegments:r,phiStart:i,phiLength:s,thetaStart:o,thetaLength:a},n=Math.max(3,Math.floor(n)),r=Math.max(2,Math.floor(r));const l=Math.min(o+a,Math.PI);let c=0;const u=[],d=new K,f=new K,h=[],p=[],x=[],v=[];for(let y=0;y<=r;y++){const b=[],S=y/r;let w=0;y===0&&o===0?w=.5/n:y===r&&l===Math.PI&&(w=-.5/n);for(let E=0;E<=n;E++){const A=E/n;d.x=-e*Math.cos(i+A*s)*Math.sin(o+S*a),d.y=e*Math.cos(o+S*a),d.z=e*Math.sin(i+A*s)*Math.sin(o+S*a),p.push(d.x,d.y,d.z),f.copy(d).normalize(),x.push(f.x,f.y,f.z),v.push(A+w,1-S),b.push(c++)}u.push(b)}for(let y=0;y<r;y++)for(let b=0;b<n;b++){const S=u[y][b+1],w=u[y][b],E=u[y+1][b],A=u[y+1][b+1];(y!==0||o>0)&&h.push(S,w,A),(y!==r-1||l<Math.PI)&&h.push(w,E,A)}this.setIndex(h),this.setAttribute("position",new mt(p,3)),this.setAttribute("normal",new mt(x,3)),this.setAttribute("uv",new mt(v,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new D0(e.radius,e.widthSegments,e.heightSegments,e.phiStart,e.phiLength,e.thetaStart,e.thetaLength)}}class jS extends Fc{constructor(e=1,n=0){const r=[1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],i=[2,1,0,0,3,2,1,3,0,2,3,1];super(r,i,e,n),this.type="TetrahedronGeometry",this.parameters={radius:e,detail:n}}static fromJSON(e){return new jS(e.radius,e.detail)}}class XS extends Lt{constructor(e=1,n=.4,r=12,i=48,s=Math.PI*2){super(),this.type="TorusGeometry",this.parameters={radius:e,tube:n,radialSegments:r,tubularSegments:i,arc:s},r=Math.floor(r),i=Math.floor(i);const o=[],a=[],l=[],c=[],u=new K,d=new K,f=new K;for(let h=0;h<=r;h++)for(let p=0;p<=i;p++){const x=p/i*s,v=h/r*Math.PI*2;d.x=(e+n*Math.cos(v))*Math.cos(x),d.y=(e+n*Math.cos(v))*Math.sin(x),d.z=n*Math.sin(v),a.push(d.x,d.y,d.z),u.x=e*Math.cos(x),u.y=e*Math.sin(x),f.subVectors(d,u).normalize(),l.push(f.x,f.y,f.z),c.push(p/i),c.push(h/r)}for(let h=1;h<=r;h++)for(let p=1;p<=i;p++){const x=(i+1)*h+p-1,v=(i+1)*(h-1)+p-1,y=(i+1)*(h-1)+p,b=(i+1)*h+p;o.push(x,v,b),o.push(v,y,b)}this.setIndex(o),this.setAttribute("position",new mt(a,3)),this.setAttribute("normal",new mt(l,3)),this.setAttribute("uv",new mt(c,2))}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new XS(e.radius,e.tube,e.radialSegments,e.tubularSegments,e.arc)}}class KS extends Lt{constructor(e=1,n=.4,r=64,i=8,s=2,o=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:e,tube:n,tubularSegments:r,radialSegments:i,p:s,q:o},r=Math.floor(r),i=Math.floor(i);const a=[],l=[],c=[],u=[],d=new K,f=new K,h=new K,p=new K,x=new K,v=new K,y=new K;for(let S=0;S<=r;++S){const w=S/r*s*Math.PI*2;b(w,s,o,e,h),b(w+.01,s,o,e,p),v.subVectors(p,h),y.addVectors(p,h),x.crossVectors(v,y),y.crossVectors(x,v),x.normalize(),y.normalize();for(let E=0;E<=i;++E){const A=E/i*Math.PI*2,T=-n*Math.cos(A),I=n*Math.sin(A);d.x=h.x+(T*y.x+I*x.x),d.y=h.y+(T*y.y+I*x.y),d.z=h.z+(T*y.z+I*x.z),l.push(d.x,d.y,d.z),f.subVectors(d,h).normalize(),c.push(f.x,f.y,f.z),u.push(S/r),u.push(E/i)}}for(let S=1;S<=r;S++)for(let w=1;w<=i;w++){const E=(i+1)*(S-1)+(w-1),A=(i+1)*S+(w-1),T=(i+1)*S+w,I=(i+1)*(S-1)+w;a.push(E,A,I),a.push(A,T,I)}this.setIndex(a),this.setAttribute("position",new mt(l,3)),this.setAttribute("normal",new mt(c,3)),this.setAttribute("uv",new mt(u,2));function b(S,w,E,A,T){const I=Math.cos(S),N=Math.sin(S),M=E/w*S,P=Math.cos(M);T.x=A*(2+P)*.5*I,T.y=A*(2+P)*N*.5,T.z=A*Math.sin(M)*.5}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}static fromJSON(e){return new KS(e.radius,e.tube,e.tubularSegments,e.radialSegments,e.p,e.q)}}class qS extends Lt{constructor(e=new jR(new K(-1,-1,0),new K(-1,1,0),new K(1,1,0)),n=64,r=1,i=8,s=!1){super(),this.type="TubeGeometry",this.parameters={path:e,tubularSegments:n,radius:r,radialSegments:i,closed:s};const o=e.computeFrenetFrames(n,s);this.tangents=o.tangents,this.normals=o.normals,this.binormals=o.binormals;const a=new K,l=new K,c=new Re;let u=new K;const d=[],f=[],h=[],p=[];x(),this.setIndex(p),this.setAttribute("position",new mt(d,3)),this.setAttribute("normal",new mt(f,3)),this.setAttribute("uv",new mt(h,2));function x(){for(let S=0;S<n;S++)v(S);v(s===!1?n:0),b(),y()}function v(S){u=e.getPointAt(S/n,u);const w=o.normals[S],E=o.binormals[S];for(let A=0;A<=i;A++){const T=A/i*Math.PI*2,I=Math.sin(T),N=-Math.cos(T);l.x=N*w.x+I*E.x,l.y=N*w.y+I*E.y,l.z=N*w.z+I*E.z,l.normalize(),f.push(l.x,l.y,l.z),a.x=u.x+r*l.x,a.y=u.y+r*l.y,a.z=u.z+r*l.z,d.push(a.x,a.y,a.z)}}function y(){for(let S=1;S<=n;S++)for(let w=1;w<=i;w++){const E=(i+1)*(S-1)+(w-1),A=(i+1)*S+(w-1),T=(i+1)*S+w,I=(i+1)*(S-1)+w;p.push(E,A,I),p.push(A,T,I)}}function b(){for(let S=0;S<=n;S++)for(let w=0;w<=i;w++)c.x=S/n,c.y=w/i,h.push(c.x,c.y)}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}toJSON(){const e=super.toJSON();return e.path=this.parameters.path.toJSON(),e}static fromJSON(e){return new qS(new G1[e.path.type]().fromJSON(e.path),e.tubularSegments,e.radius,e.radialSegments,e.closed)}}class Y5 extends Lt{constructor(e=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:e},e!==null){const n=[],r=new Set,i=new K,s=new K;if(e.index!==null){const o=e.attributes.position,a=e.index;let l=e.groups;l.length===0&&(l=[{start:0,count:a.count,materialIndex:0}]);for(let c=0,u=l.length;c<u;++c){const d=l[c],f=d.start,h=d.count;for(let p=f,x=f+h;p<x;p+=3)for(let v=0;v<3;v++){const y=a.getX(p+v),b=a.getX(p+(v+1)%3);i.fromBufferAttribute(o,y),s.fromBufferAttribute(o,b),GO(i,s,r)===!0&&(n.push(i.x,i.y,i.z),n.push(s.x,s.y,s.z))}}}else{const o=e.attributes.position;for(let a=0,l=o.count/3;a<l;a++)for(let c=0;c<3;c++){const u=3*a+c,d=3*a+(c+1)%3;i.fromBufferAttribute(o,u),s.fromBufferAttribute(o,d),GO(i,s,r)===!0&&(n.push(i.x,i.y,i.z),n.push(s.x,s.y,s.z))}}this.setAttribute("position",new mt(n,3))}}copy(e){return super.copy(e),this.parameters=Object.assign({},e.parameters),this}}function GO(t,e,n){const r=`${t.x},${t.y},${t.z}-${e.x},${e.y},${e.z}`,i=`${e.x},${e.y},${e.z}-${t.x},${t.y},${t.z}`;return n.has(r)===!0||n.has(i)===!0?!1:(n.add(r),n.add(i),!0)}var HO=Object.freeze({__proto__:null,BoxGeometry:Pd,CapsuleGeometry:BS,CircleGeometry:FS,ConeGeometry:$S,CylinderGeometry:bp,DodecahedronGeometry:US,EdgesGeometry:X5,ExtrudeGeometry:GS,IcosahedronGeometry:HS,LatheGeometry:P0,OctahedronGeometry:k0,PlaneGeometry:kd,PolyhedronGeometry:Fc,RingGeometry:VS,ShapeGeometry:WS,SphereGeometry:D0,TetrahedronGeometry:jS,TorusGeometry:XS,TorusKnotGeometry:KS,TubeGeometry:qS,WireframeGeometry:Y5});class Q5 extends wr{constructor(e){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Qe(0),this.transparent=!0,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.fog=e.fog,this}}class Z5 extends Ko{constructor(e){super(e),this.isRawShaderMaterial=!0,this.type="RawShaderMaterial"}}class O0 extends wr{constructor(e){super(),this.isMeshStandardMaterial=!0,this.defines={STANDARD:""},this.type="MeshStandardMaterial",this.color=new Qe(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Qe(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Bc,this.normalScale=new Re(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Is,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={STANDARD:""},this.color.copy(e.color),this.roughness=e.roughness,this.metalness=e.metalness,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.roughnessMap=e.roughnessMap,this.metalnessMap=e.metalnessMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.envMapIntensity=e.envMapIntensity,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class Da extends O0{constructor(e){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Re(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return sr(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(n){this.ior=(1+.4*n)/(1-.4*n)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Qe(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=1/0,this.attenuationColor=new Qe(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Qe(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(e)}get anisotropy(){return this._anisotropy}set anisotropy(e){this._anisotropy>0!=e>0&&this.version++,this._anisotropy=e}get clearcoat(){return this._clearcoat}set clearcoat(e){this._clearcoat>0!=e>0&&this.version++,this._clearcoat=e}get iridescence(){return this._iridescence}set iridescence(e){this._iridescence>0!=e>0&&this.version++,this._iridescence=e}get sheen(){return this._sheen}set sheen(e){this._sheen>0!=e>0&&this.version++,this._sheen=e}get transmission(){return this._transmission}set transmission(e){this._transmission>0!=e>0&&this.version++,this._transmission=e}copy(e){return super.copy(e),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=e.anisotropy,this.anisotropyRotation=e.anisotropyRotation,this.anisotropyMap=e.anisotropyMap,this.clearcoat=e.clearcoat,this.clearcoatMap=e.clearcoatMap,this.clearcoatRoughness=e.clearcoatRoughness,this.clearcoatRoughnessMap=e.clearcoatRoughnessMap,this.clearcoatNormalMap=e.clearcoatNormalMap,this.clearcoatNormalScale.copy(e.clearcoatNormalScale),this.ior=e.ior,this.iridescence=e.iridescence,this.iridescenceMap=e.iridescenceMap,this.iridescenceIOR=e.iridescenceIOR,this.iridescenceThicknessRange=[...e.iridescenceThicknessRange],this.iridescenceThicknessMap=e.iridescenceThicknessMap,this.sheen=e.sheen,this.sheenColor.copy(e.sheenColor),this.sheenColorMap=e.sheenColorMap,this.sheenRoughness=e.sheenRoughness,this.sheenRoughnessMap=e.sheenRoughnessMap,this.transmission=e.transmission,this.transmissionMap=e.transmissionMap,this.thickness=e.thickness,this.thicknessMap=e.thicknessMap,this.attenuationDistance=e.attenuationDistance,this.attenuationColor.copy(e.attenuationColor),this.specularIntensity=e.specularIntensity,this.specularIntensityMap=e.specularIntensityMap,this.specularColor.copy(e.specularColor),this.specularColorMap=e.specularColorMap,this}}class e6 extends wr{constructor(e){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Qe(16777215),this.specular=new Qe(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Qe(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Bc,this.normalScale=new Re(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Is,this.combine=E0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.specular.copy(e.specular),this.shininess=e.shininess,this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class t6 extends wr{constructor(e){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Qe(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Qe(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Bc,this.normalScale=new Re(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.gradientMap=e.gradientMap,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.fog=e.fog,this}}class n6 extends wr{constructor(e){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Bc,this.normalScale=new Re(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(e)}copy(e){return super.copy(e),this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.flatShading=e.flatShading,this}}class r6 extends wr{constructor(e){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Qe(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Qe(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Bc,this.normalScale=new Re(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Is,this.combine=E0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.color.copy(e.color),this.map=e.map,this.lightMap=e.lightMap,this.lightMapIntensity=e.lightMapIntensity,this.aoMap=e.aoMap,this.aoMapIntensity=e.aoMapIntensity,this.emissive.copy(e.emissive),this.emissiveMap=e.emissiveMap,this.emissiveIntensity=e.emissiveIntensity,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.specularMap=e.specularMap,this.alphaMap=e.alphaMap,this.envMap=e.envMap,this.envMapRotation.copy(e.envMapRotation),this.combine=e.combine,this.reflectivity=e.reflectivity,this.refractionRatio=e.refractionRatio,this.wireframe=e.wireframe,this.wireframeLinewidth=e.wireframeLinewidth,this.wireframeLinecap=e.wireframeLinecap,this.wireframeLinejoin=e.wireframeLinejoin,this.flatShading=e.flatShading,this.fog=e.fog,this}}class i6 extends wr{constructor(e){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Qe(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=Bc,this.normalScale=new Re(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.flatShading=!1,this.fog=!0,this.setValues(e)}copy(e){return super.copy(e),this.defines={MATCAP:""},this.color.copy(e.color),this.matcap=e.matcap,this.map=e.map,this.bumpMap=e.bumpMap,this.bumpScale=e.bumpScale,this.normalMap=e.normalMap,this.normalMapType=e.normalMapType,this.normalScale.copy(e.normalScale),this.displacementMap=e.displacementMap,this.displacementScale=e.displacementScale,this.displacementBias=e.displacementBias,this.alphaMap=e.alphaMap,this.flatShading=e.flatShading,this.fog=e.fog,this}}class s6 extends Si{constructor(e){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(e)}copy(e){return super.copy(e),this.scale=e.scale,this.dashSize=e.dashSize,this.gapSize=e.gapSize,this}}function Fu(t,e,n){return!t||!n&&t.constructor===e?t:typeof e.BYTES_PER_ELEMENT=="number"?new e(t):Array.prototype.slice.call(t)}function o6(t){return ArrayBuffer.isView(t)&&!(t instanceof DataView)}function a6(t){function e(i,s){return t[i]-t[s]}const n=t.length,r=new Array(n);for(let i=0;i!==n;++i)r[i]=i;return r.sort(e),r}function $2(t,e,n){const r=t.length,i=new t.constructor(r);for(let s=0,o=0;o!==r;++s){const a=n[s]*e;for(let l=0;l!==e;++l)i[o++]=t[a+l]}return i}function KR(t,e,n,r){let i=1,s=t[0];for(;s!==void 0&&s[r]===void 0;)s=t[i++];if(s===void 0)return;let o=s[r];if(o!==void 0)if(Array.isArray(o))do o=s[r],o!==void 0&&(e.push(s.time),n.push.apply(n,o)),s=t[i++];while(s!==void 0);else if(o.toArray!==void 0)do o=s[r],o!==void 0&&(e.push(s.time),o.toArray(n,n.length)),s=t[i++];while(s!==void 0);else do o=s[r],o!==void 0&&(e.push(s.time),n.push(o)),s=t[i++];while(s!==void 0)}function Spe(t,e,n,r,i=30){const s=t.clone();s.name=e;const o=[];for(let l=0;l<s.tracks.length;++l){const c=s.tracks[l],u=c.getValueSize(),d=[],f=[];for(let h=0;h<c.times.length;++h){const p=c.times[h]*i;if(!(p<n||p>=r)){d.push(c.times[h]);for(let x=0;x<u;++x)f.push(c.values[h*u+x])}}d.length!==0&&(c.times=Fu(d,c.times.constructor),c.values=Fu(f,c.values.constructor),o.push(c))}s.tracks=o;let a=1/0;for(let l=0;l<s.tracks.length;++l)a>s.tracks[l].times[0]&&(a=s.tracks[l].times[0]);for(let l=0;l<s.tracks.length;++l)s.tracks[l].shift(-1*a);return s.resetDuration(),s}function _pe(t,e=0,n=t,r=30){r<=0&&(r=30);const i=n.tracks.length,s=e/r;for(let o=0;o<i;++o){const a=n.tracks[o],l=a.ValueTypeName;if(l==="bool"||l==="string")continue;const c=t.tracks.find(function(y){return y.name===a.name&&y.ValueTypeName===l});if(c===void 0)continue;let u=0;const d=a.getValueSize();a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(u=d/3);let f=0;const h=c.getValueSize();c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline&&(f=h/3);const p=a.times.length-1;let x;if(s<=a.times[0]){const y=u,b=d-u;x=a.values.slice(y,b)}else if(s>=a.times[p]){const y=p*d+u,b=y+d-u;x=a.values.slice(y,b)}else{const y=a.createInterpolant(),b=u,S=d-u;y.evaluate(s),x=y.resultBuffer.slice(b,S)}l==="quaternion"&&new Hr().fromArray(x).normalize().conjugate().toArray(x);const v=c.times.length;for(let y=0;y<v;++y){const b=y*h+f;if(l==="quaternion")Hr.multiplyQuaternionsFlat(c.values,b,x,0,c.values,b);else{const S=h-f*2;for(let w=0;w<S;++w)c.values[b+w]-=x[w]}}}return t.blendMode=ER,t}const wpe={convertArray:Fu,isTypedArray:o6,getKeyframeOrder:a6,sortedArray:$2,flattenJSON:KR,subclip:Spe,makeClipAdditive:_pe};class Sp{constructor(e,n,r,i){this.parameterPositions=e,this._cachedIndex=0,this.resultBuffer=i!==void 0?i:new n.constructor(r),this.sampleValues=n,this.valueSize=r,this.settings=null,this.DefaultSettings_={}}evaluate(e){const n=this.parameterPositions;let r=this._cachedIndex,i=n[r],s=n[r-1];e:{t:{let o;n:{r:if(!(e<i)){for(let a=r+2;;){if(i===void 0){if(e<s)break r;return r=n.length,this._cachedIndex=r,this.copySampleValue_(r-1)}if(r===a)break;if(s=i,i=n[++r],e<i)break t}o=n.length;break n}if(!(e>=s)){const a=n[1];e<a&&(r=2,s=a);for(let l=r-2;;){if(s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(r===l)break;if(i=s,s=n[--r-1],e>=s)break t}o=r,r=0;break n}break e}for(;r<o;){const a=r+o>>>1;e<n[a]?o=a:r=a+1}if(i=n[r],s=n[r-1],s===void 0)return this._cachedIndex=0,this.copySampleValue_(0);if(i===void 0)return r=n.length,this._cachedIndex=r,this.copySampleValue_(r-1)}this._cachedIndex=r,this.intervalChanged_(r,s,i)}return this.interpolate_(r,s,e,i)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(e){const n=this.resultBuffer,r=this.sampleValues,i=this.valueSize,s=e*i;for(let o=0;o!==i;++o)n[o]=r[s+o];return n}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class l6 extends Sp{constructor(e,n,r,i){super(e,n,r,i),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:Ou,endingEnd:Ou}}intervalChanged_(e,n,r){const i=this.parameterPositions;let s=e-2,o=e+1,a=i[s],l=i[o];if(a===void 0)switch(this.getSettings_().endingStart){case Lu:s=e,a=2*n-r;break;case Fg:s=i.length-2,a=n+i[s]-i[s+1];break;default:s=e,a=r}if(l===void 0)switch(this.getSettings_().endingEnd){case Lu:o=e,l=2*r-n;break;case Fg:o=1,l=r+i[1]-i[0];break;default:o=e-1,l=n}const c=(r-n)*.5,u=this.valueSize;this._weightPrev=c/(n-a),this._weightNext=c/(l-r),this._offsetPrev=s*u,this._offsetNext=o*u}interpolate_(e,n,r,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,u=this._offsetPrev,d=this._offsetNext,f=this._weightPrev,h=this._weightNext,p=(r-n)/(i-n),x=p*p,v=x*p,y=-f*v+2*f*x-f*p,b=(1+f)*v+(-1.5-2*f)*x+(-.5+f)*p+1,S=(-1-h)*v+(1.5+h)*x+.5*p,w=h*v-h*x;for(let E=0;E!==a;++E)s[E]=y*o[u+E]+b*o[c+E]+S*o[l+E]+w*o[d+E];return s}}class qR extends Sp{constructor(e,n,r,i){super(e,n,r,i)}interpolate_(e,n,r,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=e*a,c=l-a,u=(r-n)/(i-n),d=1-u;for(let f=0;f!==a;++f)s[f]=o[c+f]*d+o[l+f]*u;return s}}class c6 extends Sp{constructor(e,n,r,i){super(e,n,r,i)}interpolate_(e){return this.copySampleValue_(e-1)}}class Zo{constructor(e,n,r,i){if(e===void 0)throw new Error("THREE.KeyframeTrack: track name is undefined");if(n===void 0||n.length===0)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+e);this.name=e,this.times=Fu(n,this.TimeBufferType),this.values=Fu(r,this.ValueBufferType),this.setInterpolation(i||this.DefaultInterpolation)}static toJSON(e){const n=e.constructor;let r;if(n.toJSON!==this.toJSON)r=n.toJSON(e);else{r={name:e.name,times:Fu(e.times,Array),values:Fu(e.values,Array)};const i=e.getInterpolation();i!==e.DefaultInterpolation&&(r.interpolation=i)}return r.type=e.ValueTypeName,r}InterpolantFactoryMethodDiscrete(e){return new c6(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodLinear(e){return new qR(this.times,this.values,this.getValueSize(),e)}InterpolantFactoryMethodSmooth(e){return new l6(this.times,this.values,this.getValueSize(),e)}setInterpolation(e){let n;switch(e){case zh:n=this.InterpolantFactoryMethodDiscrete;break;case md:n=this.InterpolantFactoryMethodLinear;break;case Qx:n=this.InterpolantFactoryMethodSmooth;break}if(n===void 0){const r="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(this.createInterpolant===void 0)if(e!==this.DefaultInterpolation)this.setInterpolation(this.DefaultInterpolation);else throw new Error(r);return console.warn("THREE.KeyframeTrack:",r),this}return this.createInterpolant=n,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return zh;case this.InterpolantFactoryMethodLinear:return md;case this.InterpolantFactoryMethodSmooth:return Qx}}getValueSize(){return this.values.length/this.times.length}shift(e){if(e!==0){const n=this.times;for(let r=0,i=n.length;r!==i;++r)n[r]+=e}return this}scale(e){if(e!==1){const n=this.times;for(let r=0,i=n.length;r!==i;++r)n[r]*=e}return this}trim(e,n){const r=this.times,i=r.length;let s=0,o=i-1;for(;s!==i&&r[s]<e;)++s;for(;o!==-1&&r[o]>n;)--o;if(++o,s!==0||o!==i){s>=o&&(o=Math.max(o,1),s=o-1);const a=this.getValueSize();this.times=r.slice(s,o),this.values=this.values.slice(s*a,o*a)}return this}validate(){let e=!0;const n=this.getValueSize();n-Math.floor(n)!==0&&(console.error("THREE.KeyframeTrack: Invalid value size in track.",this),e=!1);const r=this.times,i=this.values,s=r.length;s===0&&(console.error("THREE.KeyframeTrack: Track is empty.",this),e=!1);let o=null;for(let a=0;a!==s;a++){const l=r[a];if(typeof l=="number"&&isNaN(l)){console.error("THREE.KeyframeTrack: Time is not a valid number.",this,a,l),e=!1;break}if(o!==null&&o>l){console.error("THREE.KeyframeTrack: Out of order keys.",this,a,l,o),e=!1;break}o=l}if(i!==void 0&&o6(i))for(let a=0,l=i.length;a!==l;++a){const c=i[a];if(isNaN(c)){console.error("THREE.KeyframeTrack: Value is not a valid number.",this,a,c),e=!1;break}}return e}optimize(){const e=this.times.slice(),n=this.values.slice(),r=this.getValueSize(),i=this.getInterpolation()===Qx,s=e.length-1;let o=1;for(let a=1;a<s;++a){let l=!1;const c=e[a],u=e[a+1];if(c!==u&&(a!==1||c!==e[0]))if(i)l=!0;else{const d=a*r,f=d-r,h=d+r;for(let p=0;p!==r;++p){const x=n[d+p];if(x!==n[f+p]||x!==n[h+p]){l=!0;break}}}if(l){if(a!==o){e[o]=e[a];const d=a*r,f=o*r;for(let h=0;h!==r;++h)n[f+h]=n[d+h]}++o}}if(s>0){e[o]=e[s];for(let a=s*r,l=o*r,c=0;c!==r;++c)n[l+c]=n[a+c];++o}return o!==e.length?(this.times=e.slice(0,o),this.values=n.slice(0,o*r)):(this.times=e,this.values=n),this}clone(){const e=this.times.slice(),n=this.values.slice(),r=this.constructor,i=new r(this.name,e,n);return i.createInterpolant=this.createInterpolant,i}}Zo.prototype.TimeBufferType=Float32Array;Zo.prototype.ValueBufferType=Float32Array;Zo.prototype.DefaultInterpolation=md;class Dd extends Zo{}Dd.prototype.ValueTypeName="bool";Dd.prototype.ValueBufferType=Array;Dd.prototype.DefaultInterpolation=zh;Dd.prototype.InterpolantFactoryMethodLinear=void 0;Dd.prototype.InterpolantFactoryMethodSmooth=void 0;class JR extends Zo{}JR.prototype.ValueTypeName="color";class Wh extends Zo{}Wh.prototype.ValueTypeName="number";class u6 extends Sp{constructor(e,n,r,i){super(e,n,r,i)}interpolate_(e,n,r,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=(r-n)/(i-n);let c=e*a;for(let u=c+a;c!==u;c+=4)Hr.slerpFlat(s,0,o,c-a,o,c,l);return s}}class Rc extends Zo{InterpolantFactoryMethodLinear(e){return new u6(this.times,this.values,this.getValueSize(),e)}}Rc.prototype.ValueTypeName="quaternion";Rc.prototype.DefaultInterpolation=md;Rc.prototype.InterpolantFactoryMethodSmooth=void 0;class Od extends Zo{}Od.prototype.ValueTypeName="string";Od.prototype.ValueBufferType=Array;Od.prototype.DefaultInterpolation=zh;Od.prototype.InterpolantFactoryMethodLinear=void 0;Od.prototype.InterpolantFactoryMethodSmooth=void 0;class jh extends Zo{}jh.prototype.ValueTypeName="vector";class Xh{constructor(e="",n=-1,r=[],i=TS){this.name=e,this.tracks=r,this.duration=n,this.blendMode=i,this.uuid=Ms(),this.duration<0&&this.resetDuration()}static parse(e){const n=[],r=e.tracks,i=1/(e.fps||1);for(let o=0,a=r.length;o!==a;++o)n.push(Epe(r[o]).scale(i));const s=new this(e.name,e.duration,n,e.blendMode);return s.uuid=e.uuid,s}static toJSON(e){const n=[],r=e.tracks,i={name:e.name,duration:e.duration,tracks:n,uuid:e.uuid,blendMode:e.blendMode};for(let s=0,o=r.length;s!==o;++s)n.push(Zo.toJSON(r[s]));return i}static CreateFromMorphTargetSequence(e,n,r,i){const s=n.length,o=[];for(let a=0;a<s;a++){let l=[],c=[];l.push((a+s-1)%s,a,(a+1)%s),c.push(0,1,0);const u=a6(l);l=$2(l,1,u),c=$2(c,1,u),!i&&l[0]===0&&(l.push(s),c.push(c[0])),o.push(new Wh(".morphTargetInfluences["+n[a].name+"]",l,c).scale(1/r))}return new this(e,-1,o)}static findByName(e,n){let r=e;if(!Array.isArray(e)){const i=e;r=i.geometry&&i.geometry.animations||i.animations}for(let i=0;i<r.length;i++)if(r[i].name===n)return r[i];return null}static CreateClipsFromMorphTargetSequences(e,n,r){const i={},s=/^([\w-]*?)([\d]+)$/;for(let a=0,l=e.length;a<l;a++){const c=e[a],u=c.name.match(s);if(u&&u.length>1){const d=u[1];let f=i[d];f||(i[d]=f=[]),f.push(c)}}const o=[];for(const a in i)o.push(this.CreateFromMorphTargetSequence(a,i[a],n,r));return o}static parseAnimation(e,n){if(!e)return console.error("THREE.AnimationClip: No animation in JSONLoader data."),null;const r=function(d,f,h,p,x){if(h.length!==0){const v=[],y=[];KR(h,v,y,p),v.length!==0&&x.push(new d(f,v,y))}},i=[],s=e.name||"default",o=e.fps||30,a=e.blendMode;let l=e.length||-1;const c=e.hierarchy||[];for(let d=0;d<c.length;d++){const f=c[d].keys;if(!(!f||f.length===0))if(f[0].morphTargets){const h={};let p;for(p=0;p<f.length;p++)if(f[p].morphTargets)for(let x=0;x<f[p].morphTargets.length;x++)h[f[p].morphTargets[x]]=-1;for(const x in h){const v=[],y=[];for(let b=0;b!==f[p].morphTargets.length;++b){const S=f[p];v.push(S.time),y.push(S.morphTarget===x?1:0)}i.push(new Wh(".morphTargetInfluence["+x+"]",v,y))}l=h.length*o}else{const h=".bones["+n[d].name+"]";r(jh,h+".position",f,"pos",i),r(Rc,h+".quaternion",f,"rot",i),r(jh,h+".scale",f,"scl",i)}}return i.length===0?null:new this(s,l,i,a)}resetDuration(){const e=this.tracks;let n=0;for(let r=0,i=e.length;r!==i;++r){const s=this.tracks[r];n=Math.max(n,s.times[s.times.length-1])}return this.duration=n,this}trim(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].trim(0,this.duration);return this}validate(){let e=!0;for(let n=0;n<this.tracks.length;n++)e=e&&this.tracks[n].validate();return e}optimize(){for(let e=0;e<this.tracks.length;e++)this.tracks[e].optimize();return this}clone(){const e=[];for(let n=0;n<this.tracks.length;n++)e.push(this.tracks[n].clone());return new this.constructor(this.name,this.duration,e,this.blendMode)}toJSON(){return this.constructor.toJSON(this)}}function Cpe(t){switch(t.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return Wh;case"vector":case"vector2":case"vector3":case"vector4":return jh;case"color":return JR;case"quaternion":return Rc;case"bool":case"boolean":return Dd;case"string":return Od}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+t)}function Epe(t){if(t.type===void 0)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const e=Cpe(t.type);if(t.times===void 0){const n=[],r=[];KR(t.keys,n,r,"value"),t.times=n,t.values=r}return e.parse!==void 0?e.parse(t):new e(t.name,t.times,t.values,t.interpolation)}const ol={enabled:!1,files:{},add:function(t,e){this.enabled!==!1&&(this.files[t]=e)},get:function(t){if(this.enabled!==!1)return this.files[t]},remove:function(t){delete this.files[t]},clear:function(){this.files={}}};class YR{constructor(e,n,r){const i=this;let s=!1,o=0,a=0,l;const c=[];this.onStart=void 0,this.onLoad=e,this.onProgress=n,this.onError=r,this.itemStart=function(u){a++,s===!1&&i.onStart!==void 0&&i.onStart(u,o,a),s=!0},this.itemEnd=function(u){o++,i.onProgress!==void 0&&i.onProgress(u,o,a),o===a&&(s=!1,i.onLoad!==void 0&&i.onLoad())},this.itemError=function(u){i.onError!==void 0&&i.onError(u)},this.resolveURL=function(u){return l?l(u):u},this.setURLModifier=function(u){return l=u,this},this.addHandler=function(u,d){return c.push(u,d),this},this.removeHandler=function(u){const d=c.indexOf(u);return d!==-1&&c.splice(d,2),this},this.getHandler=function(u){for(let d=0,f=c.length;d<f;d+=2){const h=c[d],p=c[d+1];if(h.global&&(h.lastIndex=0),h.test(u))return p}return null}}}const d6=new YR;class _i{constructor(e){this.manager=e!==void 0?e:d6,this.crossOrigin="anonymous",this.withCredentials=!1,this.path="",this.resourcePath="",this.requestHeader={}}load(){}loadAsync(e,n){const r=this;return new Promise(function(i,s){r.load(e,i,n,s)})}parse(){}setCrossOrigin(e){return this.crossOrigin=e,this}setWithCredentials(e){return this.withCredentials=e,this}setPath(e){return this.path=e,this}setResourcePath(e){return this.resourcePath=e,this}setRequestHeader(e){return this.requestHeader=e,this}}_i.DEFAULT_MATERIAL_NAME="__DEFAULT";const Ka={};class Ape extends Error{constructor(e,n){super(e),this.response=n}}class Ns extends _i{constructor(e){super(e)}load(e,n,r,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=ol.get(e);if(s!==void 0)return this.manager.itemStart(e),setTimeout(()=>{n&&n(s),this.manager.itemEnd(e)},0),s;if(Ka[e]!==void 0){Ka[e].push({onLoad:n,onProgress:r,onError:i});return}Ka[e]=[],Ka[e].push({onLoad:n,onProgress:r,onError:i});const o=new Request(e,{headers:new Headers(this.requestHeader),credentials:this.withCredentials?"include":"same-origin"}),a=this.mimeType,l=this.responseType;fetch(o).then(c=>{if(c.status===200||c.status===0){if(c.status===0&&console.warn("THREE.FileLoader: HTTP Status 0 received."),typeof ReadableStream>"u"||c.body===void 0||c.body.getReader===void 0)return c;const u=Ka[e],d=c.body.getReader(),f=c.headers.get("Content-Length")||c.headers.get("X-File-Size"),h=f?parseInt(f):0,p=h!==0;let x=0;const v=new ReadableStream({start(y){b();function b(){d.read().then(({done:S,value:w})=>{if(S)y.close();else{x+=w.byteLength;const E=new ProgressEvent("progress",{lengthComputable:p,loaded:x,total:h});for(let A=0,T=u.length;A<T;A++){const I=u[A];I.onProgress&&I.onProgress(E)}y.enqueue(w),b()}})}}});return new Response(v)}else throw new Ape(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)}).then(c=>{switch(l){case"arraybuffer":return c.arrayBuffer();case"blob":return c.blob();case"document":return c.text().then(u=>new DOMParser().parseFromString(u,a));case"json":return c.json();default:if(a===void 0)return c.text();{const d=/charset="?([^;"\s]*)"?/i.exec(a),f=d&&d[1]?d[1].toLowerCase():void 0,h=new TextDecoder(f);return c.arrayBuffer().then(p=>h.decode(p))}}}).then(c=>{ol.add(e,c);const u=Ka[e];delete Ka[e];for(let d=0,f=u.length;d<f;d++){const h=u[d];h.onLoad&&h.onLoad(c)}}).catch(c=>{const u=Ka[e];if(u===void 0)throw this.manager.itemError(e),c;delete Ka[e];for(let d=0,f=u.length;d<f;d++){const h=u[d];h.onError&&h.onError(c)}this.manager.itemError(e)}).finally(()=>{this.manager.itemEnd(e)}),this.manager.itemStart(e)}setResponseType(e){return this.responseType=e,this}setMimeType(e){return this.mimeType=e,this}}class Tpe extends _i{constructor(e){super(e)}load(e,n,r,i){const s=this,o=new Ns(this.manager);o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(a){try{n(s.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),s.manager.itemError(e)}},r,i)}parse(e){const n=[];for(let r=0;r<e.length;r++){const i=Xh.parse(e[r]);n.push(i)}return n}}class Mpe extends _i{constructor(e){super(e)}load(e,n,r,i){const s=this,o=[],a=new OS,l=new Ns(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(s.withCredentials);let c=0;function u(d){l.load(e[d],function(f){const h=s.parse(f,!0);o[d]={width:h.width,height:h.height,format:h.format,mipmaps:h.mipmaps},c+=1,c===6&&(h.mipmapCount===1&&(a.minFilter=or),a.image=o,a.format=h.format,a.needsUpdate=!0,n&&n(a))},r,i)}if(Array.isArray(e))for(let d=0,f=e.length;d<f;++d)u(d);else l.load(e,function(d){const f=s.parse(d,!0);if(f.isCubemap){const h=f.mipmaps.length/f.mipmapCount;for(let p=0;p<h;p++){o[p]={mipmaps:[]};for(let x=0;x<f.mipmapCount;x++)o[p].mipmaps.push(f.mipmaps[p*f.mipmapCount+x]),o[p].format=f.format,o[p].width=f.width,o[p].height=f.height}a.image=o}else a.image.width=f.width,a.image.height=f.height,a.mipmaps=f.mipmaps;f.mipmapCount===1&&(a.minFilter=or),a.format=f.format,a.needsUpdate=!0,n&&n(a)},r,i);return a}}class Jg extends _i{constructor(e){super(e)}load(e,n,r,i){this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=ol.get(e);if(o!==void 0)return s.manager.itemStart(e),setTimeout(function(){n&&n(o),s.manager.itemEnd(e)},0),o;const a=Vg("img");function l(){u(),ol.add(e,this),n&&n(this),s.manager.itemEnd(e)}function c(d){u(),i&&i(d),s.manager.itemError(e),s.manager.itemEnd(e)}function u(){a.removeEventListener("load",l,!1),a.removeEventListener("error",c,!1)}return a.addEventListener("load",l,!1),a.addEventListener("error",c,!1),e.slice(0,5)!=="data:"&&this.crossOrigin!==void 0&&(a.crossOrigin=this.crossOrigin),s.manager.itemStart(e),a.src=e,a}}class Rpe extends _i{constructor(e){super(e)}load(e,n,r,i){const s=new M0;s.colorSpace=xs;const o=new Jg(this.manager);o.setCrossOrigin(this.crossOrigin),o.setPath(this.path);let a=0;function l(c){o.load(e[c],function(u){s.images[c]=u,a++,a===6&&(s.needsUpdate=!0,n&&n(s))},void 0,i)}for(let c=0;c<e.length;++c)l(c);return s}}class Ipe extends _i{constructor(e){super(e)}load(e,n,r,i){const s=this,o=new bc,a=new Ns(this.manager);return a.setResponseType("arraybuffer"),a.setRequestHeader(this.requestHeader),a.setPath(this.path),a.setWithCredentials(s.withCredentials),a.load(e,function(l){let c;try{c=s.parse(l)}catch(u){if(i!==void 0)i(u);else{console.error(u);return}}c.image!==void 0?o.image=c.image:c.data!==void 0&&(o.image.width=c.width,o.image.height=c.height,o.image.data=c.data),o.wrapS=c.wrapS!==void 0?c.wrapS:ws,o.wrapT=c.wrapT!==void 0?c.wrapT:ws,o.magFilter=c.magFilter!==void 0?c.magFilter:or,o.minFilter=c.minFilter!==void 0?c.minFilter:or,o.anisotropy=c.anisotropy!==void 0?c.anisotropy:1,c.colorSpace!==void 0&&(o.colorSpace=c.colorSpace),c.flipY!==void 0&&(o.flipY=c.flipY),c.format!==void 0&&(o.format=c.format),c.type!==void 0&&(o.type=c.type),c.mipmaps!==void 0&&(o.mipmaps=c.mipmaps,o.minFilter=ao),c.mipmapCount===1&&(o.minFilter=or),c.generateMipmaps!==void 0&&(o.generateMipmaps=c.generateMipmaps),o.needsUpdate=!0,n&&n(o,c)},r,i),o}}class QR extends _i{constructor(e){super(e)}load(e,n,r,i){const s=new Bn,o=new Jg(this.manager);return o.setCrossOrigin(this.crossOrigin),o.setPath(this.path),o.load(e,function(a){s.image=a,s.needsUpdate=!0,n!==void 0&&n(s)},r,i),s}}class $c extends Zt{constructor(e,n=1){super(),this.isLight=!0,this.type="Light",this.color=new Qe(e),this.intensity=n}dispose(){}copy(e,n){return super.copy(e,n),this.color.copy(e.color),this.intensity=e.intensity,this}toJSON(e){const n=super.toJSON(e);return n.object.color=this.color.getHex(),n.object.intensity=this.intensity,this.groundColor!==void 0&&(n.object.groundColor=this.groundColor.getHex()),this.distance!==void 0&&(n.object.distance=this.distance),this.angle!==void 0&&(n.object.angle=this.angle),this.decay!==void 0&&(n.object.decay=this.decay),this.penumbra!==void 0&&(n.object.penumbra=this.penumbra),this.shadow!==void 0&&(n.object.shadow=this.shadow.toJSON()),n}}class f6 extends $c{constructor(e,n,r){super(e,r),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Zt.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Qe(n)}copy(e,n){return super.copy(e,n),this.groundColor.copy(e.groundColor),this}}const oE=new St,VO=new K,WO=new K;class ZR{constructor(e){this.camera=e,this.bias=0,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Re(512,512),this.map=null,this.mapPass=null,this.matrix=new St,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new R0,this._frameExtents=new Re(1,1),this._viewportCount=1,this._viewports=[new vn(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(e){const n=this.camera,r=this.matrix;VO.setFromMatrixPosition(e.matrixWorld),n.position.copy(VO),WO.setFromMatrixPosition(e.target.matrixWorld),n.lookAt(WO),n.updateMatrixWorld(),oE.multiplyMatrices(n.projectionMatrix,n.matrixWorldInverse),this._frustum.setFromProjectionMatrix(oE),r.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),r.multiply(oE)}getViewport(e){return this._viewports[e]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(e){return this.camera=e.camera.clone(),this.bias=e.bias,this.radius=e.radius,this.mapSize.copy(e.mapSize),this}clone(){return new this.constructor().copy(this)}toJSON(){const e={};return this.bias!==0&&(e.bias=this.bias),this.normalBias!==0&&(e.normalBias=this.normalBias),this.radius!==1&&(e.radius=this.radius),(this.mapSize.x!==512||this.mapSize.y!==512)&&(e.mapSize=this.mapSize.toArray()),e.camera=this.camera.toJSON(!1).object,delete e.camera.matrix,e}}class Npe extends ZR{constructor(){super(new Hn(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1}updateMatrices(e){const n=this.camera,r=Gh*2*e.angle*this.focus,i=this.mapSize.width/this.mapSize.height,s=e.distance||n.far;(r!==n.fov||i!==n.aspect||s!==n.far)&&(n.fov=r,n.aspect=i,n.far=s,n.updateProjectionMatrix()),super.updateMatrices(e)}copy(e){return super.copy(e),this.focus=e.focus,this}}class eI extends $c{constructor(e,n,r=0,i=Math.PI/3,s=0,o=2){super(e,n),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Zt.DEFAULT_UP),this.updateMatrix(),this.target=new Zt,this.distance=r,this.angle=i,this.penumbra=s,this.decay=o,this.map=null,this.shadow=new Npe}get power(){return this.intensity*Math.PI}set power(e){this.intensity=e/Math.PI}dispose(){this.shadow.dispose()}copy(e,n){return super.copy(e,n),this.distance=e.distance,this.angle=e.angle,this.penumbra=e.penumbra,this.decay=e.decay,this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}const jO=new St,Tm=new K,aE=new K;class Ppe extends ZR{constructor(){super(new Hn(90,1,.5,500)),this.isPointLightShadow=!0,this._frameExtents=new Re(4,2),this._viewportCount=6,this._viewports=[new vn(2,1,1,1),new vn(0,1,1,1),new vn(3,1,1,1),new vn(1,1,1,1),new vn(3,0,1,1),new vn(1,0,1,1)],this._cubeDirections=[new K(1,0,0),new K(-1,0,0),new K(0,0,1),new K(0,0,-1),new K(0,1,0),new K(0,-1,0)],this._cubeUps=[new K(0,1,0),new K(0,1,0),new K(0,1,0),new K(0,1,0),new K(0,0,1),new K(0,0,-1)]}updateMatrices(e,n=0){const r=this.camera,i=this.matrix,s=e.distance||r.far;s!==r.far&&(r.far=s,r.updateProjectionMatrix()),Tm.setFromMatrixPosition(e.matrixWorld),r.position.copy(Tm),aE.copy(r.position),aE.add(this._cubeDirections[n]),r.up.copy(this._cubeUps[n]),r.lookAt(aE),r.updateMatrixWorld(),i.makeTranslation(-Tm.x,-Tm.y,-Tm.z),jO.multiplyMatrices(r.projectionMatrix,r.matrixWorldInverse),this._frustum.setFromProjectionMatrix(jO)}}class tI extends $c{constructor(e,n,r=0,i=2){super(e,n),this.isPointLight=!0,this.type="PointLight",this.distance=r,this.decay=i,this.shadow=new Ppe}get power(){return this.intensity*4*Math.PI}set power(e){this.intensity=e/(4*Math.PI)}dispose(){this.shadow.dispose()}copy(e,n){return super.copy(e,n),this.distance=e.distance,this.decay=e.decay,this.shadow=e.shadow.clone(),this}}class kpe extends ZR{constructor(){super(new ba(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class nI extends $c{constructor(e,n){super(e,n),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Zt.DEFAULT_UP),this.updateMatrix(),this.target=new Zt,this.shadow=new kpe}dispose(){this.shadow.dispose()}copy(e){return super.copy(e),this.target=e.target.clone(),this.shadow=e.shadow.clone(),this}}class h6 extends $c{constructor(e,n){super(e,n),this.isAmbientLight=!0,this.type="AmbientLight"}}class p6 extends $c{constructor(e,n,r=10,i=10){super(e,n),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=r,this.height=i}get power(){return this.intensity*this.width*this.height*Math.PI}set power(e){this.intensity=e/(this.width*this.height*Math.PI)}copy(e){return super.copy(e),this.width=e.width,this.height=e.height,this}toJSON(e){const n=super.toJSON(e);return n.object.width=this.width,n.object.height=this.height,n}}class m6{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let e=0;e<9;e++)this.coefficients.push(new K)}set(e){for(let n=0;n<9;n++)this.coefficients[n].copy(e[n]);return this}zero(){for(let e=0;e<9;e++)this.coefficients[e].set(0,0,0);return this}getAt(e,n){const r=e.x,i=e.y,s=e.z,o=this.coefficients;return n.copy(o[0]).multiplyScalar(.282095),n.addScaledVector(o[1],.488603*i),n.addScaledVector(o[2],.488603*s),n.addScaledVector(o[3],.488603*r),n.addScaledVector(o[4],1.092548*(r*i)),n.addScaledVector(o[5],1.092548*(i*s)),n.addScaledVector(o[6],.315392*(3*s*s-1)),n.addScaledVector(o[7],1.092548*(r*s)),n.addScaledVector(o[8],.546274*(r*r-i*i)),n}getIrradianceAt(e,n){const r=e.x,i=e.y,s=e.z,o=this.coefficients;return n.copy(o[0]).multiplyScalar(.886227),n.addScaledVector(o[1],2*.511664*i),n.addScaledVector(o[2],2*.511664*s),n.addScaledVector(o[3],2*.511664*r),n.addScaledVector(o[4],2*.429043*r*i),n.addScaledVector(o[5],2*.429043*i*s),n.addScaledVector(o[6],.743125*s*s-.247708),n.addScaledVector(o[7],2*.429043*r*s),n.addScaledVector(o[8],.429043*(r*r-i*i)),n}add(e){for(let n=0;n<9;n++)this.coefficients[n].add(e.coefficients[n]);return this}addScaledSH(e,n){for(let r=0;r<9;r++)this.coefficients[r].addScaledVector(e.coefficients[r],n);return this}scale(e){for(let n=0;n<9;n++)this.coefficients[n].multiplyScalar(e);return this}lerp(e,n){for(let r=0;r<9;r++)this.coefficients[r].lerp(e.coefficients[r],n);return this}equals(e){for(let n=0;n<9;n++)if(!this.coefficients[n].equals(e.coefficients[n]))return!1;return!0}copy(e){return this.set(e.coefficients)}clone(){return new this.constructor().copy(this)}fromArray(e,n=0){const r=this.coefficients;for(let i=0;i<9;i++)r[i].fromArray(e,n+i*3);return this}toArray(e=[],n=0){const r=this.coefficients;for(let i=0;i<9;i++)r[i].toArray(e,n+i*3);return e}static getBasisAt(e,n){const r=e.x,i=e.y,s=e.z;n[0]=.282095,n[1]=.488603*i,n[2]=.488603*s,n[3]=.488603*r,n[4]=1.092548*r*i,n[5]=1.092548*i*s,n[6]=.315392*(3*s*s-1),n[7]=1.092548*r*s,n[8]=.546274*(r*r-i*i)}}class g6 extends $c{constructor(e=new m6,n=1){super(void 0,n),this.isLightProbe=!0,this.sh=e}copy(e){return super.copy(e),this.sh.copy(e.sh),this}fromJSON(e){return this.intensity=e.intensity,this.sh.fromArray(e.sh),this}toJSON(e){const n=super.toJSON(e);return n.object.sh=this.sh.toArray(),n}}class JS extends _i{constructor(e){super(e),this.textures={}}load(e,n,r,i){const s=this,o=new Ns(s.manager);o.setPath(s.path),o.setRequestHeader(s.requestHeader),o.setWithCredentials(s.withCredentials),o.load(e,function(a){try{n(s.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),s.manager.itemError(e)}},r,i)}parse(e){const n=this.textures;function r(s){return n[s]===void 0&&console.warn("THREE.MaterialLoader: Undefined texture",s),n[s]}const i=JS.createMaterialFromType(e.type);if(e.uuid!==void 0&&(i.uuid=e.uuid),e.name!==void 0&&(i.name=e.name),e.color!==void 0&&i.color!==void 0&&i.color.setHex(e.color),e.roughness!==void 0&&(i.roughness=e.roughness),e.metalness!==void 0&&(i.metalness=e.metalness),e.sheen!==void 0&&(i.sheen=e.sheen),e.sheenColor!==void 0&&(i.sheenColor=new Qe().setHex(e.sheenColor)),e.sheenRoughness!==void 0&&(i.sheenRoughness=e.sheenRoughness),e.emissive!==void 0&&i.emissive!==void 0&&i.emissive.setHex(e.emissive),e.specular!==void 0&&i.specular!==void 0&&i.specular.setHex(e.specular),e.specularIntensity!==void 0&&(i.specularIntensity=e.specularIntensity),e.specularColor!==void 0&&i.specularColor!==void 0&&i.specularColor.setHex(e.specularColor),e.shininess!==void 0&&(i.shininess=e.shininess),e.clearcoat!==void 0&&(i.clearcoat=e.clearcoat),e.clearcoatRoughness!==void 0&&(i.clearcoatRoughness=e.clearcoatRoughness),e.iridescence!==void 0&&(i.iridescence=e.iridescence),e.iridescenceIOR!==void 0&&(i.iridescenceIOR=e.iridescenceIOR),e.iridescenceThicknessRange!==void 0&&(i.iridescenceThicknessRange=e.iridescenceThicknessRange),e.transmission!==void 0&&(i.transmission=e.transmission),e.thickness!==void 0&&(i.thickness=e.thickness),e.attenuationDistance!==void 0&&(i.attenuationDistance=e.attenuationDistance),e.attenuationColor!==void 0&&i.attenuationColor!==void 0&&i.attenuationColor.setHex(e.attenuationColor),e.anisotropy!==void 0&&(i.anisotropy=e.anisotropy),e.anisotropyRotation!==void 0&&(i.anisotropyRotation=e.anisotropyRotation),e.fog!==void 0&&(i.fog=e.fog),e.flatShading!==void 0&&(i.flatShading=e.flatShading),e.blending!==void 0&&(i.blending=e.blending),e.combine!==void 0&&(i.combine=e.combine),e.side!==void 0&&(i.side=e.side),e.shadowSide!==void 0&&(i.shadowSide=e.shadowSide),e.opacity!==void 0&&(i.opacity=e.opacity),e.transparent!==void 0&&(i.transparent=e.transparent),e.alphaTest!==void 0&&(i.alphaTest=e.alphaTest),e.alphaHash!==void 0&&(i.alphaHash=e.alphaHash),e.depthFunc!==void 0&&(i.depthFunc=e.depthFunc),e.depthTest!==void 0&&(i.depthTest=e.depthTest),e.depthWrite!==void 0&&(i.depthWrite=e.depthWrite),e.colorWrite!==void 0&&(i.colorWrite=e.colorWrite),e.blendSrc!==void 0&&(i.blendSrc=e.blendSrc),e.blendDst!==void 0&&(i.blendDst=e.blendDst),e.blendEquation!==void 0&&(i.blendEquation=e.blendEquation),e.blendSrcAlpha!==void 0&&(i.blendSrcAlpha=e.blendSrcAlpha),e.blendDstAlpha!==void 0&&(i.blendDstAlpha=e.blendDstAlpha),e.blendEquationAlpha!==void 0&&(i.blendEquationAlpha=e.blendEquationAlpha),e.blendColor!==void 0&&i.blendColor!==void 0&&i.blendColor.setHex(e.blendColor),e.blendAlpha!==void 0&&(i.blendAlpha=e.blendAlpha),e.stencilWriteMask!==void 0&&(i.stencilWriteMask=e.stencilWriteMask),e.stencilFunc!==void 0&&(i.stencilFunc=e.stencilFunc),e.stencilRef!==void 0&&(i.stencilRef=e.stencilRef),e.stencilFuncMask!==void 0&&(i.stencilFuncMask=e.stencilFuncMask),e.stencilFail!==void 0&&(i.stencilFail=e.stencilFail),e.stencilZFail!==void 0&&(i.stencilZFail=e.stencilZFail),e.stencilZPass!==void 0&&(i.stencilZPass=e.stencilZPass),e.stencilWrite!==void 0&&(i.stencilWrite=e.stencilWrite),e.wireframe!==void 0&&(i.wireframe=e.wireframe),e.wireframeLinewidth!==void 0&&(i.wireframeLinewidth=e.wireframeLinewidth),e.wireframeLinecap!==void 0&&(i.wireframeLinecap=e.wireframeLinecap),e.wireframeLinejoin!==void 0&&(i.wireframeLinejoin=e.wireframeLinejoin),e.rotation!==void 0&&(i.rotation=e.rotation),e.linewidth!==void 0&&(i.linewidth=e.linewidth),e.dashSize!==void 0&&(i.dashSize=e.dashSize),e.gapSize!==void 0&&(i.gapSize=e.gapSize),e.scale!==void 0&&(i.scale=e.scale),e.polygonOffset!==void 0&&(i.polygonOffset=e.polygonOffset),e.polygonOffsetFactor!==void 0&&(i.polygonOffsetFactor=e.polygonOffsetFactor),e.polygonOffsetUnits!==void 0&&(i.polygonOffsetUnits=e.polygonOffsetUnits),e.dithering!==void 0&&(i.dithering=e.dithering),e.alphaToCoverage!==void 0&&(i.alphaToCoverage=e.alphaToCoverage),e.premultipliedAlpha!==void 0&&(i.premultipliedAlpha=e.premultipliedAlpha),e.forceSinglePass!==void 0&&(i.forceSinglePass=e.forceSinglePass),e.visible!==void 0&&(i.visible=e.visible),e.toneMapped!==void 0&&(i.toneMapped=e.toneMapped),e.userData!==void 0&&(i.userData=e.userData),e.vertexColors!==void 0&&(typeof e.vertexColors=="number"?i.vertexColors=e.vertexColors>0:i.vertexColors=e.vertexColors),e.uniforms!==void 0)for(const s in e.uniforms){const o=e.uniforms[s];switch(i.uniforms[s]={},o.type){case"t":i.uniforms[s].value=r(o.value);break;case"c":i.uniforms[s].value=new Qe().setHex(o.value);break;case"v2":i.uniforms[s].value=new Re().fromArray(o.value);break;case"v3":i.uniforms[s].value=new K().fromArray(o.value);break;case"v4":i.uniforms[s].value=new vn().fromArray(o.value);break;case"m3":i.uniforms[s].value=new $t().fromArray(o.value);break;case"m4":i.uniforms[s].value=new St().fromArray(o.value);break;default:i.uniforms[s].value=o.value}}if(e.defines!==void 0&&(i.defines=e.defines),e.vertexShader!==void 0&&(i.vertexShader=e.vertexShader),e.fragmentShader!==void 0&&(i.fragmentShader=e.fragmentShader),e.glslVersion!==void 0&&(i.glslVersion=e.glslVersion),e.extensions!==void 0)for(const s in e.extensions)i.extensions[s]=e.extensions[s];if(e.lights!==void 0&&(i.lights=e.lights),e.clipping!==void 0&&(i.clipping=e.clipping),e.size!==void 0&&(i.size=e.size),e.sizeAttenuation!==void 0&&(i.sizeAttenuation=e.sizeAttenuation),e.map!==void 0&&(i.map=r(e.map)),e.matcap!==void 0&&(i.matcap=r(e.matcap)),e.alphaMap!==void 0&&(i.alphaMap=r(e.alphaMap)),e.bumpMap!==void 0&&(i.bumpMap=r(e.bumpMap)),e.bumpScale!==void 0&&(i.bumpScale=e.bumpScale),e.normalMap!==void 0&&(i.normalMap=r(e.normalMap)),e.normalMapType!==void 0&&(i.normalMapType=e.normalMapType),e.normalScale!==void 0){let s=e.normalScale;Array.isArray(s)===!1&&(s=[s,s]),i.normalScale=new Re().fromArray(s)}return e.displacementMap!==void 0&&(i.displacementMap=r(e.displacementMap)),e.displacementScale!==void 0&&(i.displacementScale=e.displacementScale),e.displacementBias!==void 0&&(i.displacementBias=e.displacementBias),e.roughnessMap!==void 0&&(i.roughnessMap=r(e.roughnessMap)),e.metalnessMap!==void 0&&(i.metalnessMap=r(e.metalnessMap)),e.emissiveMap!==void 0&&(i.emissiveMap=r(e.emissiveMap)),e.emissiveIntensity!==void 0&&(i.emissiveIntensity=e.emissiveIntensity),e.specularMap!==void 0&&(i.specularMap=r(e.specularMap)),e.specularIntensityMap!==void 0&&(i.specularIntensityMap=r(e.specularIntensityMap)),e.specularColorMap!==void 0&&(i.specularColorMap=r(e.specularColorMap)),e.envMap!==void 0&&(i.envMap=r(e.envMap)),e.envMapRotation!==void 0&&i.envMapRotation.fromArray(e.envMapRotation),e.envMapIntensity!==void 0&&(i.envMapIntensity=e.envMapIntensity),e.reflectivity!==void 0&&(i.reflectivity=e.reflectivity),e.refractionRatio!==void 0&&(i.refractionRatio=e.refractionRatio),e.lightMap!==void 0&&(i.lightMap=r(e.lightMap)),e.lightMapIntensity!==void 0&&(i.lightMapIntensity=e.lightMapIntensity),e.aoMap!==void 0&&(i.aoMap=r(e.aoMap)),e.aoMapIntensity!==void 0&&(i.aoMapIntensity=e.aoMapIntensity),e.gradientMap!==void 0&&(i.gradientMap=r(e.gradientMap)),e.clearcoatMap!==void 0&&(i.clearcoatMap=r(e.clearcoatMap)),e.clearcoatRoughnessMap!==void 0&&(i.clearcoatRoughnessMap=r(e.clearcoatRoughnessMap)),e.clearcoatNormalMap!==void 0&&(i.clearcoatNormalMap=r(e.clearcoatNormalMap)),e.clearcoatNormalScale!==void 0&&(i.clearcoatNormalScale=new Re().fromArray(e.clearcoatNormalScale)),e.iridescenceMap!==void 0&&(i.iridescenceMap=r(e.iridescenceMap)),e.iridescenceThicknessMap!==void 0&&(i.iridescenceThicknessMap=r(e.iridescenceThicknessMap)),e.transmissionMap!==void 0&&(i.transmissionMap=r(e.transmissionMap)),e.thicknessMap!==void 0&&(i.thicknessMap=r(e.thicknessMap)),e.anisotropyMap!==void 0&&(i.anisotropyMap=r(e.anisotropyMap)),e.sheenColorMap!==void 0&&(i.sheenColorMap=r(e.sheenColorMap)),e.sheenRoughnessMap!==void 0&&(i.sheenRoughnessMap=r(e.sheenRoughnessMap)),i}setTextures(e){return this.textures=e,this}static createMaterialFromType(e){const n={ShadowMaterial:Q5,SpriteMaterial:BR,RawShaderMaterial:Z5,ShaderMaterial:Ko,PointsMaterial:DS,MeshPhysicalMaterial:Da,MeshStandardMaterial:O0,MeshPhongMaterial:e6,MeshToonMaterial:t6,MeshNormalMaterial:n6,MeshLambertMaterial:r6,MeshDepthMaterial:DR,MeshDistanceMaterial:OR,MeshBasicMaterial:Qi,MeshMatcapMaterial:i6,LineDashedMaterial:s6,LineBasicMaterial:Si,Material:wr};return new n[e]}}class Ta{static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let n="";for(let r=0,i=e.length;r<i;r++)n+=String.fromCharCode(e[r]);try{return decodeURIComponent(escape(n))}catch{return n}}static extractUrlBase(e){const n=e.lastIndexOf("/");return n===-1?"./":e.slice(0,n+1)}static resolveURL(e,n){return typeof e!="string"||e===""?"":(/^https?:\/\//i.test(n)&&/^\//.test(e)&&(n=n.replace(/(^https?:\/\/[^\/]+).*/i,"$1")),/^(https?:)?\/\//i.test(e)||/^data:.*,.*$/i.test(e)||/^blob:.*$/i.test(e)?e:n+e)}}class y6 extends Lt{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=1/0}copy(e){return super.copy(e),this.instanceCount=e.instanceCount,this}toJSON(){const e=super.toJSON();return e.instanceCount=this.instanceCount,e.isInstancedBufferGeometry=!0,e}}class v6 extends _i{constructor(e){super(e)}load(e,n,r,i){const s=this,o=new Ns(s.manager);o.setPath(s.path),o.setRequestHeader(s.requestHeader),o.setWithCredentials(s.withCredentials),o.load(e,function(a){try{n(s.parse(JSON.parse(a)))}catch(l){i?i(l):console.error(l),s.manager.itemError(e)}},r,i)}parse(e){const n={},r={};function i(h,p){if(n[p]!==void 0)return n[p];const v=h.interleavedBuffers[p],y=s(h,v.buffer),b=oh(v.type,y),S=new I0(b,v.stride);return S.uuid=v.uuid,n[p]=S,S}function s(h,p){if(r[p]!==void 0)return r[p];const v=h.arrayBuffers[p],y=new Uint32Array(v).buffer;return r[p]=y,y}const o=e.isInstancedBufferGeometry?new y6:new Lt,a=e.data.index;if(a!==void 0){const h=oh(a.type,a.array);o.setIndex(new en(h,1))}const l=e.data.attributes;for(const h in l){const p=l[h];let x;if(p.isInterleavedBufferAttribute){const v=i(e.data,p.data);x=new Mc(v,p.itemSize,p.offset,p.normalized)}else{const v=oh(p.type,p.array),y=p.isInstancedBufferAttribute?Vh:en;x=new y(v,p.itemSize,p.normalized)}p.name!==void 0&&(x.name=p.name),p.usage!==void 0&&x.setUsage(p.usage),o.setAttribute(h,x)}const c=e.data.morphAttributes;if(c)for(const h in c){const p=c[h],x=[];for(let v=0,y=p.length;v<y;v++){const b=p[v];let S;if(b.isInterleavedBufferAttribute){const w=i(e.data,b.data);S=new Mc(w,b.itemSize,b.offset,b.normalized)}else{const w=oh(b.type,b.array);S=new en(w,b.itemSize,b.normalized)}b.name!==void 0&&(S.name=b.name),x.push(S)}o.morphAttributes[h]=x}e.data.morphTargetsRelative&&(o.morphTargetsRelative=!0);const d=e.data.groups||e.data.drawcalls||e.data.offsets;if(d!==void 0)for(let h=0,p=d.length;h!==p;++h){const x=d[h];o.addGroup(x.start,x.count,x.materialIndex)}const f=e.data.boundingSphere;if(f!==void 0){const h=new K;f.center!==void 0&&h.fromArray(f.center),o.boundingSphere=new Zr(h,f.radius)}return e.name&&(o.name=e.name),e.userData&&(o.userData=e.userData),o}}class Dpe extends _i{constructor(e){super(e)}load(e,n,r,i){const s=this,o=this.path===""?Ta.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||o;const a=new Ns(this.manager);a.setPath(this.path),a.setRequestHeader(this.requestHeader),a.setWithCredentials(this.withCredentials),a.load(e,function(l){let c=null;try{c=JSON.parse(l)}catch(d){i!==void 0&&i(d),console.error("THREE:ObjectLoader: Can't parse "+e+".",d.message);return}const u=c.metadata;if(u===void 0||u.type===void 0||u.type.toLowerCase()==="geometry"){i!==void 0&&i(new Error("THREE.ObjectLoader: Can't load "+e)),console.error("THREE.ObjectLoader: Can't load "+e);return}s.parse(c,n)},r,i)}async loadAsync(e,n){const r=this,i=this.path===""?Ta.extractUrlBase(e):this.path;this.resourcePath=this.resourcePath||i;const s=new Ns(this.manager);s.setPath(this.path),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials);const o=await s.loadAsync(e,n),a=JSON.parse(o),l=a.metadata;if(l===void 0||l.type===void 0||l.type.toLowerCase()==="geometry")throw new Error("THREE.ObjectLoader: Can't load "+e);return await r.parseAsync(a)}parse(e,n){const r=this.parseAnimations(e.animations),i=this.parseShapes(e.shapes),s=this.parseGeometries(e.geometries,i),o=this.parseImages(e.images,function(){n!==void 0&&n(c)}),a=this.parseTextures(e.textures,o),l=this.parseMaterials(e.materials,a),c=this.parseObject(e.object,s,l,a,r),u=this.parseSkeletons(e.skeletons,c);if(this.bindSkeletons(c,u),n!==void 0){let d=!1;for(const f in o)if(o[f].data instanceof HTMLImageElement){d=!0;break}d===!1&&n(c)}return c}async parseAsync(e){const n=this.parseAnimations(e.animations),r=this.parseShapes(e.shapes),i=this.parseGeometries(e.geometries,r),s=await this.parseImagesAsync(e.images),o=this.parseTextures(e.textures,s),a=this.parseMaterials(e.materials,o),l=this.parseObject(e.object,i,a,o,n),c=this.parseSkeletons(e.skeletons,l);return this.bindSkeletons(l,c),l}parseShapes(e){const n={};if(e!==void 0)for(let r=0,i=e.length;r<i;r++){const s=new Zu().fromJSON(e[r]);n[s.uuid]=s}return n}parseSkeletons(e,n){const r={},i={};if(n.traverse(function(s){s.isBone&&(i[s.uuid]=s)}),e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=new N0().fromJSON(e[s],i);r[a.uuid]=a}return r}parseGeometries(e,n){const r={};if(e!==void 0){const i=new v6;for(let s=0,o=e.length;s<o;s++){let a;const l=e[s];switch(l.type){case"BufferGeometry":case"InstancedBufferGeometry":a=i.parse(l);break;default:l.type in HO?a=HO[l.type].fromJSON(l,n):console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)}a.uuid=l.uuid,l.name!==void 0&&(a.name=l.name),l.userData!==void 0&&(a.userData=l.userData),r[l.uuid]=a}}return r}parseMaterials(e,n){const r={},i={};if(e!==void 0){const s=new JS;s.setTextures(n);for(let o=0,a=e.length;o<a;o++){const l=e[o];r[l.uuid]===void 0&&(r[l.uuid]=s.parse(l)),i[l.uuid]=r[l.uuid]}}return i}parseAnimations(e){const n={};if(e!==void 0)for(let r=0;r<e.length;r++){const i=e[r],s=Xh.parse(i);n[s.uuid]=s}return n}parseImages(e,n){const r=this,i={};let s;function o(l){return r.manager.itemStart(l),s.load(l,function(){r.manager.itemEnd(l)},void 0,function(){r.manager.itemError(l),r.manager.itemEnd(l)})}function a(l){if(typeof l=="string"){const c=l,u=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(c)?c:r.resourcePath+c;return o(u)}else return l.data?{data:oh(l.type,l.data),width:l.width,height:l.height}:null}if(e!==void 0&&e.length>0){const l=new YR(n);s=new Jg(l),s.setCrossOrigin(this.crossOrigin);for(let c=0,u=e.length;c<u;c++){const d=e[c],f=d.url;if(Array.isArray(f)){const h=[];for(let p=0,x=f.length;p<x;p++){const v=f[p],y=a(v);y!==null&&(y instanceof HTMLImageElement?h.push(y):h.push(new bc(y.data,y.width,y.height)))}i[d.uuid]=new Bu(h)}else{const h=a(d.url);i[d.uuid]=new Bu(h)}}}return i}async parseImagesAsync(e){const n=this,r={};let i;async function s(o){if(typeof o=="string"){const a=o,l=/^(\/\/)|([a-z]+:(\/\/)?)/i.test(a)?a:n.resourcePath+a;return await i.loadAsync(l)}else return o.data?{data:oh(o.type,o.data),width:o.width,height:o.height}:null}if(e!==void 0&&e.length>0){i=new Jg(this.manager),i.setCrossOrigin(this.crossOrigin);for(let o=0,a=e.length;o<a;o++){const l=e[o],c=l.url;if(Array.isArray(c)){const u=[];for(let d=0,f=c.length;d<f;d++){const h=c[d],p=await s(h);p!==null&&(p instanceof HTMLImageElement?u.push(p):u.push(new bc(p.data,p.width,p.height)))}r[l.uuid]=new Bu(u)}else{const u=await s(l.url);r[l.uuid]=new Bu(u)}}}return r}parseTextures(e,n){function r(s,o){return typeof s=="number"?s:(console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.",s),o[s])}const i={};if(e!==void 0)for(let s=0,o=e.length;s<o;s++){const a=e[s];a.image===void 0&&console.warn('THREE.ObjectLoader: No "image" specified for',a.uuid),n[a.image]===void 0&&console.warn("THREE.ObjectLoader: Undefined image",a.image);const l=n[a.image],c=l.data;let u;Array.isArray(c)?(u=new M0,c.length===6&&(u.needsUpdate=!0)):(c&&c.data?u=new bc:u=new Bn,c&&(u.needsUpdate=!0)),u.source=l,u.uuid=a.uuid,a.name!==void 0&&(u.name=a.name),a.mapping!==void 0&&(u.mapping=r(a.mapping,Ope)),a.channel!==void 0&&(u.channel=a.channel),a.offset!==void 0&&u.offset.fromArray(a.offset),a.repeat!==void 0&&u.repeat.fromArray(a.repeat),a.center!==void 0&&u.center.fromArray(a.center),a.rotation!==void 0&&(u.rotation=a.rotation),a.wrap!==void 0&&(u.wrapS=r(a.wrap[0],XO),u.wrapT=r(a.wrap[1],XO)),a.format!==void 0&&(u.format=a.format),a.internalFormat!==void 0&&(u.internalFormat=a.internalFormat),a.type!==void 0&&(u.type=a.type),a.colorSpace!==void 0&&(u.colorSpace=a.colorSpace),a.minFilter!==void 0&&(u.minFilter=r(a.minFilter,KO)),a.magFilter!==void 0&&(u.magFilter=r(a.magFilter,KO)),a.anisotropy!==void 0&&(u.anisotropy=a.anisotropy),a.flipY!==void 0&&(u.flipY=a.flipY),a.generateMipmaps!==void 0&&(u.generateMipmaps=a.generateMipmaps),a.premultiplyAlpha!==void 0&&(u.premultiplyAlpha=a.premultiplyAlpha),a.unpackAlignment!==void 0&&(u.unpackAlignment=a.unpackAlignment),a.compareFunction!==void 0&&(u.compareFunction=a.compareFunction),a.userData!==void 0&&(u.userData=a.userData),i[a.uuid]=u}return i}parseObject(e,n,r,i,s){let o;function a(f){return n[f]===void 0&&console.warn("THREE.ObjectLoader: Undefined geometry",f),n[f]}function l(f){if(f!==void 0){if(Array.isArray(f)){const h=[];for(let p=0,x=f.length;p<x;p++){const v=f[p];r[v]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",v),h.push(r[v])}return h}return r[f]===void 0&&console.warn("THREE.ObjectLoader: Undefined material",f),r[f]}}function c(f){return i[f]===void 0&&console.warn("THREE.ObjectLoader: Undefined texture",f),i[f]}let u,d;switch(e.type){case"Scene":o=new Wg,e.background!==void 0&&(Number.isInteger(e.background)?o.background=new Qe(e.background):o.background=c(e.background)),e.environment!==void 0&&(o.environment=c(e.environment)),e.fog!==void 0&&(e.fog.type==="Fog"?o.fog=new PS(e.fog.color,e.fog.near,e.fog.far):e.fog.type==="FogExp2"&&(o.fog=new NS(e.fog.color,e.fog.density)),e.fog.name!==""&&(o.fog.name=e.fog.name)),e.backgroundBlurriness!==void 0&&(o.backgroundBlurriness=e.backgroundBlurriness),e.backgroundIntensity!==void 0&&(o.backgroundIntensity=e.backgroundIntensity),e.backgroundRotation!==void 0&&o.backgroundRotation.fromArray(e.backgroundRotation),e.environmentIntensity!==void 0&&(o.environmentIntensity=e.environmentIntensity),e.environmentRotation!==void 0&&o.environmentRotation.fromArray(e.environmentRotation);break;case"PerspectiveCamera":o=new Hn(e.fov,e.aspect,e.near,e.far),e.focus!==void 0&&(o.focus=e.focus),e.zoom!==void 0&&(o.zoom=e.zoom),e.filmGauge!==void 0&&(o.filmGauge=e.filmGauge),e.filmOffset!==void 0&&(o.filmOffset=e.filmOffset),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"OrthographicCamera":o=new ba(e.left,e.right,e.top,e.bottom,e.near,e.far),e.zoom!==void 0&&(o.zoom=e.zoom),e.view!==void 0&&(o.view=Object.assign({},e.view));break;case"AmbientLight":o=new h6(e.color,e.intensity);break;case"DirectionalLight":o=new nI(e.color,e.intensity);break;case"PointLight":o=new tI(e.color,e.intensity,e.distance,e.decay);break;case"RectAreaLight":o=new p6(e.color,e.intensity,e.width,e.height);break;case"SpotLight":o=new eI(e.color,e.intensity,e.distance,e.angle,e.penumbra,e.decay);break;case"HemisphereLight":o=new f6(e.color,e.groundColor,e.intensity);break;case"LightProbe":o=new g6().fromJSON(e);break;case"SkinnedMesh":u=a(e.geometry),d=l(e.material),o=new FR(u,d),e.bindMode!==void 0&&(o.bindMode=e.bindMode),e.bindMatrix!==void 0&&o.bindMatrix.fromArray(e.bindMatrix),e.skeleton!==void 0&&(o.skeleton=e.skeleton);break;case"Mesh":u=a(e.geometry),d=l(e.material),o=new lr(u,d);break;case"InstancedMesh":u=a(e.geometry),d=l(e.material);const f=e.count,h=e.instanceMatrix,p=e.instanceColor;o=new $R(u,d,f),o.instanceMatrix=new Vh(new Float32Array(h.array),16),p!==void 0&&(o.instanceColor=new Vh(new Float32Array(p.array),p.itemSize));break;case"BatchedMesh":u=a(e.geometry),d=l(e.material),o=new z5(e.maxGeometryCount,e.maxVertexCount,e.maxIndexCount,d),o.geometry=u,o.perObjectFrustumCulled=e.perObjectFrustumCulled,o.sortObjects=e.sortObjects,o._drawRanges=e.drawRanges,o._reservedRanges=e.reservedRanges,o._visibility=e.visibility,o._active=e.active,o._bounds=e.bounds.map(x=>{const v=new vi;v.min.fromArray(x.boxMin),v.max.fromArray(x.boxMax);const y=new Zr;return y.radius=x.sphereRadius,y.center.fromArray(x.sphereCenter),{boxInitialized:x.boxInitialized,box:v,sphereInitialized:x.sphereInitialized,sphere:y}}),o._maxGeometryCount=e.maxGeometryCount,o._maxVertexCount=e.maxVertexCount,o._maxIndexCount=e.maxIndexCount,o._geometryInitialized=e.geometryInitialized,o._geometryCount=e.geometryCount,o._matricesTexture=c(e.matricesTexture.uuid);break;case"LOD":o=new U5;break;case"Line":o=new bl(a(e.geometry),l(e.material));break;case"LineLoop":o=new UR(a(e.geometry),l(e.material));break;case"LineSegments":o=new Yo(a(e.geometry),l(e.material));break;case"PointCloud":case"Points":o=new zR(a(e.geometry),l(e.material));break;case"Sprite":o=new $5(l(e.material));break;case"Group":o=new Ho;break;case"Bone":o=new kS;break;default:o=new Zt}if(o.uuid=e.uuid,e.name!==void 0&&(o.name=e.name),e.matrix!==void 0?(o.matrix.fromArray(e.matrix),e.matrixAutoUpdate!==void 0&&(o.matrixAutoUpdate=e.matrixAutoUpdate),o.matrixAutoUpdate&&o.matrix.decompose(o.position,o.quaternion,o.scale)):(e.position!==void 0&&o.position.fromArray(e.position),e.rotation!==void 0&&o.rotation.fromArray(e.rotation),e.quaternion!==void 0&&o.quaternion.fromArray(e.quaternion),e.scale!==void 0&&o.scale.fromArray(e.scale)),e.up!==void 0&&o.up.fromArray(e.up),e.castShadow!==void 0&&(o.castShadow=e.castShadow),e.receiveShadow!==void 0&&(o.receiveShadow=e.receiveShadow),e.shadow&&(e.shadow.bias!==void 0&&(o.shadow.bias=e.shadow.bias),e.shadow.normalBias!==void 0&&(o.shadow.normalBias=e.shadow.normalBias),e.shadow.radius!==void 0&&(o.shadow.radius=e.shadow.radius),e.shadow.mapSize!==void 0&&o.shadow.mapSize.fromArray(e.shadow.mapSize),e.shadow.camera!==void 0&&(o.shadow.camera=this.parseObject(e.shadow.camera))),e.visible!==void 0&&(o.visible=e.visible),e.frustumCulled!==void 0&&(o.frustumCulled=e.frustumCulled),e.renderOrder!==void 0&&(o.renderOrder=e.renderOrder),e.userData!==void 0&&(o.userData=e.userData),e.layers!==void 0&&(o.layers.mask=e.layers),e.children!==void 0){const f=e.children;for(let h=0;h<f.length;h++)o.add(this.parseObject(f[h],n,r,i,s))}if(e.animations!==void 0){const f=e.animations;for(let h=0;h<f.length;h++){const p=f[h];o.animations.push(s[p])}}if(e.type==="LOD"){e.autoUpdate!==void 0&&(o.autoUpdate=e.autoUpdate);const f=e.levels;for(let h=0;h<f.length;h++){const p=f[h],x=o.getObjectByProperty("uuid",p.object);x!==void 0&&o.addLevel(x,p.distance,p.hysteresis)}}return o}bindSkeletons(e,n){Object.keys(n).length!==0&&e.traverse(function(r){if(r.isSkinnedMesh===!0&&r.skeleton!==void 0){const i=n[r.skeleton];i===void 0?console.warn("THREE.ObjectLoader: No skeleton found with UUID:",r.skeleton):r.bind(i,r.bindMatrix)}})}}const Ope={UVMapping:ES,CubeReflectionMapping:xl,CubeRefractionMapping:Ac,EquirectangularReflectionMapping:Og,EquirectangularRefractionMapping:Lg,CubeUVReflectionMapping:yp},XO={RepeatWrapping:Tc,ClampToEdgeWrapping:ws,MirroredRepeatWrapping:$h},KO={NearestFilter:Nr,NearestMipmapNearestFilter:AS,NearestMipmapLinearFilter:Du,LinearFilter:or,LinearMipmapNearestFilter:Sh,LinearMipmapLinearFilter:ao};class x6 extends _i{constructor(e){super(e),this.isImageBitmapLoader=!0,typeof createImageBitmap>"u"&&console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),typeof fetch>"u"&&console.warn("THREE.ImageBitmapLoader: fetch() not supported."),this.options={premultiplyAlpha:"none"}}setOptions(e){return this.options=e,this}load(e,n,r,i){e===void 0&&(e=""),this.path!==void 0&&(e=this.path+e),e=this.manager.resolveURL(e);const s=this,o=ol.get(e);if(o!==void 0){if(s.manager.itemStart(e),o.then){o.then(c=>{n&&n(c),s.manager.itemEnd(e)}).catch(c=>{i&&i(c)});return}return setTimeout(function(){n&&n(o),s.manager.itemEnd(e)},0),o}const a={};a.credentials=this.crossOrigin==="anonymous"?"same-origin":"include",a.headers=this.requestHeader;const l=fetch(e,a).then(function(c){return c.blob()}).then(function(c){return createImageBitmap(c,Object.assign(s.options,{colorSpaceConversion:"none"}))}).then(function(c){return ol.add(e,c),n&&n(c),s.manager.itemEnd(e),c}).catch(function(c){i&&i(c),ol.remove(e),s.manager.itemError(e),s.manager.itemEnd(e)});ol.add(e,l),s.manager.itemStart(e)}}let ox;class rI{static getContext(){return ox===void 0&&(ox=new(window.AudioContext||window.webkitAudioContext)),ox}static setContext(e){ox=e}}class Lpe extends _i{constructor(e){super(e)}load(e,n,r,i){const s=this,o=new Ns(this.manager);o.setResponseType("arraybuffer"),o.setPath(this.path),o.setRequestHeader(this.requestHeader),o.setWithCredentials(this.withCredentials),o.load(e,function(l){try{const c=l.slice(0);rI.getContext().decodeAudioData(c,function(d){n(d)}).catch(a)}catch(c){a(c)}},r,i);function a(l){i?i(l):console.error(l),s.manager.itemError(e)}}}const qO=new St,JO=new St,lu=new St;class Bpe{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new Hn,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new Hn,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(e){const n=this._cache;if(n.focus!==e.focus||n.fov!==e.fov||n.aspect!==e.aspect*this.aspect||n.near!==e.near||n.far!==e.far||n.zoom!==e.zoom||n.eyeSep!==this.eyeSep){n.focus=e.focus,n.fov=e.fov,n.aspect=e.aspect*this.aspect,n.near=e.near,n.far=e.far,n.zoom=e.zoom,n.eyeSep=this.eyeSep,lu.copy(e.projectionMatrix);const i=n.eyeSep/2,s=i*n.near/n.focus,o=n.near*Math.tan(Yu*n.fov*.5)/n.zoom;let a,l;JO.elements[12]=-i,qO.elements[12]=i,a=-o*n.aspect+s,l=o*n.aspect+s,lu.elements[0]=2*n.near/(l-a),lu.elements[8]=(l+a)/(l-a),this.cameraL.projectionMatrix.copy(lu),a=-o*n.aspect-s,l=o*n.aspect-s,lu.elements[0]=2*n.near/(l-a),lu.elements[8]=(l+a)/(l-a),this.cameraR.projectionMatrix.copy(lu)}this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(JO),this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(qO)}}class iI{constructor(e=!0){this.autoStart=e,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1}start(){this.startTime=YO(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let e=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const n=YO();e=(n-this.oldTime)/1e3,this.oldTime=n,this.elapsedTime+=e}return e}}function YO(){return(typeof performance>"u"?Date:performance).now()}const cu=new K,QO=new Hr,Fpe=new K,uu=new K;class $pe extends Zt{constructor(){super(),this.type="AudioListener",this.context=rI.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new iI}getInput(){return this.gain}removeFilter(){return this.filter!==null&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(e){return this.filter!==null?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=e,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}updateMatrixWorld(e){super.updateMatrixWorld(e);const n=this.context.listener,r=this.up;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(cu,QO,Fpe),uu.set(0,0,-1).applyQuaternion(QO),n.positionX){const i=this.context.currentTime+this.timeDelta;n.positionX.linearRampToValueAtTime(cu.x,i),n.positionY.linearRampToValueAtTime(cu.y,i),n.positionZ.linearRampToValueAtTime(cu.z,i),n.forwardX.linearRampToValueAtTime(uu.x,i),n.forwardY.linearRampToValueAtTime(uu.y,i),n.forwardZ.linearRampToValueAtTime(uu.z,i),n.upX.linearRampToValueAtTime(r.x,i),n.upY.linearRampToValueAtTime(r.y,i),n.upZ.linearRampToValueAtTime(r.z,i)}else n.setPosition(cu.x,cu.y,cu.z),n.setOrientation(uu.x,uu.y,uu.z,r.x,r.y,r.z)}}class b6 extends Zt{constructor(e){super(),this.type="Audio",this.listener=e,this.context=e.context,this.gain=this.context.createGain(),this.gain.connect(e.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(e){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=e,this.connect(),this}setMediaElementSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(e),this.connect(),this}setMediaStreamSource(e){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(e),this.connect(),this}setBuffer(e){return this.buffer=e,this.sourceType="buffer",this.autoplay&&this.play(),this}play(e=0){if(this.isPlaying===!0){console.warn("THREE.Audio: Audio is already playing.");return}if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}this._startedAt=this.context.currentTime+e;const n=this.context.createBufferSource();return n.buffer=this.buffer,n.loop=this.loop,n.loopStart=this.loopStart,n.loopEnd=this.loopEnd,n.onended=this.onEnded.bind(this),n.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=n,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.isPlaying===!0&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,this.loop===!0&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this}stop(){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this._progress=0,this.source!==null&&(this.source.stop(),this.source.onended=null),this.isPlaying=!1,this}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let e=1,n=this.filters.length;e<n;e++)this.filters[e-1].connect(this.filters[e]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(this._connected!==!1){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let e=1,n=this.filters.length;e<n;e++)this.filters[e-1].disconnect(this.filters[e]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(e){return e||(e=[]),this._connected===!0?(this.disconnect(),this.filters=e.slice(),this.connect()):this.filters=e.slice(),this}setDetune(e){return this.detune=e,this.isPlaying===!0&&this.source.detune!==void 0&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(e){return this.setFilters(e?[e]:[])}setPlaybackRate(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.playbackRate=e,this.isPlaying===!0&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1}getLoop(){return this.hasPlaybackControl===!1?(console.warn("THREE.Audio: this Audio has no playback control."),!1):this.loop}setLoop(e){if(this.hasPlaybackControl===!1){console.warn("THREE.Audio: this Audio has no playback control.");return}return this.loop=e,this.isPlaying===!0&&(this.source.loop=this.loop),this}setLoopStart(e){return this.loopStart=e,this}setLoopEnd(e){return this.loopEnd=e,this}getVolume(){return this.gain.gain.value}setVolume(e){return this.gain.gain.setTargetAtTime(e,this.context.currentTime,.01),this}}const du=new K,ZO=new Hr,Upe=new K,fu=new K;class zpe extends b6{constructor(e){super(e),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){super.connect(),this.panner.connect(this.gain)}disconnect(){super.disconnect(),this.panner.disconnect(this.gain)}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(e){return this.panner.refDistance=e,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(e){return this.panner.rolloffFactor=e,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(e){return this.panner.distanceModel=e,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(e){return this.panner.maxDistance=e,this}setDirectionalCone(e,n,r){return this.panner.coneInnerAngle=e,this.panner.coneOuterAngle=n,this.panner.coneOuterGain=r,this}updateMatrixWorld(e){if(super.updateMatrixWorld(e),this.hasPlaybackControl===!0&&this.isPlaying===!1)return;this.matrixWorld.decompose(du,ZO,Upe),fu.set(0,0,1).applyQuaternion(ZO);const n=this.panner;if(n.positionX){const r=this.context.currentTime+this.listener.timeDelta;n.positionX.linearRampToValueAtTime(du.x,r),n.positionY.linearRampToValueAtTime(du.y,r),n.positionZ.linearRampToValueAtTime(du.z,r),n.orientationX.linearRampToValueAtTime(fu.x,r),n.orientationY.linearRampToValueAtTime(fu.y,r),n.orientationZ.linearRampToValueAtTime(fu.z,r)}else n.setPosition(du.x,du.y,du.z),n.setOrientation(fu.x,fu.y,fu.z)}}class Gpe{constructor(e,n=2048){this.analyser=e.context.createAnalyser(),this.analyser.fftSize=n,this.data=new Uint8Array(this.analyser.frequencyBinCount),e.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let e=0;const n=this.getFrequencyData();for(let r=0;r<n.length;r++)e+=n[r];return e/n.length}}class S6{constructor(e,n,r){this.binding=e,this.valueSize=r;let i,s,o;switch(n){case"quaternion":i=this._slerp,s=this._slerpAdditive,o=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(r*6),this._workIndex=5;break;case"string":case"bool":i=this._select,s=this._select,o=this._setAdditiveIdentityOther,this.buffer=new Array(r*5);break;default:i=this._lerp,s=this._lerpAdditive,o=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(r*5)}this._mixBufferRegion=i,this._mixBufferRegionAdditive=s,this._setIdentity=o,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(e,n){const r=this.buffer,i=this.valueSize,s=e*i+i;let o=this.cumulativeWeight;if(o===0){for(let a=0;a!==i;++a)r[s+a]=r[a];o=n}else{o+=n;const a=n/o;this._mixBufferRegion(r,s,0,a,i)}this.cumulativeWeight=o}accumulateAdditive(e){const n=this.buffer,r=this.valueSize,i=r*this._addIndex;this.cumulativeWeightAdditive===0&&this._setIdentity(),this._mixBufferRegionAdditive(n,i,0,e,r),this.cumulativeWeightAdditive+=e}apply(e){const n=this.valueSize,r=this.buffer,i=e*n+n,s=this.cumulativeWeight,o=this.cumulativeWeightAdditive,a=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,s<1){const l=n*this._origIndex;this._mixBufferRegion(r,i,l,1-s,n)}o>0&&this._mixBufferRegionAdditive(r,i,this._addIndex*n,1,n);for(let l=n,c=n+n;l!==c;++l)if(r[l]!==r[l+n]){a.setValue(r,i);break}}saveOriginalState(){const e=this.binding,n=this.buffer,r=this.valueSize,i=r*this._origIndex;e.getValue(n,i);for(let s=r,o=i;s!==o;++s)n[s]=n[i+s%r];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const e=this.valueSize*3;this.binding.setValue(this.buffer,e)}_setAdditiveIdentityNumeric(){const e=this._addIndex*this.valueSize,n=e+this.valueSize;for(let r=e;r<n;r++)this.buffer[r]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const e=this._origIndex*this.valueSize,n=this._addIndex*this.valueSize;for(let r=0;r<this.valueSize;r++)this.buffer[n+r]=this.buffer[e+r]}_select(e,n,r,i,s){if(i>=.5)for(let o=0;o!==s;++o)e[n+o]=e[r+o]}_slerp(e,n,r,i){Hr.slerpFlat(e,n,e,n,e,r,i)}_slerpAdditive(e,n,r,i,s){const o=this._workIndex*s;Hr.multiplyQuaternionsFlat(e,o,e,n,e,r),Hr.slerpFlat(e,n,e,n,e,o,i)}_lerp(e,n,r,i,s){const o=1-i;for(let a=0;a!==s;++a){const l=n+a;e[l]=e[l]*o+e[r+a]*i}}_lerpAdditive(e,n,r,i,s){for(let o=0;o!==s;++o){const a=n+o;e[a]=e[a]+e[r+o]*i}}}const sI="\\[\\]\\.:\\/",Hpe=new RegExp("["+sI+"]","g"),oI="[^"+sI+"]",Vpe="[^"+sI.replace("\\.","")+"]",Wpe=/((?:WC+[\/:])*)/.source.replace("WC",oI),jpe=/(WCOD+)?/.source.replace("WCOD",Vpe),Xpe=/(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC",oI),Kpe=/\.(WC+)(?:\[(.+)\])?/.source.replace("WC",oI),qpe=new RegExp("^"+Wpe+jpe+Xpe+Kpe+"$"),Jpe=["material","materials","bones","map"];class Ype{constructor(e,n,r){const i=r||Yt.parseTrackName(n);this._targetGroup=e,this._bindings=e.subscribe_(n,i)}getValue(e,n){this.bind();const r=this._targetGroup.nCachedObjects_,i=this._bindings[r];i!==void 0&&i.getValue(e,n)}setValue(e,n){const r=this._bindings;for(let i=this._targetGroup.nCachedObjects_,s=r.length;i!==s;++i)r[i].setValue(e,n)}bind(){const e=this._bindings;for(let n=this._targetGroup.nCachedObjects_,r=e.length;n!==r;++n)e[n].bind()}unbind(){const e=this._bindings;for(let n=this._targetGroup.nCachedObjects_,r=e.length;n!==r;++n)e[n].unbind()}}class Yt{constructor(e,n,r){this.path=n,this.parsedPath=r||Yt.parseTrackName(n),this.node=Yt.findNode(e,this.parsedPath.nodeName),this.rootNode=e,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(e,n,r){return e&&e.isAnimationObjectGroup?new Yt.Composite(e,n,r):new Yt(e,n,r)}static sanitizeNodeName(e){return e.replace(/\s/g,"_").replace(Hpe,"")}static parseTrackName(e){const n=qpe.exec(e);if(n===null)throw new Error("PropertyBinding: Cannot parse trackName: "+e);const r={nodeName:n[2],objectName:n[3],objectIndex:n[4],propertyName:n[5],propertyIndex:n[6]},i=r.nodeName&&r.nodeName.lastIndexOf(".");if(i!==void 0&&i!==-1){const s=r.nodeName.substring(i+1);Jpe.indexOf(s)!==-1&&(r.nodeName=r.nodeName.substring(0,i),r.objectName=s)}if(r.propertyName===null||r.propertyName.length===0)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+e);return r}static findNode(e,n){if(n===void 0||n===""||n==="."||n===-1||n===e.name||n===e.uuid)return e;if(e.skeleton){const r=e.skeleton.getBoneByName(n);if(r!==void 0)return r}if(e.children){const r=function(s){for(let o=0;o<s.length;o++){const a=s[o];if(a.name===n||a.uuid===n)return a;const l=r(a.children);if(l)return l}return null},i=r(e.children);if(i)return i}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(e,n){e[n]=this.targetObject[this.propertyName]}_getValue_array(e,n){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)e[n++]=r[i]}_getValue_arrayElement(e,n){e[n]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(e,n){this.resolvedProperty.toArray(e,n)}_setValue_direct(e,n){this.targetObject[this.propertyName]=e[n]}_setValue_direct_setNeedsUpdate(e,n){this.targetObject[this.propertyName]=e[n],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(e,n){this.targetObject[this.propertyName]=e[n],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(e,n){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)r[i]=e[n++]}_setValue_array_setNeedsUpdate(e,n){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)r[i]=e[n++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(e,n){const r=this.resolvedProperty;for(let i=0,s=r.length;i!==s;++i)r[i]=e[n++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(e,n){this.resolvedProperty[this.propertyIndex]=e[n]}_setValue_arrayElement_setNeedsUpdate(e,n){this.resolvedProperty[this.propertyIndex]=e[n],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(e,n){this.resolvedProperty[this.propertyIndex]=e[n],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(e,n){this.resolvedProperty.fromArray(e,n)}_setValue_fromArray_setNeedsUpdate(e,n){this.resolvedProperty.fromArray(e,n),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(e,n){this.resolvedProperty.fromArray(e,n),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(e,n){this.bind(),this.getValue(e,n)}_setValue_unbound(e,n){this.bind(),this.setValue(e,n)}bind(){let e=this.node;const n=this.parsedPath,r=n.objectName,i=n.propertyName;let s=n.propertyIndex;if(e||(e=Yt.findNode(this.rootNode,n.nodeName),this.node=e),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!e){console.warn("THREE.PropertyBinding: No target node found for track: "+this.path+".");return}if(r){let c=n.objectIndex;switch(r){case"materials":if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.materials){console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);return}e=e.material.materials;break;case"bones":if(!e.skeleton){console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);return}e=e.skeleton.bones;for(let u=0;u<e.length;u++)if(e[u].name===c){c=u;break}break;case"map":if("map"in e){e=e.map;break}if(!e.material){console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.",this);return}if(!e.material.map){console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);return}e=e.material.map;break;default:if(e[r]===void 0){console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.",this);return}e=e[r]}if(c!==void 0){if(e[c]===void 0){console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,e);return}e=e[c]}}const o=e[i];if(o===void 0){const c=n.nodeName;console.error("THREE.PropertyBinding: Trying to update property for track: "+c+"."+i+" but it wasn't found.",e);return}let a=this.Versioning.None;this.targetObject=e,e.needsUpdate!==void 0?a=this.Versioning.NeedsUpdate:e.matrixWorldNeedsUpdate!==void 0&&(a=this.Versioning.MatrixWorldNeedsUpdate);let l=this.BindingType.Direct;if(s!==void 0){if(i==="morphTargetInfluences"){if(!e.geometry){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);return}if(!e.geometry.morphAttributes){console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);return}e.morphTargetDictionary[s]!==void 0&&(s=e.morphTargetDictionary[s])}l=this.BindingType.ArrayElement,this.resolvedProperty=o,this.propertyIndex=s}else o.fromArray!==void 0&&o.toArray!==void 0?(l=this.BindingType.HasFromToArray,this.resolvedProperty=o):Array.isArray(o)?(l=this.BindingType.EntireArray,this.resolvedProperty=o):this.propertyName=i;this.getValue=this.GetterByBindingType[l],this.setValue=this.SetterByBindingTypeAndVersioning[l][a]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}Yt.Composite=Ype;Yt.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3};Yt.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2};Yt.prototype.GetterByBindingType=[Yt.prototype._getValue_direct,Yt.prototype._getValue_array,Yt.prototype._getValue_arrayElement,Yt.prototype._getValue_toArray];Yt.prototype.SetterByBindingTypeAndVersioning=[[Yt.prototype._setValue_direct,Yt.prototype._setValue_direct_setNeedsUpdate,Yt.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[Yt.prototype._setValue_array,Yt.prototype._setValue_array_setNeedsUpdate,Yt.prototype._setValue_array_setMatrixWorldNeedsUpdate],[Yt.prototype._setValue_arrayElement,Yt.prototype._setValue_arrayElement_setNeedsUpdate,Yt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[Yt.prototype._setValue_fromArray,Yt.prototype._setValue_fromArray_setNeedsUpdate,Yt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class Qpe{constructor(){this.isAnimationObjectGroup=!0,this.uuid=Ms(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const e={};this._indicesByUUID=e;for(let r=0,i=arguments.length;r!==i;++r)e[arguments[r].uuid]=r;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const n=this;this.stats={objects:{get total(){return n._objects.length},get inUse(){return this.total-n.nCachedObjects_}},get bindingsPerObject(){return n._bindings.length}}}add(){const e=this._objects,n=this._indicesByUUID,r=this._paths,i=this._parsedPaths,s=this._bindings,o=s.length;let a,l=e.length,c=this.nCachedObjects_;for(let u=0,d=arguments.length;u!==d;++u){const f=arguments[u],h=f.uuid;let p=n[h];if(p===void 0){p=l++,n[h]=p,e.push(f);for(let x=0,v=o;x!==v;++x)s[x].push(new Yt(f,r[x],i[x]))}else if(p<c){a=e[p];const x=--c,v=e[x];n[v.uuid]=p,e[p]=v,n[h]=x,e[x]=f;for(let y=0,b=o;y!==b;++y){const S=s[y],w=S[x];let E=S[p];S[p]=w,E===void 0&&(E=new Yt(f,r[y],i[y])),S[x]=E}}else e[p]!==a&&console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=c}remove(){const e=this._objects,n=this._indicesByUUID,r=this._bindings,i=r.length;let s=this.nCachedObjects_;for(let o=0,a=arguments.length;o!==a;++o){const l=arguments[o],c=l.uuid,u=n[c];if(u!==void 0&&u>=s){const d=s++,f=e[d];n[f.uuid]=u,e[u]=f,n[c]=d,e[d]=l;for(let h=0,p=i;h!==p;++h){const x=r[h],v=x[d],y=x[u];x[u]=v,x[d]=y}}}this.nCachedObjects_=s}uncache(){const e=this._objects,n=this._indicesByUUID,r=this._bindings,i=r.length;let s=this.nCachedObjects_,o=e.length;for(let a=0,l=arguments.length;a!==l;++a){const c=arguments[a],u=c.uuid,d=n[u];if(d!==void 0)if(delete n[u],d<s){const f=--s,h=e[f],p=--o,x=e[p];n[h.uuid]=d,e[d]=h,n[x.uuid]=f,e[f]=x,e.pop();for(let v=0,y=i;v!==y;++v){const b=r[v],S=b[f],w=b[p];b[d]=S,b[f]=w,b.pop()}}else{const f=--o,h=e[f];f>0&&(n[h.uuid]=d),e[d]=h,e.pop();for(let p=0,x=i;p!==x;++p){const v=r[p];v[d]=v[f],v.pop()}}}this.nCachedObjects_=s}subscribe_(e,n){const r=this._bindingsIndicesByPath;let i=r[e];const s=this._bindings;if(i!==void 0)return s[i];const o=this._paths,a=this._parsedPaths,l=this._objects,c=l.length,u=this.nCachedObjects_,d=new Array(c);i=s.length,r[e]=i,o.push(e),a.push(n),s.push(d);for(let f=u,h=l.length;f!==h;++f){const p=l[f];d[f]=new Yt(p,e,n)}return d}unsubscribe_(e){const n=this._bindingsIndicesByPath,r=n[e];if(r!==void 0){const i=this._paths,s=this._parsedPaths,o=this._bindings,a=o.length-1,l=o[a],c=e[a];n[c]=r,o[r]=l,o.pop(),s[r]=s[a],s.pop(),i[r]=i[a],i.pop()}}}class _6{constructor(e,n,r=null,i=n.blendMode){this._mixer=e,this._clip=n,this._localRoot=r,this.blendMode=i;const s=n.tracks,o=s.length,a=new Array(o),l={endingStart:Ou,endingEnd:Ou};for(let c=0;c!==o;++c){const u=s[c].createInterpolant(null);a[c]=u,u.settings=l}this._interpolantSettings=l,this._interpolants=a,this._propertyBindings=new Array(o),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=o5,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=1/0,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&this.timeScale!==0&&this._startTime===null&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(e){return this._startTime=e,this}setLoop(e,n){return this.loop=e,this.repetitions=n,this}setEffectiveWeight(e){return this.weight=e,this._effectiveWeight=this.enabled?e:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(e){return this._scheduleFading(e,0,1)}fadeOut(e){return this._scheduleFading(e,1,0)}crossFadeFrom(e,n,r){if(e.fadeOut(n),this.fadeIn(n),r){const i=this._clip.duration,s=e._clip.duration,o=s/i,a=i/s;e.warp(1,o,n),this.warp(a,1,n)}return this}crossFadeTo(e,n,r){return e.crossFadeFrom(this,n,r)}stopFading(){const e=this._weightInterpolant;return e!==null&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}setEffectiveTimeScale(e){return this.timeScale=e,this._effectiveTimeScale=this.paused?0:e,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(e){return this.timeScale=this._clip.duration/e,this.stopWarping()}syncWith(e){return this.time=e.time,this.timeScale=e.timeScale,this.stopWarping()}halt(e){return this.warp(this._effectiveTimeScale,0,e)}warp(e,n,r){const i=this._mixer,s=i.time,o=this.timeScale;let a=this._timeScaleInterpolant;a===null&&(a=i._lendControlInterpolant(),this._timeScaleInterpolant=a);const l=a.parameterPositions,c=a.sampleValues;return l[0]=s,l[1]=s+r,c[0]=e/o,c[1]=n/o,this}stopWarping(){const e=this._timeScaleInterpolant;return e!==null&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(e)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(e,n,r,i){if(!this.enabled){this._updateWeight(e);return}const s=this._startTime;if(s!==null){const l=(e-s)*r;l<0||r===0?n=0:(this._startTime=null,n=r*l)}n*=this._updateTimeScale(e);const o=this._updateTime(n),a=this._updateWeight(e);if(a>0){const l=this._interpolants,c=this._propertyBindings;switch(this.blendMode){case ER:for(let u=0,d=l.length;u!==d;++u)l[u].evaluate(o),c[u].accumulateAdditive(a);break;case TS:default:for(let u=0,d=l.length;u!==d;++u)l[u].evaluate(o),c[u].accumulate(i,a)}}}_updateWeight(e){let n=0;if(this.enabled){n=this.weight;const r=this._weightInterpolant;if(r!==null){const i=r.evaluate(e)[0];n*=i,e>r.parameterPositions[1]&&(this.stopFading(),i===0&&(this.enabled=!1))}}return this._effectiveWeight=n,n}_updateTimeScale(e){let n=0;if(!this.paused){n=this.timeScale;const r=this._timeScaleInterpolant;if(r!==null){const i=r.evaluate(e)[0];n*=i,e>r.parameterPositions[1]&&(this.stopWarping(),n===0?this.paused=!0:this.timeScale=n)}}return this._effectiveTimeScale=n,n}_updateTime(e){const n=this._clip.duration,r=this.loop;let i=this.time+e,s=this._loopCount;const o=r===a5;if(e===0)return s===-1?i:o&&(s&1)===1?n-i:i;if(r===s5){s===-1&&(this._loopCount=0,this._setEndings(!0,!0,!1));e:{if(i>=n)i=n;else if(i<0)i=0;else{this.time=i;break e}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e<0?-1:1})}}else{if(s===-1&&(e>=0?(s=0,this._setEndings(!0,this.repetitions===0,o)):this._setEndings(this.repetitions===0,!0,o)),i>=n||i<0){const a=Math.floor(i/n);i-=n*a,s+=Math.abs(a);const l=this.repetitions-s;if(l<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,i=e>0?n:0,this.time=i,this._mixer.dispatchEvent({type:"finished",action:this,direction:e>0?1:-1});else{if(l===1){const c=e<0;this._setEndings(c,!c,o)}else this._setEndings(!1,!1,o);this._loopCount=s,this.time=i,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:a})}}else this.time=i;if(o&&(s&1)===1)return n-i}return i}_setEndings(e,n,r){const i=this._interpolantSettings;r?(i.endingStart=Lu,i.endingEnd=Lu):(e?i.endingStart=this.zeroSlopeAtStart?Lu:Ou:i.endingStart=Fg,n?i.endingEnd=this.zeroSlopeAtEnd?Lu:Ou:i.endingEnd=Fg)}_scheduleFading(e,n,r){const i=this._mixer,s=i.time;let o=this._weightInterpolant;o===null&&(o=i._lendControlInterpolant(),this._weightInterpolant=o);const a=o.parameterPositions,l=o.sampleValues;return a[0]=s,l[0]=n,a[1]=s+e,l[1]=r,this}}const Zpe=new Float32Array(1);class eme extends ka{constructor(e){super(),this._root=e,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1}_bindAction(e,n){const r=e._localRoot||this._root,i=e._clip.tracks,s=i.length,o=e._propertyBindings,a=e._interpolants,l=r.uuid,c=this._bindingsByRootAndName;let u=c[l];u===void 0&&(u={},c[l]=u);for(let d=0;d!==s;++d){const f=i[d],h=f.name;let p=u[h];if(p!==void 0)++p.referenceCount,o[d]=p;else{if(p=o[d],p!==void 0){p._cacheIndex===null&&(++p.referenceCount,this._addInactiveBinding(p,l,h));continue}const x=n&&n._propertyBindings[d].binding.parsedPath;p=new S6(Yt.create(r,h,x),f.ValueTypeName,f.getValueSize()),++p.referenceCount,this._addInactiveBinding(p,l,h),o[d]=p}a[d].resultBuffer=p.buffer}}_activateAction(e){if(!this._isActiveAction(e)){if(e._cacheIndex===null){const r=(e._localRoot||this._root).uuid,i=e._clip.uuid,s=this._actionsByClip[i];this._bindAction(e,s&&s.knownActions[0]),this._addInactiveAction(e,i,r)}const n=e._propertyBindings;for(let r=0,i=n.length;r!==i;++r){const s=n[r];s.useCount++===0&&(this._lendBinding(s),s.saveOriginalState())}this._lendAction(e)}}_deactivateAction(e){if(this._isActiveAction(e)){const n=e._propertyBindings;for(let r=0,i=n.length;r!==i;++r){const s=n[r];--s.useCount===0&&(s.restoreOriginalState(),this._takeBackBinding(s))}this._takeBackAction(e)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const e=this;this.stats={actions:{get total(){return e._actions.length},get inUse(){return e._nActiveActions}},bindings:{get total(){return e._bindings.length},get inUse(){return e._nActiveBindings}},controlInterpolants:{get total(){return e._controlInterpolants.length},get inUse(){return e._nActiveControlInterpolants}}}}_isActiveAction(e){const n=e._cacheIndex;return n!==null&&n<this._nActiveActions}_addInactiveAction(e,n,r){const i=this._actions,s=this._actionsByClip;let o=s[n];if(o===void 0)o={knownActions:[e],actionByRoot:{}},e._byClipCacheIndex=0,s[n]=o;else{const a=o.knownActions;e._byClipCacheIndex=a.length,a.push(e)}e._cacheIndex=i.length,i.push(e),o.actionByRoot[r]=e}_removeInactiveAction(e){const n=this._actions,r=n[n.length-1],i=e._cacheIndex;r._cacheIndex=i,n[i]=r,n.pop(),e._cacheIndex=null;const s=e._clip.uuid,o=this._actionsByClip,a=o[s],l=a.knownActions,c=l[l.length-1],u=e._byClipCacheIndex;c._byClipCacheIndex=u,l[u]=c,l.pop(),e._byClipCacheIndex=null;const d=a.actionByRoot,f=(e._localRoot||this._root).uuid;delete d[f],l.length===0&&delete o[s],this._removeInactiveBindingsForAction(e)}_removeInactiveBindingsForAction(e){const n=e._propertyBindings;for(let r=0,i=n.length;r!==i;++r){const s=n[r];--s.referenceCount===0&&this._removeInactiveBinding(s)}}_lendAction(e){const n=this._actions,r=e._cacheIndex,i=this._nActiveActions++,s=n[i];e._cacheIndex=i,n[i]=e,s._cacheIndex=r,n[r]=s}_takeBackAction(e){const n=this._actions,r=e._cacheIndex,i=--this._nActiveActions,s=n[i];e._cacheIndex=i,n[i]=e,s._cacheIndex=r,n[r]=s}_addInactiveBinding(e,n,r){const i=this._bindingsByRootAndName,s=this._bindings;let o=i[n];o===void 0&&(o={},i[n]=o),o[r]=e,e._cacheIndex=s.length,s.push(e)}_removeInactiveBinding(e){const n=this._bindings,r=e.binding,i=r.rootNode.uuid,s=r.path,o=this._bindingsByRootAndName,a=o[i],l=n[n.length-1],c=e._cacheIndex;l._cacheIndex=c,n[c]=l,n.pop(),delete a[s],Object.keys(a).length===0&&delete o[i]}_lendBinding(e){const n=this._bindings,r=e._cacheIndex,i=this._nActiveBindings++,s=n[i];e._cacheIndex=i,n[i]=e,s._cacheIndex=r,n[r]=s}_takeBackBinding(e){const n=this._bindings,r=e._cacheIndex,i=--this._nActiveBindings,s=n[i];e._cacheIndex=i,n[i]=e,s._cacheIndex=r,n[r]=s}_lendControlInterpolant(){const e=this._controlInterpolants,n=this._nActiveControlInterpolants++;let r=e[n];return r===void 0&&(r=new qR(new Float32Array(2),new Float32Array(2),1,Zpe),r.__cacheIndex=n,e[n]=r),r}_takeBackControlInterpolant(e){const n=this._controlInterpolants,r=e.__cacheIndex,i=--this._nActiveControlInterpolants,s=n[i];e.__cacheIndex=i,n[i]=e,s.__cacheIndex=r,n[r]=s}clipAction(e,n,r){const i=n||this._root,s=i.uuid;let o=typeof e=="string"?Xh.findByName(i,e):e;const a=o!==null?o.uuid:e,l=this._actionsByClip[a];let c=null;if(r===void 0&&(o!==null?r=o.blendMode:r=TS),l!==void 0){const d=l.actionByRoot[s];if(d!==void 0&&d.blendMode===r)return d;c=l.knownActions[0],o===null&&(o=c._clip)}if(o===null)return null;const u=new _6(this,o,n,r);return this._bindAction(u,c),this._addInactiveAction(u,a,s),u}existingAction(e,n){const r=n||this._root,i=r.uuid,s=typeof e=="string"?Xh.findByName(r,e):e,o=s?s.uuid:e,a=this._actionsByClip[o];return a!==void 0&&a.actionByRoot[i]||null}stopAllAction(){const e=this._actions,n=this._nActiveActions;for(let r=n-1;r>=0;--r)e[r].stop();return this}update(e){e*=this.timeScale;const n=this._actions,r=this._nActiveActions,i=this.time+=e,s=Math.sign(e),o=this._accuIndex^=1;for(let c=0;c!==r;++c)n[c]._update(i,e,s,o);const a=this._bindings,l=this._nActiveBindings;for(let c=0;c!==l;++c)a[c].apply(o);return this}setTime(e){this.time=0;for(let n=0;n<this._actions.length;n++)this._actions[n].time=0;return this.update(e)}getRoot(){return this._root}uncacheClip(e){const n=this._actions,r=e.uuid,i=this._actionsByClip,s=i[r];if(s!==void 0){const o=s.knownActions;for(let a=0,l=o.length;a!==l;++a){const c=o[a];this._deactivateAction(c);const u=c._cacheIndex,d=n[n.length-1];c._cacheIndex=null,c._byClipCacheIndex=null,d._cacheIndex=u,n[u]=d,n.pop(),this._removeInactiveBindingsForAction(c)}delete i[r]}}uncacheRoot(e){const n=e.uuid,r=this._actionsByClip;for(const o in r){const a=r[o].actionByRoot,l=a[n];l!==void 0&&(this._deactivateAction(l),this._removeInactiveAction(l))}const i=this._bindingsByRootAndName,s=i[n];if(s!==void 0)for(const o in s){const a=s[o];a.restoreOriginalState(),this._removeInactiveBinding(a)}}uncacheAction(e,n){const r=this.existingAction(e,n);r!==null&&(this._deactivateAction(r),this._removeInactiveAction(r))}}class aI{constructor(e){this.value=e}clone(){return new aI(this.value.clone===void 0?this.value:this.value.clone())}}let tme=0;class nme extends ka{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:tme++}),this.name="",this.usage=Gg,this.uniforms=[]}add(e){return this.uniforms.push(e),this}remove(e){const n=this.uniforms.indexOf(e);return n!==-1&&this.uniforms.splice(n,1),this}setName(e){return this.name=e,this}setUsage(e){return this.usage=e,this}dispose(){return this.dispatchEvent({type:"dispose"}),this}copy(e){this.name=e.name,this.usage=e.usage;const n=e.uniforms;this.uniforms.length=0;for(let r=0,i=n.length;r<i;r++){const s=Array.isArray(n[r])?n[r]:[n[r]];for(let o=0;o<s.length;o++)this.uniforms.push(s[o].clone())}return this}clone(){return new this.constructor().copy(this)}}class rme extends I0{constructor(e,n,r=1){super(e,n),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=r}copy(e){return super.copy(e),this.meshPerAttribute=e.meshPerAttribute,this}clone(e){const n=super.clone(e);return n.meshPerAttribute=this.meshPerAttribute,n}toJSON(e){const n=super.toJSON(e);return n.isInstancedInterleavedBuffer=!0,n.meshPerAttribute=this.meshPerAttribute,n}}class ime{constructor(e,n,r,i,s){this.isGLBufferAttribute=!0,this.name="",this.buffer=e,this.type=n,this.itemSize=r,this.elementSize=i,this.count=s,this.version=0}set needsUpdate(e){e===!0&&this.version++}setBuffer(e){return this.buffer=e,this}setType(e,n){return this.type=e,this.elementSize=n,this}setItemSize(e){return this.itemSize=e,this}setCount(e){return this.count=e,this}}const eL=new St;class w6{constructor(e,n,r=0,i=1/0){this.ray=new Nd(e,n),this.near=r,this.far=i,this.camera=null,this.layers=new Qu,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(e,n){this.ray.set(e,n)}setFromCamera(e,n){n.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(n.matrixWorld),this.ray.direction.set(e.x,e.y,.5).unproject(n).sub(this.ray.origin).normalize(),this.camera=n):n.isOrthographicCamera?(this.ray.origin.set(e.x,e.y,(n.near+n.far)/(n.near-n.far)).unproject(n),this.ray.direction.set(0,0,-1).transformDirection(n.matrixWorld),this.camera=n):console.error("THREE.Raycaster: Unsupported camera type: "+n.type)}setFromXRController(e){return eL.identity().extractRotation(e.matrixWorld),this.ray.origin.setFromMatrixPosition(e.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(eL),this}intersectObject(e,n=!0,r=[]){return U2(e,this,r,n),r.sort(tL),r}intersectObjects(e,n=!0,r=[]){for(let i=0,s=e.length;i<s;i++)U2(e[i],this,r,n);return r.sort(tL),r}}function tL(t,e){return t.distance-e.distance}function U2(t,e,n,r){if(t.layers.test(e.layers)&&t.raycast(e,n),r===!0){const i=t.children;for(let s=0,o=i.length;s<o;s++)U2(i[s],e,n,!0)}}class z2{constructor(e=1,n=0,r=0){return this.radius=e,this.phi=n,this.theta=r,this}set(e,n,r){return this.radius=e,this.phi=n,this.theta=r,this}copy(e){return this.radius=e.radius,this.phi=e.phi,this.theta=e.theta,this}makeSafe(){return this.phi=Math.max(1e-6,Math.min(Math.PI-1e-6,this.phi)),this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,n,r){return this.radius=Math.sqrt(e*e+n*n+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(e,r),this.phi=Math.acos(sr(n/this.radius,-1,1))),this}clone(){return new this.constructor().copy(this)}}class sme{constructor(e=1,n=0,r=0){return this.radius=e,this.theta=n,this.y=r,this}set(e,n,r){return this.radius=e,this.theta=n,this.y=r,this}copy(e){return this.radius=e.radius,this.theta=e.theta,this.y=e.y,this}setFromVector3(e){return this.setFromCartesianCoords(e.x,e.y,e.z)}setFromCartesianCoords(e,n,r){return this.radius=Math.sqrt(e*e+r*r),this.theta=Math.atan2(e,r),this.y=n,this}clone(){return new this.constructor().copy(this)}}const nL=new Re;class ome{constructor(e=new Re(1/0,1/0),n=new Re(-1/0,-1/0)){this.isBox2=!0,this.min=e,this.max=n}set(e,n){return this.min.copy(e),this.max.copy(n),this}setFromPoints(e){this.makeEmpty();for(let n=0,r=e.length;n<r;n++)this.expandByPoint(e[n]);return this}setFromCenterAndSize(e,n){const r=nL.copy(n).multiplyScalar(.5);return this.min.copy(e).sub(r),this.max.copy(e).add(r),this}clone(){return new this.constructor().copy(this)}copy(e){return this.min.copy(e.min),this.max.copy(e.max),this}makeEmpty(){return this.min.x=this.min.y=1/0,this.max.x=this.max.y=-1/0,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(e){return this.isEmpty()?e.set(0,0):e.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(e){return this.isEmpty()?e.set(0,0):e.subVectors(this.max,this.min)}expandByPoint(e){return this.min.min(e),this.max.max(e),this}expandByVector(e){return this.min.sub(e),this.max.add(e),this}expandByScalar(e){return this.min.addScalar(-e),this.max.addScalar(e),this}containsPoint(e){return!(e.x<this.min.x||e.x>this.max.x||e.y<this.min.y||e.y>this.max.y)}containsBox(e){return this.min.x<=e.min.x&&e.max.x<=this.max.x&&this.min.y<=e.min.y&&e.max.y<=this.max.y}getParameter(e,n){return n.set((e.x-this.min.x)/(this.max.x-this.min.x),(e.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(e){return!(e.max.x<this.min.x||e.min.x>this.max.x||e.max.y<this.min.y||e.min.y>this.max.y)}clampPoint(e,n){return n.copy(e).clamp(this.min,this.max)}distanceToPoint(e){return this.clampPoint(e,nL).distanceTo(e)}intersect(e){return this.min.max(e.min),this.max.min(e.max),this.isEmpty()&&this.makeEmpty(),this}union(e){return this.min.min(e.min),this.max.max(e.max),this}translate(e){return this.min.add(e),this.max.add(e),this}equals(e){return e.min.equals(this.min)&&e.max.equals(this.max)}}const rL=new K,ax=new K;class ame{constructor(e=new K,n=new K){this.start=e,this.end=n}set(e,n){return this.start.copy(e),this.end.copy(n),this}copy(e){return this.start.copy(e.start),this.end.copy(e.end),this}getCenter(e){return e.addVectors(this.start,this.end).multiplyScalar(.5)}delta(e){return e.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(e,n){return this.delta(n).multiplyScalar(e).add(this.start)}closestPointToPointParameter(e,n){rL.subVectors(e,this.start),ax.subVectors(this.end,this.start);const r=ax.dot(ax);let s=ax.dot(rL)/r;return n&&(s=sr(s,0,1)),s}closestPointToPoint(e,n,r){const i=this.closestPointToPointParameter(e,n);return this.delta(r).multiplyScalar(i).add(this.start)}applyMatrix4(e){return this.start.applyMatrix4(e),this.end.applyMatrix4(e),this}equals(e){return e.start.equals(this.start)&&e.end.equals(this.end)}clone(){return new this.constructor().copy(this)}}const iL=new K;class lme extends Zt{constructor(e,n){super(),this.light=e,this.matrixAutoUpdate=!1,this.color=n,this.type="SpotLightHelper";const r=new Lt,i=[0,0,0,0,0,1,0,0,0,1,0,1,0,0,0,-1,0,1,0,0,0,0,1,1,0,0,0,0,-1,1];for(let o=0,a=1,l=32;o<l;o++,a++){const c=o/l*Math.PI*2,u=a/l*Math.PI*2;i.push(Math.cos(c),Math.sin(c),1,Math.cos(u),Math.sin(u),1)}r.setAttribute("position",new mt(i,3));const s=new Si({fog:!1,toneMapped:!1});this.cone=new Yo(r,s),this.add(this.cone),this.update()}dispose(){this.cone.geometry.dispose(),this.cone.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),this.parent?(this.parent.updateWorldMatrix(!0),this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)):this.matrix.copy(this.light.matrixWorld),this.matrixWorld.copy(this.light.matrixWorld);const e=this.light.distance?this.light.distance:1e3,n=e*Math.tan(this.light.angle);this.cone.scale.set(n,n,e),iL.setFromMatrixPosition(this.light.target.matrixWorld),this.cone.lookAt(iL),this.color!==void 0?this.cone.material.color.set(this.color):this.cone.material.color.copy(this.light.color)}}const Ql=new K,lx=new St,lE=new St;class cme extends Yo{constructor(e){const n=C6(e),r=new Lt,i=[],s=[],o=new Qe(0,0,1),a=new Qe(0,1,0);for(let c=0;c<n.length;c++){const u=n[c];u.parent&&u.parent.isBone&&(i.push(0,0,0),i.push(0,0,0),s.push(o.r,o.g,o.b),s.push(a.r,a.g,a.b))}r.setAttribute("position",new mt(i,3)),r.setAttribute("color",new mt(s,3));const l=new Si({vertexColors:!0,depthTest:!1,depthWrite:!1,toneMapped:!1,transparent:!0});super(r,l),this.isSkeletonHelper=!0,this.type="SkeletonHelper",this.root=e,this.bones=n,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1}updateMatrixWorld(e){const n=this.bones,r=this.geometry,i=r.getAttribute("position");lE.copy(this.root.matrixWorld).invert();for(let s=0,o=0;s<n.length;s++){const a=n[s];a.parent&&a.parent.isBone&&(lx.multiplyMatrices(lE,a.matrixWorld),Ql.setFromMatrixPosition(lx),i.setXYZ(o,Ql.x,Ql.y,Ql.z),lx.multiplyMatrices(lE,a.parent.matrixWorld),Ql.setFromMatrixPosition(lx),i.setXYZ(o+1,Ql.x,Ql.y,Ql.z),o+=2)}r.getAttribute("position").needsUpdate=!0,super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose()}}function C6(t){const e=[];t.isBone===!0&&e.push(t);for(let n=0;n<t.children.length;n++)e.push.apply(e,C6(t.children[n]));return e}class ume extends lr{constructor(e,n,r){const i=new D0(n,4,2),s=new Qi({wireframe:!0,fog:!1,toneMapped:!1});super(i,s),this.light=e,this.color=r,this.type="PointLightHelper",this.matrix=this.light.matrixWorld,this.matrixAutoUpdate=!1,this.update()}dispose(){this.geometry.dispose(),this.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.color!==void 0?this.material.color.set(this.color):this.material.color.copy(this.light.color)}}const dme=new K,sL=new Qe,oL=new Qe;class fme extends Zt{constructor(e,n,r){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r,this.type="HemisphereLightHelper";const i=new k0(n);i.rotateY(Math.PI*.5),this.material=new Qi({wireframe:!0,fog:!1,toneMapped:!1}),this.color===void 0&&(this.material.vertexColors=!0);const s=i.getAttribute("position"),o=new Float32Array(s.count*3);i.setAttribute("color",new en(o,3)),this.add(new lr(i,this.material)),this.update()}dispose(){this.children[0].geometry.dispose(),this.children[0].material.dispose()}update(){const e=this.children[0];if(this.color!==void 0)this.material.color.set(this.color);else{const n=e.geometry.getAttribute("color");sL.copy(this.light.color),oL.copy(this.light.groundColor);for(let r=0,i=n.count;r<i;r++){const s=r<i/2?sL:oL;n.setXYZ(r,s.r,s.g,s.b)}n.needsUpdate=!0}this.light.updateWorldMatrix(!0,!1),e.lookAt(dme.setFromMatrixPosition(this.light.matrixWorld).negate())}}class hme extends Yo{constructor(e=10,n=10,r=4473924,i=8947848){r=new Qe(r),i=new Qe(i);const s=n/2,o=e/n,a=e/2,l=[],c=[];for(let f=0,h=0,p=-a;f<=n;f++,p+=o){l.push(-a,0,p,a,0,p),l.push(p,0,-a,p,0,a);const x=f===s?r:i;x.toArray(c,h),h+=3,x.toArray(c,h),h+=3,x.toArray(c,h),h+=3,x.toArray(c,h),h+=3}const u=new Lt;u.setAttribute("position",new mt(l,3)),u.setAttribute("color",new mt(c,3));const d=new Si({vertexColors:!0,toneMapped:!1});super(u,d),this.type="GridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}class pme extends Yo{constructor(e=10,n=16,r=8,i=64,s=4473924,o=8947848){s=new Qe(s),o=new Qe(o);const a=[],l=[];if(n>1)for(let d=0;d<n;d++){const f=d/n*(Math.PI*2),h=Math.sin(f)*e,p=Math.cos(f)*e;a.push(0,0,0),a.push(h,0,p);const x=d&1?s:o;l.push(x.r,x.g,x.b),l.push(x.r,x.g,x.b)}for(let d=0;d<r;d++){const f=d&1?s:o,h=e-e/r*d;for(let p=0;p<i;p++){let x=p/i*(Math.PI*2),v=Math.sin(x)*h,y=Math.cos(x)*h;a.push(v,0,y),l.push(f.r,f.g,f.b),x=(p+1)/i*(Math.PI*2),v=Math.sin(x)*h,y=Math.cos(x)*h,a.push(v,0,y),l.push(f.r,f.g,f.b)}}const c=new Lt;c.setAttribute("position",new mt(a,3)),c.setAttribute("color",new mt(l,3));const u=new Si({vertexColors:!0,toneMapped:!1});super(c,u),this.type="PolarGridHelper"}dispose(){this.geometry.dispose(),this.material.dispose()}}const aL=new K,cx=new K,lL=new K;class mme extends Zt{constructor(e,n,r){super(),this.light=e,this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.color=r,this.type="DirectionalLightHelper",n===void 0&&(n=1);let i=new Lt;i.setAttribute("position",new mt([-n,n,0,n,n,0,n,-n,0,-n,-n,0,-n,n,0],3));const s=new Si({fog:!1,toneMapped:!1});this.lightPlane=new bl(i,s),this.add(this.lightPlane),i=new Lt,i.setAttribute("position",new mt([0,0,0,0,0,1],3)),this.targetLine=new bl(i,s),this.add(this.targetLine),this.update()}dispose(){this.lightPlane.geometry.dispose(),this.lightPlane.material.dispose(),this.targetLine.geometry.dispose(),this.targetLine.material.dispose()}update(){this.light.updateWorldMatrix(!0,!1),this.light.target.updateWorldMatrix(!0,!1),aL.setFromMatrixPosition(this.light.matrixWorld),cx.setFromMatrixPosition(this.light.target.matrixWorld),lL.subVectors(cx,aL),this.lightPlane.lookAt(cx),this.color!==void 0?(this.lightPlane.material.color.set(this.color),this.targetLine.material.color.set(this.color)):(this.lightPlane.material.color.copy(this.light.color),this.targetLine.material.color.copy(this.light.color)),this.targetLine.lookAt(cx),this.targetLine.scale.z=lL.length()}}const ux=new K,tr=new T0;class gme extends Yo{constructor(e){const n=new Lt,r=new Si({color:16777215,vertexColors:!0,toneMapped:!1}),i=[],s=[],o={};a("n1","n2"),a("n2","n4"),a("n4","n3"),a("n3","n1"),a("f1","f2"),a("f2","f4"),a("f4","f3"),a("f3","f1"),a("n1","f1"),a("n2","f2"),a("n3","f3"),a("n4","f4"),a("p","n1"),a("p","n2"),a("p","n3"),a("p","n4"),a("u1","u2"),a("u2","u3"),a("u3","u1"),a("c","t"),a("p","c"),a("cn1","cn2"),a("cn3","cn4"),a("cf1","cf2"),a("cf3","cf4");function a(p,x){l(p),l(x)}function l(p){i.push(0,0,0),s.push(0,0,0),o[p]===void 0&&(o[p]=[]),o[p].push(i.length/3-1)}n.setAttribute("position",new mt(i,3)),n.setAttribute("color",new mt(s,3)),super(n,r),this.type="CameraHelper",this.camera=e,this.camera.updateProjectionMatrix&&this.camera.updateProjectionMatrix(),this.matrix=e.matrixWorld,this.matrixAutoUpdate=!1,this.pointMap=o,this.update();const c=new Qe(16755200),u=new Qe(16711680),d=new Qe(43775),f=new Qe(16777215),h=new Qe(3355443);this.setColors(c,u,d,f,h)}setColors(e,n,r,i,s){const a=this.geometry.getAttribute("color");a.setXYZ(0,e.r,e.g,e.b),a.setXYZ(1,e.r,e.g,e.b),a.setXYZ(2,e.r,e.g,e.b),a.setXYZ(3,e.r,e.g,e.b),a.setXYZ(4,e.r,e.g,e.b),a.setXYZ(5,e.r,e.g,e.b),a.setXYZ(6,e.r,e.g,e.b),a.setXYZ(7,e.r,e.g,e.b),a.setXYZ(8,e.r,e.g,e.b),a.setXYZ(9,e.r,e.g,e.b),a.setXYZ(10,e.r,e.g,e.b),a.setXYZ(11,e.r,e.g,e.b),a.setXYZ(12,e.r,e.g,e.b),a.setXYZ(13,e.r,e.g,e.b),a.setXYZ(14,e.r,e.g,e.b),a.setXYZ(15,e.r,e.g,e.b),a.setXYZ(16,e.r,e.g,e.b),a.setXYZ(17,e.r,e.g,e.b),a.setXYZ(18,e.r,e.g,e.b),a.setXYZ(19,e.r,e.g,e.b),a.setXYZ(20,e.r,e.g,e.b),a.setXYZ(21,e.r,e.g,e.b),a.setXYZ(22,e.r,e.g,e.b),a.setXYZ(23,e.r,e.g,e.b),a.setXYZ(24,n.r,n.g,n.b),a.setXYZ(25,n.r,n.g,n.b),a.setXYZ(26,n.r,n.g,n.b),a.setXYZ(27,n.r,n.g,n.b),a.setXYZ(28,n.r,n.g,n.b),a.setXYZ(29,n.r,n.g,n.b),a.setXYZ(30,n.r,n.g,n.b),a.setXYZ(31,n.r,n.g,n.b),a.setXYZ(32,r.r,r.g,r.b),a.setXYZ(33,r.r,r.g,r.b),a.setXYZ(34,r.r,r.g,r.b),a.setXYZ(35,r.r,r.g,r.b),a.setXYZ(36,r.r,r.g,r.b),a.setXYZ(37,r.r,r.g,r.b),a.setXYZ(38,i.r,i.g,i.b),a.setXYZ(39,i.r,i.g,i.b),a.setXYZ(40,s.r,s.g,s.b),a.setXYZ(41,s.r,s.g,s.b),a.setXYZ(42,s.r,s.g,s.b),a.setXYZ(43,s.r,s.g,s.b),a.setXYZ(44,s.r,s.g,s.b),a.setXYZ(45,s.r,s.g,s.b),a.setXYZ(46,s.r,s.g,s.b),a.setXYZ(47,s.r,s.g,s.b),a.setXYZ(48,s.r,s.g,s.b),a.setXYZ(49,s.r,s.g,s.b),a.needsUpdate=!0}update(){const e=this.geometry,n=this.pointMap,r=1,i=1;tr.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),dr("c",n,e,tr,0,0,-1),dr("t",n,e,tr,0,0,1),dr("n1",n,e,tr,-r,-i,-1),dr("n2",n,e,tr,r,-i,-1),dr("n3",n,e,tr,-r,i,-1),dr("n4",n,e,tr,r,i,-1),dr("f1",n,e,tr,-r,-i,1),dr("f2",n,e,tr,r,-i,1),dr("f3",n,e,tr,-r,i,1),dr("f4",n,e,tr,r,i,1),dr("u1",n,e,tr,r*.7,i*1.1,-1),dr("u2",n,e,tr,-r*.7,i*1.1,-1),dr("u3",n,e,tr,0,i*2,-1),dr("cf1",n,e,tr,-r,0,1),dr("cf2",n,e,tr,r,0,1),dr("cf3",n,e,tr,0,-i,1),dr("cf4",n,e,tr,0,i,1),dr("cn1",n,e,tr,-r,0,-1),dr("cn2",n,e,tr,r,0,-1),dr("cn3",n,e,tr,0,-i,-1),dr("cn4",n,e,tr,0,i,-1),e.getAttribute("position").needsUpdate=!0}dispose(){this.geometry.dispose(),this.material.dispose()}}function dr(t,e,n,r,i,s,o){ux.set(i,s,o).unproject(r);const a=e[t];if(a!==void 0){const l=n.getAttribute("position");for(let c=0,u=a.length;c<u;c++)l.setXYZ(a[c],ux.x,ux.y,ux.z)}}const dx=new vi;class yme extends Yo{constructor(e,n=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=new Float32Array(8*3),s=new Lt;s.setIndex(new en(r,1)),s.setAttribute("position",new en(i,3)),super(s,new Si({color:n,toneMapped:!1})),this.object=e,this.type="BoxHelper",this.matrixAutoUpdate=!1,this.update()}update(e){if(e!==void 0&&console.warn("THREE.BoxHelper: .update() has no longer arguments."),this.object!==void 0&&dx.setFromObject(this.object),dx.isEmpty())return;const n=dx.min,r=dx.max,i=this.geometry.attributes.position,s=i.array;s[0]=r.x,s[1]=r.y,s[2]=r.z,s[3]=n.x,s[4]=r.y,s[5]=r.z,s[6]=n.x,s[7]=n.y,s[8]=r.z,s[9]=r.x,s[10]=n.y,s[11]=r.z,s[12]=r.x,s[13]=r.y,s[14]=n.z,s[15]=n.x,s[16]=r.y,s[17]=n.z,s[18]=n.x,s[19]=n.y,s[20]=n.z,s[21]=r.x,s[22]=n.y,s[23]=n.z,i.needsUpdate=!0,this.geometry.computeBoundingSphere()}setFromObject(e){return this.object=e,this.update(),this}copy(e,n){return super.copy(e,n),this.object=e.object,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class vme extends Yo{constructor(e,n=16776960){const r=new Uint16Array([0,1,1,2,2,3,3,0,4,5,5,6,6,7,7,4,0,4,1,5,2,6,3,7]),i=[1,1,1,-1,1,1,-1,-1,1,1,-1,1,1,1,-1,-1,1,-1,-1,-1,-1,1,-1,-1],s=new Lt;s.setIndex(new en(r,1)),s.setAttribute("position",new mt(i,3)),super(s,new Si({color:n,toneMapped:!1})),this.box=e,this.type="Box3Helper",this.geometry.computeBoundingSphere()}updateMatrixWorld(e){const n=this.box;n.isEmpty()||(n.getCenter(this.position),n.getSize(this.scale),this.scale.multiplyScalar(.5),super.updateMatrixWorld(e))}dispose(){this.geometry.dispose(),this.material.dispose()}}class xme extends bl{constructor(e,n=1,r=16776960){const i=r,s=[1,-1,0,-1,1,0,-1,-1,0,1,1,0,-1,1,0,-1,-1,0,1,-1,0,1,1,0],o=new Lt;o.setAttribute("position",new mt(s,3)),o.computeBoundingSphere(),super(o,new Si({color:i,toneMapped:!1})),this.type="PlaneHelper",this.plane=e,this.size=n;const a=[1,1,0,-1,1,0,-1,-1,0,1,1,0,-1,-1,0,1,-1,0],l=new Lt;l.setAttribute("position",new mt(a,3)),l.computeBoundingSphere(),this.add(new lr(l,new Qi({color:i,opacity:.2,transparent:!0,depthWrite:!1,toneMapped:!1})))}updateMatrixWorld(e){this.position.set(0,0,0),this.scale.set(.5*this.size,.5*this.size,1),this.lookAt(this.plane.normal),this.translateZ(-this.plane.constant),super.updateMatrixWorld(e)}dispose(){this.geometry.dispose(),this.material.dispose(),this.children[0].geometry.dispose(),this.children[0].material.dispose()}}const cL=new K;let fx,cE;class bme extends Zt{constructor(e=new K(0,0,1),n=new K(0,0,0),r=1,i=16776960,s=r*.2,o=s*.2){super(),this.type="ArrowHelper",fx===void 0&&(fx=new Lt,fx.setAttribute("position",new mt([0,0,0,0,1,0],3)),cE=new bp(0,.5,1,5,1),cE.translate(0,-.5,0)),this.position.copy(n),this.line=new bl(fx,new Si({color:i,toneMapped:!1})),this.line.matrixAutoUpdate=!1,this.add(this.line),this.cone=new lr(cE,new Qi({color:i,toneMapped:!1})),this.cone.matrixAutoUpdate=!1,this.add(this.cone),this.setDirection(e),this.setLength(r,s,o)}setDirection(e){if(e.y>.99999)this.quaternion.set(0,0,0,1);else if(e.y<-.99999)this.quaternion.set(1,0,0,0);else{cL.set(e.z,0,-e.x).normalize();const n=Math.acos(e.y);this.quaternion.setFromAxisAngle(cL,n)}}setLength(e,n=e*.2,r=n*.2){this.line.scale.set(1,Math.max(1e-4,e-n),1),this.line.updateMatrix(),this.cone.scale.set(r,n,r),this.cone.position.y=e,this.cone.updateMatrix()}setColor(e){this.line.material.color.set(e),this.cone.material.color.set(e)}copy(e){return super.copy(e,!1),this.line.copy(e.line),this.cone.copy(e.cone),this}dispose(){this.line.geometry.dispose(),this.line.material.dispose(),this.cone.geometry.dispose(),this.cone.material.dispose()}}class Sme extends Yo{constructor(e=1){const n=[0,0,0,e,0,0,0,0,0,0,e,0,0,0,0,0,0,e],r=[1,0,0,1,.6,0,0,1,0,.6,1,0,0,0,1,0,.6,1],i=new Lt;i.setAttribute("position",new mt(n,3)),i.setAttribute("color",new mt(r,3));const s=new Si({vertexColors:!0,toneMapped:!1});super(i,s),this.type="AxesHelper"}setColors(e,n,r){const i=new Qe,s=this.geometry.attributes.color.array;return i.set(e),i.toArray(s,0),i.toArray(s,3),i.set(n),i.toArray(s,6),i.toArray(s,9),i.set(r),i.toArray(s,12),i.toArray(s,15),this.geometry.attributes.color.needsUpdate=!0,this}dispose(){this.geometry.dispose(),this.material.dispose()}}class _me{constructor(){this.type="ShapePath",this.color=new Qe,this.subPaths=[],this.currentPath=null}moveTo(e,n){return this.currentPath=new jg,this.subPaths.push(this.currentPath),this.currentPath.moveTo(e,n),this}lineTo(e,n){return this.currentPath.lineTo(e,n),this}quadraticCurveTo(e,n,r,i){return this.currentPath.quadraticCurveTo(e,n,r,i),this}bezierCurveTo(e,n,r,i,s,o){return this.currentPath.bezierCurveTo(e,n,r,i,s,o),this}splineThru(e){return this.currentPath.splineThru(e),this}toShapes(e){function n(y){const b=[];for(let S=0,w=y.length;S<w;S++){const E=y[S],A=new Zu;A.curves=E.curves,b.push(A)}return b}function r(y,b){const S=b.length;let w=!1;for(let E=S-1,A=0;A<S;E=A++){let T=b[E],I=b[A],N=I.x-T.x,M=I.y-T.y;if(Math.abs(M)>Number.EPSILON){if(M<0&&(T=b[A],N=-N,I=b[E],M=-M),y.y<T.y||y.y>I.y)continue;if(y.y===T.y){if(y.x===T.x)return!0}else{const P=M*(y.x-T.x)-N*(y.y-T.y);if(P===0)return!0;if(P<0)continue;w=!w}}else{if(y.y!==T.y)continue;if(I.x<=y.x&&y.x<=T.x||T.x<=y.x&&y.x<=I.x)return!0}}return w}const i=Aa.isClockWise,s=this.subPaths;if(s.length===0)return[];let o,a,l;const c=[];if(s.length===1)return a=s[0],l=new Zu,l.curves=a.curves,c.push(l),c;let u=!i(s[0].getPoints());u=e?!u:u;const d=[],f=[];let h=[],p=0,x;f[p]=void 0,h[p]=[];for(let y=0,b=s.length;y<b;y++)a=s[y],x=a.getPoints(),o=i(x),o=e?!o:o,o?(!u&&f[p]&&p++,f[p]={s:new Zu,p:x},f[p].s.curves=a.curves,u&&p++,h[p]=[]):h[p].push({h:a,p:x[0]});if(!f[0])return n(s);if(f.length>1){let y=!1,b=0;for(let S=0,w=f.length;S<w;S++)d[S]=[];for(let S=0,w=f.length;S<w;S++){const E=h[S];for(let A=0;A<E.length;A++){const T=E[A];let I=!0;for(let N=0;N<f.length;N++)r(T.p,f[N].p)&&(S!==N&&b++,I?(I=!1,d[N].push(T)):y=!0);I&&d[S].push(T)}}b>0&&y===!1&&(h=d)}let v;for(let y=0,b=f.length;y<b;y++){l=f[y].s,c.push(l),v=h[y];for(let S=0,w=v.length;S<w;S++)l.holes.push(v[S].h)}return c}}class wme extends Xo{constructor(e=1,n=1,r=1,i={}){console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'),super(e,n,{...i,count:r}),this.isWebGLMultipleRenderTargets=!0}get texture(){return this.textures}}typeof __THREE_DEVTOOLS__<"u"&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:C0}}));typeof window<"u"&&(window.__THREE__?console.warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__=C0);const Cme=Object.freeze(Object.defineProperty({__proto__:null,ACESFilmicToneMapping:mR,AddEquation:sc,AddOperation:G9,AdditiveAnimationBlendMode:ER,AdditiveBlending:r2,AgXToneMapping:X9,AlphaFormat:Z9,AlwaysCompare:v5,AlwaysDepth:O9,AlwaysStencilFunc:P2,AmbientLight:h6,AnimationAction:_6,AnimationClip:Xh,AnimationLoader:Tpe,AnimationMixer:eme,AnimationObjectGroup:Qpe,AnimationUtils:wpe,ArcCurve:G5,ArrayCamera:B5,ArrowHelper:bme,AttachedBindMode:o2,Audio:b6,AudioAnalyser:Gpe,AudioContext:rI,AudioListener:$pe,AudioLoader:Lpe,AxesHelper:Sme,BackSide:Fi,BasicDepthPacking:c5,BasicShadowMap:m9,BatchedMesh:z5,Bone:kS,BooleanKeyframeTrack:Dd,Box2:ome,Box3:vi,Box3Helper:vme,BoxGeometry:Pd,BoxHelper:yme,BufferAttribute:en,BufferGeometry:Lt,BufferGeometryLoader:v6,ByteType:J9,Cache:ol,Camera:T0,CameraHelper:gme,CanvasTexture:Xhe,CapsuleGeometry:BS,CatmullRomCurve3:H5,CineonToneMapping:W9,CircleGeometry:FS,ClampToEdgeWrapping:ws,Clock:iI,Color:Qe,ColorKeyframeTrack:JR,ColorManagement:gn,CompressedArrayTexture:Whe,CompressedCubeTexture:jhe,CompressedTexture:OS,CompressedTextureLoader:Mpe,ConeGeometry:$S,ConstantAlphaFactor:P9,ConstantColorFactor:I9,CubeCamera:M5,CubeReflectionMapping:xl,CubeRefractionMapping:Ac,CubeTexture:M0,CubeTextureLoader:Rpe,CubeUVReflectionMapping:yp,CubicBezierCurve:HR,CubicBezierCurve3:V5,CubicInterpolant:l6,CullFaceBack:n2,CullFaceFront:p9,CullFaceFrontBack:Bae,CullFaceNone:h9,Curve:Qo,CurvePath:j5,CustomBlending:g9,CustomToneMapping:j9,CylinderGeometry:bp,Cylindrical:sme,Data3DTexture:RR,DataArrayTexture:RS,DataTexture:bc,DataTextureLoader:Ipe,DataUtils:Gle,DecrementStencilOp:Wae,DecrementWrapStencilOp:Xae,DefaultLoadingManager:d6,DepthFormat:Ju,DepthStencilFormat:Uh,DepthTexture:kR,DetachedBindMode:q9,DirectionalLight:nI,DirectionalLightHelper:mme,DiscreteInterpolant:c6,DisplayP3ColorSpace:MS,DodecahedronGeometry:US,DoubleSide:Uo,DstAlphaFactor:E9,DstColorFactor:T9,DynamicCopyUsage:lle,DynamicDrawUsage:nle,DynamicReadUsage:sle,EdgesGeometry:X5,EllipseCurve:LS,EqualCompare:p5,EqualDepth:B9,EqualStencilFunc:Yae,EquirectangularReflectionMapping:Og,EquirectangularRefractionMapping:Lg,Euler:Is,EventDispatcher:ka,ExtrudeGeometry:GS,FileLoader:Ns,Float16BufferAttribute:Kle,Float32BufferAttribute:mt,FloatType:lo,Fog:PS,FogExp2:NS,FramebufferTexture:Vhe,FrontSide:Ia,Frustum:R0,GLBufferAttribute:ime,GLSL1:ule,GLSL3:k2,GreaterCompare:m5,GreaterDepth:$9,GreaterEqualCompare:y5,GreaterEqualDepth:F9,GreaterEqualStencilFunc:tle,GreaterStencilFunc:Zae,GridHelper:hme,Group:Ho,HalfFloatType:Bg,HemisphereLight:f6,HemisphereLightHelper:fme,IcosahedronGeometry:HS,ImageBitmapLoader:x6,ImageLoader:Jg,ImageUtils:w5,IncrementStencilOp:Vae,IncrementWrapStencilOp:jae,InstancedBufferAttribute:Vh,InstancedBufferGeometry:y6,InstancedInterleavedBuffer:rme,InstancedMesh:$R,Int16BufferAttribute:jle,Int32BufferAttribute:Xle,Int8BufferAttribute:Hle,IntType:yR,InterleavedBuffer:I0,InterleavedBufferAttribute:Mc,Interpolant:Sp,InterpolateDiscrete:zh,InterpolateLinear:md,InterpolateSmooth:Qx,InvertStencilOp:Kae,KeepStencilOp:_u,KeyframeTrack:Zo,LOD:U5,LatheGeometry:P0,Layers:Qu,LessCompare:h5,LessDepth:L9,LessEqualCompare:TR,LessEqualDepth:Dg,LessEqualStencilFunc:Qae,LessStencilFunc:Jae,Light:$c,LightProbe:g6,Line:bl,Line3:ame,LineBasicMaterial:Si,LineCurve:VR,LineCurve3:W5,LineDashedMaterial:s6,LineLoop:UR,LineSegments:Yo,LinearDisplayP3ColorSpace:A0,LinearFilter:or,LinearInterpolant:qR,LinearMipMapLinearFilter:zae,LinearMipMapNearestFilter:Uae,LinearMipmapLinearFilter:ao,LinearMipmapNearestFilter:Sh,LinearSRGBColorSpace:Ml,LinearToneMapping:H9,LinearTransfer:$g,Loader:_i,LoaderUtils:Ta,LoadingManager:YR,LoopOnce:s5,LoopPingPong:a5,LoopRepeat:o5,LuminanceAlphaFormat:n5,LuminanceFormat:t5,MOUSE:bu,Material:wr,MaterialLoader:JS,MathUtils:x5,Matrix3:$t,Matrix4:St,MaxEquation:b9,Mesh:lr,MeshBasicMaterial:Qi,MeshDepthMaterial:DR,MeshDistanceMaterial:OR,MeshLambertMaterial:r6,MeshMatcapMaterial:i6,MeshNormalMaterial:n6,MeshPhongMaterial:e6,MeshPhysicalMaterial:Da,MeshStandardMaterial:O0,MeshToonMaterial:t6,MinEquation:x9,MirroredRepeatWrapping:$h,MixOperation:z9,MultiplyBlending:s2,MultiplyOperation:E0,NearestFilter:Nr,NearestMipMapLinearFilter:$ae,NearestMipMapNearestFilter:Fae,NearestMipmapLinearFilter:Du,NearestMipmapNearestFilter:AS,NeutralToneMapping:K9,NeverCompare:f5,NeverDepth:D9,NeverStencilFunc:qae,NoBlending:cl,NoColorSpace:tl,NoToneMapping:Ca,NormalAnimationBlendMode:TS,NormalBlending:qu,NotEqualCompare:g5,NotEqualDepth:U9,NotEqualStencilFunc:ele,NumberKeyframeTrack:Wh,Object3D:Zt,ObjectLoader:Dpe,ObjectSpaceNormalMap:d5,OctahedronGeometry:k0,OneFactor:_9,OneMinusConstantAlphaFactor:k9,OneMinusConstantColorFactor:N9,OneMinusDstAlphaFactor:A9,OneMinusDstColorFactor:M9,OneMinusSrcAlphaFactor:U1,OneMinusSrcColorFactor:C9,OrthographicCamera:ba,P3Primaries:zg,PCFShadowMap:CS,PCFSoftShadowMap:ig,PMREMGenerator:D2,Path:jg,PerspectiveCamera:Hn,Plane:Ya,PlaneGeometry:kd,PlaneHelper:xme,PointLight:tI,PointLightHelper:ume,Points:zR,PointsMaterial:DS,PolarGridHelper:pme,PolyhedronGeometry:Fc,PositionalAudio:zpe,PropertyBinding:Yt,PropertyMixer:S6,QuadraticBezierCurve:WR,QuadraticBezierCurve3:jR,Quaternion:Hr,QuaternionKeyframeTrack:Rc,QuaternionLinearInterpolant:u6,RED_GREEN_RGTC2_Format:I2,RED_RGTC1_Format:i5,REVISION:C0,RGBADepthPacking:u5,RGBAFormat:Yi,RGBAIntegerFormat:wR,RGBA_ASTC_10x10_Format:C2,RGBA_ASTC_10x5_Format:S2,RGBA_ASTC_10x6_Format:_2,RGBA_ASTC_10x8_Format:w2,RGBA_ASTC_12x10_Format:E2,RGBA_ASTC_12x12_Format:A2,RGBA_ASTC_4x4_Format:h2,RGBA_ASTC_5x4_Format:p2,RGBA_ASTC_5x5_Format:m2,RGBA_ASTC_6x5_Format:g2,RGBA_ASTC_6x6_Format:y2,RGBA_ASTC_8x5_Format:v2,RGBA_ASTC_8x6_Format:x2,RGBA_ASTC_8x8_Format:b2,RGBA_BPTC_Format:Yx,RGBA_ETC2_EAC_Format:f2,RGBA_PVRTC_2BPPV1_Format:u2,RGBA_PVRTC_4BPPV1_Format:c2,RGBA_S3TC_DXT1_Format:Kx,RGBA_S3TC_DXT3_Format:qx,RGBA_S3TC_DXT5_Format:Jx,RGBFormat:e5,RGB_BPTC_SIGNED_Format:T2,RGB_BPTC_UNSIGNED_Format:M2,RGB_ETC1_Format:CR,RGB_ETC2_Format:d2,RGB_PVRTC_2BPPV1_Format:l2,RGB_PVRTC_4BPPV1_Format:a2,RGB_S3TC_DXT1_Format:Xx,RGFormat:r5,RGIntegerFormat:_R,RawShaderMaterial:Z5,Ray:Nd,Raycaster:w6,Rec709Primaries:Ug,RectAreaLight:p6,RedFormat:bR,RedIntegerFormat:SR,ReinhardToneMapping:V9,RenderTarget:C5,RepeatWrapping:Tc,ReplaceStencilOp:Hae,ReverseSubtractEquation:v9,RingGeometry:VS,SIGNED_RED_GREEN_RGTC2_Format:N2,SIGNED_RED_RGTC1_Format:R2,SRGBColorSpace:xs,SRGBTransfer:Tn,Scene:Wg,ShaderChunk:Gt,ShaderLib:Bo,ShaderMaterial:Ko,ShadowMaterial:Q5,Shape:Zu,ShapeGeometry:WS,ShapePath:_me,ShapeUtils:Aa,ShortType:Y9,Skeleton:N0,SkeletonHelper:cme,SkinnedMesh:FR,Source:Bu,Sphere:Zr,SphereGeometry:D0,Spherical:z2,SphericalHarmonics3:m6,SplineCurve:XR,SpotLight:eI,SpotLightHelper:lme,Sprite:$5,SpriteMaterial:BR,SrcAlphaFactor:$1,SrcAlphaSaturateFactor:R9,SrcColorFactor:w9,StaticCopyUsage:ale,StaticDrawUsage:Gg,StaticReadUsage:ile,StereoCamera:Bpe,StreamCopyUsage:cle,StreamDrawUsage:rle,StreamReadUsage:ole,StringKeyframeTrack:Od,SubtractEquation:y9,SubtractiveBlending:i2,TOUCH:Su,TangentSpaceNormalMap:Bc,TetrahedronGeometry:jS,Texture:Bn,TextureLoader:QR,TorusGeometry:XS,TorusKnotGeometry:KS,Triangle:Ss,TriangleFanDrawMode:z1,TriangleStripDrawMode:AR,TrianglesDrawMode:l5,TubeGeometry:qS,UVMapping:ES,Uint16BufferAttribute:IR,Uint32BufferAttribute:NR,Uint8BufferAttribute:Vle,Uint8ClampedBufferAttribute:Wle,Uniform:aI,UniformsGroup:nme,UniformsLib:Ye,UniformsUtils:T5,UnsignedByteType:Ea,UnsignedInt248Type:vp,UnsignedInt5999Type:Q9,UnsignedIntType:pd,UnsignedShort4444Type:vR,UnsignedShort5551Type:xR,UnsignedShortType:gR,VSMShadowMap:ko,Vector2:Re,Vector3:K,Vector4:vn,VectorKeyframeTrack:jh,VideoTexture:Hhe,WebGL3DRenderTarget:Ple,WebGLArrayRenderTarget:Nle,WebGLCoordinateSystem:xa,WebGLCubeRenderTarget:R5,WebGLMultipleRenderTargets:wme,WebGLRenderTarget:Xo,WebGLRenderer:LR,WebGLUtils:L5,WebGPUCoordinateSystem:Hg,WireframeGeometry:Y5,WrapAroundEnding:Fg,ZeroCurvatureEnding:Ou,ZeroFactor:S9,ZeroSlopeEnding:Lu,ZeroStencilOp:Gae,createCanvasElement:S5},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Eme=1e-7,Ame=1e-4;class Tme{constructor(e,n){this.backend=e,this.dataMover=n,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,n){this.dataIdsCount++,this.data.set(e,n)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class E6{refCount(e){return ys("refCount")}incRef(e){return ys("incRef")}timerAvailable(){return!0}time(e){return ys("time")}read(e){return ys("read")}readSync(e){return ys("readSync")}readToGPU(e,n){return ys("readToGPU")}numDataIds(){return ys("numDataIds")}disposeData(e,n){return ys("disposeData")}write(e,n,r){return ys("write")}move(e,n,r,i,s){return ys("move")}memory(){return ys("memory")}floatPrecision(){return ys("floatPrecision")}epsilon(){return this.floatPrecision()===32?Eme:Ame}dispose(){return ys("dispose")}}function ys(t){throw new Error(`'${t}' not yet implemented or not found in the registry. This kernel may not be supported by the tfjs backend you have chosen`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H1(t,e,n){return Math.max(t,Math.min(e,n))}function lI(t){return t%2===0?t:t+1}function Mm(t,e,n){const r=t[e];t[e]=t[n],t[n]=r}function Mme(t){let e=0;for(let n=0;n<t.length;n++)e+=t[n];return e}function Y(t,e){if(!t)throw new Error(typeof e=="string"?e:e())}function Ls(t,e,n=""){Y(Yn(t,e),()=>n+` Shapes ${t} and ${e} must match`)}function _p(t){Y(t!=null,()=>"The input to the tensor constructor must be a non-null value.")}function Kh(t,e=[],n=!1){if(e==null&&(e=[]),Array.isArray(t)||Na(t)&&!n)for(let r=0;r<t.length;++r)Kh(t[r],e,n);else e.push(t);return e}function Ve(t){if(t.length===0)return 1;let e=t[0];for(let n=1;n<t.length;n++)e*=t[n];return e}function Yn(t,e){if(t===e)return!0;if(t==null||e==null||t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function qh(t){return t%1===0}function G2(t){const e=Math.ceil(Math.sqrt(t));return[e,Math.ceil(t/e)]}function wh(t,e){return e<=t.length?t:t+" ".repeat(e-t.length)}function uL(t,e=i=>0,n,r=setTimeout){return new Promise((i,s)=>{let o=0;const a=()=>{if(t()){i();return}o++;const l=e(o);if(n!=null&&o>=n){s();return}r(a,l)};a()})}function Rme(t,e){let n=1,r=-1;for(let s=0;s<t.length;++s)if(t[s]>=0)n*=t[s];else if(t[s]===-1){if(r!==-1)throw Error(`Shapes can only have 1 implicit size. Found -1 at dim ${r} and dim ${s}`);r=s}else if(t[s]<0)throw Error(`Shapes can not be < 0. Found ${t[s]} at dim ${s}`);if(r===-1){if(e>0&&e!==n)throw Error(`Size(${e}) must match the product of shape ${t}`);return t}if(n===0)throw Error(`Cannot infer the missing size in [${t}] when there are 0 elements`);if(e%n!==0)throw Error(`The implicit shape can't be a fractional number. Got ${e} / ${n}`);const i=t.slice();return i[r]=e/n,i}function Dr(t,e){const n=e.length;return t=t==null?e.map((r,i)=>i):[].concat(t),Y(t.every(r=>r>=-n&&r<n),()=>`All values in axis param must be in range [-${n}, ${n}) but got axis ${t}`),Y(t.every(r=>qh(r)),()=>`All values in axis param must be integers but got axis ${t}`),t.map(r=>r<0?n+r:r)}function Uc(t,e){const n=[],r=[],i=e!=null&&Array.isArray(e)&&e.length===0,s=e==null||i?null:Dr(e,t).sort();let o=0;for(let a=0;a<t.length;++a){if(s!=null){if(s[o]===a&&t[a]!==1)throw new Error(`Can't squeeze axis ${a} since its dim '${t[a]}' is not 1`);(s[o]==null||s[o]>a)&&t[a]===1&&(n.push(t[a]),r.push(a)),s[o]<=a&&o++}t[a]!==1&&(n.push(t[a]),r.push(a))}return{newShape:n,keptDims:r}}function Sl(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else throw new Error(`Unknown data type ${t}`);return n}function Oi(t,e){let n=null;if(t==null||t==="float32")n=new Float32Array(e);else if(t==="int32")n=new Int32Array(e);else if(t==="bool")n=new Uint8Array(e);else if(t==="string")n=new Array(e);else throw new Error(`Unknown data type ${t}`);return n}function Ime(t,e){for(let n=0;n<t.length;n++){const r=t[n];if(isNaN(r)||!isFinite(r))throw Error(`A tensor of type ${e} being uploaded contains ${r}.`)}}function Nme(t){return t==="bool"||t==="complex64"||t==="float32"||t==="int32"||t==="string"}function Pme(t,e){return!(e==="complex64"||e==="float32"&&t!=="complex64"||e==="int32"&&t!=="float32"&&t!=="complex64"||e==="bool"&&t==="bool")}function Na(t){return t instanceof Float32Array||t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray}function H2(t){if(t==="float32"||t==="int32")return 4;if(t==="complex64")return 8;if(t==="bool")return 1;throw new Error(`Unknown dtype ${t}`)}function kme(t){if(t==null)return 0;let e=0;return t.forEach(n=>e+=n.length),e}function YS(t){return typeof t=="string"||t instanceof String}function Dme(t){return typeof t=="boolean"}function Ome(t){return typeof t=="number"}function QS(t){return Array.isArray(t)?QS(t[0]):t instanceof Float32Array?"float32":t instanceof Int32Array||t instanceof Uint8Array||t instanceof Uint8ClampedArray?"int32":Ome(t)?"float32":YS(t)?"string":Dme(t)?"bool":"float32"}function dL(t){return!!(t&&t.constructor&&t.call&&t.apply)}function V2(t,e){for(let n=e;n<t;++n)if(t%n===0)return n;return t}function Vr(t){const e=t.length;if(e<2)return[];const n=new Array(e-1);n[e-2]=t[e-1];for(let r=e-3;r>=0;--r)n[r]=n[r+1]*t[r+1];return n}function A6(t,e,n,r=!1){const i=new Array;if(e.length===1){const s=e[0]*(r?2:1);for(let o=0;o<s;o++)i[o]=n[t+o]}else{const s=e[0],o=e.slice(1),a=o.reduce((l,c)=>l*c)*(r?2:1);for(let l=0;l<s;l++)i[l]=A6(t+l*a,o,n,r)}return i}function W2(t,e,n=!1){if(t.length===0)return e[0];const r=t.reduce((i,s)=>i*s)*(n?2:1);if(r===0)return[];if(r!==e.length)throw new Error(`[${t}] does not match the input size ${e.length}${n?" for a complex tensor":""}.`);return A6(0,t,e,n)}function T6(t,e){const n=Ic(t,e);for(let r=0;r<n.length;r++)n[r]=1;return n}function Ic(t,e){if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool")return new Uint8Array(t);throw new Error(`Unknown data type ${e}`)}function M6(t){t.forEach(e=>{Y(Number.isInteger(e)&&e>=0,()=>`Tensor must have a shape comprised of positive integers but got shape [${t}].`)})}function j2(t,e,n){if(e===0)return 0;if(e===1)return t[0];let r=t[t.length-1];for(let i=0;i<t.length-1;++i)r+=n[i]*t[i];return r}function cI(t,e,n){if(e===0)return[];if(e===1)return[t];const r=new Array(e);for(let i=0;i<r.length-1;++i)r[i]=Math.floor(t/n[i]),t-=r[i]*n[i];return r[r.length-1]=t,r}function Jh(t){return t&&t.then&&typeof t.then=="function"}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fL="tfjsflags";class Lme{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Bme,this.populateURLFlags()}setPlatform(e,n){this.platform!=null&&(ge().getBool("IS_TEST")||ge().getBool("PROD")||console.warn(`Platform ${this.platformName} has already been set. Overwriting the platform with ${e}.`)),this.platformName=e,this.platform=n}registerFlag(e,n,r){if(this.flagRegistry[e]={evaluationFn:n,setHook:r},this.urlFlags[e]!=null){const i=this.urlFlags[e];ge().getBool("IS_TEST")||ge().getBool("PROD")||console.warn(`Setting feature override from URL ${e}: ${i}.`),this.set(e,i)}}async getAsync(e){return e in this.flags?this.flags[e]:(this.flags[e]=await this.evaluateFlag(e),this.flags[e])}get(e){if(e in this.flags)return this.flags[e];const n=this.evaluateFlag(e);if(Jh(n))throw new Error(`Flag ${e} cannot be synchronously evaluated. Please use getAsync() instead.`);return this.flags[e]=n,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,n){if(this.flagRegistry[e]==null)throw new Error(`Cannot set flag ${e} as it has not been registered.`);this.flags[e]=n,this.flagRegistry[e].setHook!=null&&this.flagRegistry[e].setHook(n)}evaluateFlag(e){if(this.flagRegistry[e]==null)throw new Error(`Cannot evaluate flag '${e}': no evaluation function found.`);return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if(typeof this.global>"u"||typeof this.global.location>"u"||typeof this.global.location.search>"u")return;const e=this.getQueryParams(this.global.location.search);fL in e&&e[fL].split(",").forEach(r=>{const[i,s]=r.split(":");this.urlFlags[i]=$me(i,s)})}}function Bme(t){const e={};return t.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(n,...r)=>(Fme(e,r[0],r[1]),r.join("="))),e}function Fme(t,e,n){t[decodeURIComponent(e)]=decodeURIComponent(n||"")}function $me(t,e){if(e=e.toLowerCase(),e==="true"||e==="false")return e==="true";if(`${+e}`===e)return+e;throw new Error(`Could not parse value flag value ${e} for flag ${t}.`)}function ge(){return R6}let R6=null;function Ume(t){R6=t}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let uE;function I6(){if(uE==null){let t;if(typeof window<"u")t=window;else if(typeof global<"u")t=global;else if(typeof process<"u")t=process;else if(typeof self<"u")t=self;else throw new Error("Could not find a global object");uE=t}return uE}function zme(){const t=I6();return t._tfGlobals==null&&(t._tfGlobals=new Map),t._tfGlobals}function uI(t,e){const n=zme();if(n.has(t))return n.get(t);{const r=e();return n.set(t,r),n.get(t)}}const N6="Abs",P6="Acos",k6="Acosh",dI="Add",D6="AddN",O6="All",L6="Any",B6="ArgMax",F6="ArgMin",$6="Asin",U6="Asinh",z6="Atan",G6="Atanh",H6="Atan2",V6="AvgPool",Gme="AvgPoolGrad",W6="AvgPool3D",Hme="AvgPool3DGrad",j6="BatchMatMul",X6="BatchToSpaceND",K6="Bincount",q6="BroadcastArgs",fI="Cast",J6="Ceil",Y6="ClipByValue",Q6="Complex",Z6="ComplexAbs",ez="Concat",tz="Conv2D",nz="Conv2DBackpropFilter",rz="Conv2DBackpropInput",iz="Conv3D",Vme="Conv3DBackpropFilterV2",sz="Conv3DBackpropInputV2",oz="Cos",az="Cosh",lz="Cumprod",cz="Cumsum",uz="CropAndResize",dz="DenseBincount",fz="DepthToSpace",hz="DepthwiseConv2dNative",pz="DepthwiseConv2dNativeBackpropFilter",mz="DepthwiseConv2dNativeBackpropInput",gz="Diag",yz="Dilation2D",vz="RealDiv",xz="Einsum",bz="Elu",Wme="EluGrad",Sz="Erf",_z="Equal",wz="Exp",Cz="ExpandDims",Ez="Expm1",Az="FFT",Tz="Fill",Mz="FlipLeftRight",Rz="Floor",Iz="FloorDiv",Nz="FusedBatchNorm",Pz="GatherV2",kz="GatherNd",Dz="Greater",Oz="GreaterEqual",hI="Identity",Lz="IFFT",Bz="Imag",Fz="IsFinite",$z="IsInf",Uz="IsNan",zz="LeakyRelu",Gz="Less",Hz="LessEqual",Vz="LinSpace",Wz="Log",jz="Log1p",Xz="LogicalAnd",Kz="LogicalNot",qz="LogicalOr",Jz="LRN",jme="LRNGrad",Yz="Max",Qz="Maximum",Zz="MaxPool",Xme="MaxPoolGrad",e8="MaxPool3D",Kme="MaxPool3DGrad",t8="MaxPoolWithArgmax",n8="Mean",r8="Min",i8="Minimum",s8="MirrorPad",o8="Mod",a8="Multinomial",l8="Multiply",c8="Neg",u8="NotEqual",d8="NonMaxSuppressionV3",f8="NonMaxSuppressionV4",h8="NonMaxSuppressionV5",p8="OnesLike",m8="OneHot",g8="Pack",y8="PadV2",v8="Pow",x8="Prelu",b8="Prod",S8="RaggedGather",_8="RaggedTensorToTensor",w8="Range",C8="Real",E8="Reciprocal",A8="Relu",T8="Reshape",M8="ResizeNearestNeighbor",qme="ResizeNearestNeighborGrad",R8="ResizeBilinear",Jme="ResizeBilinearGrad",I8="Relu6",N8="Reverse",P8="Round",k8="Rsqrt",D8="ScatterNd",O8="SearchSorted",L8="Select",B8="Selu",F8="Slice",$8="Sin",U8="Sinh",z8="Sign",G8="Sigmoid",H8="Softplus",V8="Sqrt",W8="Sum",j8="SpaceToBatchND",X8="SplitV",K8="Softmax",q8="SparseFillEmptyRows",J8="SparseReshape",Y8="SparseSegmentMean",Q8="SparseSegmentSum",Z8="SparseToDense",eG="SquaredDifference",Yme="Square",tG="StridedSlice",nG="StringNGrams",rG="StringSplit",iG="StringToHashBucketFast",sG="Sub",oG="Tan",aG="Tanh",pI="Tile",lG="TopK",cG="Transform",e1="Transpose",uG="Unique",dG="Unpack",fG="UnsortedSegmentSum",hG="ZerosLike",pG="Step",X2="FromPixels",mG="RotateWithOffset",K2="_FusedMatMul",q2="FusedConv2D",J2="FusedDepthwiseConv2D";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zo(...t){ge().getBool("IS_TEST")||ge().getBool("PROD")||console.warn(...t)}function Qme(...t){ge().getBool("IS_TEST")||ge().getBool("PROD")||console.log(...t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const V1=uI("kernelRegistry",()=>new Map),Zme=uI("gradRegistry",()=>new Map);function Y2(t,e){const n=gG(t,e);return V1.get(n)}function hL(t){return Zme.get(t)}function pL(t){const e=V1.entries(),n=[];for(;;){const{done:r,value:i}=e.next();if(r)break;const[s,o]=i,[a]=s.split("_");a===t&&n.push(o)}return n}function ege(t){const{kernelName:e,backendName:n}=t,r=gG(e,n);V1.has(r)&&zo(`The kernel '${e}' for backend '${n}' is already registered`),V1.set(r,t)}function gG(t,e){return`${e}_${t}`}var yG=Nn,co=null;try{co=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch{}function Nn(t,e,n){this.low=t|0,this.high=e|0,this.unsigned=!!n}Nn.prototype.__isLong__;Object.defineProperty(Nn.prototype,"__isLong__",{value:!0});function as(t){return(t&&t.__isLong__)===!0}Nn.isLong=as;var mL={},gL={};function Ld(t,e){var n,r,i;return e?(t>>>=0,(i=0<=t&&t<256)&&(r=gL[t],r)?r:(n=Pn(t,(t|0)<0?-1:0,!0),i&&(gL[t]=n),n)):(t|=0,(i=-128<=t&&t<128)&&(r=mL[t],r)?r:(n=Pn(t,t<0?-1:0,!1),i&&(mL[t]=n),n))}Nn.fromInt=Ld;function uo(t,e){if(isNaN(t))return e?$u:fo;if(e){if(t<0)return $u;if(t>=vG)return SG}else{if(t<=-vL)return Zi;if(t+1>=vL)return bG}return t<0?uo(-t,e).neg():Pn(t%Yh|0,t/Yh|0,e)}Nn.fromNumber=uo;function Pn(t,e,n){return new Nn(t,e,n)}Nn.fromBits=Pn;var W1=Math.pow;function mI(t,e,n){if(t.length===0)throw Error("empty string");if(t==="NaN"||t==="Infinity"||t==="+Infinity"||t==="-Infinity")return fo;if(typeof e=="number"?(n=e,e=!1):e=!!e,n=n||10,n<2||36<n)throw RangeError("radix");var r;if((r=t.indexOf("-"))>0)throw Error("interior hyphen");if(r===0)return mI(t.substring(1),e,n).neg();for(var i=uo(W1(n,8)),s=fo,o=0;o<t.length;o+=8){var a=Math.min(8,t.length-o),l=parseInt(t.substring(o,o+a),n);if(a<8){var c=uo(W1(n,a));s=s.mul(c).add(uo(l))}else s=s.mul(i),s=s.add(uo(l))}return s.unsigned=e,s}Nn.fromString=mI;function ea(t,e){return typeof t=="number"?uo(t,e):typeof t=="string"?mI(t,e):Pn(t.low,t.high,typeof e=="boolean"?e:t.unsigned)}Nn.fromValue=ea;var yL=65536,tge=1<<24,Yh=yL*yL,vG=Yh*Yh,vL=vG/2,xL=Ld(tge),fo=Ld(0);Nn.ZERO=fo;var $u=Ld(0,!0);Nn.UZERO=$u;var ch=Ld(1);Nn.ONE=ch;var xG=Ld(1,!0);Nn.UONE=xG;var Q2=Ld(-1);Nn.NEG_ONE=Q2;var bG=Pn(-1,2147483647,!1);Nn.MAX_VALUE=bG;var SG=Pn(-1,-1,!0);Nn.MAX_UNSIGNED_VALUE=SG;var Zi=Pn(0,-2147483648,!1);Nn.MIN_VALUE=Zi;var Xe=Nn.prototype;Xe.toInt=function(){return this.unsigned?this.low>>>0:this.low};Xe.toNumber=function(){return this.unsigned?(this.high>>>0)*Yh+(this.low>>>0):this.high*Yh+(this.low>>>0)};Xe.toString=function(e){if(e=e||10,e<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative())if(this.eq(Zi)){var n=uo(e),r=this.div(n),i=r.mul(n).sub(this);return r.toString(e)+i.toInt().toString(e)}else return"-"+this.neg().toString(e);for(var s=uo(W1(e,6),this.unsigned),o=this,a="";;){var l=o.div(s),c=o.sub(l.mul(s)).toInt()>>>0,u=c.toString(e);if(o=l,o.isZero())return u+a;for(;u.length<6;)u="0"+u;a=""+u+a}};Xe.getHighBits=function(){return this.high};Xe.getHighBitsUnsigned=function(){return this.high>>>0};Xe.getLowBits=function(){return this.low};Xe.getLowBitsUnsigned=function(){return this.low>>>0};Xe.getNumBitsAbs=function(){if(this.isNegative())return this.eq(Zi)?64:this.neg().getNumBitsAbs();for(var e=this.high!=0?this.high:this.low,n=31;n>0&&!(e&1<<n);n--);return this.high!=0?n+33:n+1};Xe.isZero=function(){return this.high===0&&this.low===0};Xe.eqz=Xe.isZero;Xe.isNegative=function(){return!this.unsigned&&this.high<0};Xe.isPositive=function(){return this.unsigned||this.high>=0};Xe.isOdd=function(){return(this.low&1)===1};Xe.isEven=function(){return(this.low&1)===0};Xe.equals=function(e){return as(e)||(e=ea(e)),this.unsigned!==e.unsigned&&this.high>>>31===1&&e.high>>>31===1?!1:this.high===e.high&&this.low===e.low};Xe.eq=Xe.equals;Xe.notEquals=function(e){return!this.eq(e)};Xe.neq=Xe.notEquals;Xe.ne=Xe.notEquals;Xe.lessThan=function(e){return this.comp(e)<0};Xe.lt=Xe.lessThan;Xe.lessThanOrEqual=function(e){return this.comp(e)<=0};Xe.lte=Xe.lessThanOrEqual;Xe.le=Xe.lessThanOrEqual;Xe.greaterThan=function(e){return this.comp(e)>0};Xe.gt=Xe.greaterThan;Xe.greaterThanOrEqual=function(e){return this.comp(e)>=0};Xe.gte=Xe.greaterThanOrEqual;Xe.ge=Xe.greaterThanOrEqual;Xe.compare=function(e){if(as(e)||(e=ea(e)),this.eq(e))return 0;var n=this.isNegative(),r=e.isNegative();return n&&!r?-1:!n&&r?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1};Xe.comp=Xe.compare;Xe.negate=function(){return!this.unsigned&&this.eq(Zi)?Zi:this.not().add(ch)};Xe.neg=Xe.negate;Xe.add=function(e){as(e)||(e=ea(e));var n=this.high>>>16,r=this.high&65535,i=this.low>>>16,s=this.low&65535,o=e.high>>>16,a=e.high&65535,l=e.low>>>16,c=e.low&65535,u=0,d=0,f=0,h=0;return h+=s+c,f+=h>>>16,h&=65535,f+=i+l,d+=f>>>16,f&=65535,d+=r+a,u+=d>>>16,d&=65535,u+=n+o,u&=65535,Pn(f<<16|h,u<<16|d,this.unsigned)};Xe.subtract=function(e){return as(e)||(e=ea(e)),this.add(e.neg())};Xe.sub=Xe.subtract;Xe.multiply=function(e){if(this.isZero())return fo;if(as(e)||(e=ea(e)),co){var n=co.mul(this.low,this.high,e.low,e.high);return Pn(n,co.get_high(),this.unsigned)}if(e.isZero())return fo;if(this.eq(Zi))return e.isOdd()?Zi:fo;if(e.eq(Zi))return this.isOdd()?Zi:fo;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(xL)&&e.lt(xL))return uo(this.toNumber()*e.toNumber(),this.unsigned);var r=this.high>>>16,i=this.high&65535,s=this.low>>>16,o=this.low&65535,a=e.high>>>16,l=e.high&65535,c=e.low>>>16,u=e.low&65535,d=0,f=0,h=0,p=0;return p+=o*u,h+=p>>>16,p&=65535,h+=s*u,f+=h>>>16,h&=65535,h+=o*c,f+=h>>>16,h&=65535,f+=i*u,d+=f>>>16,f&=65535,f+=s*c,d+=f>>>16,f&=65535,f+=o*l,d+=f>>>16,f&=65535,d+=r*u+i*c+s*l+o*a,d&=65535,Pn(h<<16|p,d<<16|f,this.unsigned)};Xe.mul=Xe.multiply;Xe.divide=function(e){if(as(e)||(e=ea(e)),e.isZero())throw Error("division by zero");if(co){if(!this.unsigned&&this.high===-2147483648&&e.low===-1&&e.high===-1)return this;var n=(this.unsigned?co.div_u:co.div_s)(this.low,this.high,e.low,e.high);return Pn(n,co.get_high(),this.unsigned)}if(this.isZero())return this.unsigned?$u:fo;var r,i,s;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return $u;if(e.gt(this.shru(1)))return xG;s=$u}else{if(this.eq(Zi)){if(e.eq(ch)||e.eq(Q2))return Zi;if(e.eq(Zi))return ch;var o=this.shr(1);return r=o.div(e).shl(1),r.eq(fo)?e.isNegative()?ch:Q2:(i=this.sub(e.mul(r)),s=r.add(i.div(e)),s)}else if(e.eq(Zi))return this.unsigned?$u:fo;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=fo}for(i=this;i.gte(e);){r=Math.max(1,Math.floor(i.toNumber()/e.toNumber()));for(var a=Math.ceil(Math.log(r)/Math.LN2),l=a<=48?1:W1(2,a-48),c=uo(r),u=c.mul(e);u.isNegative()||u.gt(i);)r-=l,c=uo(r,this.unsigned),u=c.mul(e);c.isZero()&&(c=ch),s=s.add(c),i=i.sub(u)}return s};Xe.div=Xe.divide;Xe.modulo=function(e){if(as(e)||(e=ea(e)),co){var n=(this.unsigned?co.rem_u:co.rem_s)(this.low,this.high,e.low,e.high);return Pn(n,co.get_high(),this.unsigned)}return this.sub(this.div(e).mul(e))};Xe.mod=Xe.modulo;Xe.rem=Xe.modulo;Xe.not=function(){return Pn(~this.low,~this.high,this.unsigned)};Xe.and=function(e){return as(e)||(e=ea(e)),Pn(this.low&e.low,this.high&e.high,this.unsigned)};Xe.or=function(e){return as(e)||(e=ea(e)),Pn(this.low|e.low,this.high|e.high,this.unsigned)};Xe.xor=function(e){return as(e)||(e=ea(e)),Pn(this.low^e.low,this.high^e.high,this.unsigned)};Xe.shiftLeft=function(e){return as(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Pn(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):Pn(0,this.low<<e-32,this.unsigned)};Xe.shl=Xe.shiftLeft;Xe.shiftRight=function(e){return as(e)&&(e=e.toInt()),(e&=63)===0?this:e<32?Pn(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):Pn(this.high>>e-32,this.high>=0?0:-1,this.unsigned)};Xe.shr=Xe.shiftRight;Xe.shiftRightUnsigned=function(e){if(as(e)&&(e=e.toInt()),e&=63,e===0)return this;var n=this.high;if(e<32){var r=this.low;return Pn(r>>>e|n<<32-e,n>>>e,this.unsigned)}else return e===32?Pn(n,0,this.unsigned):Pn(n>>>e-32,0,this.unsigned)};Xe.shru=Xe.shiftRightUnsigned;Xe.shr_u=Xe.shiftRightUnsigned;Xe.toSigned=function(){return this.unsigned?Pn(this.low,this.high,!1):this};Xe.toUnsigned=function(){return this.unsigned?this:Pn(this.low,this.high,!0)};Xe.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()};Xe.toBytesLE=function(){var e=this.high,n=this.low;return[n&255,n>>>8&255,n>>>16&255,n>>>24,e&255,e>>>8&255,e>>>16&255,e>>>24]};Xe.toBytesBE=function(){var e=this.high,n=this.low;return[e>>>24,e>>>16&255,e>>>8&255,e&255,n>>>24,n>>>16&255,n>>>8&255,n&255]};Nn.fromBytes=function(e,n,r){return r?Nn.fromBytesLE(e,n):Nn.fromBytesBE(e,n)};Nn.fromBytesLE=function(e,n){return new Nn(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,n)};Nn.fromBytesBE=function(e,n){return new Nn(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],n)};const _G=Ed(yG),nge=iF({__proto__:null,default:_G},[yG]);/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Tu=_G||nge;function ZS(t){return Tu.fromString(t,!0,16)}const wG=ZS("c3a5c85c97cb3127"),Cu=ZS("b492b66fbe98f273"),mi=ZS("9ae16a3b2f90404f");function Z2(t){return t.xor(t.shru(47))}function CG(t,e,n){const r=t.slice(e,e+n);return Tu.fromBytes(Array.from(r),!0,!0)}function En(t,e){return CG(t,e,8)}function bL(t,e){return CG(t,e,4)}function Rr(t,e){return e===0?t:t.shru(e).or(t.shl(64-e))}function Sc(t,e,n=ZS("9ddfea08eb382d69")){let r=t.xor(e).mul(n);r=r.xor(r.shru(47));let i=e.xor(r).mul(n);return i=i.xor(i.shru(47)),i=i.mul(n),i}function rge(t,e,n,r,i,s){i=i.add(t),s=Rr(s.add(i).add(r),21);const o=i;return i=i.add(e),i=i.add(n),s=s.add(Rr(i,44)),[i.add(r),s.add(o)]}function hx(t,e,n,r){return rge(En(t,e),En(t,e+8),En(t,e+16),En(t,e+24),n,r)}function ige(t,e=t.length){if(e>=8){const n=mi.add(e*2),r=En(t,0).add(mi),i=En(t,e-8),s=Rr(i,37).mul(n).add(r),o=Rr(r,25).add(i).mul(n);return Sc(s,o,n)}if(e>=4){const n=mi.add(e*2),r=bL(t,0);return Sc(r.shl(3).add(e),bL(t,e-4),n)}if(e>0){const n=t[0],r=t[e>>1],i=t[e-1],s=n+(r<<8),o=e+(i<<2);return Z2(mi.mul(s).xor(wG.mul(o))).mul(mi)}return mi}function sge(t,e=t.length){const n=mi.add(e*2),r=En(t,0).mul(Cu),i=En(t,8),s=En(t,e-8).mul(n),o=En(t,e-16).mul(mi);return Sc(Rr(r.add(i),43).add(Rr(s,30)).add(o),r.add(Rr(i.add(mi),18)).add(s),n)}function oge(t,e=t.length){const n=mi.add(e*2),r=En(t,0).mul(mi),i=En(t,8),s=En(t,e-8).mul(n),o=En(t,e-16).mul(mi),a=Rr(r.add(i),43).add(Rr(s,30)).add(o),l=Sc(a,r.add(Rr(i.add(mi),18)).add(s),n),c=En(t,16).mul(n),u=En(t,24),d=a.add(En(t,e-32)).mul(n),f=l.add(En(t,e-24)).mul(n);return Sc(Rr(c.add(u),43).add(Rr(d,30)).add(f),c.add(Rr(u.add(r),18)).add(d),n)}function age(t,e=t.length){const n=Tu.fromNumber(81,!0);if(e<=32)return e<=16?ige(t,e):sge(t,e);if(e<=64)return oge(t,e);let r=n,i=n.mul(Cu).add(113),s=Z2(i.mul(mi).add(113)).mul(mi),o=[Tu.UZERO,Tu.UZERO],a=[Tu.UZERO,Tu.UZERO];r=r.mul(mi).add(En(t,0));let l=0;const c=(e-1>>6)*64,u=c+(e-1&63)-63;do r=Rr(r.add(i).add(o[0]).add(En(t,l+8)),37).mul(Cu),i=Rr(i.add(o[1]).add(En(t,l+48)),42).mul(Cu),r=r.xor(a[1]),i=i.add(o[0]).add(En(t,l+40)),s=Rr(s.add(a[0]),33).mul(Cu),o=hx(t,l,o[1].mul(Cu),r.add(a[0])),a=hx(t,l+32,s.add(a[1]),i.add(En(t,l+16))),[s,r]=[r,s],l+=64;while(l!==c);const d=Cu.add(s.and(255).shl(1));return l=u,a[0]=a[0].add(e-1&63),o[0]=o[0].add(a[0]),a[0]=a[0].add(o[0]),r=Rr(r.add(i).add(o[0]).add(En(t,l+8)),37).mul(d),i=Rr(i.add(o[1]).add(En(t,l+48)),42).mul(d),r=r.xor(a[1].mul(9)),i=i.add(o[0].mul(9).add(En(t,l+40))),s=Rr(s.add(a[0]),33).mul(d),o=hx(t,l,o[1].mul(d),r.add(a[0])),a=hx(t,l+32,s.add(a[1]),i.add(En(t,l+16))),[s,r]=[r,s],Sc(Sc(o[0],a[0],d).add(Z2(i).mul(wG)).add(s),Sc(o[1],a[1],d).add(r),d)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wp(t,e){return e==="string"?ed(t):e_([t],e)}function lge(t,e){return t instanceof Float32Array&&e==="float32"||t instanceof Int32Array&&e==="int32"||t instanceof Uint8Array&&e==="bool"}function e_(t,e){if(e==="string")throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(t)&&(t=Kh(t)),ge().getBool("DEBUG")&&Ime(t,e),lge(t,e))return t;if(e==null||e==="float32"||e==="complex64")return new Float32Array(t);if(e==="int32")return new Int32Array(t);if(e==="bool"){const n=new Uint8Array(t.length);for(let r=0;r<n.length;++r)Math.round(t[r])!==0&&(n[r]=1);return n}else throw new Error(`Unknown data type ${e}`)}function Oo(){return ge().platform.now()}function ed(t,e="utf-8"){return e=e||"utf-8",ge().platform.encode(t,e)}function Qh(t,e="utf-8"){return e=e||"utf-8",ge().platform.decode(t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class cge{constructor(e,n){this.backendTimer=e,this.logger=n,n==null&&(this.logger=new dge)}profileKernel(e,n,r){let i;const s=()=>{i=r()};let o;const a=Oo();if(this.backendTimer.timerAvailable())o=this.backendTimer.time(s);else{s();for(const c of i)c.dataSync();o=Promise.resolve({kernelMs:Oo()-a})}if(ge().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let c=0;c<i.length;c++){const u=i[c];u.data().then(d=>{uge(d,u.dtype,e)})}return{kernelName:e,outputs:i,inputs:n,timeMs:o.then(c=>c.kernelMs),extraInfo:o.then(c=>c.getExtraProfileInfo!=null?c.getExtraProfileInfo():"")}}logKernelProfile(e){const{kernelName:n,outputs:r,timeMs:i,inputs:s,extraInfo:o}=e;r.forEach(a=>{Promise.all([a.data(),i,o]).then(l=>{this.logger.logKernelProfile(n,a,l[0],l[1],s,l[2])})})}}function uge(t,e,n){if(e!=="float32")return!1;for(let r=0;r<t.length;r++){const i=t[r];if(isNaN(i)||!isFinite(i))return console.warn(`Found ${i} in the result of '${n}'`),!0}return!1}class dge{logKernelProfile(e,n,r,i,s,o){const a=typeof i=="number"?wh(`${i}ms`,9):i.error,l=wh(e,25),c=n.rank,u=n.size,d=wh(n.shape.toString(),14);let f="";for(const h in s){const p=s[h];if(p!=null){const x=p.shape||n.shape,v=x.length;f+=`${h}: ${v}D ${v>0?x:""} `}}console.log(`%c${l}	%c${a}	%c${c}D ${d}	%c${u}	%c${f}	%c${o}`,"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fge(t,e,n){const r={},i={};for(let l=0;l<e.length;l++)r[e[l].id]=!0;for(let l=0;l<t.length;l++){const c=t[l],u=c.inputs;for(const d in u){const f=u[d];let h=!1;for(let p=0;p<e.length;p++)if(r[f.id]){c.outputs.forEach(x=>r[x.id]=!0),h=!0,i[c.id]=!0;break}if(h)break}}const s={};s[n.id]=!0;const o={};for(let l=t.length-1;l>=0;l--){const c=t[l],u=c.inputs;for(let d=0;d<c.outputs.length;d++)if(s[c.outputs[d].id]){for(const f in u)s[u[f].id]=!0,o[c.id]=!0;break}}const a=[];for(let l=0;l<t.length;l++){const c=t[l];if(i[c.id]&&o[c.id]){const u={};for(const f in c.inputs){const h=c.inputs[f];r[h.id]&&(u[f]=h)}const d=Object.assign({},c);d.inputs=u,d.outputs=c.outputs,a.push(d)}}return a}function hge(t,e,n,r){for(let i=e.length-1;i>=0;i--){const s=e[i],o=[];if(s.outputs.forEach(l=>{const c=t[l.id];c!=null?o.push(c):o.push(null)}),s.gradient==null)throw new Error(`Cannot compute gradient: gradient function not found for ${s.kernelName}.`);const a=s.gradient(o);for(const l in s.inputs){if(!(l in a))throw new Error(`Cannot backprop through input ${l}. Available gradients found: ${Object.keys(a)}.`);const c=n(()=>a[l]());if(c.dtype!=="float32")throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input ${l} must have 'float32' dtype, but has '${c.dtype}'`);const u=s.inputs[l];if(!Yn(c.shape,u.shape))throw new Error(`Error in gradient for op ${s.kernelName}. The gradient of input '${l}' has shape '${c.shape}', which does not match the shape of the input '${u.shape}'`);if(t[u.id]==null)t[u.id]=c;else{const d=t[u.id];t[u.id]=r(d,c),d.dispose()}}}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SL=20,Rm=3,dE=7;function pge(t,e,n,r){const i=Vr(e),s=mge(t,e,n,i),o=e.length,a=t1(t,e,n,i,s),l=["Tensor"];return r&&(l.push(`  dtype: ${n}`),l.push(`  rank: ${o}`),l.push(`  shape: [${e}]`),l.push("  values:")),l.push(a.map(c=>"    "+c).join(`
`)),l.join(`
`)}function mge(t,e,n,r){const i=Ve(e),s=r[r.length-1],o=new Array(s).fill(0),a=e.length,l=n==="complex64"?Hm(t):t;if(a>1)for(let c=0;c<i/s;c++){const u=c*s;for(let d=0;d<s;d++)o[d]=Math.max(o[d],Gm(l[u+d],0,n).length)}return o}function Gm(t,e,n){let r;return Array.isArray(t)?r=`${parseFloat(t[0].toFixed(dE))} + ${parseFloat(t[1].toFixed(dE))}j`:YS(t)?r=`'${t}'`:n==="bool"?r=EG(t):r=parseFloat(t.toFixed(dE)).toString(),wh(r,e)}function EG(t){return t===0?"false":"true"}function t1(t,e,n,r,i,s=!0){const o=n==="complex64"?2:1,a=e[0],l=e.length;if(l===0){if(n==="complex64"){const x=Hm(t);return[Gm(x[0],0,n)]}return n==="bool"?[EG(t[0])]:[t[0].toString()]}if(l===1){if(a>SL){const v=Rm*o;let y=Array.from(t.slice(0,v)),b=Array.from(t.slice((a-Rm)*o,a*o));return n==="complex64"&&(y=Hm(y),b=Hm(b)),["["+y.map((S,w)=>Gm(S,i[w],n)).join(", ")+", ..., "+b.map((S,w)=>Gm(S,i[a-Rm+w],n)).join(", ")+"]"]}return["["+(n==="complex64"?Hm(t):Array.from(t)).map((v,y)=>Gm(v,i[y],n)).join(", ")+"]"]}const c=e.slice(1),u=r.slice(1),d=r[0]*o,f=[];if(a>SL){for(let x=0;x<Rm;x++){const v=x*d,y=v+d;f.push(...t1(t.slice(v,y),c,n,u,i,!1))}f.push("...");for(let x=a-Rm;x<a;x++){const v=x*d,y=v+d;f.push(...t1(t.slice(v,y),c,n,u,i,x===a-1))}}else for(let x=0;x<a;x++){const v=x*d,y=v+d;f.push(...t1(t.slice(v,y),c,n,u,i,x===a-1))}const h=l===2?",":"";f[0]="["+f[0]+h;for(let x=1;x<f.length-1;x++)f[x]=" "+f[x]+h;let p=`,
`;for(let x=2;x<l;x++)p+=`
`;return f[f.length-1]=" "+f[f.length-1]+"]"+(s?"":p),f}function Hm(t){const e=[];for(let n=0;n<t.length;n+=2)e.push([t[n],t[n+1]]);return e}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Yg{constructor(e,n,r){if(this.dtype=n,this.shape=e.slice(),this.size=Ve(e),r!=null){const i=r.length;Y(i===this.size,()=>`Length of values '${i}' does not match the size inferred by the shape '${this.size}'.`)}if(n==="complex64")throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=r||Oi(n,this.size),this.strides=Vr(e)}set(e,...n){n.length===0&&(n=[0]),Y(n.length===this.rank,()=>`The number of provided coordinates (${n.length}) must match the rank (${this.rank})`);const r=this.locToIndex(n);this.values[r]=e}get(...e){e.length===0&&(e=[0]);let n=0;for(const i of e){if(i<0||i>=this.shape[n]){const s=`Requested out of range element at ${e}.   Buffer shape=${this.shape}`;throw new Error(s)}n++}let r=e[e.length-1];for(let i=0;i<e.length-1;++i)r+=this.strides[i]*e[i];return this.values[r]}locToIndex(e){if(this.rank===0)return 0;if(this.rank===1)return e[0];let n=e[e.length-1];for(let r=0;r<e.length-1;++r)n+=this.strides[r]*e[r];return n}indexToLoc(e){if(this.rank===0)return[];if(this.rank===1)return[e];const n=new Array(this.shape.length);for(let r=0;r<n.length-1;++r)n[r]=Math.floor(e/this.strides[r]),e-=n[r]*this.strides[r];return n[n.length-1]=e,n}get rank(){return this.shape.length}toTensor(){return Fo().makeTensor(this.values,this.shape,this.dtype)}}let Fo=null,Uf=null;function gge(t){Fo=t}function yge(t){Uf=t}class Mn{constructor(e,n,r,i){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=n||"float32",this.size=Ve(e),this.strides=Vr(e),this.dataId=r,this.id=i,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Uf.buffer(this.shape,this.dtype,e)}bufferSync(){return Uf.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return W2(this.shape,e,this.dtype==="complex64")}arraySync(){return W2(this.shape,this.dataSync(),this.dtype==="complex64")}async data(){this.throwIfDisposed();const e=Fo().read(this.dataId);if(this.dtype==="string"){const n=await e;try{return n.map(r=>Qh(r))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Fo().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Fo().readSync(this.dataId);if(this.dtype==="string")try{return e.map(n=>Qh(n))}catch{throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Fo().read(this.dataId);return this.dtype==="string"?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(Fo().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(e=!1){return Uf.print(this,e)}clone(){return this.throwIfDisposed(),Uf.clone(this)}toString(e=!1){const n=this.dataSync();return pge(n,this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Uf.cast(this,e)}variable(e=!0,n,r){return this.throwIfDisposed(),Fo().makeVariable(this,e,n,r)}}Object.defineProperty(Mn,Symbol.hasInstance,{value:t=>!!t&&t.data!=null&&t.dataSync!=null&&t.throwIfDisposed!=null});function vge(){return uI("Tensor",()=>Mn)}vge();class eT extends Mn{constructor(e,n,r,i){super(e.shape,e.dtype,e.dataId,i),this.trainable=n,this.name=r}assign(e){if(e.dtype!==this.dtype)throw new Error(`dtype of the new value (${e.dtype}) and previous value (${this.dtype}) must match`);if(!Yn(e.shape,this.shape))throw new Error(`shape of the new value (${e.shape}) and previous value (${this.shape}) must match`);Fo().disposeTensor(this),this.dataId=e.dataId,Fo().incRef(this,null)}dispose(){Fo().disposeVariable(this),this.isDisposedInternal=!0}}Object.defineProperty(eT,Symbol.hasInstance,{value:t=>t instanceof Mn&&t.assign!=null&&t.assign instanceof Function});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var _L;(function(t){t.R0="R0",t.R1="R1",t.R2="R2",t.R3="R3",t.R4="R4",t.R5="R5",t.R6="R6"})(_L||(_L={}));var tT;(function(t){t.float32="float32",t.int32="int32",t.bool="int32",t.complex64="complex64"})(tT||(tT={}));var nT;(function(t){t.float32="float32",t.int32="int32",t.bool="bool",t.complex64="complex64"})(nT||(nT={}));var rT;(function(t){t.float32="float32",t.int32="float32",t.bool="float32",t.complex64="complex64"})(rT||(rT={}));var iT;(function(t){t.float32="complex64",t.int32="complex64",t.bool="complex64",t.complex64="complex64"})(iT||(iT={}));const xge={float32:rT,int32:tT,bool:nT,complex64:iT};function Pa(t,e){if(t==="string"||e==="string"){if(t==="string"&&e==="string")return"string";throw new Error(`Can not upcast ${t} with ${e}`)}return xge[t][e]}function gI(t){return Pa(t,"int32")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qn(t,e){if(t.dtype===e.dtype)return[t,e];const n=Pa(t.dtype,e.dtype);return[t.cast(n),e.cast(n)]}function bge(t,e){Y(t.dtype===e.dtype,()=>`The dtypes of the first(${t.dtype}) and second(${e.dtype}) input must match`)}function AG(t){const e=[];return TG(t,e,new Set),e}function TG(t,e,n){if(t==null)return;if(t instanceof Mn){e.push(t);return}if(!Sge(t))return;const r=t;for(const i in r){const s=r[i];n.has(s)||(n.add(s),TG(s,e,n))}}function Sge(t){return Array.isArray(t)||typeof t=="object"}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fE(t){return t.kernelName!=null}class wL{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map(e=>e.name)))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class Zh{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new wL}async ready(){if(this.pendingBackendInit!=null)return this.pendingBackendInit.then(()=>{});if(this.backendInstance!=null)return;const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n];if(await this.initializeBackend(r).success){await this.setBackend(r);return}}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(this.pendingBackendInit!=null)throw new Error(`Backend '${this.backendName}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);if(this.backendInstance==null){const{name:e,asyncInit:n}=this.initializeBackendsAndReturnBest();if(n)throw new Error(`The highest priority backend '${e}' has not yet been initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods`);this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry))if(e in this.registryFactory){const{asyncInit:n}=this.initializeBackend(e);if(n)return null}else return null;return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,n,r=1){return e in this.registryFactory?(zo(`${e} backend was already registered. Reusing existing backend factory.`),!1):(this.registryFactory[e]={factory:n,priority:r},!0)}async setBackend(e){if(this.registryFactory[e]==null)throw new Error(`Backend name '${e}' not found in registry`);if(this.backendName=e,this.registry[e]==null){this.backendInstance=null;const{success:n,asyncInit:r}=this.initializeBackend(e);if(!(r?await n:n))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new cge(this.backendInstance),!0}setupRegisteredKernels(){pL(this.backendName).forEach(n=>{n.setupFunc!=null&&n.setupFunc(this.backendInstance)})}disposeRegisteredKernels(e){pL(e).forEach(r=>{r.disposeFunc!=null&&r.disposeFunc(this.registry[e])})}initializeBackend(e){const n=this.registryFactory[e];if(n==null)throw new Error(`Cannot initialize backend ${e}, no registration found.`);try{const r=n.factory();if(r&&!(r instanceof E6)&&typeof r.then=="function"){const i=++this.pendingBackendInitId,s=r.then(o=>i<this.pendingBackendInitId?!1:(this.registry[e]=o,this.pendingBackendInit=null,!0)).catch(o=>(i<this.pendingBackendInitId||(this.pendingBackendInit=null,zo(`Initialization of backend ${e} failed`),zo(o.stack||o.message)),!1));return this.pendingBackendInit=s,{success:s,asyncInit:!0}}else return this.registry[e]=r,{success:!0,asyncInit:!1}}catch(r){return zo(`Initialization of backend ${e} failed`),zo(r.stack||r.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error(`${e} backend not found in registry`);this.backendName===e&&this.pendingBackendInit!=null&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(Object.keys(this.registryFactory).length===0)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort((e,n)=>this.registryFactory[n].priority-this.registryFactory[e].priority)}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let n=0;n<e.length;n++){const r=e[n],{success:i,asyncInit:s}=this.initializeBackend(r);if(s||i)return{name:r,asyncInit:s}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,n){const r=this.state.tensorInfo.get(n),i=r.backend,s=this.readSync(n),o=i.refCount(n);i.disposeData(n,!0),r.backend=e,e.move(n,s,r.shape,r.dtype,o),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,n){let r=null;if(n==null){if(typeof e!="function")throw new Error("Please provide a function to tidy()");n=e}else{if(typeof e!="string"&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if(typeof n!="function")throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");r=e}let i;return this.scopedRun(()=>this.startScope(r),()=>this.endScope(i),()=>(i=n(),i instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),i))}scopedRun(e,n,r){e();try{const i=r();return n(),i}catch(i){throw n(),i}}nextTensorId(){return Zh.nextTensorId++}nextVariableId(){return Zh.nextVariableId++}clone(e){const n=oe.runKernel(hI,{x:e}),r={x:e},i=o=>({x:()=>{const a="float32",l={x:o},c={dtype:a};return oe.runKernel(fI,l,c)}}),s=[];return this.addTapeNode(this.state.activeScope.name,r,[n],i,s,{}),n}runKernel(e,n,r){if(this.backendName==null&&this.backend,!(Y2(e,this.backendName)!=null))throw new Error(`Kernel '${e}' not registered for backend '${this.backendName}'`);return this.runKernelFunc({kernelName:e,inputs:n,attrs:r})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,n,r){const i=this.backend.numDataIds();let s=0;r.forEach(l=>{s+=l.dtype==="complex64"?3:1});const o=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],a=i-n-s-o;if(a>0)throw new Error(`Backend '${this.backendName}' has an internal memory leak (${a} data ids) after running '${e}'`)}runKernelFunc(e){let n,r=[];const i=this.isTapeOn(),s=this.state.numBytes,o=this.state.numTensors;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0);let a;this.backendName==null&&this.backend;let l;const c=fE(e)?e.kernelName:this.state.activeScope!=null?this.state.activeScope.name:"";if(fE(e)){const{kernelName:p,inputs:x,attrs:v}=e;this.backendName==null&&this.backend;const y=Y2(p,this.backendName);Y(y!=null,()=>`Cannot find registered kernel '${p}' for backend '${this.backendName}'`),a=()=>{const b=this.backend.numDataIds();l=y.kernelFunc({inputs:x,attrs:v,backend:this.backend});const S=Array.isArray(l)?l:[l];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(p,b,S);const w=S.map(E=>E.rank!=null?E:this.makeTensorFromTensorInfo(E));if(i){const E=this.getTensorsForGradient(p,x,w);r=this.saveTensorsForBackwardMode(E)}return w}}else{const{forwardFunc:p}=e,x=v=>{i&&(r=v.map(y=>this.keep(this.clone(y))))};a=()=>{const v=this.backend.numDataIds();l=this.tidy(()=>p(this.backend,x));const y=Array.isArray(l)?l:[l];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,v,y),y}}const{inputs:u,attrs:d}=e,f=fE(e)?null:e.backwardsFunc;let h;return this.scopedRun(()=>this.state.kernelDepth++,()=>this.state.kernelDepth--,()=>{!this.ENV.getBool("DEBUG")&&!this.state.profiling?n=a():(h=this.profiler.profileKernel(c,u,()=>a()),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(h),n=h.outputs)}),i&&this.addTapeNode(c,u,n,f,r,d),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-s,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-o,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(u).map(p=>u[p]!=null?u[p].shape:null),outputShapes:n.map(p=>p.shape),kernelTimeMs:h.timeMs,extraInfo:h.extraInfo}),Array.isArray(l)?n:n[0]}saveTensorsForBackwardMode(e){return e.map(r=>this.keep(this.clone(r)))}getTensorsForGradient(e,n,r){const i=hL(e);if(i!=null){const s=i.inputsToSave||[],o=i.outputsToSave||[];let a;i.saveAllInputs?(Y(Array.isArray(n),()=>"saveAllInputs is true, expected inputs to be an array."),a=Object.keys(n).map(c=>n[c])):a=s.map(c=>n[c]);const l=r.filter((c,u)=>o[u]);return a.concat(l)}return[]}makeTensor(e,n,r,i){if(e==null)throw new Error("Values passed to engine.makeTensor() are null");r=r||"float32",i=i||this.backend;let s=e;r==="string"&&YS(e[0])&&(s=e.map(l=>ed(l)));const o=i.write(s,n,r),a=new Mn(n,r,o,this.nextTensorId());if(this.trackTensor(a,i),r==="string"){const l=this.state.tensorInfo.get(o),c=kme(s);this.state.numBytes+=c-l.bytes,l.bytes=c}return a}makeTensorFromDataId(e,n,r,i){r=r||"float32";const s={dataId:e,shape:n,dtype:r};return this.makeTensorFromTensorInfo(s,i)}makeTensorFromTensorInfo(e,n){const{dataId:r,shape:i,dtype:s}=e,o=new Mn(i,s,r,this.nextTensorId());return this.trackTensor(o,n),o}makeVariable(e,n=!0,r,i){r=r||this.nextVariableId().toString(),i!=null&&i!==e.dtype&&(e=e.cast(i));const s=new eT(e,n,r,this.nextTensorId());if(this.state.registeredVariables[s.name]!=null)throw new Error(`Variable with name ${s.name} was already registered`);return this.state.registeredVariables[s.name]=s,this.incRef(s,this.backend),s}trackTensor(e,n){this.state.numTensors++,e.dtype==="string"&&this.state.numStringTensors++;let r=0;e.dtype!=="complex64"&&e.dtype!=="string"&&(r=e.size*H2(e.dtype)),this.state.numBytes+=r,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:n||this.backend,dtype:e.dtype,shape:e.shape,bytes:r})),e instanceof eT||this.track(e)}incRef(e,n){this.trackTensor(e,n),this.backend.incRef(e.dataId)}removeDataId(e,n){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===n&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const n=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,e.dtype==="string"&&(this.state.numStringTensors--,this.state.numBytes-=n.bytes),e.dtype!=="complex64"&&e.dtype!=="string"){const r=e.size*H2(e.dtype);this.state.numBytes-=r}n.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,n.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const n=this.state.registeredVariables[e];this.disposeVariable(n)}}disposeVariable(e){this.disposeTensor(e),this.state.registeredVariables[e.name]!=null&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,e.reasons==null&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const n=this.state.numBytes,r=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map(i=>i.totalBytesSnapshot)),this.state.activeProfile.newBytes=this.state.numBytes-n,this.state.activeProfile.newTensors=this.state.numTensors-r;for(const i of this.state.activeProfile.kernels)i.kernelTimeMs=await i.kernelTimeMs,i.extraInfo=await i.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&this.state.kernelDepth===0}addTapeNode(e,n,r,i,s,o){const a={id:this.state.nextTapeNodeId++,kernelName:e,inputs:n,outputs:r,saved:s},l=hL(e);l!=null&&(i=l.gradFunc),i!=null&&(a.gradient=c=>(c=c.map((u,d)=>{if(u==null){const f=r[d],h=Ic(f.size,f.dtype);return this.makeTensor(h,f.shape,f.dtype)}return u}),i(c.length>1?c:c[0],s,o))),this.state.activeTape.push(a)}keep(e){return e.kept=!0,e}startTape(){this.state.gradientDepth===0&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const n={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(n.name=e),this.state.scopeStack.push(n),this.state.activeScope=n}endScope(e){const n=AG(e),r=new Set(n.map(s=>s.id));for(let s=0;s<this.state.activeScope.track.length;s++){const o=this.state.activeScope.track[s];!o.kept&&!r.has(o.id)&&o.dispose()}const i=this.state.scopeStack.pop();this.state.activeScope=this.state.scopeStack.length===0?null:this.state.scopeStack[this.state.scopeStack.length-1],n.forEach(s=>{!s.kept&&s.scopeId===i.id&&this.track(s)})}gradients(e,n,r,i=!1){if(Y(n.length>0,()=>"gradients() received an empty list of xs."),r!=null&&r.dtype!=="float32")throw new Error(`dy must have 'float32' dtype, but has '${r.dtype}'`);const s=this.scopedRun(()=>this.startTape(),()=>this.endTape(),()=>this.tidy("forward",e));Y(s instanceof Mn,()=>"The result y returned by f() must be a tensor.");const o=fge(this.state.activeTape,n,s);if(!i&&o.length===0&&n.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",()=>{const a={};a[s.id]=r??_ge(s.shape),hge(a,o,c=>this.tidy(c),wge);const l=n.map(c=>a[c.id]);return this.state.gradientDepth===0&&(this.state.activeTape.forEach(c=>{for(const u of c.saved)u.dispose()}),this.state.activeTape=null),{value:s,grads:l}})}customGrad(e){return Y(dL(e),()=>"The f passed in customGrad(f) must be a function."),(...n)=>{Y(n.every(a=>a instanceof Mn),()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors");let r;const i={};n.forEach((a,l)=>{i[l]=a});const s=(a,l)=>(r=e(...n,l),Y(r.value instanceof Mn,()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor"),Y(dL(r.gradFunc),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function."),r.value),o=(a,l)=>{const c=r.gradFunc(a,l),u=Array.isArray(c)?c:[c];Y(u.length===n.length,()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...)."),Y(u.every(f=>f instanceof Mn),()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors.");const d={};return u.forEach((f,h)=>{d[h]=()=>f}),d};return this.runKernelFunc({forwardFunc:s,backwardsFunc:o,inputs:i})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,n){return this.state.tensorInfo.get(e).backend.readToGPU(e,n)}async time(e){const n=Oo(),r=await this.backend.time(e);return r.wallMs=Oo()-n,r}track(e){return this.state.activeScope!=null&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new wL;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}Zh.nextTensorId=0;Zh.nextVariableId=0;function _ge(t){const e=T6(Ve(t),"float32");return oe.makeTensor(e,t,"float32")}function MG(){const t=I6();if(t._tfengine==null){const e=new Lme(t);t._tfengine=new Zh(e)}return Ume(t._tfengine.ENV),gge(()=>t._tfengine),t._tfengine}const oe=MG();function wge(t,e){const n={a:t,b:e};return oe.runKernel(dI,n)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cge(){return typeof navigator<"u"&&navigator!=null}function RG(t){if(t||Cge()){if(t||(t=navigator),t.product==="ReactNative")return!0;const e=t.userAgent||t.vendor||(typeof window<"u"?window.opera:"");if(!e){const n=t;return n.userAgentData&&n.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(e)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(e.substr(0,4))}return!1}function IG(){return typeof window<"u"&&window.document!=null||typeof WorkerGlobalScope<"u"}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ss=ge();ss.registerFlag("DEBUG",()=>!1,t=>{t&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")});ss.registerFlag("IS_BROWSER",()=>IG());ss.registerFlag("IS_NODE",()=>typeof process<"u"&&typeof process.versions<"u"&&typeof process.versions.node<"u");ss.registerFlag("IS_CHROME",()=>typeof navigator<"u"&&navigator!=null&&navigator.userAgent!=null&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor));ss.registerFlag("PROD",()=>!1);ss.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",()=>ss.getBool("DEBUG"));ss.registerFlag("DEPRECATION_WARNINGS_ENABLED",()=>!0);ss.registerFlag("IS_TEST",()=>!1);ss.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",()=>!0);ss.registerFlag("WRAP_TO_IMAGEBITMAP",()=>!1);ss.registerFlag("ENGINE_COMPILE_ONLY",()=>!1);ss.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",()=>!1);ss.registerFlag("USE_SETTIMEOUTCUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zc(t,e){let n=t;if(Na(t))return e==="string"?[]:[t.length];if(!Array.isArray(t))return[];const r=[];for(;Array.isArray(n)||Na(n)&&e!=="string";)r.push(n.length),n=n[0];return Array.isArray(t)&&ge().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&NG(t,r,[]),r}function NG(t,e,n){if(n=n||[],!Array.isArray(t)&&!Na(t)){Y(e.length===0,()=>`Element arr[${n.join("][")}] is a primitive, but should be an array/TypedArray of ${e[0]} elements`);return}Y(e.length>0,()=>`Element arr[${n.join("][")}] should be a primitive, but is an array of ${t.length} elements`),Y(t.length===e[0],()=>`Element arr[${n.join("][")}] should have ${e[0]} elements, but has ${t.length} elements`);const r=e.slice(1);for(let i=0;i<t.length;++i)NG(t[i],r,n.concat(i))}function CL(t,e,n,r){if(t!=="string_or_numeric"){if(t==null)throw new Error("Expected dtype cannot be null.");if(t!=="numeric"&&t!==e||t==="numeric"&&e==="string")throw new Error(`Argument '${n}' passed to '${r}' must be ${t} tensor, but got ${e} tensor`)}}function z(t,e,n,r="numeric"){if(t instanceof Mn)return CL(r,t.dtype,e,n),t;let i=QS(t);if(i!=="string"&&["bool","int32","float32"].indexOf(r)>=0&&(i=r),CL(r,i,e,n),t==null||!Na(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string"){const l=t==null?"null":t.constructor.name;throw new Error(`Argument '${e}' passed to '${n}' must be a Tensor or TensorLike, but got '${l}'`)}const s=zc(t,i);!Na(t)&&!Array.isArray(t)&&(t=[t]);const a=i!=="string"?e_(t,i):Kh(t,[],!0);return oe.makeTensor(a,s,i)}function j1(t,e,n,r="numeric"){if(!Array.isArray(t))throw new Error(`Argument ${e} passed to ${n} must be a \`Tensor[]\` or \`TensorLike[]\``);return t.map((s,o)=>z(s,`${e}[${o}]`,n,r))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PG="__op";function ee(t){const e=Object.keys(t);if(e.length!==1)throw new Error(`Please provide an object with a single key (operation name) mapping to a function. Got an object with ${e.length} keys.`);let n=e[0];const r=t[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n=n+PG;const i=(...s)=>{oe.startScope(n);try{const o=r(...s);return Jh(o)&&console.error("Cannot return a Promise inside of tidy."),oe.endScope(o),o}catch(o){throw oe.endScope(null),o}};return Object.defineProperty(i,"name",{value:n,configurable:!0}),i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ege(t,e){const n=z(t,"real","complex"),r=z(e,"imag","complex");Ls(n.shape,r.shape,`real and imag shapes, ${n.shape} and ${r.shape}, must match in call to tf.complex().`);const i={real:n,imag:r};return oe.runKernel(Q6,i)}const Nc=ee({complex_:Ege});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gc(t,e,n,r){if(r==null&&(r=QS(t)),r==="complex64")throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Na(t)&&!Array.isArray(t)&&typeof t!="number"&&typeof t!="boolean"&&typeof t!="string")throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(e!=null){M6(e);const i=Ve(e),s=Ve(n);Y(i===s,()=>`Based on the provided shape, [${e}], the tensor should have ${i} values but has ${s}`);for(let o=0;o<n.length;++o){const a=n[o],l=o===n.length-1?a!==Ve(e.slice(o)):!0;Y(n[o]===e[o]||!l,()=>`Error creating a new Tensor. Inferred shape (${n}) does not match the provided shape (${e}). `)}}return!Na(t)&&!Array.isArray(t)&&(t=[t]),e=e||n,t=r!=="string"?e_(t,r):Kh(t,[],!0),oe.makeTensor(t,e,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ma(t,e,n){const r=zc(t,n);return Gc(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sT={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X1=4;async function Age(t,e){const n=[],r=[],i=Array.isArray(t)?t.map(o=>o.name):Object.keys(t);for(let o=0;o<i.length;++o){const a=i[o],l=Array.isArray(t)?t[o].tensor:t[a];if(l.dtype!=="float32"&&l.dtype!=="int32"&&l.dtype!=="bool"&&l.dtype!=="string"&&l.dtype!=="complex64")throw new Error(`Unsupported dtype in weight '${a}': ${l.dtype}`);const c={name:a,shape:l.shape,dtype:l.dtype};if(l.dtype==="string"){const u=new Promise(async d=>{const f=await l.bytes(),h=f.reduce((v,y)=>v+y.length,0)+X1*f.length,p=new Uint8Array(h);let x=0;for(let v=0;v<f.length;v++){const y=f[v],b=new Uint8Array(new Uint32Array([y.length]).buffer);p.set(b,x),x+=X1,p.set(y,x),x+=y.length}d(p)});r.push(u)}else r.push(l.data());e!=null&&(c.group=e),n.push(c)}const s=await Promise.all(r);return{data:Tge(s),specs:n}}function kG(t,e){const n={};let r,i=0;for(const s of e){const o=s.name,a=s.dtype,l=s.shape,c=Ve(l);let u;if("quantization"in s){const d=s.quantization;if(d.dtype==="uint8"||d.dtype==="uint16"){if(!("min"in d&&"scale"in d))throw new Error(`Weight ${s.name} with quantization ${d.dtype} doesn't have corresponding metadata min and scale.`)}else if(d.dtype==="float16"){if(a!=="float32")throw new Error(`Weight ${s.name} is quantized with ${d.dtype} which only supports weights of type float32 not ${a}.`)}else throw new Error(`Weight ${s.name} has unknown quantization dtype ${d.dtype}. Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.`);const f=sT[d.dtype],h=t.slice(i,i+c*f),p=d.dtype==="uint8"?new Uint8Array(h):new Uint16Array(h);if(a==="float32")if(d.dtype==="uint8"||d.dtype==="uint16"){u=new Float32Array(p.length);for(let x=0;x<p.length;x++){const v=p[x];u[x]=v*d.scale+d.min}}else if(d.dtype==="float16")r===void 0&&(r=kge()),u=r(p);else throw new Error(`Unsupported quantization type ${d.dtype} for weight type float32.`);else if(a==="int32"){if(d.dtype!=="uint8"&&d.dtype!=="uint16")throw new Error(`Unsupported quantization type ${d.dtype} for weight type int32.`);u=new Int32Array(p.length);for(let x=0;x<p.length;x++){const v=p[x];u[x]=Math.round(v*d.scale+d.min)}}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);i+=c*f}else if(a==="string"){const d=Ve(s.shape);u=[];for(let f=0;f<d;f++){const h=new Uint32Array(t.slice(i,i+X1))[0];i+=X1;const p=new Uint8Array(t.slice(i,i+h));u.push(p),i+=h}}else{const d=sT[a],f=t.slice(i,i+c*d);if(a==="float32")u=new Float32Array(f);else if(a==="int32")u=new Int32Array(f);else if(a==="bool")u=new Uint8Array(f);else if(a==="complex64"){u=new Float32Array(f);const h=new Float32Array(u.length/2),p=new Float32Array(u.length/2);for(let y=0;y<h.length;y++)h[y]=u[y*2],p[y]=u[y*2+1];const x=Ma(h,l,"float32"),v=Ma(p,l,"float32");n[o]=Nc(x,v),x.dispose(),v.dispose()}else throw new Error(`Unsupported dtype in weight '${o}': ${a}`);i+=c*d}a!=="complex64"&&(n[o]=Ma(u,l,a))}return n}function Tge(t){if(t===null)throw new Error(`Invalid input value: ${JSON.stringify(t)}`);let e=0;const n=[];t.forEach(s=>{if(e+=s.byteLength,n.push(s.byteLength===s.buffer.byteLength?s:new s.constructor(s)),!(s instanceof Float32Array||s instanceof Int32Array||s instanceof Uint8Array))throw new Error(`Unsupported TypedArray subtype: ${s.constructor.name}`)});const r=new Uint8Array(e);let i=0;return n.forEach(s=>{r.set(new Uint8Array(s.buffer),i),i+=s.byteLength}),r.buffer}const yI=typeof Buffer<"u"&&(typeof Blob>"u"||typeof atob>"u"||typeof btoa>"u");function EL(t){return yI?Buffer.byteLength(t):new Blob([t]).size}function Mge(t){if(yI)return Buffer.from(t).toString("base64");const e=new Uint8Array(t);let n="";for(let r=0,i=e.length;r<i;r++)n+=String.fromCharCode(e[r]);return btoa(n)}function Rge(t){if(yI){const r=Buffer.from(t,"base64");return r.buffer.slice(r.byteOffset,r.byteOffset+r.byteLength)}const e=atob(t),n=new Uint8Array(e.length);for(let r=0;r<e.length;++r)n.set([e.charCodeAt(r)],r);return n.buffer}function vI(t){if(t.length===1)return t[0];let e=0;t.forEach(i=>{e+=i.byteLength});const n=new Uint8Array(e);let r=0;return t.forEach(i=>{n.set(new Uint8Array(i),r),r+=i.byteLength}),n.buffer}function AL(t){const e="/";for(t=t.trim();t.endsWith(e);)t=t.slice(0,t.length-1);const n=t.split(e);return n[n.length-1]}function DG(t,e){const n={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy,weightsManifest:e};return t.signature!=null&&(n.signature=t.signature),t.userDefinedMetadata!=null&&(n.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(n.modelInitializer=t.modelInitializer),t.trainingConfig!=null&&(n.trainingConfig=t.trainingConfig),n}function OG(t,e,n){const r={modelTopology:t.modelTopology,format:t.format,generatedBy:t.generatedBy,convertedBy:t.convertedBy};if(t.trainingConfig!=null&&(r.trainingConfig=t.trainingConfig),t.weightsManifest!=null){if(!e)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");r.weightSpecs=e,r.weightData=n}return t.signature!=null&&(r.signature=t.signature),t.userDefinedMetadata!=null&&(r.userDefinedMetadata=t.userDefinedMetadata),t.modelInitializer!=null&&(r.modelInitializer=t.modelInitializer),r}async function xI(t,e){let n,r;return t.weightsManifest!=null&&([n,r]=await e(t.weightsManifest)),OG(t,n,r)}function L0(t){if(t.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:t.modelTopology==null?0:EL(JSON.stringify(t.modelTopology)),weightSpecsBytes:t.weightSpecs==null?0:EL(JSON.stringify(t.weightSpecs)),weightDataBytes:t.weightData==null?0:t.weightData.byteLength}}function LG(t){const e=[];for(const n of t)e.push(...n.weights);return e}function Ige(){const t=n=>{let r=n<<13,i=0;for(;!(r&8388608);)i-=8388608,r<<=1;return r&=-8388609,i+=947912704,r|i},e=new Uint32Array(2048);e[0]=0;for(let n=1;n<1024;n++)e[n]=t(n);for(let n=1024;n<2048;n++)e[n]=939524096+(n-1024<<13);return e}function Nge(){const t=new Uint32Array(64);t[0]=0,t[31]=1199570944,t[32]=2147483648,t[63]=3347054592;for(let e=1;e<31;e++)t[e]=e<<23;for(let e=33;e<63;e++)t[e]=2147483648+(e-32<<23);return t}function Pge(){const t=new Uint32Array(64);for(let e=0;e<64;e++)t[e]=1024;return t[0]=t[32]=0,t}function kge(){const t=Ige(),e=Nge(),n=Pge();return r=>{const i=new ArrayBuffer(4*r.length),s=new Uint32Array(i);for(let o=0;o<r.length;o++){const a=r[o],l=t[n[a>>10]+(a&1023)]+e[a>>10];s[o]=l}return new Float32Array(i)}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class zn{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return zn.instance==null&&(zn.instance=new zn),zn.instance}static registerSaveRouter(e){zn.getInstance().saveRouters.push(e)}static registerLoadRouter(e){zn.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return zn.getHandlers(e,"save")}static getLoadHandlers(e,n){return zn.getHandlers(e,"load",n)}static getHandlers(e,n,r){const i=[];return(n==="load"?zn.getInstance().loadRouters:zn.getInstance().saveRouters).forEach(o=>{const a=o(e,r);a!==null&&i.push(a)}),i}}const Dge=t=>zn.registerSaveRouter(t),Oge=t=>zn.registerLoadRouter(t),Lge=t=>zn.getSaveHandlers(t),Bge=(t,e)=>zn.getLoadHandlers(t,e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oT="tensorflowjs",aT=1,Uu="models_store",cc="model_info_store";function BG(){if(!ge().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const t=typeof window>"u"?self:window,e=t.indexedDB||t.mozIndexedDB||t.webkitIndexedDB||t.msIndexedDB||t.shimIndexedDB;if(e==null)throw new Error("The current browser does not appear to support IndexedDB.");return e}function lT(t){const e=t.result;e.createObjectStore(Uu,{keyPath:"modelPath"}),e.createObjectStore(cc,{keyPath:"modelPath"})}class yd{constructor(e){if(this.indexedDB=BG(),e==null||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,n){return new Promise((r,i)=>{const s=this.indexedDB.open(oT,aT);s.onupgradeneeded=()=>lT(s),s.onsuccess=()=>{const o=s.result;if(n==null){const a=o.transaction(Uu,"readonly"),c=a.objectStore(Uu).get(this.modelPath);c.onsuccess=()=>{if(c.result==null)return o.close(),i(new Error(`Cannot find model with path '${this.modelPath}' in IndexedDB.`));r(c.result.modelArtifacts)},c.onerror=u=>(o.close(),i(c.error)),a.oncomplete=()=>o.close()}else{const a=L0(n),l=o.transaction(cc,"readwrite");let c=l.objectStore(cc);const u=c.put({modelPath:this.modelPath,modelArtifactsInfo:a});let d;u.onsuccess=()=>{d=o.transaction(Uu,"readwrite");const h=d.objectStore(Uu).put({modelPath:this.modelPath,modelArtifacts:n,modelArtifactsInfo:a});h.onsuccess=()=>r({modelArtifactsInfo:a}),h.onerror=p=>{c=l.objectStore(cc);const x=c.delete(this.modelPath);x.onsuccess=()=>(o.close(),i(h.error)),x.onerror=v=>(o.close(),i(h.error))}},u.onerror=f=>(o.close(),i(u.error)),l.oncomplete=()=>{d==null?o.close():d.oncomplete=()=>o.close()}}},s.onerror=o=>i(s.error)})}}yd.URL_SCHEME="indexeddb://";const FG=t=>ge().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(yd.URL_SCHEME)?Fge(t.slice(yd.URL_SCHEME.length)):null;zn.registerSaveRouter(FG);zn.registerLoadRouter(FG);function Fge(t){return new yd(t)}function $ge(t){return t.startsWith(yd.URL_SCHEME)?t.slice(yd.URL_SCHEME.length):t}class Uge{constructor(){this.indexedDB=BG()}async listModels(){return new Promise((e,n)=>{const r=this.indexedDB.open(oT,aT);r.onupgradeneeded=()=>lT(r),r.onsuccess=()=>{const i=r.result,s=i.transaction(cc,"readonly"),a=s.objectStore(cc).getAll();a.onsuccess=()=>{const l={};for(const c of a.result)l[c.modelPath]=c.modelArtifactsInfo;e(l)},a.onerror=l=>(i.close(),n(a.error)),s.oncomplete=()=>i.close()},r.onerror=i=>n(r.error)})}async removeModel(e){return e=$ge(e),new Promise((n,r)=>{const i=this.indexedDB.open(oT,aT);i.onupgradeneeded=()=>lT(i),i.onsuccess=()=>{const s=i.result,o=s.transaction(cc,"readwrite"),a=o.objectStore(cc),l=a.get(e);let c;l.onsuccess=()=>{if(l.result==null)return s.close(),r(new Error(`Cannot find model with path '${e}' in IndexedDB.`));{const u=a.delete(e),d=()=>{c=s.transaction(Uu,"readwrite");const h=c.objectStore(Uu).delete(e);h.onsuccess=()=>n(l.result.modelArtifactsInfo),h.onerror=p=>r(l.error)};u.onsuccess=d,u.onerror=f=>(d(),s.close(),r(l.error))}},l.onerror=u=>(s.close(),r(l.error)),o.oncomplete=()=>{c==null?s.close():c.oncomplete=()=>s.close()}},i.onerror=s=>r(i.error)})}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rl="/",zf="tensorflowjs_models",$G="info",zge="model_topology",Gge="weight_specs",Hge="weight_data",Vge="model_metadata";function UG(t){return{info:[zf,t,$G].join(rl),topology:[zf,t,zge].join(rl),weightSpecs:[zf,t,Gge].join(rl),weightData:[zf,t,Hge].join(rl),modelMetadata:[zf,t,Vge].join(rl)}}function zG(t){for(const e of Object.values(t))window.localStorage.removeItem(e)}function Wge(t){const e=t.split(rl);if(e.length<3)throw new Error(`Invalid key format: ${t}`);return e.slice(1,e.length-1).join(rl)}function jge(t){return t.startsWith(vd.URL_SCHEME)?t.slice(vd.URL_SCHEME.length):t}class vd{constructor(e){if(!ge().getBool("IS_BROWSER")||typeof window>"u"||typeof window.localStorage>"u")throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,e==null||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=UG(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),r=JSON.stringify(e.weightSpecs),i=L0(e);try{this.LS.setItem(this.keys.info,JSON.stringify(i)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,r),this.LS.setItem(this.keys.weightData,Mge(e.weightData));const s={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:e.signature!=null?e.signature:void 0,userDefinedMetadata:e.userDefinedMetadata!=null?e.userDefinedMetadata:void 0,modelInitializer:e.modelInitializer!=null?e.modelInitializer:void 0,trainingConfig:e.trainingConfig!=null?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(s)),{modelArtifactsInfo:i}}catch{throw zG(this.keys),new Error(`Failed to save model '${this.modelPath}' to local storage: size quota being exceeded is a possible cause of this failure: modelTopologyBytes=${i.modelTopologyBytes}, weightSpecsBytes=${i.weightSpecsBytes}, weightDataBytes=${i.weightDataBytes}.`)}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(e==null)throw new Error(`In local storage, there is no model with name '${this.modelPath}'`);if(e.modelTopologyType!=="JSON")throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const n={},r=JSON.parse(this.LS.getItem(this.keys.topology));if(r==null)throw new Error(`In local storage, the topology of model '${this.modelPath}' is missing.`);n.modelTopology=r;const i=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(i==null)throw new Error(`In local storage, the weight specs of model '${this.modelPath}' are missing.`);n.weightSpecs=i;const s=this.LS.getItem(this.keys.modelMetadata);if(s!=null){const a=JSON.parse(s);n.format=a.format,n.generatedBy=a.generatedBy,n.convertedBy=a.convertedBy,a.signature!=null&&(n.signature=a.signature),a.userDefinedMetadata!=null&&(n.userDefinedMetadata=a.userDefinedMetadata),a.modelInitializer!=null&&(n.modelInitializer=a.modelInitializer),a.trainingConfig!=null&&(n.trainingConfig=a.trainingConfig)}const o=this.LS.getItem(this.keys.weightData);if(o==null)throw new Error(`In local storage, the binary weight values of model '${this.modelPath}' are missing.`);return n.weightData=Rge(o),n}}vd.URL_SCHEME="localstorage://";const GG=t=>ge().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(vd.URL_SCHEME)?Xge(t.slice(vd.URL_SCHEME.length)):null;zn.registerSaveRouter(GG);zn.registerLoadRouter(GG);function Xge(t){return new vd(t)}class Kge{constructor(){Y(ge().getBool("IS_BROWSER"),()=>"Current environment is not a web browser"),Y(typeof window>"u"||typeof window.localStorage<"u",()=>"Current browser does not appear to support localStorage"),this.LS=window.localStorage}async listModels(){const e={},n=zf+rl,r=rl+$G;for(let i=0;i<this.LS.length;++i){const s=this.LS.key(i);if(s.startsWith(n)&&s.endsWith(r)){const o=Wge(s);e[o]=JSON.parse(this.LS.getItem(s))}}return e}async removeModel(e){e=jge(e);const n=UG(e);if(this.LS.getItem(n.info)==null)throw new Error(`Cannot find model at path '${e}'`);const r=JSON.parse(this.LS.getItem(n.info));return zG(n),r}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Ch="://";class hi{constructor(){this.managers={}}static getInstance(){return hi.instance==null&&(hi.instance=new hi),hi.instance}static registerManager(e,n){Y(e!=null,()=>"scheme must not be undefined or null."),e.endsWith(Ch)&&(e=e.slice(0,e.indexOf(Ch))),Y(e.length>0,()=>"scheme must not be an empty string.");const r=hi.getInstance();Y(r.managers[e]==null,()=>`A model store manager is already registered for scheme '${e}'.`),r.managers[e]=n}static getManager(e){const n=hi.getInstance().managers[e];if(n==null)throw new Error(`Cannot find model manager for scheme '${e}'`);return n}static getSchemes(){return Object.keys(hi.getInstance().managers)}}function n1(t){if(t.indexOf(Ch)===-1)throw new Error(`The url string provided does not contain a scheme. Supported schemes are: ${hi.getSchemes().join(",")}`);return{scheme:t.split(Ch)[0],path:t.split(Ch)[1]}}async function HG(t,e,n=!1){Y(t!==e,()=>`Old path and new path are the same: '${t}'`);const r=zn.getLoadHandlers(t);Y(r.length>0,()=>`Copying failed because no load handler is found for source URL ${t}.`),Y(r.length<2,()=>`Copying failed because more than one (${r.length}) load handlers for source URL ${t}.`);const i=r[0],s=zn.getSaveHandlers(e);Y(s.length>0,()=>`Copying failed because no save handler is found for destination URL ${e}.`),Y(s.length<2,()=>`Copying failed because more than one (${r.length}) save handlers for destination URL ${e}.`);const o=s[0],a=n1(t).scheme,l=n1(t).path,c=a===n1(t).scheme,u=await i.load();n&&c&&await hi.getManager(a).removeModel(l);const d=await o.save(u);return n&&!c&&await hi.getManager(a).removeModel(l),d.modelArtifactsInfo}async function qge(){const t=hi.getSchemes(),e={};for(const n of t){const r=await hi.getManager(n).listModels();for(const i in r){const s=n+Ch+i;e[s]=r[i]}}return e}async function Jge(t){const e=n1(t);return hi.getManager(e.scheme).removeModel(e.path)}async function Yge(t,e){return HG(t,e,!1)}async function Qge(t,e){return HG(t,e,!0)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Zge{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,n){return fetch(e,n)}now(){return performance.now()}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Browser's encoder only supports utf-8, but got ${n}`);return this.textEncoder==null&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,n){return new TextDecoder(n).decode(e)}setTimeoutCustom(e,n){if(!window||!ge().getBool("USE_SETTIMEOUTCUSTOM")){setTimeout(e,n);return}this.functionRefs.push(e),setTimeout(()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")},n),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",r=>{if(r.source===window&&r.data.name===this.messageName){r.stopPropagation();const i=this.functionRefs[r.data.index];i(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}},!0))}}if(ge().get("IS_BROWSER")){ge().setPlatform("browser",new Zge);try{hi.registerManager(vd.URL_SCHEME,new Kge)}catch{}try{hi.registerManager(yd.URL_SCHEME,new Uge)}catch{}}const e0e={},t0e=Object.freeze(Object.defineProperty({__proto__:null,default:e0e},Symbol.toStringTag,{value:"Module"})),bI=Cl(t0e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n0e={importFetch:()=>bI};let hE;class r0e{constructor(){this.util=bI,this.textEncoder=new this.util.TextEncoder}fetch(e,n){return ge().global.fetch!=null?ge().global.fetch(e,n):(hE==null&&(hE=n0e.importFetch()),hE(e,n))}now(){const e=process.hrtime();return e[0]*1e3+e[1]/1e6}encode(e,n){if(n!=="utf-8"&&n!=="utf8")throw new Error(`Node built-in encoder only supports utf-8, but got ${n}`);return this.textEncoder.encode(e)}decode(e,n){return e.length===0?"":new this.util.TextDecoder(n).decode(e)}}ge().get("IS_NODE")&&!ge().get("IS_BROWSER")&&ge().setPlatform("node",new r0e);/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vn(t,e="float32",n){return e=e||"float32",M6(t),new Yg(t,e,n)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i0e(t,e){const n=z(t,"x","cast");if(!Nme(e))throw new Error(`Failed to cast to unknown dtype ${e}`);if(e==="string"&&n.dtype!=="string"||e!=="string"&&n.dtype==="string")throw new Error("Only strings can be casted to strings");const r={x:n},i={dtype:e};return oe.runKernel(fI,r,i)}const hr=ee({cast_:i0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s0e(t){const n={x:z(t,"x","clone","string_or_numeric")};return oe.runKernel(hI,n)}const _c=ee({clone_:s0e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VG(t,e=!1){console.log(t.toString(e))}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */MG();const o0e={buffer:Vn,cast:hr,clone:_c,print:VG};yge(o0e);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a0e="model",l0e=".json",c0e=".weights.bin";function TL(t){return new Promise(e=>setTimeout(e)).then(t)}class xd{constructor(e){if(!ge().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(xd.URL_SCHEME)&&(e=e.slice(xd.URL_SCHEME.length)),(e==null||e.length===0)&&(e=a0e),this.modelJsonFileName=e+l0e,this.weightDataFileName=e+c0e}async save(e){if(typeof document>"u")throw new Error("Browser downloads are not supported in this environment since `document` is not present");const n=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const r=[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}],i=DG(e,r),s=window.URL.createObjectURL(new Blob([JSON.stringify(i)],{type:"application/json"})),o=this.modelJsonAnchor==null?document.createElement("a"):this.modelJsonAnchor;if(o.download=this.modelJsonFileName,o.href=s,await TL(()=>o.dispatchEvent(new MouseEvent("click"))),e.weightData!=null){const a=this.weightDataAnchor==null?document.createElement("a"):this.weightDataAnchor;a.download=this.weightDataFileName,a.href=n,await TL(()=>a.dispatchEvent(new MouseEvent("click")))}return{modelArtifactsInfo:L0(e)}}}}xd.URL_SCHEME="downloads://";class u0e{constructor(e){if(e==null||e.length<1)throw new Error(`When calling browserFiles, at least 1 file is required, but received ${e}`);this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise((e,n)=>{const r=new FileReader;r.onload=i=>{const s=JSON.parse(i.target.result),o=s.modelTopology;if(o==null){n(new Error(`modelTopology field is missing from file ${this.jsonFile.name}`));return}if(s.weightsManifest==null){n(new Error(`weightManifest field is missing from file ${this.jsonFile.name}`));return}if(this.weightsFiles.length===0){e({modelTopology:o});return}const l=xI(s,c=>this.loadWeights(c));e(l)},r.onerror=i=>n(`Failed to read model topology and weights manifest JSON from file '${this.jsonFile.name}'. BrowserFiles supports loading Keras-style tf.Model artifacts only.`),r.readAsText(this.jsonFile)})}loadWeights(e){const n=[],r=[];for(const o of e)n.push(...o.weights),r.push(...o.paths);const i=this.checkManifestAndWeightFiles(e),s=r.map(o=>this.loadWeightsFile(o,i[o]));return Promise.all(s).then(o=>[n,vI(o)])}loadWeightsFile(e,n){return new Promise((r,i)=>{const s=new FileReader;s.onload=o=>{const a=o.target.result;r(a)},s.onerror=o=>i(`Failed to weights data from file of path '${e}'.`),s.readAsArrayBuffer(n)})}checkManifestAndWeightFiles(e){const n=[],r=this.weightsFiles.map(s=>AL(s.name)),i={};for(const s of e)s.paths.forEach(o=>{const a=AL(o);if(n.indexOf(a)!==-1)throw new Error(`Duplicate file basename found in weights manifest: '${a}'`);if(n.push(a),r.indexOf(a)===-1)throw new Error(`Weight file with basename '${a}' is not provided.`);i[o]=this.weightsFiles[r.indexOf(a)]});if(n.length!==this.weightsFiles.length)throw new Error(`Mismatch in the number of files in weights manifest (${n.length}) and the number of weight files provided (${this.weightsFiles.length}).`);return i}}const d0e=t=>ge().getBool("IS_BROWSER")&&!Array.isArray(t)&&t.startsWith(xd.URL_SCHEME)?f0e(t.slice(xd.URL_SCHEME.length)):null;zn.registerSaveRouter(d0e);function f0e(t="model"){return new xd(t)}function h0e(t){return new u0e(t)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ML(t,e,n,r){o(t),n=n??0,r=r??1,a(n,r);let i=0;const s=l=>(l.then(c=>{const u=n+ ++i/t.length*(r-n);return e(u),c}),l);function o(l){Y(l!=null&&Array.isArray(l)&&l.length>0,()=>"promises must be a none empty array")}function a(l,c){Y(l>=0&&l<=1,()=>`Progress fraction must be in range [0, 1], but got startFraction ${l}`),Y(c>=0&&c<=1,()=>`Progress fraction must be in range [0, 1], but got endFraction ${c}`),Y(c>=l,()=>`startFraction must be no more than endFraction, but got startFraction ${l} and endFraction ${c}`)}return Promise.all(t.map(s))}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function WG(t,e){e==null&&(e={});const n=e.fetchFunc==null?ge().platform.fetch:e.fetchFunc,r=t.map(d=>n(d,e.requestInit,{isBinary:!0})),a=(e.onProgress==null?await Promise.all(r):await ML(r,e.onProgress,0,.5)).map(d=>d.arrayBuffer());return e.onProgress==null?await Promise.all(a):await ML(a,e.onProgress,.5,1)}async function p0e(t,e="",n,r){return jG(o=>WG(o,{requestInit:r}))(t,e,n)}function jG(t){return async(e,n="",r)=>{const i=e.map(()=>!1),s={},o=r!=null?r.map(()=>!1):[],a=[];if(e.forEach((h,p)=>{let x=0;h.weights.forEach(v=>{const y="quantization"in v?v.quantization.dtype:v.dtype,b=sT[y]*Ve(v.shape),S=()=>{i[p]=!0,s[p]==null&&(s[p]=[]),s[p].push({manifestEntry:v,groupOffset:x,sizeBytes:b})};r!=null?r.forEach((w,E)=>{w===v.name&&(S(),o[E]=!0)}):S(),a.push(v.name),x+=b})}),!o.every(h=>h)){const h=r.filter((p,x)=>!o[x]);throw new Error(`Could not find weights in manifest with names: ${h.join(", ")}. 
Manifest JSON has weights with names: ${a.join(", ")}.`)}const l=i.reduce((h,p,x)=>(p&&h.push(x),h),[]),c=[];l.forEach(h=>{e[h].paths.forEach(p=>{const x=n+(n.endsWith("/")?"":"/")+p;c.push(x)})});const u=await t(c),d={};let f=0;return l.forEach(h=>{const p=e[h].paths.length;let x=0;for(let w=0;w<p;w++)x+=u[f+w].byteLength;const v=new ArrayBuffer(x),y=new Uint8Array(v);let b=0;for(let w=0;w<p;w++){const E=new Uint8Array(u[f+w]);y.set(E,b),b+=E.byteLength}s[h].forEach(w=>{const E=v.slice(w.groupOffset,w.groupOffset+w.sizeBytes),A=kG(E,[w.manifestEntry]);for(const T in A)d[T]=A[T]}),f+=p}),d}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const m0e="application/octet-stream",g0e="application/json";class SI{constructor(e,n){if(this.DEFAULT_METHOD="POST",n==null&&(n={}),this.weightPathPrefix=n.weightPathPrefix,this.onProgress=n.onProgress,this.weightUrlConverter=n.weightUrlConverter,n.fetchFunc!=null?(Y(typeof n.fetchFunc=="function",()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)"),this.fetch=n.fetchFunc):this.fetch=ge().platform.fetch,Y(e!=null&&e.length>0,()=>"URL path for http must not be null, undefined or empty."),Array.isArray(e)&&Y(e.length===2,()=>`URL paths for http must have a length of 2, (actual length is ${e.length}).`),this.path=e,n.requestInit!=null&&n.requestInit.body!=null)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=n.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const n=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);n.body=new FormData;const r=[{paths:["./model.weights.bin"],weights:e.weightSpecs}],i=DG(e,r);n.body.append("model.json",new Blob([JSON.stringify(i)],{type:g0e}),"model.json"),e.weightData!=null&&n.body.append("model.weights.bin",new Blob([e.weightData],{type:m0e}),"model.weights.bin");const s=await this.fetch(this.path,n);if(s.ok)return{modelArtifactsInfo:L0(e),responses:[s]};throw new Error(`BrowserHTTPRequest.save() failed due to HTTP response status ${s.status}.`)}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error(`Request to ${this.path} failed with status code ${e.status}. Please verify this URL points to the model JSON of the model to load.`);let n;try{n=await e.json()}catch{let o=`Failed to parse model JSON of response from ${this.path}.`;throw this.path.endsWith(".pb")?o+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":o+=" Please make sure the server is serving valid JSON for this request.",new Error(o)}const r=n.modelTopology,i=n.weightsManifest;if(r==null&&i==null)throw new Error(`The JSON from HTTP path ${this.path} contains neither model topology or manifest for weights.`);return xI(n,s=>this.loadWeights(s))}async loadWeights(e){const n=Array.isArray(this.path)?this.path[1]:this.path,[r,i]=y0e(n),s=this.weightPathPrefix||r,o=LG(e),a=[],l=[];for(const u of e)for(const d of u.paths)this.weightUrlConverter!=null?l.push(this.weightUrlConverter(d)):a.push(s+d+i);this.weightUrlConverter&&a.push(...await Promise.all(l));const c=await WG(a,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress});return[o,vI(c)]}}SI.URL_SCHEME_REGEX=/^https?:\/\//;function y0e(t){const e=t.lastIndexOf("/"),n=t.lastIndexOf("?"),r=t.substring(0,e),i=n>e?t.substring(n):"";return[r+"/",i]}function cT(t){return t.match(SI.URL_SCHEME_REGEX)!=null}const XG=(t,e)=>{if(typeof fetch>"u"&&(e==null||e.fetchFunc==null))return null;{let n=!0;if(Array.isArray(t)?n=t.every(r=>cT(r)):n=cT(t),n)return _I(t,e)}return null};zn.registerSaveRouter(XG);zn.registerLoadRouter(XG);function _I(t,e){return new SI(t,e)}function v0e(t,e){return _I(t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pE{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class KG{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class x0e{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=n=>Promise.resolve(e.save(n)))}}function b0e(t,e,n,r){const i=arguments;return new x0e(qG(...i))}function qG(t,e,n,r){return arguments.length===1?t.modelTopology!=null||t.weightSpecs!=null?new pE(t):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new pE({modelTopology:t})):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new pE({modelTopology:t,weightSpecs:e,weightData:n,trainingConfig:r}))}function S0e(t){return new KG(t)}function _0e(t){return new KG(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JG=Object.freeze(Object.defineProperty({__proto__:null,browserFiles:h0e,browserHTTPRequest:v0e,concatenateArrayBuffers:vI,copyModel:Yge,decodeWeights:kG,encodeWeights:Age,fromMemory:b0e,fromMemorySync:qG,getLoadHandlers:Bge,getModelArtifactsForJSON:xI,getModelArtifactsForJSONSync:OG,getModelArtifactsInfoForJSON:L0,getSaveHandlers:Lge,getWeightSpecs:LG,http:_I,isHTTPScheme:cT,listModels:qge,loadWeights:p0e,moveModel:Qge,registerLoadRouter:Oge,registerSaveRouter:Dge,removeModel:Jge,weightsLoaderFactory:jG,withSaveHandler:S0e,withSaveHandlerSync:_0e},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w0e(t,e,n=!1,r=!1){let i=z(t,"a","matMul"),s=z(e,"b","matMul");[i,s]=Qn(i,s);const o={a:i,b:s},a={transposeA:n,transposeB:r};return oe.runKernel(j6,o,a)}const yn=ee({matMul_:w0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C0e(t,e,n=1,r=0,i="int32"){if(e<2)throw new Error(`Error in oneHot: depth must be >=2, but it is ${e}`);const o={indices:z(t,"indices","oneHot","int32")},a={dtype:i,depth:e,onValue:n,offValue:r};return oe.runKernel(m8,o,a)}const E0e=ee({oneHot_:C0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kf(){return oe}function qn(t,e){return oe.tidy(t,e)}function A0e(t){AG(t).forEach(n=>n.dispose())}function uc(t){return oe.keep(t)}function T0e(t){return oe.setBackend(t)}function M0e(){return oe.backendName}function R0e(t,e,n=1){return oe.registerBackend(t,e,n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I0e(t){const n={input:z(t,"input","imag")};return oe.runKernel(Bz,n)}const t_=ee({imag_:I0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N0e(t){const n={x:z(t,"x","neg")};return oe.runKernel(c8,n)}const ul=ee({neg_:N0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P0e(t){const n={input:z(t,"input","real")};return oe.runKernel(C8,n)}const Qg=ee({real_:P0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k0e(t,e,n){const r=z(t,"x","transpose");if(e==null&&(e=r.shape.map((o,a)=>a).reverse()),Y(r.rank===e.length,()=>`Error in transpose: rank of input ${r.rank} must match length of perm ${e}.`),e.forEach(o=>{Y(o>=0&&o<r.rank,()=>`All entries in 'perm' must be between 0 and ${r.rank-1} but got ${e}`)}),r.rank<=1)return r.clone();const i={x:r},s={perm:e};return r.dtype==="complex64"?qn(()=>{let o=Qg(r),a=t_(r);return o=oe.runKernel(e1,{x:o},s),a=oe.runKernel(e1,{x:a},s),n&&(a=ul(a)),Nc(o,a)}):oe.runKernel(e1,i,s)}const uT=ee({transpose_:k0e});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K1(t,e){const n=t.length,r=[];for(let i=0;i<n;i++){const s=n-1-i,o=t[s]||1;(e[e.length-1-i]||1)>1&&o===1&&r.unshift(s)}return r}function YG(t,e){const n=[];for(let r=0;r<e.length;r++){const i=t[t.length-r-1],s=e.length-r-1,o=e[s];(i==null||i===1&&o>1)&&n.unshift(s)}return n}function Qt(t,e){const n=[],r=Math.max(t.length,e.length);for(let i=0;i<r;i++){let s=t[t.length-i-1];s==null&&(s=1);let o=e[e.length-i-1];if(o==null&&(o=1),s===1)n.unshift(o);else if(o===1)n.unshift(s);else if(s!==o){const a=`Operands could not be broadcast together with shapes ${t} and ${e}.`;throw Error(a)}else n.unshift(s)}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QG(t,e,n){if(_p(t),e!=null&&e.length!==3)throw new Error("tensor3d() requires shape to have three numbers");const r=zc(t,n);if(r.length!==3&&r.length!==1)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return Gc(t,e,r,n)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */let hu;function D0e(t,e=3){if(e>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(t==null)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,r=!1,i=!1,s=!1,o=!1,a=!1;if(t.data instanceof Uint8Array)n=!0;else if(typeof ImageData<"u"&&t instanceof ImageData)r=!0;else if(typeof HTMLVideoElement<"u"&&t instanceof HTMLVideoElement)i=!0;else if(typeof HTMLImageElement<"u"&&t instanceof HTMLImageElement)s=!0;else if(t.getContext!=null)o=!0;else if(typeof ImageBitmap<"u"&&t instanceof ImageBitmap)a=!0;else throw new Error(`pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, but was ${t.constructor.name}`);if(Y2(X2,oe.backendName)!=null){const p={pixels:t},x={numChannels:e};return oe.runKernel(X2,p,x)}const[c,u]=i?[t.videoWidth,t.videoHeight]:[t.width,t.height];let d;if(o)d=t.getContext("2d").getImageData(0,0,c,u).data;else if(r||n)d=t.data;else if(s||i||a){if(hu==null)if(typeof document>"u")if(typeof OffscreenCanvas<"u"&&typeof OffscreenCanvasRenderingContext2D<"u")hu=new OffscreenCanvas(1,1).getContext("2d");else throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");else hu=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});hu.canvas.width=c,hu.canvas.height=u,hu.drawImage(t,0,0,c,u),d=hu.getImageData(0,0,c,u).data}let f;if(e===4)f=new Int32Array(d);else{const p=c*u;f=new Int32Array(p*e);for(let x=0;x<p;x++)for(let v=0;v<e;++v)f[x*e+v]=d[x*4+v]}return QG(f,[u,c,e],"int32")}const ZG=ee({fromPixels_:D0e});function eH(t,e){const n=t.shape.length,r=e.shape.length;if(n<1)throw new Error(`tf.gatherND() expects the input to be rank 1 or higher, but the rank was ${n}.`);if(r<1)throw new Error(`tf.gatherND() expects the indices to be rank 1 or higher, but the rank was ${r}.`);if(e.dtype!=="int32")throw new Error(`tf.gatherND() expects the indices to be int32 type, but the dtype was ${e.dtype}.`);if(e.shape[r-1]>n)throw new Error(`index innermost dimension length must be <= tensor rank; saw: ${e.shape[r-1]} vs. ${n}`);if(Ve(t.shape)===0)throw new Error(`Requested more than 0 entries, but input is empty. Input shape: ${t.shape}.`);const i=e.shape,s=i[i.length-1];let o=1;for(let d=0;d<i.length-1;++d)o*=i[d];const a=t.shape,l=i.slice();l.pop();let c=1;for(let d=s;d<n;++d)c*=a[d],l.push(a[d]);const u=[...Vr(t.shape).map(d=>d/c),1].slice(0,s);return[l,o,c,u]}function tH(t,e,n){const r=e.rank>1?e.shape[e.rank-1]:1,i=e.rank>1?e.rank-1:1,s=`Must have updates.shape = indices.shape[:batchDim] + shape[sliceDim:], got updates.shape: ${n.shape}, indices.shape: ${e.shape}, shape: ${t}, sliceDim: ${r}, and batchDim: ${i}.`;if(n.rank<i)throw new Error(s+` update.rank < ${i}. `);if(t.length<r+(n.rank-i))throw new Error(s+` Output shape length < ${r+(n.rank-i)}`);if(n.rank!==i+t.length-r)throw new Error(s+` update.rank != ${i+t.length-r}`);for(let o=0;o<i;++o)if(n.shape[o]!==e.shape[o])throw new Error(s+` updates.shape[${o}] (${n.shape[o]}) != indices.shape[${o}] (${e.shape[o]}).`);for(let o=0;o<n.rank-i;++o)if(n.shape[o+i]!==t[o+r])throw new Error(s+` updates.shape[${o+i}] (${n.shape[o+i]}) != shape[${o+i}] (${t[o+i]})`)}function nH(t,e,n){if(e.rank<1)throw new Error(`tf.scatterND() expects the indices to be rank 1 or higher, but the rank was ${e.rank}.`);if(t.rank<1)throw new Error(`tf.scatterND() expects the updates to be rank 1 or higher, but the rank was ${t.rank}.`);if(e.dtype!=="int32")throw new Error(`The dtype of 'indices' should be int32, but got dtype: ${e.dtype}`);if(n.length<1)throw new Error(`Output rank must be greater or equal to 1, but got shape: ${n}`);if(n.length===0){if(e.size===0)throw new Error(`Indices specified for empty output. indices shape: ${e.shape}`);if(t.size===0)throw new Error(`Updates specified for empty output. updates shape: ${t.shape}`)}tH(n,e,t)}function wI(t,e,n){const r=e.shape.length,i=r>1?e.shape[r-1]:1,s=n.length;let o=1;for(let d=i;d<s;++d)o*=n[d];const a=i<1?1:i,l=Ve(e.shape)/a,c=[...Vr(n.slice(0,i)),1],u=Ve(n);return{sliceRank:i,numUpdates:l,sliceSize:o,strides:c,outputSize:u}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dT=-2,O0e=-1;function rH(t,e,n){const r=t.shape.length;Y(r===e.length,()=>`Error in slice${r}D: Length of begin ${e} must match the rank of the array (${r}).`),Y(r===n.length,()=>`Error in slice${r}D: Length of size ${n} must match the rank of the array (${r}).`);for(let i=0;i<r;++i)Y(e[i]+n[i]<=t.shape[i],()=>`Error in slice${r}D: begin[${i}] + size[${i}] (${e[i]+n[i]}) would overflow input.shape[${i}] (${t.shape[i]})`)}function L0e(t){const e=[];let n=0;for(;t>0;)t&1&&e.push(n),t/=2,n++;return e}function iH(t,e,n){const r=[];for(let i=0;i<t.length;i++)r[i]=Math.ceil((e[i]-t[i])/n[i]);return r}function sH(t,e,n,r){const i=[...t];for(let s=i.length;s<r.length;s++)i.push(1);for(let s=0;s<n;s++)s===0?i[e]=1:(i.splice(e,0,1),i.pop());return i}function oH(t,e,n){return n<=t?n:n-(e-1)}function aH(t,e){const n=[];for(let r=0;r<t;r++)n.push(e+r);return n}function B0e(t,e,n,r,i,s,o,a,l){const c=t.length;let u=new Array(c),d=new Array(c),f=new Array(c);if(e.length&&n>0){const h=e[0],p=n+1;u=lH(o,h,p,r,t),d=cH(a,h,p,i,t),f=sH(s,h,p,t)}else for(let h=0;h<c;h++)u[h]=dH(o,r,s,t,h,l),d[h]=fH(a,i,s,t,h,l),f[h]=uH(s,h,l);return{begin:u,end:d,strides:f}}function lH(t,e,n,r,i){const s=[...i],o=aH(n,e);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=0;else{const l=oH(e,n,a);let c=r[l];t&1<<l&&(c=0),s[a]=c}return s}function cH(t,e,n,r,i){const s=[...i],o=aH(n,e);for(let a=0;a<s.length;a++)if(o.indexOf(a)>-1)s[a]=Number.MAX_SAFE_INTEGER;else{const l=oH(e,n,a);let c=r[l];t&1<<l&&(c=Number.MAX_SAFE_INTEGER),s[a]=c}for(let a=0;a<s.length;a++){const l=i[a];s[a]<0&&(s[a]+=l),s[a]=H1(0,s[a],i[a])}return s}function uH(t,e,n){let r=t[e];return(n&1<<e||r==null)&&(r=1),r}function dH(t,e,n,r,i,s){let o=e[i];const a=n[i]||1;(t&1<<i||s&1<<i||o==null)&&(a>0?o=Number.MIN_SAFE_INTEGER:o=Number.MAX_SAFE_INTEGER);const l=r[i];return o<0&&(o+=l),o=H1(0,o,l-1),o}function fH(t,e,n,r,i,s){let o=e[i];const a=n[i]||1;(t&1<<i||s&1<<i||o==null)&&(a>0?o=Number.MAX_SAFE_INTEGER:o=Number.MIN_SAFE_INTEGER);const l=r[i];return o<0&&(o+=l),a>0?o=H1(0,o,l):o=H1(-1,o,l-1),o}function CI(t,e,n){let r=n.length;for(let i=0;i<n.length;i++)if(n[i]>1){r=i;break}for(let i=r+1;i<n.length;i++)if(e[i]>0||n[i]!==t[i])return!1;return!0}function EI(t,e){let n=t.length>0?t[t.length-1]:1;for(let r=0;r<t.length-1;r++)n+=t[r]*e[r];return n}function hH(t,e,n){let r;const i=t.shape.length;typeof e=="number"?r=[e,...new Array(i-1).fill(0)]:e.length<i?r=e.concat(new Array(i-e.length).fill(0)):r=e.slice(),r.forEach(o=>{Y(o!==-1,()=>"slice() does not support negative begin indexing.")});let s;return n==null?s=new Array(i).fill(-1):typeof n=="number"?s=[n,...new Array(i-1).fill(-1)]:n.length<i?s=n.concat(new Array(i-n.length).fill(-1)):s=n,s=s.map((o,a)=>o>=0?o:(Y(o===-1,()=>`Negative size values should be exactly -1 but got ${o} for the slice() size at index ${a}.`),t.shape[a]-r[a])),[r,s]}function pH(t,e,n,r,i,s,o,a,l){let c;if(r==null?(c=new Array(e.length),c.fill(1)):c=r,o!=null&&o&o-1)throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const d={dims:c.length,numAddAxisAfterEllipsis:0,begin:e.slice(),end:n.slice(),strides:c.slice(),beginMask:i,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};for(let S=0;S<d.dims;S++)u&&1<<S&a&&d.numAddAxisAfterEllipsis++,1<<S&o&&(u=!0);u||(d.ellipsisMask|=1<<d.dims,d.dims++);const f={dims:t.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};F0e(d,f);let h=!0,p=!0,x=!0;const v=[],y=[];for(let S=0;S<t.length;++S){if(f.strides[S]===0)throw Error(`strides[${S}] must be non-zero`);const w=!!(f.shrinkAxisMask&1<<S),E=t[S];if(E===-1){v.push(w?1:-1);continue}const A=[f.beginMask&1<<S,f.endMask&1<<S],T=[f.strides[S]>0?0:-1,f.strides[S]>0?E:E-1];if(w&&f.strides[S]<=0)throw Error("only stride 1 allowed on non-range indexing.");x=x&&f.strides[S]===1;const I=!!(f.beginMask&1<<S&&f.endMask&1<<S);if(f.beginValid&&f.endValid){if(w){const B=f.begin[S]<0?E+f.begin[S]:f.begin[S];if(f.begin[S]=B,f.end[S]=f.begin[S]+1,B<0||B>=E)throw Error(`slice index ${f.begin[S]} of dimension ${S} out of bounds.`)}else f.begin[S]=RL(f.begin[S],0,f.strides[S],E,A,T),f.end[S]=RL(f.end[S],1,f.strides[S],E,A,T);const P=f.strides[S]===1&&f.begin[S]===0&&f.end[S]===E;h=h&&P,p=p&&(S===0&&f.strides[S]===1||P)}else h=h&&f.strides[S]===1&&I,p=p&&(S===0&&f.strides[S]===1||I);let N,M=!1;if(f.beginValid&&f.endValid?(N=f.end[S]-f.begin[S],M=!0):w?(N=1,M=!0):I&&E>=0&&(f.strides[S]<0?N=-E:N=E,M=!0),M){let P;N===0||N<0!=f.strides[S]<0?P=0:P=Math.trunc(N/f.strides[S])+(N%f.strides[S]!==0?1:0),v.push(P)}else v.push(-1)}for(let S=0;S<f.finalShapeGatherIndices.length;++S){const w=f.finalShapeGatherIndices[S];w>=0?y.push(v[w]):w===dT&&y.push(1)}return{finalShapeSparse:y.filter((S,w)=>f.finalShapeGatherIndices[w]!==dT),finalShape:y,isIdentity:h,sliceDim0:p,isSimpleSlice:x,begin:f.begin,end:f.end,strides:f.strides}}function F0e(t,e){e.beginMask=0,e.endMask=0,e.shrinkAxisMask=0;let n=0;e.beginValid=t.begin!=null,e.endValid=t.end!=null,e.begin=new Array(e.dims),e.end=new Array(e.dims),e.strides=new Array(e.dims),e.finalShapeGatherIndices=[],e.finalShapeGatherIndicesSparse=[],e.inputShapeGatherIndicesSparse=new Array(e.dims);for(let r=0;r<t.dims;r++)if(1<<r&t.ellipsisMask){const i=Math.min(e.dims-(t.dims-r)+1+t.numAddAxisAfterEllipsis,e.dims);for(;n<i;n++)e.begin[n]=0,e.end[n]=0,e.strides[n]=1,e.beginMask|=1<<n,e.endMask|=1<<n,e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(-1),e.inputShapeGatherIndicesSparse[n]=r}else if(1<<r&t.newAxisMask)e.finalShapeGatherIndices.push(dT),e.finalShapeGatherIndicesSparse.push(-1);else{if(n===e.begin.length)throw Error(`Index out of range using input dim ${n}; input has only ${e.dims} dims, ${e.begin.length}.`);t.begin!=null&&(e.begin[n]=t.begin[r]),t.end!=null&&(e.end[n]=t.end[r]),e.strides[n]=t.strides[r],t.beginMask&1<<r&&(e.beginMask|=1<<n),t.endMask&1<<r&&(e.endMask|=1<<n),t.shrinkAxisMask&1<<r?(e.finalShapeGatherIndices.push(O0e),e.finalShapeGatherIndicesSparse.push(-1),e.shrinkAxisMask|=1<<n):(e.finalShapeGatherIndices.push(n),e.finalShapeGatherIndicesSparse.push(r)),e.inputShapeGatherIndicesSparse[n]=r,n++}}function RL(t,e,n,r,i,s){if(i[e])return n>0?s[e]:s[e+1&1];{const o=t<0?r+t:t;return o<s[0]?s[0]:o>s[1]?s[1]:o}}const $0e=Object.freeze(Object.defineProperty({__proto__:null,assertParamsValid:rH,computeFlatOffset:EI,computeOutShape:iH,getNormalizedAxes:B0e,isSliceContinous:CI,maskToAxes:L0e,parseSliceParams:hH,sliceInfo:pH,startForAxis:dH,startIndicesWithElidedDims:lH,stopForAxis:fH,stopIndicesWithElidedDims:cH,stridesForAxis:uH,stridesWithElidedDims:sH},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U0e(t,e){let n=z(t,"a","add"),r=z(e,"b","add");[n,r]=Qn(n,r);const i={a:n,b:r};return oe.runKernel(dI,i)}const cr=ee({add_:U0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z0e(t,e){let n=z(t,"a","floorDiv"),r=z(e,"b","floorDiv");[n,r]=Qn(n,r);const i={a:n,b:r};return oe.runKernel(Iz,i)}const mH=ee({floorDiv_:z0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G0e(t,e){let n=z(t,"a","div"),r=z(e,"b","div");if([n,r]=Qn(n,r),n.dtype==="int32"&&r.dtype==="int32")return mH(n,r);const i={a:n,b:r},s={};return oe.runKernel(vz,i,s)}const ar=ee({div_:G0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H0e(t,e){let n=z(t,"a","mul"),r=z(e,"b","mul");[n,r]=Qn(n,r);const i={a:n,b:r};return oe.runKernel(l8,i)}const Et=ee({mul_:H0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function V0e(t){const e=z(t,"x","abs");if(e.dtype==="complex64"){const n={x:e};return oe.runKernel(Z6,n)}else{const n={x:e};return oe.runKernel(N6,n)}}const Zs=ee({abs_:V0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0e(t){const n={x:z(t,"x","acos")};return oe.runKernel(P6,n)}const j0e=ee({acos_:W0e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function X0e(t){const n={x:z(t,"x","acosh")};return oe.runKernel(k6,n)}const K0e=ee({acosh_:X0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q0e(t){Y(Array.isArray(t),()=>"The argument passed to tf.addN() must be a list of tensors"),Y(t.length>=1,()=>`Must pass at least one tensor to tf.addN(), but got ${t.length}`);const e=t.map((i,s)=>z(i,`tensors${s}`,"addN")),n=e[0];e.forEach(i=>{if(i.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")}),e.forEach(i=>{if(!Yn(i.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")});const r=e;return oe.runKernel(D6,r)}const J0e=ee({addN_:q0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y0e(t,e=null,n=!1){const i={x:z(t,"x","all","bool")},s={axis:e,keepDims:n};return oe.runKernel(O6,i,s)}const Q0e=ee({all_:Y0e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z0e(t,e=null,n=!1){const i={x:z(t,"x","any","bool")},s={axis:e,keepDims:n};return oe.runKernel(L6,i,s)}const eye=ee({any_:Z0e});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tye(t,e=0){const r={x:z(t,"x","argMax")},i={axis:e};return oe.runKernel(B6,r,i)}const nye=ee({argMax_:tye});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rye(t,e=0){const r={x:z(t,"x","argMin")},i={axis:e};return oe.runKernel(F6,r,i)}const iye=ee({argMin_:rye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sye(t){const n={x:z(t,"x","asin")};return oe.runKernel($6,n)}const oye=ee({asin_:sye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aye(t){const n={x:z(t,"x","asinh")};return oe.runKernel(U6,n)}const lye=ee({asinh_:aye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cye(t){const n={x:z(t,"x","atan")};return oe.runKernel(z6,n)}const uye=ee({atan_:cye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dye(t,e){let n=z(t,"a","atan2"),r=z(e,"b","atan2");[n,r]=Qn(n,r);const i={a:n,b:r};return oe.runKernel(H6,i)}const fye=ee({atan2_:dye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hye(t){const n={x:z(t,"x","atanh")};return oe.runKernel(G6,n)}const pye=ee({atanh_:hye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gH(t,e,n,r,i="NHWC",s){const o=t[3],a=[...e,o],l=Cp(i);return Bs(t,a,n,s,r,null,null,l)}function Bd(t,e,n,r,i,s,o="channelsLast"){const[a,l]=q1(e);let c;if(o==="channelsLast")c=[a,l,t[3],t[3]];else if(o==="channelsFirst")c=[a,l,t[1],t[1]];else throw new Error(`Unknown dataFormat ${o}`);return Bs(t,c,n,r,i,s,!1,o)}function B0(t,e,n,r,i,s,o="NDHWC"){const[a,l,c]=fT(e);let u,d;if(o==="NDHWC")d="channelsLast",u=[a,l,c,t[4],t[4]];else if(o==="NCDHW")d="channelsFirst",u=[a,l,c,t[1],t[1]];else throw new Error(`Unknown dataFormat ${o}`);return F0(t,u,n,r,i,!1,d,s)}function Bs(t,e,n,r,i,s,o=!1,a="channelsLast"){let[l,c,u,d]=[-1,-1,-1,-1];if(a==="channelsLast")[l,c,u,d]=t;else if(a==="channelsFirst")[l,d,c,u]=t;else throw new Error(`Unknown dataFormat ${a}`);const[f,h,,p]=e,[x,v]=q1(n),[y,b]=q1(r),S=Eh(f,y),w=Eh(h,b),{padInfo:E,outHeight:A,outWidth:T}=yye(i,c,u,x,v,S,w,s,a),I=o?p*d:p;let N;return a==="channelsFirst"?N=[l,I,A,T]:a==="channelsLast"&&(N=[l,A,T,I]),{batchSize:l,dataFormat:a,inHeight:c,inWidth:u,inChannels:d,outHeight:A,outWidth:T,outChannels:I,padInfo:E,strideHeight:x,strideWidth:v,filterHeight:f,filterWidth:h,effectiveFilterHeight:S,effectiveFilterWidth:w,dilationHeight:y,dilationWidth:b,inShape:t,outShape:N,filterShape:e}}function F0(t,e,n,r,i,s=!1,o="channelsLast",a){let[l,c,u,d,f]=[-1,-1,-1,-1,-1];if(o==="channelsLast")[l,c,u,d,f]=t;else if(o==="channelsFirst")[l,f,c,u,d]=t;else throw new Error(`Unknown dataFormat ${o}`);const[h,p,x,,v]=e,[y,b,S]=fT(n),[w,E,A]=fT(r),T=Eh(h,w),I=Eh(p,E),N=Eh(x,A),{padInfo:M,outDepth:P,outHeight:B,outWidth:F}=vye(i,c,u,d,y,b,S,T,I,N,a),U=s?v*f:v;let j;return o==="channelsFirst"?j=[l,U,P,B,F]:o==="channelsLast"&&(j=[l,P,B,F,U]),{batchSize:l,dataFormat:o,inDepth:c,inHeight:u,inWidth:d,inChannels:f,outDepth:P,outHeight:B,outWidth:F,outChannels:U,padInfo:M,strideDepth:y,strideHeight:b,strideWidth:S,filterDepth:h,filterHeight:p,filterWidth:x,effectiveFilterDepth:T,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:w,dilationHeight:E,dilationWidth:A,inShape:t,outShape:j,filterShape:e}}function mye(t,e,n,r,i){r==null&&(r=AI(t,e,n));const s=t[0],o=t[1],a=td((s-e+2*r)/n+1,i),l=td((o-e+2*r)/n+1,i);return[a,l]}function gye(t,e,n,r,i,s){i==null&&(i=AI(t,e,r));const o=t[0],a=t[1],l=t[2],c=td((o-e+2*i)/r+1,s),u=td((a-e+2*i)/r+1,s),d=td((l-e+2*i)/r+1,s);return[c,u,d,n]}function AI(t,e,n,r=1){const i=Eh(e,r);return Math.floor((t[0]*(n-1)-n+i)/2)}function q1(t){return typeof t=="number"?[t,t,t]:t.length===2?[t[0],t[1],1]:t}function fT(t){return typeof t=="number"?[t,t,t]:t}function Eh(t,e){return e<=1?t:t+(t-1)*(e-1)}function yye(t,e,n,r,i,s,o,a,l){let c,u,d;if(typeof t=="number"){c={top:t,bottom:t,left:t,right:t,type:t===0?"VALID":"NUMBER"};const h=mye([e,n],s,r,t,a);u=h[0],d=h[1]}else if(t==="same"){u=Math.ceil(e/r),d=Math.ceil(n/i);const f=Math.max(0,(u-1)*r+s-e),h=Math.max(0,(d-1)*i+o-n),p=Math.floor(f/2),x=f-p,v=Math.floor(h/2),y=h-v;c={top:p,bottom:x,left:v,right:y,type:"SAME"}}else if(t==="valid")c={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((e-s+1)/r),d=Math.ceil((n-o+1)/i);else if(typeof t=="object"){const f=l==="channelsLast"?t[1][0]:t[2][0],h=l==="channelsLast"?t[1][1]:t[2][1],p=l==="channelsLast"?t[2][0]:t[3][0],x=l==="channelsLast"?t[2][1]:t[3][1];c={top:f,bottom:h,left:p,right:x,type:f===0&&h===0&&p===0&&x===0?"VALID":"EXPLICIT"},u=td((e-s+f+h)/r+1,a),d=td((n-o+p+x)/i+1,a)}else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:c,outHeight:u,outWidth:d}}function vye(t,e,n,r,i,s,o,a,l,c,u){let d,f,h,p;if(typeof t=="number"){d={top:t,bottom:t,left:t,right:t,front:t,back:t,type:t===0?"VALID":"NUMBER"};const v=gye([e,n,r,1],a,1,i,t,u);f=v[0],h=v[1],p=v[2]}else if(t==="same"){f=Math.ceil(e/i),h=Math.ceil(n/s),p=Math.ceil(r/o);const x=(f-1)*i+a-e,v=(h-1)*s+l-n,y=(p-1)*o+c-r,b=Math.floor(x/2),S=x-b,w=Math.floor(v/2),E=v-w,A=Math.floor(y/2),T=y-A;d={top:w,bottom:E,left:A,right:T,front:b,back:S,type:"SAME"}}else if(t==="valid")d={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},f=Math.ceil((e-a+1)/i),h=Math.ceil((n-l+1)/s),p=Math.ceil((r-c+1)/o);else throw Error(`Unknown padding parameter: ${t}`);return{padInfo:d,outDepth:f,outHeight:h,outWidth:p}}function td(t,e){if(!e)return Math.trunc(t);switch(e){case"round":return Math.round(t);case"ceil":return Math.ceil(t);case"floor":return Math.floor(t);default:throw new Error(`Unknown roundingMode ${e}`)}}function Zg(t){const[e,n,r]=q1(t);return e===1&&n===1&&r===1}function ls(t,e){return Zg(t)||Zg(e)}function Cp(t){if(t==="NHWC")return"channelsLast";if(t==="NCHW")return"channelsFirst";throw new Error(`Unknown dataFormat ${t}`)}function So(t,e,n){if(n!=null){if(typeof e=="string")throw Error(`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);if(typeof e=="number")Y(qh(e),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${e}.`);else if(typeof e=="object")e.forEach(r=>{r.forEach(i=>{Y(qh(i),()=>`Error in ${t}: pad must be an integer when using dimRoundingMode ${n} but got pad ${i}.`)})});else throw Error(`Error in ${t}: Unknown padding parameter: ${e}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xye(t,e){const r={x:z(t,"x","reshape","string_or_numeric")},i={shape:e};return oe.runKernel(T8,r,i)}const Pe=ee({reshape_:xye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bye(t,e,n,r,i){const s=z(t,"x","avgPool","float32"),o=1;Y(ls(n,o),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`);let a=s,l=!1;s.rank===3&&(l=!0,a=Pe(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Y(a.rank===4,()=>`Error in avgPool: x must be rank 4 but got rank ${a.rank}.`),So("avgPool",r,i);const c={x:a},u={filterSize:e,strides:n,pad:r,dimRoundingMode:i};let d=oe.runKernel(V6,c,u);return d=hr(d,s.dtype),l?Pe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const yH=ee({avgPool_:bye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sye(t,e,n,r,i,s="NDHWC"){const o=z(t,"x","avgPool3d","float32");let a=o,l=!1;o.rank===4&&(l=!0,a=Pe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Y(a.rank===5,()=>`Error in avgPool3d: x must be rank 5 but got rank ${a.rank}.`),Y(s==="NDHWC",()=>`Error in avgPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),So("avgPool3d",r,i);const c={x:a},u={filterSize:e,strides:n,pad:r,dimRoundingMode:i,dataFormat:s};let d=oe.runKernel(W6,c,u);return d=hr(d,a.dtype),l?Pe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const _ye=ee({avgPool3d_:Sye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wye(t,e=0){Y(t.length>=1,()=>"Pass at least one tensor to concat");const n=j1(t,"tensors","concat","string_or_numeric");if(n[0].dtype==="complex64"&&n.forEach(s=>{if(s.dtype!=="complex64")throw new Error(`Cannot concatenate complex64 tensors with a tensor
          with dtype ${s.dtype}. `)}),n.length===1)return _c(n[0]);const r=n,i={axis:e};return oe.runKernel(ez,r,i)}const pr=ee({concat_:wye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cye(t){const n={x:z(t,"x","sigmoid","float32")};return oe.runKernel(G8,n)}const nd=ee({sigmoid_:Cye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Eye(t,e,n){const r=z(t,"x","slice","string_or_numeric");if(r.rank===0)throw new Error("Slicing scalar is not possible");const i={x:r},s={begin:e,size:n};return oe.runKernel(F8,i,s)}const Rt=ee({slice_:Eye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Aye(t){const n={x:z(t,"x","tanh","float32")};return oe.runKernel(aG,n)}const hT=ee({tanh_:Aye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tye(t,e,n,r,i,s){const o=z(t,"forgetBias","basicLSTMCell"),a=z(e,"lstmKernel","basicLSTMCell"),l=z(n,"lstmBias","basicLSTMCell"),c=z(r,"data","basicLSTMCell"),u=z(i,"c","basicLSTMCell"),d=z(s,"h","basicLSTMCell"),f=pr([c,d],1),h=yn(f,a),p=cr(h,l),x=p.shape[0],v=p.shape[1]/4,y=[x,v],b=Rt(p,[0,0],y),S=Rt(p,[0,v],y),w=Rt(p,[0,v*2],y),E=Rt(p,[0,v*3],y),A=cr(Et(nd(b),hT(S)),Et(u,nd(cr(o,w)))),T=Et(hT(A),nd(E));return[A,T]}const Mye=ee({basicLSTMCell_:Tye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rye(t,e,n){const r=z(t,"x","batchToSpaceND"),i=e.reduce((a,l)=>a*l);Y(r.rank>=1+e.length,()=>`input rank is ${r.rank} but should be > than blockShape.length ${e.length}`),Y(n.length===e.length,()=>`crops.length is ${n.length} but should be equal to blockShape.length  ${e.length}`),Y(r.shape[0]%i===0,()=>`input tensor batch is ${r.shape[0]} but is not divisible by the product of the elements of blockShape ${e.join(" * ")} === ${i}`);const s={x:r},o={blockShape:e,crops:n};return oe.runKernel(X6,s,o)}const vH=ee({batchToSpaceND_:Rye});function Iye(t){let e;return t.rank===0||t.rank===1?e=Pe(t,[1,1,1,t.size]):t.rank===2?e=Pe(t,[1,1,t.shape[0],t.shape[1]]):t.rank===3?e=Pe(t,[1,t.shape[0],t.shape[1],t.shape[2]]):e=t,e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nye(t,e,n,r,i,s){s==null&&(s=.001);const o=z(t,"x","batchNorm"),a=z(e,"mean","batchNorm"),l=z(n,"variance","batchNorm");let c;i!=null&&(c=z(i,"scale","batchNorm"));let u;r!=null&&(u=z(r,"offset","batchNorm")),Y(a.rank===l.rank,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Y(u==null||a.rank===u.rank,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Y(c==null||a.rank===c.rank,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");const f={x:Iye(o),scale:c,offset:u,mean:a,variance:l},h={varianceEpsilon:s},p=oe.runKernel(Nz,f,h);return Pe(p,o.shape)}const n_=ee({batchNorm_:Nye});function Pye(t,e,n,r,i,s){const o=z(t,"x","batchNorm"),a=z(e,"mean","batchNorm"),l=z(n,"variance","batchNorm");let c;i!=null&&(c=z(i,"scale","batchNorm"));let u;return r!=null&&(u=z(r,"offset","batchNorm")),Y(o.rank===2,()=>`Error in batchNorm2D: x must be rank 2 but got rank ${o.rank}.`),Y(a.rank===2||a.rank===1,()=>`Error in batchNorm2D: mean must be rank 2 or rank 1 but got rank ${a.rank}.`),Y(l.rank===2||l.rank===1,()=>`Error in batchNorm2D: variance must be rank 2 or rank 1 but got rank ${l.rank}.`),c!=null&&Y(c.rank===2||c.rank===1,()=>`Error in batchNorm2D: scale must be rank 2 or rank 1 but got rank ${c.rank}.`),u!=null&&Y(u.rank===2||u.rank===1,()=>`Error in batchNorm2D: offset must be rank 2 or rank 1 but got rank ${u.rank}.`),n_(o,a,l,u,c,s)}const kye=ee({batchNorm2d_:Pye});function Dye(t,e,n,r,i,s){const o=z(t,"x","batchNorm"),a=z(e,"mean","batchNorm"),l=z(n,"variance","batchNorm");let c;i!=null&&(c=z(i,"scale","batchNorm"));let u;return r!=null&&(u=z(r,"offset","batchNorm")),Y(o.rank===3,()=>`Error in batchNorm3D: x must be rank 3 but got rank ${o.rank}.`),Y(a.rank===3||a.rank===1,()=>`Error in batchNorm3D: mean must be rank 3 or rank 1 but got rank ${a.rank}.`),Y(l.rank===3||l.rank===1,()=>`Error in batchNorm3D: variance must be rank 3 or rank 1 but got rank ${l.rank}.`),c!=null&&Y(c.rank===3||c.rank===1,()=>`Error in batchNorm3D: scale must be rank 3 or rank 1 but got rank ${c.rank}.`),u!=null&&Y(u.rank===3||u.rank===1,()=>`Error in batchNorm3D: offset must be rank 3 or rank 1 but got rank ${u.rank}.`),n_(o,a,l,u,c,s)}const Oye=ee({batchNorm3d_:Dye});function Lye(t,e,n,r,i,s){const o=z(t,"x","batchNorm"),a=z(e,"mean","batchNorm"),l=z(n,"variance","batchNorm");let c;i!=null&&(c=z(i,"scale","batchNorm"));let u;return r!=null&&(u=z(r,"offset","batchNorm")),Y(o.rank===4,()=>`Error in batchNorm4D: x must be rank 4 but got rank ${o.rank}.`),Y(a.rank===4||a.rank===1,()=>`Error in batchNorm4D: mean must be rank 4 or rank 1 but got rank ${a.rank}.`),Y(l.rank===4||l.rank===1,()=>`Error in batchNorm4D: variance must be rank 4 or rank 1 but got rank ${l.rank}.`),c!=null&&Y(c.rank===4||c.rank===1,()=>`Error in batchNorm4D: scale must be rank 4 or rank 1 but got rank ${c.rank}.`),u!=null&&Y(u.rank===4||u.rank===1,()=>`Error in batchNorm4D: offset must be rank 4 or rank 1 but got rank ${u.rank}.`),n_(o,a,l,u,c,s)}const Bye=ee({batchNorm4d_:Lye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fye(t,e,n){const r=z(t,"x","bincount"),i=z(e,"weights","bincount");Y(r.dtype==="int32",()=>`Error in bincount: input dtype must be int32, but got ${r.dtype}`),Y(n>=0,()=>`size must be non-negative, but got ${n}.`),Y(i.size===r.size||i.size===0,()=>`Error in bincount: weights must have the same size as input or0-length, but got input shape: ${r.shape}, weights shape: ${i.shape}.`);const s={x:r,weights:i},o={size:n};return oe.runKernel(K6,s,o)}const xH=ee({bincount_:Fye});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $ye(t,e){const n=z(t,"s0","broadcastArgs","int32"),r=z(e,"s1","broadcastArgs","int32");if(n.rank!==1)throw new Error(`broadcastArgs(): first input must be a vector (rank=1). Has rank ${n.rank}`);if(r.rank!==1)throw new Error(`broadcastArgs(): second input must be a vector (rank=1). Has rank ${r.rank}`);const i={s0:n,s1:r};return oe.runKernel(q6,i)}const Uye=ee({broadcastArgs_:$ye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zye(t,e){let n=z(t,"broadcastTo","x");const r=n.shape;if(e.some(c=>!(c>0)||c%1!==0))throw new Error(`broadcastTo(): Invalid broadcast shape [${e}].`);if(e.length<n.rank)throw new Error(`broadcastTo(): shape.length=${e.length} < input.rank=${n.rank}.`);if(e.length>n.rank){const c=n.shape.slice();for(;c.length<e.length;)c.unshift(1);n=Pe(n,c)}const i=n.shape,s=Array.from(e);for(let c=e.length-1;c>=0;c--)if(i[c]===e[c])s[c]=1;else if(n.shape[c]!==1)throw new Error(`broadcastTo(): [${r}] cannot be broadcast to [${e}].`);if(s.map((c,u)=>c>1?u:-1).filter(c=>c>=0).length===0)return _c(n);const a={x:n},l={reps:s};return oe.runKernel(pI,a,l)}const lg=ee({broadcastTo_:zye});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gye(t){const n={x:z(t,"x","ceil","float32")};return oe.runKernel(J6,n)}const Hye=ee({ceil_:Gye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r_(t,e,n){const r={shape:t,value:e,dtype:n};return oe.runKernel(Tz,{},r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vye(t,e,n){const r=z(t,"x","clipByValue");if(Y(e<=n,()=>`Error in clip: min (${e}) must be less than or equal to max (${n}).`),e===n)return r_(r.shape,e,r.dtype);const i={x:r},s={clipValueMin:e,clipValueMax:n};return oe.runKernel(Y6,i,s)}const Wye=ee({clipByValue_:Vye});function jye(t){return pr(t,0)}const Xye=ee({concat1d_:jye});function Kye(t,e){return pr(t,e)}const TI=ee({concat2d_:Kye});function qye(t,e){return pr(t,e)}const Jye=ee({concat3d_:qye});function Yye(t,e){return pr(t,e)}const Qye=ee({concat4d_:Yye});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zye(t,e,n,r,i="NHWC",s=[1,1],o){const a=z(t,"x","conv2d","float32"),l=z(e,"filter","conv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=Pe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Y(c.rank===4,()=>`Error in conv2d: input must be rank 4, but got rank ${c.rank}.`),Y(l.rank===4,()=>`Error in conv2d: filter must be rank 4, but got rank ${l.rank}.`),So("conv2d",r,o);const d=i==="NHWC"?c.shape[3]:c.shape[1];Y(d===l.shape[2],()=>`Error in conv2d: depth of input (${d}) must match input depth for filter ${l.shape[2]}.`),Y(ls(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);const f={x:c,filter:l},h={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:o},p=oe.runKernel(tz,f,h);return u?Pe(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const i_=ee({conv2d_:Zye});function eve(t,e,n,r,i="NWC",s=1,o){const a=z(t,"x","conv1d"),l=z(e,"filter","conv1d");let c=a,u=!1;a.rank===2&&(u=!0,c=Pe(a,[1,a.shape[0],a.shape[1]])),Y(c.rank===3,()=>`Error in conv1d: input must be rank 3, but got rank ${c.rank}.`),Y(l.rank===3,()=>`Error in conv1d: filter must be rank 3, but got rank ${l.rank}.`),So("conv1d",r,o),Y(c.shape[2]===l.shape[1],()=>`Error in conv1d: depth of input (${c.shape[2]}) must match input depth for filter ${l.shape[1]}.`),Y(ls(n,s),()=>`Error in conv1D: Either stride or dilation must be 1. Got stride ${n} and dilation '${s}'`),Y(i==="NWC",()=>`Error in conv1d: got dataFormat of ${i} but only NWC is currently supported.`);const d=Pe(l,[1,l.shape[0],l.shape[1],l.shape[2]]),f=Pe(c,[c.shape[0],1,c.shape[1],c.shape[2]]),v=i_(f,d,[1,n],r,"NHWC",[1,s],o);return u?Pe(v,[v.shape[2],v.shape[3]]):Pe(v,[v.shape[0],v.shape[2],v.shape[3]])}const tve=ee({conv1d_:eve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nve(t,e,n,r,i,s="NHWC",o){Y(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let a=t,l=e,c=!1;e.rank===3&&(c=!0,l=Pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]),a=[1,t[0],t[1],t[2]]),Y(a.length===4,()=>`Error in conv2dDerInput: inShape must be length 4, but got length ${a.length}.`),Y(l.rank===4,()=>`Error in conv2dDerInput: dy must be rank 4, but got rank ${l.rank}`),Y(n.rank===4,()=>`Error in conv2dDerInput: filter must be rank 4, but got rank ${n.rank}`);const u=s==="NHWC"?a[3]:a[1],d=s==="NHWC"?l.shape[3]:l.shape[1];Y(u===n.shape[2],()=>`Error in conv2dDerInput: depth of input (${u}) must match input depth for filter ${n.shape[2]}.`),Y(d===n.shape[3],()=>`Error in conv2dDerInput: depth of output (${d}) must match output depth for filter ${n.shape[3]}.`),So("conv2dDerInput",i,o);const f={dy:l,filter:n},h={strides:r,pad:i,dataFormat:s,dimRoundingMode:o,inputShape:a},p=oe.runKernel(rz,f,h);return c?Pe(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const bH=ee({conv2DBackpropInput_:nve});function rve(t,e,n,r,i,s){const o=z(t,"x","conv2dTranspose"),a=z(e,"filter","conv2dTranspose");return bH(n,o,a,r,i,"NHWC",s)}const ive=ee({conv2dTranspose_:rve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sve(t,e,n,r,i="NDHWC",s=[1,1,1]){const o=z(t,"x","conv3d"),a=z(e,"filter","conv3d");let l=o,c=!1;o.rank===4&&(c=!0,l=Pe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Y(l.rank===5,()=>`Error in conv3d: input must be rank 5, but got rank ${l.rank}.`),Y(a.rank===5,()=>`Error in conv3d: filter must be rank 5, but got rank ${a.rank}.`),Y(l.shape[4]===a.shape[3],()=>`Error in conv3d: depth of input (${l.shape[4]}) must match input depth for filter ${a.shape[3]}.`),Y(ls(n,s),()=>`Error in conv3D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),Y(i==="NDHWC",()=>`Error in conv3d: got dataFormat of ${i} but only NDHWC is currently supported.`);const u={x:l,filter:a},d={strides:n,pad:r,dataFormat:i,dilations:s},f=oe.runKernel(iz,u,d);return c?Pe(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const ove=ee({conv3d_:sve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ave(t,e,n,r,i){Y(t.length===e.rank,()=>`Length of inShape (${t.length}) and rank of dy (${e.rank}) must match`);let s=t,o=e,a=!1;e.rank===4&&(a=!0,o=Pe(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]),s=[1,t[0],t[1],t[2],t[3]]);const l=s[4],c=o.shape[4];Y(s.length===5,()=>`Error in conv3dDerInput: inShape must be length 5, but got length ${s.length}.`),Y(o.rank===5,()=>`Error in conv3dDerInput: dy must be rank 5, but got rank ${o.rank}`),Y(n.rank===5,()=>`Error in conv3dDerInput: filter must be rank 5, but got rank ${n.rank}`),Y(l===n.shape[3],()=>`Error in conv3dDerInput: depth of input (${l}) must match input depth for filter ${n.shape[3]}.`),Y(c===n.shape[4],()=>`Error in conv3dDerInput: depth of output (${c}) must match output depth for filter ${n.shape[4]}.`);const u={dy:o,filter:n},d={pad:i,strides:r,inputShape:s},f=oe.runKernel(sz,u,d);return a?Pe(f,[f.shape[1],f.shape[2],f.shape[3],f.shape[4]]):f}const lve=ee({conv3DBackpropInput_:ave});function cve(t,e,n,r,i){const s=z(t,"x","conv3dTranspose"),o=z(e,"filter","conv3dTranspose");return lve(n,s,o,r,i)}const uve=ee({conv3dTranspose_:cve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dve(t){const n={x:z(t,"x","cos","float32")};return oe.runKernel(oz,n)}const fve=ee({cos_:dve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hve(t){const n={x:z(t,"x","cosh","float32")};return oe.runKernel(az,n)}const pve=ee({cosh_:hve});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an 'AS IS' BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mve(t,e=0,n=!1,r=!1){const s={x:z(t,"x","cumprod")},o={axis:e,exclusive:n,reverse:r};return oe.runKernel(lz,s,o)}const gve=ee({cumprod_:mve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yve(t,e=0,n=!1,r=!1){const s={x:z(t,"x","cumsum")},o={axis:e,exclusive:n,reverse:r};return oe.runKernel(cz,s,o)}const vve=ee({cumsum_:yve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xve(t,e,n,r=!1){const i=z(t,"x","denseBincount"),s=z(e,"weights","denseBincount");Y(i.dtype==="int32",()=>`Error in denseBincount: input dtype must be int32, but got ${i.dtype}`),Y(i.rank<=2,()=>`Error in denseBincount: input must be at most rank 2, but got rank ${i.rank}.`),Y(n>=0,()=>`size must be non-negative, but got ${n}.`),Y(s.size===i.size||s.size===0,()=>`Error in denseBincount: weights must have the same shape as x or 0-length, but got x shape: ${i.shape}, weights shape: ${s.shape}.`);const o={x:i,weights:s},a={size:n,binaryOutput:r};return oe.runKernel(dz,o,a)}const bve=ee({denseBincount_:xve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sve(t,e,n="NHWC"){const r=z(t,"x","depthToSpace","float32"),i=n==="NHWC"?r.shape[1]:r.shape[2],s=n==="NHWC"?r.shape[2]:r.shape[3],o=n==="NHWC"?r.shape[3]:r.shape[1];Y(e>1,()=>`blockSize should be > 1 for depthToSpace, but was: ${e}`),Y(i*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${i} and ${e}  for depthToSpace with input shape
    ${r.shape}`),Y(s*e>=0,()=>`Negative dimension size caused by overflow when multiplying
    ${s} and ${e} for depthToSpace with input shape
        ${r.shape}`),Y(o%(e*e)===0,()=>`Dimension size must be evenly divisible by ${e*e} but is ${o} for depthToSpace with input shape ${r.shape}`);const a={x:r},l={blockSize:e,dataFormat:n};return oe.runKernel(fz,a,l)}const _ve=ee({depthToSpace_:Sve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wve(t,e,n,r,i="NHWC",s=[1,1],o){const a=z(t,"x","depthwiseConv2d","float32"),l=z(e,"filter","depthwiseConv2d","float32");let c=a,u=!1;a.rank===3&&(u=!0,c=Pe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Y(c.rank===4,()=>`Error in depthwiseConv2d: input must be rank 4, but got rank ${c.rank}.`),Y(l.rank===4,()=>`Error in depthwiseConv2d: filter must be rank 4, but got rank ${l.rank}.`);const d=i==="NHWC"?c.shape[3]:c.shape[1];Y(d===l.shape[2],()=>`Error in depthwiseConv2d: number of input channels (${d}) must match the inChannels dimension in filter ${l.shape[2]}.`),So("depthwiseConv2d",r,o);const f={x:c,filter:l},h={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:o},p=oe.runKernel(hz,f,h);return u?Pe(p,[p.shape[1],p.shape[2],p.shape[3]]):p}const MI=ee({depthwiseConv2d_:wve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cve(t){const n={x:z(t,"x","diag")};return oe.runKernel(gz,n)}const Eve=ee({diag_:Cve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ave(t,e,n,r,i=[1,1],s="NHWC"){const o=z(t,"x","dilation2d"),a=z(e,"filter","dilation2d");Y(o.rank===3||o.rank===4,()=>`Error in dilation2d: input must be rank 3 or 4, but got rank ${o.rank}.`),Y(a.rank===3,()=>`Error in dilation2d: filter must be rank 3, but got rank ${a.rank}.`),Y(s==="NHWC",()=>`Error in dilation2d: Only NHWC is currently supported, but got dataFormat of ${s}`);let l=o,c=!1;o.rank===3&&(l=Pe(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=!0);const u={x:l,filter:a},d={strides:n,pad:r,dilations:i},f=oe.runKernel(yz,u,d);return c?Pe(f,[f.shape[1],f.shape[2],f.shape[3]]):f}const Tve=ee({dilation2d_:Ave});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mve(t,e){let n=z(t,"a","equal","string_or_numeric"),r=z(e,"b","equal","string_or_numeric");[n,r]=Qn(n,r),Qt(n.shape,r.shape);const i={a:n,b:r};return oe.runKernel(_z,i)}const SH=ee({equal_:Mve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rve(t,e,n){const r=z(e,"a","where"),i=z(n,"b","where"),s=z(t,"condition","where","bool"),o=Qt(Qt(s.shape,r.shape),i.shape),a=lg(s,o),l=lg(r,o),c=lg(i,o),u={condition:a,t:l,e:c};return oe.runKernel(L8,u)}const ep=ee({where_:Rve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ive(t){const n={x:z(t,"x","zerosLike")};return oe.runKernel(hG,n)}const RI=ee({zerosLike_:Ive});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nve(t,e){let n=z(t,"a","div"),r=z(e,"b","div");[n,r]=Qn(n,r);const i=ar(n,r),s=RI(i),o=SH(r,s);return ep(o,s,i)}const Pve=ee({divNoNan_:Nve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kve(t,e){const n=z(t,"t1","dot"),r=z(e,"t2","dot");Y((n.rank===1||n.rank===2)&&(r.rank===1||r.rank===2),()=>`Error in dot: inputs must all be rank 1 or 2, but got ranks ${n.rank} and ${r.rank}.`);const i=n.rank===1?n.size:n.shape[1],s=r.rank===1?r.size:r.shape[0];if(Y(i===s,()=>`Error in dot: inner dimensions of inputs must match, but got ${i} and ${s}.`),n.rank===1&&r.rank===1){const o=Pe(n,[1,-1]),a=Pe(r,[-1,1]),l=yn(o,a);return Pe(l,[])}else if(n.rank===1&&r.rank===2){const o=Pe(n,[1,-1]),a=Pe(r,[r.shape[0],r.shape[1]]),l=yn(o,a);return Pe(l,[l.size])}else if(n.rank===2&&r.rank===1){const o=Pe(r,[-1,1]),a=yn(n,o);return Pe(a,[a.size])}else{const o=Pe(r,[r.shape[0],r.shape[1]]);return yn(n,o)}}const Dve=ee({dot_:kve});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ove(t,...e){const n=e.map((i,s)=>z(i,`tensors${s}`,"einsum")),r={equation:t};return oe.runKernel(xz,n,r)}const Lve=ee({einsum_:Ove});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bve(t){const n={x:z(t,"x","elu","float32")};return oe.runKernel(bz,n)}const _H=ee({elu_:Bve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fve(t){let e=z(t,"x","erf");Y(e.dtype==="int32"||e.dtype==="float32",()=>"Input dtype must be `int32` or `float32`."),e.dtype==="int32"&&(e=hr(e,"float32"));const n={x:e};return oe.runKernel(Sz,n)}const $ve=ee({erf_:Fve});/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function II(t,e){for(let n=0;n<t.length;++n)if(t[t.length-n-1]!==e-1-n)return!1;return!0}function wH(t,e,n){const r=t.length+e.length,i=[];let s=0,o=0;for(let a=0;a<r;a++)n.indexOf(a)===-1?i.push(t[s++]):i.push(e[o++]);return i}function Oa(t,e){const n=[],r=t.length;for(let s=0;s<r;s++)e.indexOf(s)===-1&&n.push(t[s]);const i=e.map(s=>t[s]);return[n,i]}function Fs(t,e){const n=e.map(r=>1);return wH(t,n,e)}function ta(t,e,n){Y(II(e,n),()=>`${t} supports only inner-most axes for now. Got axes ${e} and rank-${n} input.`)}function _o(t,e){if(II(t,e))return null;const n=[];for(let r=0;r<e;++r)t.indexOf(r)===-1&&n.push(r);return t.forEach(r=>n.push(r)),n}function NI(t){return t.map((e,n)=>[n,e]).sort((e,n)=>e[1]-n[1]).map(e=>e[0])}function wo(t,e){const n=[];for(let r=e-t;r<e;++r)n.push(r);return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uve(t,e=null,n=!1){const i={x:z(t,"x","max")},s={reductionIndices:e,keepDims:n};return oe.runKernel(Yz,i,s)}const Ah=ee({max_:Uve});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zve(t,e=null,n=!1){const i={x:z(t,"x","min")},s={axis:e,keepDims:n};return oe.runKernel(r8,i,s)}const pT=ee({min_:zve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gve(t,e){let n=z(t,"base","pow"),r=z(e,"exp","pow");[n,r]=Qn(n,r);const i={a:n,b:r};return oe.runKernel(v8,i)}const PI=ee({pow_:Gve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fn(t,e){if((Na(t)&&e!=="string"||Array.isArray(t))&&e!=="complex64")throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if(e==="string"&&Na(t)&&!(t instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return Gc(t,[],[],e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hve(t){const n={x:z(t,"x","sqrt","float32")};return oe.runKernel(V8,n)}const mT=ee({sqrt_:Hve});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vve(t){const e=z(t,"x","square"),n={};return oe.runKernel("Square",{x:e},n)}const s_=ee({square_:Vve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wve(t,e=null,n=!1){let r=z(t,"x","sum");r.dtype==="bool"&&(r=hr(r,"int32"));const i={x:r},s={axis:e,keepDims:n};return oe.runKernel(W8,i,s)}const Rn=ee({sum_:Wve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jve(t,e="euclidean",n=null,r=!1){t=z(t,"x","norm");const i=CH(t,e,n);let s=i.shape;if(r){const o=Dr(n,t.shape);s=Fs(i.shape,o)}return Pe(i,s)}function CH(t,e,n=null){if(t.rank===0)return Zs(t);if(t.rank!==1&&n===null)return CH(Pe(t,[-1]),e,n);if(t.rank===1||typeof n=="number"||Array.isArray(n)&&n.length===1){if(e===1)return Rn(Zs(t),n);if(e===1/0)return Ah(Zs(t),n);if(e===-1/0)return pT(Zs(t),n);if(e==="euclidean"||e===2)return mT(Rn(PI(Zs(t),fn(2,"int32")),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}if(Array.isArray(n)&&n.length===2){if(e===1)return Ah(Rn(Zs(t),n[0]),n[1]-1);if(e===1/0)return Ah(Rn(Zs(t),n[1]),n[0]);if(e===-1/0)return pT(Rn(Zs(t),n[1]),n[0]);if(e==="fro"||e==="euclidean")return mT(Rn(s_(t),n));throw new Error(`Error in norm: invalid ord value: ${e}`)}throw new Error(`Error in norm: invalid axis: ${n}`)}const o_=ee({norm_:jve});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xve(t,e=null,n=!1){return o_(t,"euclidean",e,n)}const Kve=ee({euclideanNorm_:Xve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qve(t){const n={x:z(t,"x","exp")};return oe.runKernel(wz,n)}const bd=ee({exp_:qve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jve(t,e=0){const n=z(t,"x","expandDims","string_or_numeric");Y(e<=n.rank,()=>"Axis must be <= rank of the tensor");const r={input:n},i={dim:e};return oe.runKernel(Cz,r,i)}const Qa=ee({expandDims_:Jve});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Yve(t){const n={x:z(t,"x","expm1")};return oe.runKernel(Ez,n)}const Qve=ee({expm1_:Yve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zve(t,e){const n=z(t,"x","tile","string_or_numeric");Y(n.rank===e.length,()=>`Error in transpose: rank of input ${n.rank} must match length of reps ${e}.`);const r={x:n},i={reps:e};return oe.runKernel(pI,r,i)}const cg=ee({tile_:Zve});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function exe(t,e,n,r="float32"){e==null&&(e=t);const i=Vn([t,e],r),s=t<=e?t:e;for(let a=0;a<s;++a)i.set(1,a,a);const o=Pe(i.toTensor(),[t,e]);if(n==null)return o;if(n.length===1)return cg(Qa(o,0),[n[0],1,1]);if(n.length===2)return cg(Qa(Qa(o,0),0),[n[0],n[1],1,1]);if(n.length===3)return cg(Qa(Qa(Qa(o,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error(`eye() currently supports only 1D and 2D batchShapes, but received ${n.length}D.`)}const EH=ee({eye_:exe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function txe(t){const n={x:z(t,"x","floor","float32")};return oe.runKernel(Rz,n)}const AH=ee({floor_:txe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nxe(t,e,n=0,r=0){const i=z(t,"x","gather"),s=z(e,"indices","gather","int32"),o={x:i,indices:s},a={axis:n,batchDims:r};return oe.runKernel(Pz,o,a)}const TH=ee({gather_:nxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rxe(t,e){let n=z(t,"a","greater","string_or_numeric"),r=z(e,"b","greater","string_or_numeric");[n,r]=Qn(n,r),Qt(n.shape,r.shape);const i={a:n,b:r};return oe.runKernel(Dz,i)}const a_=ee({greater_:rxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ixe(t,e){let n=z(t,"a","greaterEqual","string_or_numeric"),r=z(e,"b","greaterEqual","string_or_numeric");[n,r]=Qn(n,r),Qt(n.shape,r.shape);const i={a:n,b:r};return oe.runKernel(Oz,i)}const MH=ee({greaterEqual_:ixe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sxe(t){const n={x:z(t,"x","isFinite")};return oe.runKernel(Fz,n)}const oxe=ee({isFinite_:sxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function axe(t){const n={x:z(t,"x","isInf")};return oe.runKernel($z,n)}const lxe=ee({isInf_:axe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cxe(t){const n={x:z(t,"x","isNaN")};return oe.runKernel(Uz,n)}const uxe=ee({isNaN_:cxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dxe(t,e=.2){const r={x:z(t,"x","leakyRelu")},i={alpha:e};return oe.runKernel(zz,r,i)}const RH=ee({leakyRelu_:dxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fxe(t,e){let n=z(t,"a","less","string_or_numeric"),r=z(e,"b","less","string_or_numeric");[n,r]=Qn(n,r),Qt(n.shape,r.shape);const i={a:n,b:r};return oe.runKernel(Gz,i)}const hxe=ee({less_:fxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pxe(t,e){let n=z(t,"a","lessEqual","string_or_numeric"),r=z(e,"b","lessEqual","string_or_numeric");[n,r]=Qn(n,r),Qt(n.shape,r.shape);const i={a:n,b:r};return oe.runKernel(Hz,i)}const kI=ee({lessEqual_:pxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mxe(t,e,n){if(n<=0)throw new Error("The number of values should be positive.");const r={start:t,stop:e,num:n};return oe.runKernel(Vz,{},r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gxe(t,e=5,n=1,r=1,i=.5){const s=z(t,"x","localResponseNormalization");Y(s.rank===4||s.rank===3,()=>`Error in localResponseNormalization: x must be rank 3 or 4 but got
               rank ${s.rank}.`),Y(qh(e),()=>`Error in localResponseNormalization: depthRadius must be an integer but got depthRadius ${e}.`);let o=s,a=!1;s.rank===3&&(a=!0,o=Pe(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const l={x:o},c={depthRadius:e,bias:n,alpha:r,beta:i},u=oe.runKernel(Jz,l,c);return a?Pe(u,[u.shape[1],u.shape[2],u.shape[3]]):u}const yxe=ee({localResponseNormalization_:gxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vxe(t){const n={x:z(t,"x","log","float32")};return oe.runKernel(Wz,n)}const e0=ee({log_:vxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xxe(t){const n={x:z(t,"x","log1p")};return oe.runKernel(jz,n)}const IH=ee({log1p_:xxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _l(t){return oe.customGrad(t)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bxe(t){const n={x:z(t,"x","softplus")};return oe.runKernel(H8,n)}const NH=ee({softplus_:bxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sxe(t){const e=z(t,"x","logSigmoid");return _l(r=>({value:ul(NH(ul(r))),gradFunc:o=>Et(o,nd(ul(r)))}))(e)}const _xe=ee({logSigmoid_:Sxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wxe(t,e){let n=z(t,"a","sub"),r=z(e,"b","sub");[n,r]=Qn(n,r);const i={a:n,b:r};return oe.runKernel(sG,i)}const zt=ee({sub_:wxe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Cxe(t,e=-1){const n=z(t,"logits","logSoftmax");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Log Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and axis was ${e}`);return _l((i,s)=>{const a=Ah(i,e,!0),l=zt(i,a),c=zt(hr(l,"float32"),e0(Rn(bd(l),e,!0)));return s([c]),{value:c,gradFunc:(d,f)=>{const[h]=f,p=!0,x=bd(h);return zt(d,Et(Rn(d,e,p),x))}}})(n)}const Exe=ee({logSoftmax_:Cxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Axe(t,e=null,n=!1){const r=z(t,"x","logSumExp"),i=Dr(e,r.shape),s=Ah(r,i,!0),o=zt(r,s),a=bd(o),l=Rn(a,i),c=e0(l),u=cr(Pe(s,c.shape),c);if(n){const d=Fs(u.shape,i);return Pe(u,d)}return u}const PH=ee({logSumExp_:Axe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Txe(t,e){const n=z(t,"a","logicalAnd","bool"),r=z(e,"b","logicalAnd","bool");Qt(n.shape,r.shape);const i={a:n,b:r};return oe.runKernel(Xz,i)}const J1=ee({logicalAnd_:Txe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Mxe(t){const n={x:z(t,"x","logicalNot","bool")};return oe.runKernel(Kz,n)}const kH=ee({logicalNot_:Mxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rxe(t,e){const n=z(t,"a","logicalOr","bool"),r=z(e,"b","logicalOr","bool");Qt(n.shape,r.shape);const i={a:n,b:r};return oe.runKernel(qz,i)}const DH=ee({logicalOr_:Rxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ixe(t,e){const n=z(t,"a","logicalXor","bool"),r=z(e,"b","logicalXor","bool");return Qt(n.shape,r.shape),J1(DH(t,e),kH(J1(t,e)))}const Nxe=ee({logicalXor_:Ixe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const px=2147483648;function Pxe(t,e,n="left"){const r=z(t,"sortedSequence","searchSorted"),i=z(e,"values","searchSorted"),s=r.shape[r.shape.length-1],o=i.shape[i.shape.length-1],a=Pe(r,[-1,s]),l=Pe(i,[-1,o]);if(a.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(a.shape[0]!==l.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Ve(l.shape)>=px)throw new Error(`values tensor size must less than ${px}`);if(a.shape[1]>=px)throw new Error(`trailing dim_size must less than ${px} for int32 output type, was ${a.shape[1]}`);const c={sortedSequence:a,values:l},u={side:n};return oe.runKernel(O8,c,u)}const DI=ee({searchSorted_:Pxe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kxe(t,e){return DI(t,e,"left")}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dxe(t,e,n,r,i){const s=z(t,"x","maxPool"),o=1;let a=s,l=!1;s.rank===3&&(l=!0,a=Pe(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Y(a.rank===4,()=>`Error in maxPool: input must be rank 4 but got rank ${a.rank}.`),Y(ls(n,o),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${n} and dilations '${o}'`),So("maxPool",r,i);const c={x:a},u={filterSize:e,strides:n,pad:r,dimRoundingMode:i},d=oe.runKernel(Zz,c,u);return l?Pe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const OH=ee({maxPool_:Dxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Oxe(t,e=[1,1,1],n,r,i,s="NDHWC"){const o=z(t,"x","maxPool3d");let a=o,l=!1;o.rank===4&&(l=!0,a=Pe(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Y(a.rank===5,()=>`Error in maxPool3d: x must be rank 5 but got rank ${a.rank}.`),Y(s==="NDHWC",()=>`Error in maxPool3d: Only NDHWC is currently supported, but got dataFormat of ${s}`),So("maxPool3d",r,i);const c={x:a},u={filterSize:e,strides:n,pad:r,dimRoundingMode:i,dataFormat:s},d=oe.runKernel(e8,c,u);return l?Pe(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}const Lxe=ee({maxPool3d_:Oxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bxe(t,e,n,r,i=!1){const o={x:z(t,"x","maxPoolWithArgmax")},a={filterSize:e,strides:n,pad:r,includeBatchInIndex:i},l=oe.runKernel(t8,o,a);return{result:l[0],indexes:l[1]}}const Fxe=ee({maxPoolWithArgmax_:Bxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $xe(t,e){let n=z(t,"a","maximum"),r=z(e,"b","maximum");[n,r]=Qn(n,r),n.dtype==="bool"&&(n=hr(n,"int32"),r=hr(r,"int32")),Qt(n.shape,r.shape);const i={a:n,b:r};return oe.runKernel(Qz,i)}const Uxe=ee({maximum_:$xe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zxe(t,e=null,n=!1){const i={x:z(t,"x","mean")},s={axis:e,keepDims:n};return oe.runKernel(n8,i,s)}const Y1=ee({mean_:zxe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sd(t,e="float32"){if(e==="complex64"){const r=Sd(t,"float32"),i=Sd(t,"float32");return Nc(r,i)}const n=Ic(Ve(t),e);return oe.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zu(t,e="float32"){if(e==="complex64"){const r=zu(t,"float32"),i=Sd(t,"float32");return Nc(r,i)}const n=T6(Ve(t),e);return oe.makeTensor(n,t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gxe(t,e,{indexing:n="xy"}={}){if(n!=="xy"&&n!=="ij")throw new TypeError(`${n} is not a valid third argument to meshgrid`);if(t===void 0)return[];let r=z(t,"x","meshgrid",t instanceof Mn?t.dtype:"float32");if(e===void 0)return[r];let i=z(e,"y","meshgrid",e instanceof Mn?e.dtype:"float32");const s=Ve(r.shape),o=Ve(i.shape);return n==="xy"?(r=Pe(r,[1,-1]),i=Pe(i,[-1,1]),[yn(zu([o,1],r.dtype),r),yn(i,zu([1,s],i.dtype))]):(r=Pe(r,[-1,1]),i=Pe(i,[1,-1]),[yn(r,zu([1,o],r.dtype)),yn(zu([s,1],i.dtype),i)])}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hxe(t,e){let n=z(t,"a","minimum"),r=z(e,"b","minimum");[n,r]=Qn(n,r),n.dtype==="bool"&&(n=hr(n,"int32"),r=hr(r,"int32")),Qt(n.shape,r.shape);const i={a:n,b:r};return oe.runKernel(i8,i)}const LH=ee({minimum_:Hxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vxe(t,e,n){Y(n==="reflect"||n==="symmetric",()=>`Invalid mode. Mode must be either reflect or symmetric. Got ${n}.`);const r=z(t,"x","mirrorPad");if(r.rank===0)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Y(e.length===r.rank,()=>`Padding doesn't match input. Must be ${r.rank}. Got ${e.length}.`);const i=n==="reflect"?1:0;for(let a=0;a<r.rank;a++)Y(e[a].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),Y(e[a][0]>=0&&e[a][0]<=r.shape[a]-i&&e[a][1]>=0&&e[a][1]<=r.shape[a]-i,()=>`Padding in dimension ${a} cannot be greater than or equal to ${r.shape[a]-i} or less than 0 for input of shape ${r.shape}`);const s={paddings:e,mode:n},o={x:r};return oe.runKernel(s8,o,s)}const Wxe=ee({mirrorPad_:Vxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jxe(t,e){let n=z(t,"a","mod"),r=z(e,"b","mod");[n,r]=Qn(n,r);const i={a:n,b:r};return oe.runKernel(o8,i)}const Xxe=ee({mod_:jxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kxe(t,e=null,n=!1){t=z(t,"x","moments");const r=Dr(e,t.shape),i=Y1(t,r,n);let s=i.shape;n||(s=Fs(i.shape,r));const o=s_(zt(hr(t,"float32"),Pe(i,s))),a=Y1(o,r,n);return{mean:i,variance:a}}const qxe=ee({moments_:Kxe});function Jxe(t,e,n,r){const i=z(e,"data","multiRNNCell"),s=j1(n,"c","multiRNNCell"),o=j1(r,"h","multiRNNCell");let a=i;const l=[];for(let d=0;d<t.length;d++){const f=t[d](a,s[d],o[d]);l.push(f[0]),l.push(f[1]),a=f[1]}const c=[],u=[];for(let d=0;d<l.length;d+=2)c.push(l[d]),u.push(l[d+1]);return[c,u]}const Yxe=ee({multiRNNCell_:Jxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Qxe(t,e,n,r=!1){const i=z(t,"logits","multinomial"),s=i.size,o=i.rank;if(s<2)throw new Error(`Error in multinomial: you need at least 2 outcomes, but got ${s}.`);if(o>2)throw new Error(`Rank of probabilities must be 1 or 2, but is ${o}`);n=n||Math.random();const l={logits:o===1?Pe(i,[1,-1]):i},c={numSamples:e,seed:n,normalized:r},u=oe.runKernel(a8,l,c);return o===1?Pe(u,[u.size]):u}const Zxe=ee({multinomial_:Qxe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e1e(t,e){let n=z(t,"a","notEqual","string_or_numeric"),r=z(e,"b","notEqual","string_or_numeric");[n,r]=Qn(n,r),Qt(n.shape,r.shape);const i={a:n,b:r};return oe.runKernel(u8,i)}const BH=ee({notEqual_:e1e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t1e(t){const n={x:z(t,"x","onesLike")};return oe.runKernel(p8,n)}const n1e=ee({onesLike_:t1e});function r1e(t,e){const n=z(t,"v1","outerProduct"),r=z(e,"v2","outerProduct");Y(n.rank===1&&r.rank===1,()=>`Error in outerProduct: inputs must be rank 1, but got ranks ${n.rank} and ${r.rank}.`);const i=Pe(n,[-1,1]),s=Pe(r,[1,-1]);return yn(i,s)}const i1e=ee({outerProduct_:r1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s1e(t,e,n=0){const r=z(t,"x","pad");if(r.rank===0)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const i={paddings:e,constantValue:n},s={x:r};return oe.runKernel(y8,s,i)}const $0=ee({pad_:s1e});function o1e(t,e,n=0){return Y(e.length===2,()=>"Invalid number of paddings. Must be length of 2."),$0(t,[e],n)}const a1e=ee({pad1d_:o1e});function l1e(t,e,n=0){return Y(e.length===2&&e[0].length===2&&e[1].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$0(t,e,n)}const c1e=ee({pad2d_:l1e});function u1e(t,e,n=0){return Y(e.length===3&&e[0].length===2&&e[1].length===2&&e[2].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$0(t,e,n)}const d1e=ee({pad3d_:u1e});function f1e(t,e,n=0){return Y(e.length===4&&e[0].length===2&&e[1].length===2&&e[2].length===2&&e[3].length===2,()=>"Invalid number of paddings. Must be length of 2 each."),$0(t,e,n)}const h1e=ee({pad4d_:f1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p1e(t,e,n){const r=z(t,"x","spaceToBatchND");Y(r.rank>=1+e.length,()=>`input rank ${r.rank} should be > than [blockShape] ${e.length}`),Y(n.length===e.length,()=>`paddings.shape[0] ${n.length} must be equal to [blockShape] ${e.length}`),Y(r.shape.reduce((o,a,l)=>l>0&&l<=e.length?o&&(a+n[l-1][0]+n[l-1][1])%e[l-1]===0:o,!0),()=>`input spatial dimensions ${r.shape.slice(1)} with paddings ${n.toString()} must be divisible by blockShapes ${e.toString()}`);const i={x:r},s={blockShape:e,paddings:n};return oe.runKernel(j8,i,s)}const FH=ee({spaceToBatchND_:p1e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function m1e(t,e,n,r,i,s,o){i==null&&(i=[1,1]),s==null&&(s=1),r===0&&(r="valid");const a=z(t,"x","maxPool");let l=a,c=!1;a.rank===3&&(c=!0,l=Pe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),Y(ls(s,i),()=>`Error in pool: Either strides or dilations must be 1. Got strides ${s} and dilations '${i}'`);const u=Bd(l.shape,e,s,i,r),d=[u.dilationHeight,u.dilationWidth];let f;r==="same"?f=y1e([u.filterHeight,u.filterWidth],d):f=[[0,0],[0,0]];const h=d[0]===1&&d[1]===1,[p,x]=g1e([u.inHeight,u.inWidth],d,f),v=h?r:"valid",y=h?l:FH(l,d,p),S=(n==="avg"?()=>yH(y,e,s,v,o):()=>OH(y,e,s,v,o))(),w=h?S:vH(S,d,x);return c?Pe(w,[w.shape[1],w.shape[2],w.shape[3]]):w}function g1e(t,e,n){const r=n.map(u=>u[0]),i=n.map(u=>u[1]),s=t.concat(r,i),o=e.map((u,d)=>(u-s[d]%u)%u),a=i.map((u,d)=>u+o[d]),l=e.map((u,d)=>[r[d],a[d]]),c=e.map((u,d)=>[0,o[d]]);return[l,c]}function y1e(t,e){const r=t.map((o,a)=>o+(o-1)*(e[a]-1)).map(o=>o-1),i=r.map(o=>Math.floor(o/2)),s=r.map((o,a)=>o-i[a]);return r.map((o,a)=>[i[a],s[a]])}const v1e=ee({pool_:m1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function x1e(t,e){const n=z(t,"x","prelu"),r=z(e,"alpha","prelu"),i={x:n,alpha:r};return oe.runKernel(x8,i)}const $H=ee({prelu_:x1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function b1e(t,e=null,n=!1){let r=z(t,"x","prod");r.dtype==="bool"&&(r=hr(r,"int32"));const i={x:r},s={axis:e,keepDims:n};return oe.runKernel(b8,i,s)}const S1e=ee({prod_:b1e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _1e(t,e,n,r){const i=t.map((u,d)=>z(u,`tensors${d}`,"raggedGather","int32")),s=z(e,"paramsDenseValues","raggedGather"),o=z(n,"indices","raggedGather","int32"),a={paramsNestedSplits:i,paramsDenseValues:s,indices:o},l={outputRaggedRank:r},c=oe.runKernel(S8,a,l);return{outputNestedSplits:c.slice(0,c.length-1),outputDenseValues:c[c.length-1]}}const w1e=ee({raggedGather_:_1e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C1e(t,e,n,r,i){const s=z(t,"shape","raggedTensorToTensor","int32"),o=z(e,"values","raggedTensorToTensor"),a=z(n,"defaultValue","raggedTensorToTensor",o.dtype),l=r.map((d,f)=>z(d,`tensors${f}`,"raggedTensorToTensor","int32")),c={shape:s,values:o,defaultValue:a,rowPartitionTensors:l},u={rowPartitionTypes:i};return oe.runKernel(_8,c,u)}const E1e=ee({raggedTensorToTensor_:C1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A1e(t,e,n){const r=Ve(t);let i=null;if(n==null||n==="float32")i=new Float32Array(r);else if(n==="int32")i=new Int32Array(r);else if(n==="bool")i=new Uint8Array(r);else throw new Error(`Unknown data type ${n}`);for(let s=0;s<r;s++)i[s]=e();return oe.makeTensor(i,t,n)}const T1e=ee({rand_:A1e});var OI={exports:{}};OI.exports;(function(t){(function(e,n,r){function i(l){var c=this,u=a();c.next=function(){var d=2091639*c.s0+c.c*23283064365386963e-26;return c.s0=c.s1,c.s1=c.s2,c.s2=d-(c.c=d|0)},c.c=1,c.s0=u(" "),c.s1=u(" "),c.s2=u(" "),c.s0-=u(l),c.s0<0&&(c.s0+=1),c.s1-=u(l),c.s1<0&&(c.s1+=1),c.s2-=u(l),c.s2<0&&(c.s2+=1),u=null}function s(l,c){return c.c=l.c,c.s0=l.s0,c.s1=l.s1,c.s2=l.s2,c}function o(l,c){var u=new i(l),d=c&&c.state,f=u.next;return f.int32=function(){return u.next()*4294967296|0},f.double=function(){return f()+(f()*2097152|0)*11102230246251565e-32},f.quick=f,d&&(typeof d=="object"&&s(d,u),f.state=function(){return s(u,{})}),f}function a(){var l=4022871197,c=function(u){u=String(u);for(var d=0;d<u.length;d++){l+=u.charCodeAt(d);var f=.02519603282416938*l;l=f>>>0,f-=l,f*=l,l=f>>>0,f-=l,l+=f*4294967296}return(l>>>0)*23283064365386963e-26};return c}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.alea=o})(Pc,t,!1)})(OI);var M1e=OI.exports,LI={exports:{}};LI.exports;(function(t){(function(e,n,r){function i(a){var l=this,c="";l.x=0,l.y=0,l.z=0,l.w=0,l.next=function(){var d=l.x^l.x<<11;return l.x=l.y,l.y=l.z,l.z=l.w,l.w^=l.w>>>19^d^d>>>8},a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,l.next()}function s(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l}function o(a,l){var c=new i(a),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,p=(f+h)/(1<<21);while(p===0);return p},d.int32=c.next,d.quick=d,u&&(typeof u=="object"&&s(u,c),d.state=function(){return s(c,{})}),d}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xor128=o})(Pc,t,!1)})(LI);var R1e=LI.exports,BI={exports:{}};BI.exports;(function(t){(function(e,n,r){function i(a){var l=this,c="";l.next=function(){var d=l.x^l.x>>>2;return l.x=l.y,l.y=l.z,l.z=l.w,l.w=l.v,(l.d=l.d+362437|0)+(l.v=l.v^l.v<<4^(d^d<<1))|0},l.x=0,l.y=0,l.z=0,l.w=0,l.v=0,a===(a|0)?l.x=a:c+=a;for(var u=0;u<c.length+64;u++)l.x^=c.charCodeAt(u)|0,u==c.length&&(l.d=l.x<<10^l.x>>>4),l.next()}function s(a,l){return l.x=a.x,l.y=a.y,l.z=a.z,l.w=a.w,l.v=a.v,l.d=a.d,l}function o(a,l){var c=new i(a),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,p=(f+h)/(1<<21);while(p===0);return p},d.int32=c.next,d.quick=d,u&&(typeof u=="object"&&s(u,c),d.state=function(){return s(c,{})}),d}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xorwow=o})(Pc,t,!1)})(BI);var I1e=BI.exports,FI={exports:{}};FI.exports;(function(t){(function(e,n,r){function i(a){var l=this;l.next=function(){var u=l.x,d=l.i,f,h;return f=u[d],f^=f>>>7,h=f^f<<24,f=u[d+1&7],h^=f^f>>>10,f=u[d+3&7],h^=f^f>>>3,f=u[d+4&7],h^=f^f<<7,f=u[d+7&7],f=f^f<<13,h^=f^f<<9,u[d]=h,l.i=d+1&7,h};function c(u,d){var f,h=[];if(d===(d|0))h[0]=d;else for(d=""+d,f=0;f<d.length;++f)h[f&7]=h[f&7]<<15^d.charCodeAt(f)+h[f+1&7]<<13;for(;h.length<8;)h.push(0);for(f=0;f<8&&h[f]===0;++f);for(f==8?h[7]=-1:h[f],u.x=h,u.i=0,f=256;f>0;--f)u.next()}c(l,a)}function s(a,l){return l.x=a.x.slice(),l.i=a.i,l}function o(a,l){a==null&&(a=+new Date);var c=new i(a),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,p=(f+h)/(1<<21);while(p===0);return p},d.int32=c.next,d.quick=d,u&&(u.x&&s(u,c),d.state=function(){return s(c,{})}),d}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xorshift7=o})(Pc,t,!1)})(FI);var N1e=FI.exports,$I={exports:{}};$I.exports;(function(t){(function(e,n,r){function i(a){var l=this;l.next=function(){var u=l.w,d=l.X,f=l.i,h,p;return l.w=u=u+1640531527|0,p=d[f+34&127],h=d[f=f+1&127],p^=p<<13,h^=h<<17,p^=p>>>15,h^=h>>>12,p=d[f]=p^h,l.i=f,p+(u^u>>>16)|0};function c(u,d){var f,h,p,x,v,y=[],b=128;for(d===(d|0)?(h=d,d=null):(d=d+"\0",h=0,b=Math.max(b,d.length)),p=0,x=-32;x<b;++x)d&&(h^=d.charCodeAt((x+32)%d.length)),x===0&&(v=h),h^=h<<10,h^=h>>>15,h^=h<<4,h^=h>>>13,x>=0&&(v=v+1640531527|0,f=y[x&127]^=h+v,p=f==0?p+1:0);for(p>=128&&(y[(d&&d.length||0)&127]=-1),p=127,x=4*128;x>0;--x)h=y[p+34&127],f=y[p=p+1&127],h^=h<<13,f^=f<<17,h^=h>>>15,f^=f>>>12,y[p]=h^f;u.w=v,u.X=y,u.i=p}c(l,a)}function s(a,l){return l.i=a.i,l.w=a.w,l.X=a.X.slice(),l}function o(a,l){a==null&&(a=+new Date);var c=new i(a),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,p=(f+h)/(1<<21);while(p===0);return p},d.int32=c.next,d.quick=d,u&&(u.X&&s(u,c),d.state=function(){return s(c,{})}),d}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.xor4096=o})(Pc,t,!1)})($I);var P1e=$I.exports,UI={exports:{}};UI.exports;(function(t){(function(e,n,r){function i(a){var l=this,c="";l.next=function(){var d=l.b,f=l.c,h=l.d,p=l.a;return d=d<<25^d>>>7^f,f=f-h|0,h=h<<24^h>>>8^p,p=p-d|0,l.b=d=d<<20^d>>>12^f,l.c=f=f-h|0,l.d=h<<16^f>>>16^p,l.a=p-d|0},l.a=0,l.b=0,l.c=-1640531527,l.d=1367130551,a===Math.floor(a)?(l.a=a/4294967296|0,l.b=a|0):c+=a;for(var u=0;u<c.length+20;u++)l.b^=c.charCodeAt(u)|0,l.next()}function s(a,l){return l.a=a.a,l.b=a.b,l.c=a.c,l.d=a.d,l}function o(a,l){var c=new i(a),u=l&&l.state,d=function(){return(c.next()>>>0)/4294967296};return d.double=function(){do var f=c.next()>>>11,h=(c.next()>>>0)/4294967296,p=(f+h)/(1<<21);while(p===0);return p},d.int32=c.next,d.quick=d,u&&(typeof u=="object"&&s(u,c),d.state=function(){return s(c,{})}),d}n&&n.exports?n.exports=o:r&&r.amd?r(function(){return o}):this.tychei=o})(Pc,t,!1)})(UI);var k1e=UI.exports,UH={exports:{}};(function(t){(function(e,n,r){var i=256,s=6,o=52,a="random",l=r.pow(i,s),c=r.pow(2,o),u=c*2,d=i-1,f;function h(w,E,A){var T=[];E=E==!0?{entropy:!0}:E||{};var I=y(v(E.entropy?[w,S(n)]:w??b(),3),T),N=new p(T),M=function(){for(var P=N.g(s),B=l,F=0;P<c;)P=(P+F)*i,B*=i,F=N.g(1);for(;P>=u;)P/=2,B/=2,F>>>=1;return(P+F)/B};return M.int32=function(){return N.g(4)|0},M.quick=function(){return N.g(4)/4294967296},M.double=M,y(S(N.S),n),(E.pass||A||function(P,B,F,U){return U&&(U.S&&x(U,N),P.state=function(){return x(N,{})}),F?(r[a]=P,B):P})(M,I,"global"in E?E.global:this==r,E.state)}function p(w){var E,A=w.length,T=this,I=0,N=T.i=T.j=0,M=T.S=[];for(A||(w=[A++]);I<i;)M[I]=I++;for(I=0;I<i;I++)M[I]=M[N=d&N+w[I%A]+(E=M[I])],M[N]=E;(T.g=function(P){for(var B,F=0,U=T.i,j=T.j,Z=T.S;P--;)B=Z[U=d&U+1],F=F*i+Z[d&(Z[U]=Z[j=d&j+B])+(Z[j]=B)];return T.i=U,T.j=j,F})(i)}function x(w,E){return E.i=w.i,E.j=w.j,E.S=w.S.slice(),E}function v(w,E){var A=[],T=typeof w,I;if(E&&T=="object")for(I in w)try{A.push(v(w[I],E-1))}catch{}return A.length?A:T=="string"?w:w+"\0"}function y(w,E){for(var A=w+"",T,I=0;I<A.length;)E[d&I]=d&(T^=E[d&I]*19)+A.charCodeAt(I++);return S(E)}function b(){try{var w;return f&&(w=f.randomBytes)?w=w(i):(w=new Uint8Array(i),(e.crypto||e.msCrypto).getRandomValues(w)),S(w)}catch{var E=e.navigator,A=E&&E.plugins;return[+new Date,e,A,e.screen,S(n)]}}function S(w){return String.fromCharCode.apply(0,w)}if(y(r.random(),n),t.exports){t.exports=h;try{f=bI}catch{}}else r["seed"+a]=h})(typeof self<"u"?self:Pc,[],Math)})(UH);var D1e=UH.exports,O1e=M1e,L1e=R1e,B1e=I1e,F1e=N1e,$1e=P1e,U1e=k1e,Fd=D1e;Fd.alea=O1e;Fd.xor128=L1e;Fd.xorwow=B1e;Fd.xorshift7=F1e;Fd.xor4096=$1e;Fd.tychei=U1e;var zI=Fd;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GI{constructor(e,n,r,i,s){this.mean=e,this.stdDev=n,this.dtype=r,this.nextVal=NaN,this.truncated=i,this.truncated&&(this.upper=this.mean+this.stdDev*2,this.lower=this.mean-this.stdDev*2);const o=s||Math.random();this.random=zI.alea(o.toString())}nextValue(){if(!isNaN(this.nextVal)){const i=this.nextVal;return this.nextVal=NaN,i}let e,n,r=!1;for(;!r;){let i,s,o;do i=2*this.random()-1,s=2*this.random()-1,o=i*i+s*s;while(o>=1||o===0);const a=Math.sqrt(-2*Math.log(o)/o);e=this.mean+this.stdDev*i*a,n=this.mean+this.stdDev*s*a,(!this.truncated||this.isValidTruncated(e))&&(r=!0)}return(!this.truncated||this.isValidTruncated(n))&&(this.nextVal=this.convertValue(n)),this.convertValue(e)}convertValue(e){return this.dtype==null||this.dtype==="float32"?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class z1e{constructor(e,n,r,i){this.alpha=e,this.beta=1/n,this.dtype=r;const s=i||Math.random();this.randu=zI.alea(s.toString()),this.randn=new GI(0,1,r,!1,this.randu()),e<1?this.d=e+2/3:this.d=e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,n,r,i,s,o;for(;;){do i=this.randn.nextValue(),o=1+this.c*i;while(o<=0);if(o*=o*o,e=i*i,n=1-.331*e*e,r=.5*e+this.d*(1-o+Math.log(o)),s=this.randu(),s<n||Math.log(s)<r)break}return o=1/this.beta*this.d*o,this.alpha<1&&(o*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(o)}convertValue(e){return this.dtype==="float32"?e:Math.round(e)}}class G1e{constructor(e=0,n=1,r,i){if(this.canReturnFloat=()=>this.dtype==null||this.dtype==="float32",this.min=e,this.range=n-e,this.dtype=r,i==null&&(i=Math.random()),typeof i=="number"&&(i=i.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error(`The difference between ${e} - ${n} <= 1 and dtype is not float`);this.random=zI.alea(i)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function H1e(t,e,n=1,r="float32",i){if(n==null&&(n=1),r==null&&(r="float32"),r!=="float32"&&r!=="int32")throw new Error(`Unsupported data type ${r}`);const s=new z1e(e,n,r,i),o=Vn(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}const V1e=ee({randomGamma_:H1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W1e(t,e=0,n=1,r,i){if(r!=null&&r==="bool")throw new Error(`Unsupported data type ${r}`);const s=new GI(e,n,r,!1,i),o=Vn(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}const zH=ee({randomNormal_:W1e});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j1e(t,e,n){if(e!=null&&e==="bool")throw new Error(`Unsupported data type ${e}`);return zH(t,0,1,e,n)}const X1e=ee({randomStandardNormal_:j1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K1e(t,e=0,n=1,r="float32",i){const s=Vn(t,r),o=new G1e(e,n,null,i);for(let a=0;a<s.values.length;a++)s.values[a]=o.nextValue();return s.toTensor()}const GH=ee({randomUniform_:K1e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function t0(t,e,n=1,r="float32"){if(n===0)throw new Error("Cannot have a step of zero");const i={start:t,stop:e,step:n,dtype:r};return oe.runKernel(w8,{},i)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function q1e(t){const n={x:z(t,"x","reciprocal")};return oe.runKernel(E8,n)}const J1e=ee({reciprocal_:q1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y1e(t){const n={x:z(t,"x","relu")};return oe.runKernel(A8,n)}const l_=ee({relu_:Y1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q1e(t){const n={x:z(t,"x","relu6")};return oe.runKernel(I8,n)}const HH=ee({relu6_:Q1e});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z1e(t,e){const r={x:z(t,"x","reverse")},i={dims:e};return oe.runKernel(N8,r,i)}const _d=ee({reverse_:Z1e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ebe(t){const e=z(t,"x","reverse");return Y(e.rank===1,()=>`Error in reverse1D: x must be rank 1 but got rank ${e.rank}.`),_d(e,0)}const tbe=ee({reverse1d_:ebe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nbe(t,e){const n=z(t,"x","reverse");return Y(n.rank===2,()=>`Error in reverse2D: x must be rank 2 but got rank ${n.rank}.`),_d(n,e)}const rbe=ee({reverse2d_:nbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ibe(t,e){const n=z(t,"x","reverse");return Y(n.rank===3,()=>`Error in reverse3D: x must be rank 3 but got rank ${n.rank}.`),_d(n,e)}const sbe=ee({reverse3d_:ibe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function obe(t,e){const n=z(t,"x","reverse");return Y(n.rank===4,()=>`Error in reverse4D: x must be rank 4 but got rank ${n.rank}.`),_d(n,e)}const abe=ee({reverse4d_:obe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lbe(t){const n={x:z(t,"x","round")};return oe.runKernel(P8,n)}const VH=ee({round_:lbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cbe(t){const n={x:z(t,"x","rsqrt","float32")};return oe.runKernel(k8,n)}const ube=ee({rsqrt_:cbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dbe(t){const n={x:z(t,"x","selu")};return oe.runKernel(B8,n)}const fbe=ee({selu_:dbe});function hbe(t,e,n,r,i,s=[1,1],o="NHWC"){const a=z(t,"x","separableConv2d"),l=z(e,"depthwiseFilter","separableConv2d"),c=z(n,"pointwiseFilter","separableConv2d");let u=a,d=!1;if(a.rank===3&&(d=!0,u=Pe(a,[1,a.shape[0],a.shape[1],a.shape[2]])),o==="NCHW")throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Y(u.rank===4,()=>`Error in separableConv2d: input must be rank 4, but got rank ${u.rank}.`),Y(l.rank===4,()=>`Error in separableConv2d: depthwise filter must be rank 4, but got rank ${l.rank}.`),Y(c.rank===4,()=>`Error in separableConv2d: pointwise filter must be rank 4, but got rank ${l.rank}.`),Y(c.shape[0]===1,()=>`Error in separableConv2d: the first dimension of pointwise filter  must be 1, but got ${c.shape[0]}.`),Y(c.shape[1]===1,()=>`Error in separableConv2d: the second dimension of pointwise filter must be 1, but got ${c.shape[1]}.`);const f=l.shape[2],h=l.shape[3];Y(c.shape[2]===f*h,()=>`Error in separableConv2d: the third dimension of pointwise filter must be ${f*h}, but got ${c.shape[2]}.`);const p=MI(u,l,r,i,o,s),v=i_(p,c,1,"valid",o);return d?Pe(v,[v.shape[1],v.shape[2],v.shape[3]]):v}const pbe=ee({separableConv2d_:hbe});/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function mbe(t,e){const n=z(t,"x","setdiff1d"),r=z(e,"y","setdiff1d");Y(n.dtype===r.dtype,()=>`x and y should have the same dtype, but got x (${n.dtype}) and y (${r.dtype}).`),Y(n.rank===1,()=>`x should be 1D tensor, but got x (${n.shape}).`),Y(r.rank===1,()=>`y should be 1D tensor, but got y (${r.shape}).`);const i=await n.data(),s=await r.data(),o=new Set(s);let a=0;for(let u=0;u<i.length;u++)o.has(i[u])||a++;const l=new Yg([a],n.dtype),c=new Yg([a],"int32");for(let u=0,d=0;u<i.length;u++)o.has(i[u])||(l.values[d]=i[u],c.values[d]=u,d++);return[l.toTensor(),c.toTensor()]}const gbe=mbe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ybe(t){const n={x:z(t,"x","sign")};return oe.runKernel(z8,n)}const vbe=ee({sign_:ybe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xbe(t){const n={x:z(t,"x","sin","float32")};return oe.runKernel($8,n)}const bbe=ee({sin_:xbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Sbe(t){const n={x:z(t,"x","sinh")};return oe.runKernel(U8,n)}const _be=ee({sinh_:Sbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wbe(t,e,n){const r=z(t,"x","slice1d");return Y(r.rank===1,()=>`slice1d expects a rank-1 tensor, but got a rank-${r.rank} tensor`),Rt(r,[e],[n])}const Cbe=ee({slice1d_:wbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ebe(t,e,n){const r=z(t,"x","slice2d");return Y(r.rank===2,()=>`slice2d expects a rank-2 tensor, but got a rank-${r.rank} tensor`),Rt(r,e,n)}const Abe=ee({slice2d_:Ebe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Tbe(t,e,n){const r=z(t,"x","slice3d");return Y(r.rank===3,()=>`slice3d expects a rank-3 tensor, but got a rank-${r.rank} tensor`),Rt(r,e,n)}const Mbe=ee({slice3d_:Tbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rbe(t,e,n){const r=z(t,"x","slice4d");return Y(r.rank===4,()=>`slice4d expects a rank-4 tensor, but got a rank-${r.rank} tensor`),Rt(r,e,n)}const Ibe=ee({slice4d_:Rbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Nbe(t,e=-1){const n=z(t,"logits","softmax","float32");if(e===-1&&(e=n.rank-1),e!==n.rank-1)throw Error(`Softmax along a non-last dimension is not yet supported. Logits was rank ${n.rank} and dim was ${e}`);const r={logits:n},i={dim:e};return oe.runKernel(K8,r,i)}const Pbe=ee({softmax_:Nbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kbe(t){Y(t.dtype==="complex64",()=>`The dtype for tf.spectral.fft() must be complex64 but got ${t.dtype}.`);const e={input:t};return oe.runKernel(Az,e)}const HI=ee({fft_:kbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Dbe(t){Y(t.dtype==="complex64",()=>`The dtype for tf.spectral.ifft() must be complex64 but got ${t.dtype}.`);const e={input:t};return oe.runKernel(Lz,e)}const Q1=ee({ifft_:Dbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Obe(t){const e=t.shape[t.shape.length-1],n=t.size/e;let r;if(e<=2){const i=Pe(t,[n,e]);r=Q1(i)}else{const i=[n,2*(e-1)],s=Pe(Qg(t),[n,e]),o=Pe(t_(t),[n,e]),a=_d(Rt(s,[0,1],[n,e-2]),1),l=Et(_d(Rt(o,[0,1],[n,e-2]),1),fn(-1)),c=pr([s,a],1),u=pr([o,l],1),d=Pe(Nc(c,u),[i[0],i[1]]);r=Q1(d)}if(r=Qg(r),t.rank===3&&t.shape[0]!==0){const i=r,s=t.shape[0];r=Pe(r,[s,r.shape[0]/s,r.shape[1]]),i.dispose()}return r}const WH=ee({irfft_:Obe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lbe(t,e,n=0){const i={x:z(t,"x","split")},s={numOrSizeSplits:e,axis:n};return oe.runKernel(X8,i,s)}const n0=ee({split_:Lbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Bbe(t,e){Y(t.dtype==="float32",()=>`The dtype for rfft() must be real value but got ${t.dtype}`);let n=t.shape[t.shape.length-1];const r=t.size/n;let i;if(e!=null&&e<n){const p=t.shape.map(v=>0),x=t.shape.map(v=>v);x[t.shape.length-1]=e,i=Rt(t,p,x),n=e}else if(e!=null&&e>n){const p=t.shape.map(x=>x);p[t.shape.length-1]=e-n,i=pr([t,Sd(p)],t.shape.length-1),n=e}else i=t;const s=RI(i),o=Pe(Nc(i,s),[r,n]),a=HI(o),l=Math.floor(n/2)+1,c=Qg(a),u=t_(a),d=n0(c,[l,n-l],c.shape.length-1),f=n0(u,[l,n-l],u.shape.length-1),h=i.shape.slice();return h[i.shape.length-1]=l,Pe(Nc(d[0],f[0]),h)}const VI=ee({rfft_:Bbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Fbe(t,e){let n=z(t,"a","squaredDifference"),r=z(e,"b","squaredDifference");[n,r]=Qn(n,r),Qt(n.shape,r.shape);const i={a:n,b:r},s={};return oe.runKernel(eG,i,s)}const jH=ee({squaredDifference_:Fbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $be(t,e){const n=z(t,"x","squeeze","string_or_numeric");return Pe(n,Uc(n.shape,e).newShape)}const Ra=ee({squeeze_:$be});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ube(t,e=0){const n=j1(t,"tensors","stack","string_or_numeric");Y(n.length>=1,()=>"Pass at least one tensor to tf.stack"),n.length>0&&Y(e<=n[0].rank,()=>"Axis must be <= rank of the tensor");const r=n,i={axis:e};return oe.runKernel(g8,r,i)}const wl=ee({stack_:Ube});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zbe(t,e=0){const r={x:z(t,"x","step")},i={alpha:e};return oe.runKernel(pG,r,i)}const XH=ee({step_:zbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Gbe(t,e,n,r,i=0,s=0,o=0,a=0,l=0){const u={x:z(t,"x","stridedSlice","string_or_numeric")},d={begin:e,end:n,strides:r,beginMask:i,endMask:s,ellipsisMask:o,newAxisMask:a,shrinkAxisMask:l};return oe.runKernel(tG,u,d)}const Hbe=ee({stridedSlice_:Gbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vbe(t){const n={x:z(t,"x","tan","float32")};return oe.runKernel(oG,n)}const Wbe=ee({tan_:Vbe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zr(t,e){_p(t);const n=zc(t,e);if(n.length!==1)throw new Error("tensor1d() requires values to be a flat/TypedArray");return Gc(t,null,n,e)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dl(t,e,n){if(_p(t),e!=null&&e.length!==2)throw new Error("tensor2d() requires shape to have two numbers");const r=zc(t,n);if(r.length!==2&&r.length!==1)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return Gc(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jbe(t,e,n){if(_p(t),e!=null&&e.length!==4)throw new Error("tensor4d() requires shape to have four numbers");const r=zc(t,n);if(r.length!==4&&r.length!==1)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return Gc(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Xbe(t,e,n){if(_p(t),e!=null&&e.length!==5)throw new Error("tensor5d() requires shape to have five numbers");const r=zc(t,n);if(r.length!==5&&r.length!==1)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return Gc(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Kbe(t,e,n){if(_p(t),e!=null&&e.length!==6)throw new Error("tensor6d() requires shape to have six numbers");const r=zc(t,n);if(r.length!==6&&r.length!==1)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(r.length===1&&e==null)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return e=e||r,Gc(t,e,r,n)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qbe(t,e=1,n=!0){const r=z(t,"x","topk");if(r.rank===0)throw new Error("topk() expects the input to be of rank 1 or higher");const i=r.shape[r.shape.length-1];if(e<0)throw new Error(`'k' passed to topk() must be >= 0 but got ${e}`);if(e>i)throw new Error(`'k' passed to topk() must be <= the last dimension (${i}) but got ${e}`);const s={x:r},o={k:e,sorted:n},[a,l]=oe.runKernel(lG,s,o);return{values:a,indices:l}}const Jbe=ee({topk_:qbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ybe(t,e=0,n=1,r,i){if(r!=null&&r==="bool")throw new Error("Unsupported data type $ { dtype }");const s=new GI(e,n,r,!0,i),o=Vn(t,r);for(let a=0;a<o.values.length;a++)o.values[a]=s.nextValue();return o.toTensor()}const Qbe=ee({truncatedNormal_:Ybe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zbe(t,e=0){const n=z(t,"x","unique","string_or_numeric");Y(n.rank>0,()=>"The input tensor must be at least 1D");const r={x:n},i={axis:e},[s,o]=oe.runKernel(uG,r,i);return{values:s,indices:o}}const eSe=ee({unique_:Zbe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function tSe(t,e,n){const r=z(t,"x","unsortedSegmentSum"),i=z(e,"segmentIds","unsortedSegmentSum","int32");Y(qh(n),()=>"numSegments must be of dtype int");const s={x:r,segmentIds:i},o={numSegments:n};return oe.runKernel(fG,s,o)}const nSe=ee({unsortedSegmentSum_:tSe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rSe(t,e=0){const n=z(t,"x","unstack","string_or_numeric");Y(e>=-n.shape.length&&e<n.shape.length,()=>`Axis = ${e} is not in [-${n.shape.length}, ${n.shape.length})`);const r={value:n},i={axis:e};return oe.runKernel(dG,r,i)}const $d=ee({unstack_:rSe});/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iSe(t,e){return DI(t,e,"right")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sSe(t,e=!0,n,r){return oe.makeVariable(t,e,n,r)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KH(t,e){const n=[];for(let s=0;s<e.length;s++)e[s]&&n.push(s);const r=Vn(t,"int32"),i=Vn([n.length,t.length],"int32");for(let s=0;s<n.length;s++){const o=r.indexToLoc(n[s]),a=s*t.length;i.values.set(o,a)}return i.toTensor()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function oSe(t){const e=z(t,"condition","whereAsync","bool"),n=await e.data(),r=KH(e.shape,n);return t!==e&&e.dispose(),r}const qH=oSe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function aSe(t,e,n){const r=z(t,"tensor","boolMask"),i=z(e,"mask","boolMask","bool"),s=n??0,o=i.rank,a=r.shape;Y(o>0,()=>"mask cannot be scalar"),Ls(a.slice(s,s+o),i.shape,"mask's shape must match the first K dimensions of tensor's shape,");let l=1;for(let x=s;x<s+o;x++)l*=a[x];const c=a.slice(0,s).concat([l],a.slice(s+o)),u=Pe(r,c),d=Pe(i,[-1]),f=await qH(d),h=Ra(f,[1]),p=TH(u,h,s);return t!==r&&r.dispose(),e!==i&&i.dispose(),h.dispose(),u.dispose(),d.dispose(),f.dispose(),p}const lSe=aSe;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cSe(t,e,n,r,i=!0){const s=z(t,"v","movingAverage"),o=z(e,"x","movingAverage"),a=z(n,"decay","movingAverage");bge(s,o),Y(Yn(s.shape,o.shape),()=>"Shape mismatch in v and x");const l=fn(1),c=zt(l,a);let u=Et(zt(o,s),c);if(i){Y(r!=null,()=>"When using zeroDebias: true, step is required.");const d=z(r,"step","movingAverage");u=ar(u,zt(l,PI(a,d)))}return cr(s,u)}const uSe=ee({movingAverage_:cSe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dSe(t,e,n){const r=z(t,"indices","scatterND","int32"),i=z(e,"updates","scatterND");nH(i,r,n);const s={indices:r,updates:i},o={shape:n};return oe.runKernel(D8,s,o)}const fSe=ee({scatterND_:dSe});function hSe(t,e,n,r){if(t.dtype!=="int32")throw new Error(`tf.sparseToDense() expects the indices to be int32 type, but the dtype was ${t.dtype}.`);if(t.rank>2)throw new Error(`sparseIndices should be a scalar, vector, or matrix, but got shape ${t.shape}.`);const i=t.rank>0?t.shape[0]:1,s=t.rank>1?t.shape[1]:1;if(n.length!==s)throw new Error(`outputShape has incorrect number of elements:, ${n.length}, should be: ${s}.`);const o=e.size;if(!(e.rank===0||e.rank===1&&o===i))throw new Error(`sparseValues has incorrect shape ${e.shape}, should be [] or [${i}]`);if(e.dtype!==r.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pSe(t,e,n,r=0){const i=z(t,"sparseIndices","sparseToDense","int32"),s=z(e,"sparseValues","sparseToDense","string_or_numeric"),o=z(r,"defaultValue","sparseToDense",s.dtype);hSe(i,s,n,o);const a={sparseIndices:i,sparseValues:s,defaultValue:o},l={outputShape:n};return oe.runKernel(Z8,a,l)}const mSe=ee({sparseToDense_:pSe});/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gSe(t,e){const n=z(e,"indices","gatherND","int32"),i={params:z(t,"x","gatherND","string_or_numeric"),indices:n};return oe.runKernel(kz,i)}const ySe=ee({gatherND_:gSe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function vSe(t,e){if(e==null)return t.shape.slice();if(Yn(t.shape,e))return e;if(t.shape.length===e.length){const n=[];for(let r=0;r<t.shape.length;r++)e[r]==null&&t.shape[r]!=null?n.push(t.shape[r]):n.push(e[r]);return n}return e}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xSe(t,e,n,r){const i=z(t,"x","dropout");if(Y(i.dtype==="float32",()=>`x has to be a floating point tensor since it's going to be scaled, but got a ${i.dtype} tensor instead.`),Y(e>=0&&e<1,()=>`rate must be a float in the range [0, 1), but got ${e}.`),e===0)return t instanceof Mn?i.clone():i;const s=vSe(i,n),o=1-e,a=ar(AH(cr(GH(s,0,1,"float32",r),o)),o);return Et(i,a)}const bSe=ee({dropout_:xSe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JH(t){return Math.floor(Math.pow(2,Math.ceil(Math.log(t)/Math.log(2))))}function WI(t,e,n){const r=1-t%2,i=new Float32Array(t);for(let s=0;s<t;++s){const o=2*Math.PI*s/(t+r-1);i[s]=e-n*Math.cos(o)}return zr(i,"float32")}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function SSe(t,e,n=1){const r=z(t,"predictions","inTopK"),i=z(e,"targets","inTopK");Y(r.rank>1,()=>`inTopK() expects the predictions to be of rank 2 or higher, but got ${r.rank}`),Y(r.rank-1===i.rank,()=>`predictions rank should be 1 larger than targets rank, but got predictions rank ${r.rank} and targets rank ${i.rank}`),Ls(r.shape.slice(0,r.shape.length-1),i.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=r.shape[r.shape.length-1];Y(n>0&&n<=s,()=>`'k' passed to inTopK() must be > 0 && <= the predictions last dimension (${s}), but got ${n}`);const o=await r.data(),a=await i.data(),[l,c]=[o.length/s,s],u=Sl("bool",l);for(let d=0;d<l;d++){const f=d*c,h=o.subarray(f,f+c),p=[];for(let x=0;x<h.length;x++)p.push({value:h[x],index:x});p.sort((x,v)=>v.value-x.value),u[d]=0;for(let x=0;x<n;x++)if(p[x].index===a[d]){u[d]=1;break}}return t!==r&&r.dispose(),e!==i&&i.dispose(),Ma(u,i.shape,"bool")}const _Se=SSe;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wSe(t,e,n,r,i,s="NHWC",o){let a=t;t.rank===3&&(a=Pe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=Pe(e,[1,e.shape[0],e.shape[1],e.shape[2]])),Y(a.rank===4,()=>`Error in conv2dDerFilter: input must be rank 4, but got shape ${a.shape}.`),Y(l.rank===4,()=>`Error in conv2dDerFilter: dy must be rank 4, but got shape ${l.shape}.`),Y(n.length===4,()=>`Error in conv2dDerFilter: filterShape must be length 4, but got ${n}.`);const c=s==="NHWC"?a.shape[3]:a.shape[1],u=s==="NHWC"?l.shape[3]:l.shape[1];Y(c===n[2],()=>`Error in conv2dDerFilter: depth of input ${c}) must match input depth in filter (${n[2]}.`),Y(u===n[3],()=>`Error in conv2dDerFilter: depth of dy (${u}) must match output depth for filter (${n[3]}).`),So("conv2dDerFilter",i,o);const d={x:a,dy:l},f={strides:r,pad:i,dataFormat:s,dimRoundingMode:o,filterShape:n};return oe.runKernel(nz,d,f)}const CSe=ee({conv2DBackpropFilter_:wSe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function c_(t,e,n){if(n==null||n==="linear")return t;if(n==="relu")return Et(t,XH(e));throw new Error(`Cannot compute gradient for fused activation ${n}.`)}function u_(t,e){let n=e;const r=YG(t.shape,e.shape);return r.length>0&&(n=Rn(n,r)),Pe(n,t.shape)}function d_(t,e,n,r){if(e==="linear")return t;if(e==="relu")return l_(t);if(e==="elu")return _H(t);if(e==="relu6")return HH(t);if(e==="prelu")return $H(t,n);if(e==="leakyrelu")return RH(t,r);if(e==="sigmoid")return nd(t);throw new Error(`Unknown fused activation ${e}.`)}const f_=(t,e)=>!(t>0)||e==="linear";/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ESe({x:t,filter:e,strides:n,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(l=l||"linear",f_(oe.state.gradientDepth,l)===!1){Y(i==="NHWC",()=>`Error in fused conv2d: got dataFormat of ${i} but only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear.`);let A=i_(t,e,n,r,i,s,o);return a!=null&&(A=cr(A,a)),d_(A,l,c,u)}const d=z(t,"x","conv2d","float32"),f=z(e,"filter","conv2d","float32");let h=d,p=!1;d.rank===3&&(p=!0,h=Pe(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Y(h.rank===4,()=>`Error in fused conv2d: input must be rank 4, but got rank ${h.rank}.`),Y(f.rank===4,()=>`Error in fused conv2d: filter must be rank 4, but got rank ${f.rank}.`),So("fused conv2d",r,o);const x=i==="NHWC"?h.shape[3]:h.shape[1];Y(f.shape[2]===x,()=>`Error in conv2d: depth of input (${x}) must match input depth for filter ${f.shape[2]}.`),Y(ls(n,s),()=>`Error in conv2D: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`);const v=Bs(h.shape,f.shape,n,s,r,o);let y;a!=null&&(y=z(a,"bias","fused conv2d"),[y]=Qn(y,d),i==="NHWC"?Qt(v.outShape,y.shape):(Y(y.shape.length<=1,()=>`Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of rank-${y.shape.length}.`),Y(y.shape.length===0||y.shape[0]===v.outChannels||y.shape[0]===1,()=>`Error in fused conv2d: bias shape (${y.shape}) is not compatible with the number of output channels (${v.outChannels})`)));let b;if(c!=null){const A=c.shape;if(Y(A.length<=1||A.length===3,()=>`Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of rank-${A.length}.`),A.length===1)Y(A[0]===1||A[0]===v.outChannels,()=>`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the number of output channels (${v.outChannels}).`);else if(A.length===3)try{Qt(A,v.outShape)}catch{const I=`Error in fused conv2d: PReLU activation weights (${A}) is not compatible with the output shape of the conv2d (${v.outShape}).`;throw Error(I)}b=z(c,"prelu weights","fused conv2d")}const S=(A,T)=>{Y(i==="NHWC",()=>`Error in gradient of fused conv2D: got dataFormat of ${i} but only NHWC is currently supported.`);const[I,N,M,P]=T,B=c_(A,M,l);Y(Zg(s),()=>`Error in gradient of fused conv2D: dilation rates greater than 1 are not yet supported in gradients. Got dilations '${s}'`);const F=bH(N.shape,B,I,n,r),U=CSe(N,B,I.shape,n,r),j=[F,U];if(P!=null){const Z=u_(P,B);j.push(Z)}return j},w={x:h,filter:f,bias:y,preluActivationWeights:b},E={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?_l((T,I,N)=>{let M=oe.runKernel(q2,w,E);return N([I,T,M]),p&&(M=Pe(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:S}})(h,f):_l((T,I,N,M)=>{let P=oe.runKernel(q2,w,E);return M([I,T,P,N]),p&&(P=Pe(P,[P.shape[1],P.shape[2],P.shape[3]])),{value:P,gradFunc:S}})(h,f,y)}const ASe=ee({fusedConv2d_:ESe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TSe(t,e,n,r,i,s=[1,1],o){let a=t;t.rank===3&&(a=Pe(t,[1,t.shape[0],t.shape[1],t.shape[2]]));let l=e;l.rank===3&&(l=Pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={x:a,dy:l},u={strides:r,pad:i,dimRoundingMode:o,dilations:s,filterShape:n};return oe.runKernel(pz,c,u)}const MSe=ee({depthwiseConv2dNativeBackpropFilter_:TSe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RSe(t,e,n,r,i,s=[1,1],o){let a=e,l=!1;e.rank===3&&(l=!0,a=Pe(e,[1,e.shape[0],e.shape[1],e.shape[2]]));const c={dy:a,filter:n},u={strides:r,pad:i,dimRoundingMode:o,dilations:s,inputShape:t},d=oe.runKernel(mz,c,u);return l?Pe(d,[d.shape[1],d.shape[2],d.shape[3]]):d}const ISe=ee({depthwiseConv2dNativeBackpropInput_:RSe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NSe({x:t,filter:e,strides:n,pad:r,dataFormat:i="NHWC",dilations:s=[1,1],dimRoundingMode:o,bias:a,activation:l="linear",preluActivationWeights:c,leakyreluAlpha:u}){if(f_(oe.state.gradientDepth,l)===!1){let E=MI(t,e,n,r,i,s,o);return a!=null&&(E=cr(E,a)),d_(E,l,c,u)}const d=z(t,"x","depthwiseConv2d","float32"),f=z(e,"filter","depthwiseConv2d","float32");let h=d,p=!1;d.rank===3&&(p=!0,h=Pe(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Y(h.rank===4,()=>`Error in fused depthwiseConv2d: input must be rank 4, but got rank ${h.rank}.`),Y(f.rank===4,()=>`Error in fused depthwiseConv2d: filter must be rank 4, but got rank ${f.rank}.`),Y(h.shape[3]===f.shape[2],()=>`Error in fused depthwiseConv2d: number of input channels (${h.shape[3]}) must match the inChannels dimension in filter ${f.shape[2]}.`),s==null&&(s=[1,1]),Y(ls(n,s),()=>`Error in fused depthwiseConv2d: Either strides or dilations must be 1. Got strides ${n} and dilations '${s}'`),So("fused depthwiseConv2d",r,o);const x=Bs(h.shape,f.shape,n,s,r,o,!0);let v;a!=null&&(v=z(a,"bias","fused conv2d"),[v]=Qn(v,d),Qt(x.outShape,v.shape));let y;c!=null&&(y=z(c,"prelu weights","fused depthwiseConv2d"));const b=(E,A)=>{Y(Zg(s),()=>`Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations '${s}'`);const[T,I,N,M]=A,P=c_(E,N,l),B=ISe(I.shape,P,T,n,r,s,o),F=MSe(I,P,T.shape,n,r,s,o);if(M!=null){const U=u_(v,P);return[B,F,U]}return[B,F]},S={x:h,filter:f,bias:v,preluActivationWeights:y},w={strides:n,pad:r,dataFormat:i,dilations:s,dimRoundingMode:o,activation:l,leakyreluAlpha:u};return a==null?_l((A,T,I)=>{let N=oe.runKernel(J2,S,w);return I([T,A,N]),p&&(N=Pe(N,[N.shape[1],N.shape[2],N.shape[3]])),{value:N,gradFunc:b}})(h,f):_l((A,T,I,N)=>{let M=oe.runKernel(J2,S,w);return N([T,A,M,I]),p&&(M=Pe(M,[M.shape[1],M.shape[2],M.shape[3]])),{value:M,gradFunc:b}})(h,f,v)}const PSe=ee({fusedDepthwiseConv2d_:NSe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kSe({a:t,b:e,transposeA:n=!1,transposeB:r=!1,bias:i,activation:s="linear",preluActivationWeights:o,leakyreluAlpha:a=.2}){if(f_(oe.state.gradientDepth,s)===!1){let P=yn(t,e,n,r);return i!=null&&(P=cr(P,i)),d_(P,s,o,a)}let l=z(t,"a","fused matMul"),c=z(e,"b","fused matMul");[l,c]=Qn(l,c);const u=n?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?c.shape[c.rank-1]:c.shape[c.rank-2],f=n?l.shape[l.rank-1]:l.shape[l.rank-2],h=r?c.shape[c.rank-2]:c.shape[c.rank-1],p=l.shape.slice(0,-2),x=c.shape.slice(0,-2),v=Ve(p),y=Ve(x);Y(u===d,()=>`Error in fused matMul: inner shapes (${u}) and (${d}) of Tensors with shapes ${l.shape} and ${c.shape} and transposeA=${n} and transposeB=${r} must match.`);const S=Qt(l.shape.slice(0,-2),c.shape.slice(0,-2)).concat([f,h]),w=n?Pe(l,[v,u,f]):Pe(l,[v,f,u]),E=r?Pe(c,[y,h,d]):Pe(c,[y,d,h]);let A;i!=null&&(A=z(i,"bias","fused matMul"),[A]=Qn(A,l),Qt(S,A.shape));let T;o!=null&&(T=z(o,"prelu weights","fused matMul"));const I=(P,B)=>{const[F,U,j,Z]=B,ne=c_(Pe(P,j.shape),j,s);let O,G;if(!n&&!r?(O=yn(ne,U,!1,!0),G=yn(F,ne,!0,!1)):!n&&r?(O=yn(ne,U,!1,!1),G=yn(ne,F,!0,!1)):n&&!r?(O=yn(U,ne,!1,!0),G=yn(F,ne,!1,!1)):(O=yn(U,ne,!0,!0),G=yn(ne,F,!0,!0)),i!=null){const q=u_(Z,ne);return[O,G,q]}else return[O,G]},N={a:w,b:E,bias:A,preluActivationWeights:T},M={transposeA:n,transposeB:r,activation:s,leakyreluAlpha:a};return i==null?_l((B,F,U)=>{const j=oe.runKernel(K2,N,M);return U([B,F,j]),{value:Pe(j,S),gradFunc:I}})(w,E):_l((B,F,U,j)=>{const Z=oe.runKernel(K2,N,M);return j([B,F,Z,U]),{value:Pe(Z,S),gradFunc:I}})(w,E,A)}const DSe=ee({fusedMatMul_:kSe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OSe=Object.freeze(Object.defineProperty({__proto__:null,conv2d:ASe,depthwiseConv2d:PSe,matMul:DSe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LSe(t){return WI(t,.54,.46)}const BSe=ee({hammingWindow_:LSe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FSe(t){return WI(t,.5,.5)}const YH=ee({hannWindow_:FSe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $Se(t,e,n,r=!1,i=0){let s=0;const o=[];for(;s+e<=t.size;)o.push(Rt(t,s,e)),s+=n;if(r)for(;s<t.size;){const a=s+e-t.size,l=pr([Rt(t,s,e-a),r_([a],i)]);o.push(l),s+=n}return o.length===0?dl([],[0,e]):Pe(pr(o),[o.length,e])}const QH=ee({frame_:$Se});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function USe(t,e,n,r,i=YH){r==null&&(r=JH(e));const s=QH(t,e,n),o=Et(s,i(e));return VI(o,r)}const zSe=ee({stft_:USe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GSe(t,e,n,r,i="bilinear",s=0){const o=z(t,"image","cropAndResize"),a=z(e,"boxes","cropAndResize","float32"),l=z(n,"boxInd","cropAndResize","int32"),c=a.shape[0];Y(o.rank===4,()=>`Error in cropAndResize: image must be rank 4,but got rank ${o.rank}.`),Y(a.rank===2&&a.shape[1]===4,()=>`Error in cropAndResize: boxes must be have size [${c},4] but had shape ${a.shape}.`),Y(l.rank===1&&l.shape[0]===c,()=>`Error in cropAndResize: boxInd must be have size [${c}] but had shape ${a.shape}.`),Y(r.length===2,()=>`Error in cropAndResize: cropSize must be of length 2, but got length ${r.length}.`),Y(r[0]>=1&&r[1]>=1,()=>`cropSize must be atleast [1,1], but was ${r}`),Y(i==="bilinear"||i==="nearest",()=>`method must be bilinear or nearest, but was ${i}`);const u={image:o,boxes:a,boxInd:l},d={method:i,extrapolationValue:s,cropSize:r};return oe.runKernel(uz,u,d)}const HSe=ee({cropAndResize_:GSe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VSe(t){const e=z(t,"image","flipLeftRight","float32");Y(e.rank===4,()=>`Error in flipLeftRight: image must be rank 4,but got rank ${e.rank}.`);const n={image:e};return oe.runKernel(Mz,n,{})}const WSe=ee({flipLeftRight_:VSe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function jSe(t){const e=z(t,"image","grayscaleToRGB"),n=e.rank-1,r=e.shape[n];Y(e.rank>=2,()=>`Error in grayscaleToRGB: images must be at least rank 2, but got rank ${e.rank}.`),Y(r===1,()=>`Error in grayscaleToRGB: last dimension of a grayscale image should be size 1, but got size ${r}.`);const i=new Array(e.rank);return i.fill(1,0,n),i[n]=3,cg(e,i)}const XSe=ee({grayscaleToRGB_:jSe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KSe(t,e,n=0,r=.5){const i=z(t,"image","rotateWithOffset","float32");Y(i.rank===4,()=>`Error in rotateWithOffset: image must be rank 4,but got rank ${i.rank}.`);const s={image:i},o={radians:e,fillValue:n,center:r};return oe.runKernel(mG,s,o)}const qSe=ee({rotateWithOffset_:KSe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ep(t,e,n,r,i,s){r==null&&(r=.5),i==null&&(i=Number.NEGATIVE_INFINITY),s==null&&(s=0);const o=t.shape[0];return n=Math.min(n,o),Y(0<=r&&r<=1,()=>`iouThreshold must be in [0, 1], but was '${r}'`),Y(t.rank===2,()=>`boxes must be a 2D tensor, but was of rank '${t.rank}'`),Y(t.shape[1]===4,()=>`boxes must have 4 columns, but 2nd dimension was ${t.shape[1]}`),Y(e.rank===1,()=>"scores must be a 1D tensor"),Y(e.shape[0]===o,()=>`scores has incompatible shape with boxes. Expected ${o}, but was ${e.shape[0]}`),Y(0<=s&&s<=1,()=>`softNmsSigma must be in [0, 1], but was '${s}'`),{maxOutputSize:n,iouThreshold:r,scoreThreshold:i,softNmsSigma:s}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JSe(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY){const s=z(t,"boxes","nonMaxSuppression","float32"),o=z(e,"scores","nonMaxSuppression","float32"),a=Ep(s,o,n,r,i);n=a.maxOutputSize,r=a.iouThreshold,i=a.scoreThreshold;const l={maxOutputSize:n,iouThreshold:r,scoreThreshold:i};return oe.runKernel(d8,{boxes:s,scores:o},l)}const YSe=ee({nonMaxSuppression_:JSe});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function QSe(t,e,n){const r=ZSe(t,e,n),i=r<0?-(r+1):r;t.splice(i,0,e)}function ZSe(t,e,n){return t_e(t,e,n||e_e)}function e_e(t,e){return t>e?1:t<e?-1:0}function t_e(t,e,n){let r=0,i=t.length,s=0,o=!1;for(;r<i;){s=r+(i-r>>>1);const a=n(e,t[s]);a>0?r=s+1:(i=s,o=!a)}return o?r:-r-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZH(t,e,n,r,i){return jI(t,e,n,r,i,0)}function eV(t,e,n,r,i,s){return jI(t,e,n,r,i,0,!1,s,!0)}function tV(t,e,n,r,i,s){return jI(t,e,n,r,i,s,!0)}function jI(t,e,n,r,i,s,o=!1,a=!1,l=!1){const c=[];for(let v=0;v<e.length;v++)e[v]>i&&c.push({score:e[v],boxIndex:v,suppressBeginIndex:0});c.sort(IL);const u=s>0?-.5/s:0,d=[],f=[];for(;d.length<n&&c.length>0;){const v=c.pop(),{score:y,boxIndex:b,suppressBeginIndex:S}=v;if(y<i)break;let w=!1;for(let E=d.length-1;E>=S;--E){const A=n_e(t,b,d[E]);if(A>=r){w=!0;break}if(v.score=v.score*r_e(r,u,A),v.score<=i)break}v.suppressBeginIndex=d.length,w||(v.score===y?(d.push(b),f.push(v.score)):v.score>i&&QSe(c,v,IL))}const h=d.length,p=n-h;a&&p>0&&(d.push(...new Array(p).fill(0)),f.push(...new Array(p).fill(0)));const x={selectedIndices:d};return o&&(x.selectedScores=f),l&&(x.validOutputs=h),x}function n_e(t,e,n){const r=t.subarray(e*4,e*4+4),i=t.subarray(n*4,n*4+4),s=Math.min(r[0],r[2]),o=Math.min(r[1],r[3]),a=Math.max(r[0],r[2]),l=Math.max(r[1],r[3]),c=Math.min(i[0],i[2]),u=Math.min(i[1],i[3]),d=Math.max(i[0],i[2]),f=Math.max(i[1],i[3]),h=(a-s)*(l-o),p=(d-c)*(f-u);if(h<=0||p<=0)return 0;const x=Math.max(s,c),v=Math.max(o,u),y=Math.min(a,d),b=Math.min(l,f),S=Math.max(y-x,0)*Math.max(b-v,0);return S/(h+p-S)}function r_e(t,e,n){const r=Math.exp(e*n*n);return n<=t?r:0}function IL(t,e){return t.score-e.score||t.score===e.score&&e.boxIndex-t.boxIndex}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function i_e(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY){const s=z(t,"boxes","nonMaxSuppressionAsync"),o=z(e,"scores","nonMaxSuppressionAsync"),a=Ep(s,o,n,r,i);n=a.maxOutputSize,r=a.iouThreshold,i=a.scoreThreshold;const l=await Promise.all([s.data(),o.data()]),c=l[0],u=l[1],{selectedIndices:d}=ZH(c,u,n,r,i);return s!==t&&s.dispose(),o!==e&&o.dispose(),zr(d,"int32")}const s_e=i_e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function o_e(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const o=z(t,"boxes","nonMaxSuppression"),a=z(e,"scores","nonMaxSuppression"),l=Ep(o,a,n,r,i,s);n=l.maxOutputSize,r=l.iouThreshold,i=l.scoreThreshold,s=l.softNmsSigma;const c={boxes:o,scores:a},u={maxOutputSize:n,iouThreshold:r,scoreThreshold:i,softNmsSigma:s},d=oe.runKernel(h8,c,u);return{selectedIndices:d[0],selectedScores:d[1]}}const a_e=ee({nonMaxSuppressionWithScore_:o_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function l_e(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=0){const o=z(t,"boxes","nonMaxSuppressionAsync"),a=z(e,"scores","nonMaxSuppressionAsync"),l=Ep(o,a,n,r,i,s);n=l.maxOutputSize,r=l.iouThreshold,i=l.scoreThreshold,s=l.softNmsSigma;const c=await Promise.all([o.data(),a.data()]),u=c[0],d=c[1],{selectedIndices:f,selectedScores:h}=tV(u,d,n,r,i,s);return o!==t&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:zr(f,"int32"),selectedScores:zr(h)}}const c_e=l_e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u_e(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const o=z(t,"boxes","nonMaxSuppression"),a=z(e,"scores","nonMaxSuppression"),l=Ep(o,a,n,r,i,null),c=l.maxOutputSize,u=l.iouThreshold,d=l.scoreThreshold,f={boxes:o,scores:a},h={maxOutputSize:c,iouThreshold:u,scoreThreshold:d,padToMaxOutputSize:s},p=oe.runKernel(f8,f,h);return{selectedIndices:p[0],validOutputs:p[1]}}const d_e=ee({nonMaxSuppressionPadded_:u_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */async function f_e(t,e,n,r=.5,i=Number.NEGATIVE_INFINITY,s=!1){const o=z(t,"boxes","nonMaxSuppressionAsync"),a=z(e,"scores","nonMaxSuppressionAsync"),l=Ep(o,a,n,r,i,null),c=l.maxOutputSize,u=l.iouThreshold,d=l.scoreThreshold,[f,h]=await Promise.all([o.data(),a.data()]),{selectedIndices:p,validOutputs:x}=eV(f,h,c,u,d,s);return o!==t&&o.dispose(),a!==e&&a.dispose(),{selectedIndices:zr(p,"int32"),validOutputs:fn(x,"int32")}}const h_e=f_e;/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p_e(t,e,n=!1,r=!1){const i=z(t,"images","resizeBilinear");Y(i.rank===3||i.rank===4,()=>`Error in resizeBilinear: x must be rank 3 or 4, but got rank ${i.rank}.`),Y(e.length===2,()=>`Error in resizeBilinear: new shape must 2D, but got shape ${e}.`),Y(r===!1||n===!1,()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false.");let s=i,o=!1;i.rank===3&&(o=!0,s=Pe(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const a={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=oe.runKernel(R8,a,l);return o?Pe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const m_e=ee({resizeBilinear_:p_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g_e(t,e,n=!1,r=!1){const i=z(t,"images","resizeNearestNeighbor");Y(i.rank===3||i.rank===4,()=>`Error in resizeNearestNeighbor: x must be rank 3 or 4, but got rank ${i.rank}.`),Y(e.length===2,()=>`Error in resizeNearestNeighbor: new shape must 2D, but got shape ${e}.`),Y(i.dtype==="float32"||i.dtype==="int32",()=>"`images` must have `int32` or `float32` as dtype"),Y(r===!1||n===!1,()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false.");let s=i,o=!1;i.rank===3&&(o=!0,s=Pe(i,[1,i.shape[0],i.shape[1],i.shape[2]]));const a={images:s},l={alignCorners:n,halfPixelCenters:r,size:e},c=oe.runKernel(M8,a,l);return o?Pe(c,[c.shape[1],c.shape[2],c.shape[3]]):c}const y_e=ee({resizeNearestNeighbor_:g_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v_e(t,e="binary",n=!1,r=.5){const i=z(t,"image","threshold"),s=.2989,o=.587,a=.114,l=i.shape[0]*i.shape[1];let c=Et(zr([r]),255),u,d,f,h;if(Y(i.rank===3,()=>`Error in threshold: image must be rank 3,but got rank ${i.rank}.`),Y(i.shape[2]===3||i.shape[2]===1,()=>`Error in threshold: image color channel must be equal to 3 or 1but got ${i.shape[2]}.`),Y(i.dtype==="int32"||i.dtype==="float32",()=>`Error in dtype: image dtype must be int32 or float32,but got dtype ${i.dtype}.`),Y(e==="otsu"||e==="binary",()=>`Method must be binary or otsu, but was ${e}`),i.shape[2]===3){[u,d,f]=n0(i,[1,1,1],-1);const v=Et(u,s),y=Et(d,o),b=Et(f,a);h=cr(cr(v,y),b)}else h=t;if(e==="otsu"){const v=xH(hr(VH(h),"int32"),Ma([]),256);c=x_e(v,l)}const p=n?kI(h,c):a_(h,c);return hr(Et(p,255),"int32")}function x_e(t,e){let n=zr([-1]),r=zr([0]),i=zr([0]),s,o,a,l,c,u;for(let d=0;d<t.size-1;d++){s=Rt(t,0,d+1),o=Rt(t,d+1),c=ar(Rn(s),e),u=ar(Rn(o),e);const f=Rn(Et(s,t0(0,s.size)));a=ar(f,Rn(s));const h=r_(o.shape,s.size),p=cr(t0(0,o.size),h),x=Et(o,p);l=ar(Rn(x),Rn(o));const v=zt(a,l),y=zt(a,l),b=Et(c,u);i=Et(Et(b,v),y);const S=a_(i,r);r=ep(S,i,r),n=ep(S,zr([d]),n)}return n}const b_e=ee({threshold_:v_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function S_e(t,e,n="nearest",r="constant",i=0,s){const o=z(t,"image","transform","float32"),a=z(e,"transforms","transform","float32");Y(o.rank===4,()=>`Error in transform: image must be rank 4,but got rank ${o.rank}.`),Y(a.rank===2&&(a.shape[0]===o.shape[0]||a.shape[0]===1)&&a.shape[1]===8,()=>"Error in transform: Input transform should be batch x 8 or 1 x 8"),Y(s==null||s.length===2,()=>`Error in transform: outputShape must be [height, width] or null, but got ${s}.`);const l={image:o,transforms:a},c={interpolation:n,fillMode:r,fillValue:i,outputShape:s};return oe.runKernel(cG,l,c)}const __e=ee({transform_:S_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function w_e(t,e,n){Y(e%1===0,()=>`bandPart(): numLower must be an integer, got ${e}.`),Y(n%1===0,()=>`bandPart(): numUpper must be an integer, got ${n}.`);const r=z(t,"a","bandPart");Y(r.rank>=2,()=>`bandPart(): Rank must be at least 2, got ${r.rank}.`);const i=r.shape,[s,o]=r.shape.slice(-2);if(!(e<=s))throw new Error(`bandPart(): numLower (${e}) must not be greater than the number of rows (${s}).`);if(!(n<=o))throw new Error(`bandPart(): numUpper (${n}) must not be greater than the number of columns (${o}).`);e<0&&(e=s),n<0&&(n=o);const a=Pe(t0(0,s,1,"int32"),[-1,1]),l=t0(0,o,1,"int32"),c=zt(a,l),u=J1(kI(c,fn(+e,"int32")),MH(c,fn(-n,"int32"))),d=Sd([s,o],r.dtype);return Pe(wl($d(Pe(r,[-1,s,o])).map(f=>ep(u,f,d))),i)}const C_e=ee({bandPart_:w_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function E_e(t){let e;if(Array.isArray(t)){e=!1,Y(t!=null&&t.length>0,()=>"Gram-Schmidt process: input must not be null, undefined, or empty");const i=t[0].shape[0];for(let s=1;s<t.length;++s)Y(t[s].shape[0]===i,()=>`Gram-Schmidt: Non-unique lengths found in the input vectors: (${t[s].shape[0]} vs. ${i})`)}else e=!0,t=n0(t,t.shape[0],0).map(i=>Ra(i,[0]));Y(t.length<=t[0].shape[0],()=>`Gram-Schmidt: Number of vectors (${t.length}) exceeds number of dimensions (${t[0].shape[0]}).`);const n=[],r=t;for(let i=0;i<t.length;++i)n.push(oe.tidy(()=>{let s=r[i];if(i>0)for(let o=0;o<i;++o){const a=Et(Rn(Et(n[o],s)),n[o]);s=zt(s,a)}return ar(s,o_(s,"euclidean"))}));return e?wl(n,0):n}const A_e=ee({gramSchmidt_:E_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T_e(t,e=!1){if(Y(t.rank>=2,()=>`qr() requires input tensor to have a rank >= 2, but got rank ${t.rank}`),t.rank===2)return NL(t,e);{const n=t.shape.slice(0,t.shape.length-2).reduce((l,c)=>l*c),r=$d(Pe(t,[n,t.shape[t.shape.length-2],t.shape[t.shape.length-1]]),0),i=[],s=[];r.forEach(l=>{const[c,u]=NL(l,e);i.push(c),s.push(u)});const o=Pe(wl(i,0),t.shape),a=Pe(wl(s,0),t.shape);return[o,a]}}function NL(t,e=!1){return oe.tidy(()=>{Y(t.shape.length===2,()=>`qr2d() requires a 2D Tensor, but got a ${t.shape.length}D Tensor.`);const n=t.shape[0],r=t.shape[1];let i=EH(n),s=_c(t);const o=dl([[1]],[1,1]);let a=_c(o);const l=n>=r?r:n;for(let c=0;c<l;++c){const u=s,d=a,f=i;[a,s,i]=oe.tidy(()=>{const h=Rt(s,[c,c],[n-c,1]),p=o_(h),x=Rt(s,[c,c],[1,1]),v=ep(a_(x,0),dl([[-1]]),dl([[1]])),y=zt(x,Et(v,p)),b=ar(h,y);b.shape[0]===1?a=_c(o):a=pr([o,Rt(b,[1,0],[b.shape[0]-1,b.shape[1]])],0);const S=ul(ar(yn(v,y),p)),w=Rt(s,[c,0],[n-c,r]),E=Et(S,a),A=uT(a);if(c===0)s=zt(w,yn(E,yn(A,w)));else{const N=zt(w,yn(E,yn(A,w)));s=pr([Rt(s,[0,0],[c,r]),N],0)}const T=uT(E),I=Rt(i,[0,c],[n,i.shape[1]-c]);if(c===0)i=zt(I,yn(yn(I,a),T));else{const N=zt(I,yn(yn(I,a),T));i=pr([Rt(i,[0,0],[n,c]),N],1)}return[a,s,i]}),A0e([u,d,f])}return!e&&n>r&&(i=Rt(i,[0,0],[n,r]),s=Rt(s,[0,0],[r,r])),[i,s]})}const M_e=ee({qr_:T_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var ki;(function(t){t[t.NONE=0]="NONE",t[t.MEAN=1]="MEAN",t[t.SUM=2]="SUM",t[t.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"})(ki||(ki={}));function R_e(t,e,n=ki.SUM_BY_NONZERO_WEIGHTS){const r=z(t,"losses","computeWeightedLoss");let i=null;e!=null&&(i=z(e,"weights","computeWeightedLoss"));const s=i==null?r:Et(r,i);if(n===ki.NONE)return s;if(n===ki.SUM)return Rn(s);if(n===ki.MEAN){if(i==null)return Y1(s);{const o=r.size/i.size,a=ar(Rn(s),Rn(i));return o>1?ar(a,fn(o)):a}}if(n===ki.SUM_BY_NONZERO_WEIGHTS){if(i==null)return ar(Rn(s),fn(r.size));{const o=Et(i,zu(r.shape)),a=hr(Rn(BH(o,fn(0))),"float32");return ar(Rn(s),a)}}throw Error(`Unknown reduction: ${n}`)}const Rl=ee({computeWeightedLoss_:R_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function I_e(t,e,n,r=ki.SUM_BY_NONZERO_WEIGHTS){const i=z(t,"labels","absoluteDifference"),s=z(e,"predictions","absoluteDifference");let o=null;n!=null&&(o=z(n,"weights","absoluteDifference")),Ls(i.shape,s.shape,"Error in absoluteDifference: ");const a=Zs(zt(i,s));return Rl(a,o,r)}const N_e=ee({absoluteDifference_:I_e});function P_e(t,e,n,r,i=ki.SUM_BY_NONZERO_WEIGHTS){const s=z(t,"labels","cosineDistance"),o=z(e,"predictions","cosineDistance");let a=null;r!=null&&(a=z(r,"weights","cosineDistance")),Ls(s.shape,o.shape,"Error in cosineDistance: ");const l=fn(1),c=zt(l,Rn(Et(s,o),n,!0));return Rl(c,a,i)}const k_e=ee({cosineDistance_:P_e});function D_e(t,e,n,r=ki.SUM_BY_NONZERO_WEIGHTS){let i=z(t,"labels","hingeLoss");const s=z(e,"predictions","hingeLoss");let o=null;n!=null&&(o=z(n,"weights","hingeLoss")),Ls(i.shape,s.shape,"Error in hingeLoss: ");const a=fn(1);i=zt(Et(fn(2),i),a);const l=l_(zt(a,Et(i,s)));return Rl(l,o,r)}const O_e=ee({hingeLoss_:D_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L_e(t,e,n,r=1,i=ki.SUM_BY_NONZERO_WEIGHTS){const s=z(t,"labels","huberLoss"),o=z(e,"predictions","huberLoss");let a=null;n!=null&&(a=z(n,"weights","huberLoss")),Ls(s.shape,o.shape,"Error in huberLoss: ");const l=fn(r),c=Zs(zt(o,s)),u=LH(c,l),d=zt(c,u),f=cr(Et(fn(.5),s_(u)),Et(l,d));return Rl(f,a,i)}const B_e=ee({huberLoss_:L_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function F_e(t,e,n,r=1e-7,i=ki.SUM_BY_NONZERO_WEIGHTS){const s=z(t,"labels","logLoss"),o=z(e,"predictions","logLoss");let a=null;n!=null&&(a=z(n,"weights","logLoss")),Ls(s.shape,o.shape,"Error in logLoss: ");const l=fn(1),c=fn(r),u=ul(Et(s,e0(cr(o,c)))),d=Et(zt(l,s),e0(cr(zt(l,o),c))),f=zt(u,d);return Rl(f,a,i)}const $_e=ee({logLoss_:F_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function U_e(t,e,n,r=ki.SUM_BY_NONZERO_WEIGHTS){const i=z(t,"labels","meanSquaredError"),s=z(e,"predictions","meanSquaredError");let o=null;n!=null&&(o=z(n,"weights","meanSquaredError")),Ls(i.shape,s.shape,"Error in meanSquaredError: ");const a=jH(i,s);return Rl(a,o,r)}const z_e=ee({meanSquaredError_:U_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function G_e(t,e){const n=z(t,"labels","sigmoidCrossEntropyWithLogits"),r=z(e,"logits","sigmoidCrossEntropyWithLogits");Ls(n.shape,r.shape,"Error in sigmoidCrossEntropyWithLogits: ");const i=l_(r),s=Et(r,n),o=IH(bd(ul(Zs(r))));return cr(zt(i,s),o)}function H_e(t,e,n,r=0,i=ki.SUM_BY_NONZERO_WEIGHTS){let s=z(t,"multiClassLabels","sigmoidCrossEntropy");const o=z(e,"logits","sigmoidCrossEntropy");let a=null;if(n!=null&&(a=z(n,"weights","sigmoidCrossEntropy")),Ls(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),r>0){const c=fn(r),u=fn(1),d=fn(.5);s=cr(Et(s,zt(u,c)),Et(d,c))}const l=G_e(s,o);return Rl(l,a,i)}const V_e=ee({sigmoidCrossEntropy_:H_e});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W_e(t,e,n=-1){if(n===-1&&(n=e.rank-1),n!==e.rank-1)throw Error(`Softmax cross entropy along a non-last dimension is not yet supported. Labels / logits was rank ${e.rank} and dim was ${n}`);return _l((i,s,o)=>{const l=PH(s,[n],!0),c=zt(hr(s,"float32"),l);o([i,c]);const u=ul(Et(c,i));return{value:Rn(u,[n]),gradFunc:(h,p)=>{const[x,v]=p,y=Fs(h.shape,[n]);return[Et(Pe(h,y),zt(hr(x,"float32"),bd(v))),Et(Pe(h,y),zt(bd(v),hr(x,"float32")))]}}})(t,e)}function j_e(t,e,n,r=0,i=ki.SUM_BY_NONZERO_WEIGHTS){let s=z(t,"onehotLabels","softmaxCrossEntropy");const o=z(e,"logits","softmaxCrossEntropy");let a=null;if(n!=null&&(a=z(n,"weights","softmaxCrossEntropy")),Ls(s.shape,o.shape,"Error in softmaxCrossEntropy: "),r>0){const c=fn(r),u=fn(1),d=fn(s.shape[1]);s=cr(Et(s,zt(u,c)),ar(c,d))}const l=W_e(s,o);return Rl(l,a,i)}const X_e=ee({softmaxCrossEntropy_:j_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function K_e(t,e,n,r){const i=z(t,"indices","sparseFillEmptyRows","int32"),s=z(e,"values","sparseFillEmptyRows"),o=z(n,"denseShape","sparseFillEmptyRows","int32"),a=z(r,"defaultValue","sparseFillEmptyRows",s.dtype);if(i.rank!==2)throw new Error(`Indices should be Tensor2D but received shape
        ${i.shape}`);if(s.rank!==1)throw new Error(`Values should be Tensor1D but received shape ${s.shape}`);if(o.rank!==1)throw new Error(`Dense shape should be Tensor1D but received shape ${o.shape}`);if(a.rank!==0)throw new Error(`Default value should be a scalar but received shape ${a.shape}`);const l={indices:i,values:s,denseShape:o,defaultValue:a},c=oe.runKernel(q8,l);return{outputIndices:c[0],outputValues:c[1],emptyRowIndicator:c[2],reverseIndexMap:c[3]}}const q_e=ee({sparseFillEmptyRows_:K_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function J_e(t,e,n){const r=z(t,"inputIndices","sparseReshape","int32"),i=z(e,"inputShape","sparseReshape","int32"),s=z(n,"newShape","sparseReshape","int32");if(r.rank!==2)throw new Error(`Input indices should be Tensor2D but received shape
        ${r.shape}`);if(i.rank!==1)throw new Error(`Input shape should be Tensor1D but received shape ${i.shape}`);if(s.rank!==1)throw new Error(`New shape should be Tensor1D but received shape ${s.shape}`);const o={inputIndices:r,inputShape:i,newShape:s},a=oe.runKernel(J8,o);return{outputIndices:a[0],outputShape:a[1]}}const Y_e=ee({sparseReshape_:J_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Q_e(t,e,n){const r=z(t,"data","sparseSegmentMean"),i=z(e,"indices","sparseSegmentMean","int32"),s=z(n,"segmentIds","sparseSegmentMean","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
          ${i.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
          ${s.shape}`);const o={data:r,indices:i,segmentIds:s};return oe.runKernel(Y8,o)}const Z_e=ee({sparseSegmentMean_:Q_e});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ewe(t,e,n){const r=z(t,"data","sparseSegmentSum"),i=z(e,"indices","sparseSegmentSum","int32"),s=z(n,"segmentIds","sparseSegmentSum","int32");if(r.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.rank!==1)throw new Error(`Indices should be Tensor1D but received shape
         ${i.shape}`);if(s.rank!==1)throw new Error(`Segment ids should be Tensor1D but received shape
         ${s.shape}`);const o={data:r,indices:i,segmentIds:s};return oe.runKernel(Q8,o)}const twe=ee({sparseSegmentSum_:ewe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nwe(t,e,n,r,i,s,o,a){const l=z(t,"data","stringNGrams","string");if(l.dtype!=="string")throw new Error("Data must be of datatype string");if(l.shape.length!==1)throw new Error(`Data must be a vector, saw: ${l.shape}`);const c=z(e,"dataSplits","stringNGrams");if(c.dtype!=="int32")throw new Error("Data splits must be of datatype int32");const u={separator:n,nGramWidths:r,leftPad:i,rightPad:s,padWidth:o,preserveShortSequences:a},d={data:l,dataSplits:c},f=oe.runKernel(nG,d,u);return{nGrams:f[0],nGramsSplits:f[1]}}const rwe=ee({stringNGrams_:nwe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function iwe(t,e,n=!0){const r=z(t,"input","stringSplit","string"),i=z(e,"delimiter","stringSplit","string");if(r.rank!==1)throw new Error(`Input should be Tensor1D but received shape ${r.shape}`);if(i.rank!==0)throw new Error(`Delimiter should be a scalar but received shape ${i.shape}`);const s={skipEmpty:n},o={input:r,delimiter:i},a=oe.runKernel(rG,o,s);return{indices:a[0],values:a[1],shape:a[2]}}const swe=ee({stringSplit_:iwe});/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function owe(t,e){const n=z(t,"input","stringToHashBucketFast","string"),r={numBuckets:e};if(e<=0)throw new Error("Number of buckets must be at least 1");const i={input:n};return oe.runKernel(iG,i,r)}const awe=ee({stringToHashBucketFast_:owe});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lwe={fft:HI,ifft:Q1,rfft:VI,irfft:WH},cwe={hammingWindow:BSe,hannWindow:YH,frame:QH,stft:zSe},Gu={flipLeftRight:WSe,grayscaleToRGB:XSe,resizeNearestNeighbor:y_e,resizeBilinear:m_e,rotateWithOffset:qSe,cropAndResize:HSe,nonMaxSuppression:YSe,nonMaxSuppressionAsync:s_e,nonMaxSuppressionWithScore:a_e,nonMaxSuppressionWithScoreAsync:c_e,nonMaxSuppressionPadded:d_e,nonMaxSuppressionPaddedAsync:h_e,threshold:b_e,transform:__e},uwe={bandPart:C_e,gramSchmidt:A_e,qr:M_e},dwe={absoluteDifference:N_e,computeWeightedLoss:Rl,cosineDistance:k_e,hingeLoss:O_e,huberLoss:B_e,logLoss:$_e,meanSquaredError:z_e,sigmoidCrossEntropy:V_e,softmaxCrossEntropy:X_e},fwe={sparseFillEmptyRows:q_e,sparseReshape:Y_e,sparseSegmentMean:Z_e,sparseSegmentSum:twe},hwe={stringNGrams:rwe,stringSplit:swe,stringToHashBucketFast:awe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pwe=typeof requestAnimationFrame<"u"?requestAnimationFrame:typeof setImmediate<"u"?setImmediate:t=>t();function mwe(){return new Promise(t=>pwe(()=>t()))}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nV(t,e){const n=t[0].length;t.forEach((i,s)=>{Y(i.length===n,()=>`Error in concat${n}D: rank of tensors[${s}] must be the same as the rank of the rest (${n})`)}),Y(e>=0&&e<n,()=>`Error in concat${n}D: axis must be between 0 and ${n-1}.`);const r=t[0];t.forEach((i,s)=>{for(let o=0;o<n;o++)Y(o===e||i[o]===r[o],()=>`Error in concat${n}D: Shape of tensors[${s}] (${i}) does not match the shape of the rest (${r}) along the non-concatenated axis ${s}.`)})}function wd(t,e){const n=t[0].slice();for(let r=1;r<t.length;r++)n[e]+=t[r][e];return n}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var $o;(function(t){t[t.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",t[t.VALUE_ROWIDS=1]="VALUE_ROWIDS",t[t.ROW_LENGTHS=2]="ROW_LENGTHS",t[t.ROW_SPLITS=3]="ROW_SPLITS",t[t.ROW_LIMITS=4]="ROW_LIMITS",t[t.ROW_STARTS=5]="ROW_STARTS"})($o||($o={}));function rV(t,e,n){let r=new Array;if(n==null&&e==null)return r;if(e==null)for(;r.length<t+n.length;)r.push(-1);else r=e.slice();if(n==null)return r;if(t+n.length!==r.length)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.rank = ${t+n.length}, but shape.rank = ${r.length}`);for(let i=1;i<n.length;++i){const s=n[i],o=r[r.length-n.length+i],a=r[o];if(s>=0)if(a>=0){if(a!==s)throw new Error(`rt input.shape and shape=${e} are incompatible: rt input.shape[${i+t}] = ${s} but shape[${i+t}] = ${a}`)}else r[o]=s}return r}function iV(t){const e={FIRST_DIM_SIZE:$o.FIRST_DIM_SIZE,VALUE_ROWIDS:$o.VALUE_ROWIDS,ROW_LENGTHS:$o.ROW_LENGTHS,ROW_SPLITS:$o.ROW_SPLITS,ROW_LIMITS:$o.ROW_LIMITS,ROW_STARTS:$o.ROW_STARTS},n=[];for(const r of t)if(r in e)n.push(e[r]);else break;return n}function sV(t){return t.length===0?0:t[0]===$o.FIRST_DIM_SIZE?t.length-1:t.length}function oV(t,e){if(t==null||e==null)return;const n=t.length,r=e.length;if(n>=r)throw new Error(`defaultValue.shape=${t} and ragged tensor flatValues.shape=${e}, are incompatible: defaultValue.rank = ${n} must be less than ragged tensor input flatValues.rank = ${r})`);for(let i=0;i<Math.min(n,r-1);++i){const s=t[i],o=e[i+1];if(s>=0&&o>=0&&s!==1&&s!==o)throw new Error(`defaultValue.shape=${t}, and ragged tensor input flatValues.shape=${e} are incompatible: defaultValue.shape[${i-t.length}] = ${s} but ragged tensor input.flatValues.shape[${i-t.length}] = ${o}`)}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XI=30;function h_(t){return t<=XI?t:V2(t,Math.floor(Math.sqrt(t)))}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aV(t,e,n){const r=n*(typeof t=="number"?t:t[0]),i=e*(typeof t=="number"?t:t[1]);return[r,i]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KI(t,e,n,r=!0){let i=[];if(r)i=i.concat(e.slice(0)),i.push(t[0]/n),i=i.concat(t.slice(1));else{i=i.concat(t[0]);const s=e.length;for(let o=0;o<s;++o)i=i.concat([t[o+1]/e[o],e[o]]);i=i.concat(t.slice(s+1))}return i}function qI(t,e,n=!0){const r=[];if(n){r.push(e);for(let i=e+1;i<t;++i)i<=2*e?(r.push(i),r.push(i-(e+1))):r.push(i)}else{const i=[],s=[];for(let o=1;o<t;++o)o>=e*2+1||o%2===1?s.push(o):i.push(o);r.push(...i),r.push(0),r.push(...s)}return r}function JI(t,e,n,r=!0){const i=[];r?i.push(t[0]/n):i.push(t[0]*n);for(let s=1;s<t.length;++s)s<=e.length?r?i.push(e[s-1]*t[s]):i.push(t[s]/e[s-1]):i.push(t[s]);return i}function lV(t,e){const n=[0];for(let r=0;r<e;++r)n.push(t[r][0]);return n}function cV(t,e,n){const r=t.slice(0,1);for(let i=0;i<n;++i)r.push(t[i+1]-e[i][0]-e[i][1]);return r}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uV=1.7580993408473768,dV=1.0507009873554805;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fV=.3275911,hV=.254829592,pV=-.284496736,mV=1.421413741,gV=-1.453152027,yV=1.061405429;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gT(t,e){if(t.length!==e.length)throw new Error(`Cannot merge real and imag arrays of different lengths. real:${t.length}, imag: ${e.length}.`);const n=new Float32Array(t.length*2);for(let r=0;r<n.length;r+=2)n[r]=t[r/2],n[r+1]=e[r/2];return n}function gwe(t){const e=new Float32Array(t.length/2),n=new Float32Array(t.length/2);for(let r=0;r<t.length;r+=2)e[r/2]=t[r],n[r/2]=t[r+1];return{real:e,imag:n}}function ywe(t){const e=Math.ceil(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let i=0;i<t.length;i+=4)n[Math.floor(i/4)]=t[i],r[Math.floor(i/4)]=t[i+1];return{real:n,imag:r}}function vwe(t){const e=Math.floor(t.length/4),n=new Float32Array(e),r=new Float32Array(e);for(let i=2;i<t.length;i+=4)n[Math.floor(i/4)]=t[i],r[Math.floor(i/4)]=t[i+1];return{real:n,imag:r}}function xwe(t,e){const n=t[e*2],r=t[e*2+1];return{real:n,imag:r}}function bwe(t,e,n,r){t[r*2]=e,t[r*2+1]=n}function Swe(t,e){const n=new Float32Array(t/2),r=new Float32Array(t/2);for(let i=0;i<Math.ceil(t/2);i++){const s=(e?2:-2)*Math.PI*(i/t);n[i]=Math.cos(s),r[i]=Math.sin(s)}return{real:n,imag:r}}function _we(t,e,n){const r=(n?2:-2)*Math.PI*(t/e),i=Math.cos(r),s=Math.sin(r);return{real:i,imag:s}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mE="->",wwe=/->/g,PL=",",kL="...";function vV(t,e){t=t.replace(/\s/g,"");const n=(t.length-t.replace(wwe,"").length)/mE.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error(`Equation must contain exactly one arrow ("${mE}").`);const[r,i]=t.split(mE);Y(r.indexOf(kL)===-1,()=>`The ellipsis notation ("${kL}") is not supported yet.`);const s=r.split(PL),o=s.length;if(e!==o)throw new Error(`Expected ${o} input tensors, received ${e}`);if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const a=[];for(let f=0;f<i.length;++f){const h=i[f];if(!s.some(p=>p.indexOf(h)!==-1))throw new Error(`Output subscripts contain the label ${h} not present in the input subscripts.`);a.indexOf(h)===-1&&a.push(h)}for(let f=0;f<r.length;++f){const h=r[f];a.indexOf(h)===-1&&h!==PL&&a.push(h)}const l=new Array(s.length);for(let f=0;f<o;++f){if(new Set(s[f].split("")).size!==s[f].length)throw new Error(`Found duplicate axes in input component ${s[f]}. Support for duplicate axes in input is not implemented yet.`);l[f]=[];for(let h=0;h<s[f].length;++h)l[f].push(a.indexOf(s[f][h]))}const c=a.length,u=i.length,d=[];for(let f=u;f<c;++f)d.push(f);return{allDims:a,summedDims:d,idDims:l}}function xV(t,e){let n=new Array(t);n.fill(-1);for(let i=0;i<e.length;++i)n[e[i]]=i;const r=[];for(let i=0;i<t;++i)n[i]===-1&&r.push(i);return n=n.filter(i=>i!==-1),{permutationIndices:n,expandDims:r}}function bV(t,e,n){const r=new Array(t);for(let i=0;i<n.length;++i){const s=n[i].shape;for(let o=0;o<e[i].length;++o)r[e[i][o]]===void 0?r[e[i][o]]=s[o]:Y(r[e[i][o]]===s[o],()=>`Expected dimension ${r[e[i][o]]} at axis ${o} of input shaped ${JSON.stringify(s)}, but got dimension ${s[o]}`)}}function SV(t,e){const n=t,r=[];let i=0;t.length===0&&n.push(-1),i=t.length+1;for(let o=0;o<i;++o)r.push([]);const s=[];for(let o=0;o<n.length;++o){const a=n[o],l=Cwe(e,a);for(const c of l)s.indexOf(c)===-1&&(r[o].push(c),s.push(c))}return{path:n,steps:r}}function _V(t){return t.every((e,n)=>e===n)}function Cwe(t,e){const n=[];for(let r=0;r<t.length;++r)(t[r].length===0||t[r].indexOf(e)!==-1||e===-1)&&n.push(r);return n}function wV(t,e,n=0){let r=[];if(typeof e=="number")Y(t.shape[n]%e===0,()=>"Number of splits must evenly divide the axis."),r=new Array(e).fill(t.shape[n]/e);else{const i=e.reduce((o,a)=>(a===-1&&(o+=1),o),0);Y(i<=1,()=>"There should be only one negative value in split array.");const s=e.indexOf(-1);if(s!==-1){const o=e.reduce((a,l)=>l>0?a+l:a);e[s]=t.shape[n]-o}Y(t.shape[n]===e.reduce((o,a)=>o+a),()=>"The sum of sizes must match the size of the axis dimension."),r=e}return r}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function CV(t){return`Received SparseTensor with denseShape[0] = 0 but
  indices.shape[0] = ${t}`}function EV(t,e){return`indices(${t}, 0) is invalid: ${e} < 0`}function AV(t,e,n){return`indices(${t}, 0) is invalid: ${e} >= ${n}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TV(t,e){return`only one output dimension may be -1, not both ${t} and ${e}`}function MV(t,e){return`size ${t} must be non-negative, not ${e}`}function RV(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function IV(t,e){const n=Ve(t),r=Ve(e);return`Input to reshape is a SparseTensor with ${n}
  dense values, but the requested shape requires a multiple of ${r}. inputShape=${t} outputShape= ${e}`}function NV(t,e){const n=Ve(t),r=Ve(e);return`Input to reshape is a tensor with ${n} dense values, but the requested shape has ${r}. inputShape=${t} outputShape=${e}`}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yT(){return"segment ids must be >= 0"}function PV(){return"segment ids are not increasing"}function kV(t,e){return`Segment id ${t} out of range [0, ${e}), possibly because segmentIds input is not sorted.`}function DV(t,e,n){return`Bad: indices[${t}] == ${e} out of range [0, ${n})`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OV(t,e){let n=!1,r;for(t<=XI?(r=t,n=!0):r=V2(t,Math.floor(Math.sqrt(t)));!n;)r>e||r===t?n=!0:r=V2(t,r+1);return r}function LV(t,e,n){const r=[],i=t.length;for(let s=0;s<i;s++)s!==e?r.push(t[s]):r.push(n);return r}function BV(t,e,n,r){const i=e.shape.length,s=t.shape.length;if(r!==0&&(r<-i||r>i))throw new Error(`Expect batchDims in the range of [-${i}, ${i}], but got ${r}`);if(r<0&&(r+=i),r>s)throw new Error(`batchDims (${r}) must be less than rank(x) (
    ${s}).`);if(n<r)throw new Error(`batchDims (${r}) must be less than or equal to axis (${n}).`);for(let d=0;d<r;++d)if(t.shape[d]!==e.shape[d])throw new Error(`x.shape[${d}]: ${t.shape[d]} should be equal to indices.shape[${d}]: ${e.shape[d]}.`);const o=t.shape[n],a=[];let l=1,c=1,u=1;for(let d=0;d<r;++d)a.push(t.shape[d]),l*=t.shape[d];for(let d=r;d<n;d++)a.push(t.shape[d]),c*=t.shape[d];for(let d=r;d<i;d++)a.push(e.shape[d]);for(let d=n+1;d<s;d++)a.push(t.shape[d]),u*=t.shape[d];return{batchSize:l,sliceSize:u,outerSize:c,dimSize:o,outputShape:a}}const Ewe=Object.freeze(Object.defineProperty({__proto__:null,collectGatherOpShapeInfo:BV,computeOutShape:LV,segOpComputeOptimalWindowSize:OV},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function r0(t){try{return t.map(e=>Qh(e))}catch(e){throw new Error(`Failed to decode encoded string bytes into utf-8, error: ${e}`)}}function FV(t){return t.map(e=>ed(e))}const Awe=Object.freeze(Object.defineProperty({__proto__:null,ERF_A1:hV,ERF_A2:pV,ERF_A3:mV,ERF_A4:gV,ERF_A5:yV,ERF_P:fV,PARALLELIZE_THRESHOLD:XI,get RowPartitionType(){return $o},SELU_SCALE:dV,SELU_SCALEALPHA:uV,applyActivation:d_,assertAndGetBroadcastShape:Qt,assertAxesAreInnerMostDims:ta,assertParamsConsistent:nV,assignToTypedArray:bwe,axesAreInnerMostDims:II,calculateShapes:wI,checkEinsumDimSizes:bV,checkPadOnDimRoundingMode:So,combineLocations:wH,combineRaggedTensorToTensorShapes:rV,complexWithEvenIndex:ywe,complexWithOddIndex:vwe,computeConv2DInfo:Bs,computeConv3DInfo:F0,computeDefaultPad:AI,computeDilation2DInfo:gH,computeOptimalWindowSize:h_,computeOutAndReduceShapes:Oa,computeOutShape:wd,computePool2DInfo:Bd,computePool3DInfo:B0,convertConv2DDataFormat:Cp,decodeEinsumEquation:vV,eitherStridesOrDilationsAreOne:ls,expandShapeToKeepDim:Fs,exponent:_we,exponents:Swe,fromStringArrayToUint8:FV,fromUint8ToStringArray:r0,getAxesPermutation:_o,getBroadcastDims:K1,getComplexWithIndex:xwe,getEinsumComputePath:SV,getEinsumPermutation:xV,getFusedBiasGradient:u_,getFusedDyActivation:c_,getImageCenter:aV,getInnerMostAxes:wo,getPermuted:qI,getRaggedRank:sV,getReductionAxes:YG,getReshaped:KI,getReshapedPermuted:JI,getRowPartitionTypesHelper:iV,getSliceBeginCoords:lV,getSliceSize:cV,getSparseFillEmptyRowsIndicesDenseShapeMismatch:CV,getSparseFillEmptyRowsNegativeIndexErrorMessage:EV,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:AV,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:RV,getSparseReshapeInputOutputMismatchErrorMessage:NV,getSparseReshapeInputOutputMultipleErrorMessage:IV,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:TV,getSparseReshapeNegativeOutputDimErrorMessage:MV,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:DV,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:yT,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:PV,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:kV,getUndoAxesPermutation:NI,isIdentityPermutation:_V,log:Qme,mergeRealAndImagArrays:gT,prepareAndValidate:eH,prepareSplitSize:wV,segment_util:Ewe,shouldFuse:f_,slice_util:$0e,splitRealAndImagArrays:gwe,tupleValuesAreOne:Zg,upcastType:Pa,validateDefaultValueShape:oV,validateInput:nH,validateUpdateShape:tH,warn:zo},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Twe=ge();Twe.registerFlag("KEEP_INTERMEDIATE_TENSORS",()=>!1,t=>{t&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")});/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * =============================================================================
 */var Js;(function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_QINT16=15]="DT_QINT16",t[t.DT_QUINT16=16]="DT_QUINT16",t[t.DT_UINT16=17]="DT_UINT16",t[t.DT_COMPLEX128=18]="DT_COMPLEX128",t[t.DT_HALF=19]="DT_HALF",t[t.DT_RESOURCE=20]="DT_RESOURCE",t[t.DT_VARIANT=21]="DT_VARIANT",t[t.DT_UINT32=22]="DT_UINT32",t[t.DT_UINT64=23]="DT_UINT64",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",t[t.DT_QINT16_REF=115]="DT_QINT16_REF",t[t.DT_QUINT16_REF=116]="DT_QUINT16_REF",t[t.DT_UINT16_REF=117]="DT_UINT16_REF",t[t.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",t[t.DT_HALF_REF=119]="DT_HALF_REF",t[t.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",t[t.DT_VARIANT_REF=121]="DT_VARIANT_REF",t[t.DT_UINT32_REF=122]="DT_UINT32_REF",t[t.DT_UINT64_REF=123]="DT_UINT64_REF"})(Js||(Js={}));var DL;(function(t){(function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"})(t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))})(DL||(DL={}));/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mwe={};function $V(t){return Mwe[t]}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function k(t,e,n,r,i){const s=e.inputParams[t];if(s&&s.inputIndexStart!==void 0){const a=s.inputIndexStart,l=s.inputIndexEnd===0?void 0:s.inputIndexEnd===void 0?a+1:s.inputIndexEnd;if(s.type==="tensor")return gi(e.inputNames[s.inputIndexStart],n,r,i);if(s.type==="tensors")return e.inputNames.slice(a,l).map(f=>gi(f,n,r,i));const c=gi(e.inputNames.slice(a)[0],n,r,i),u=c.dataSync();return s.type==="number"?u[0]:W2(c.shape,u)}const o=e.attrParams[t];return o&&o.value}function gi(t,e,n,r){const[i,s]=Xi(t);if(r!=null){const a=r.getHashTableHandleByName(i);if(a!=null)return a}const o=n.currentContextIds.find(a=>!!e[Z1(i,a)]);return o!==void 0?e[Z1(i,o)][s]:void 0}function Rwe(t,e,n){return e[Z1(t,n.currentContextId)]}function ga(t,e){const[n,r,i]=Xi(t);return[Z1(n,e&&e.currentContextId),r,i]}function Z1(t,e){return e?`${t}-${e}`:t}function Xi(t){const e=t.split(":");if(e.length===1)return[t,0,void 0];const n=e[0],r=e.length===3?e[1]:void 0,i=Number(e[e.length-1]);return[n,i,r]}function r1(t,e,n){let r=k("pad",t,e,n);if(r==="explicit"){r=k("explicitPaddings",t,e,n);const i=[[0,0],[0,0],[0,0],[0,0]];for(let s=0;s<4;s++)i[s][0]=r[s*2],i[s][1]=r[s*2+1];return i}return r}function Za(t){return t.kept?t:_c(t)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Iwe=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Nwe=Object.freeze(Object.defineProperty({__proto__:null,json:Iwe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Pwe=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],kwe=Object.freeze(Object.defineProperty({__proto__:null,json:Pwe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Dwe=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],Owe=Object.freeze(Object.defineProperty({__proto__:null,json:Dwe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Lwe=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],Bwe=Object.freeze(Object.defineProperty({__proto__:null,json:Lwe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Fwe=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],$we=Object.freeze(Object.defineProperty({__proto__:null,json:Fwe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Uwe=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],zwe=Object.freeze(Object.defineProperty({__proto__:null,json:Uwe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Gwe=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],Hwe=Object.freeze(Object.defineProperty({__proto__:null,json:Gwe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vwe=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],Wwe=Object.freeze(Object.defineProperty({__proto__:null,json:Vwe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const jwe=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],Xwe=Object.freeze(Object.defineProperty({__proto__:null,json:jwe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Kwe=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],qwe=Object.freeze(Object.defineProperty({__proto__:null,json:Kwe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Jwe=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],Ywe=Object.freeze(Object.defineProperty({__proto__:null,json:Jwe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Qwe=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],Zwe=Object.freeze(Object.defineProperty({__proto__:null,json:Qwe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eCe=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],tCe=Object.freeze(Object.defineProperty({__proto__:null,json:eCe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nCe=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],rCe=Object.freeze(Object.defineProperty({__proto__:null,json:nCe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iCe=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],sCe=Object.freeze(Object.defineProperty({__proto__:null,json:iCe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oCe=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],aCe=Object.freeze(Object.defineProperty({__proto__:null,json:oCe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lCe=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],cCe=Object.freeze(Object.defineProperty({__proto__:null,json:lCe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uCe=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],dCe=Object.freeze(Object.defineProperty({__proto__:null,json:uCe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fCe=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}],hCe=Object.freeze(Object.defineProperty({__proto__:null,json:fCe},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class OL{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[Nwe,kwe,Owe,Bwe,$we,zwe,Hwe,Wwe,Xwe,qwe,Ywe,Zwe,tCe,rCe,sCe,aCe,cCe,dCe,hCe],n=[].concat(...e.map(r=>r.json));this.opMappers=n.reduce((r,i)=>(r[i.tfOpName]=i,r),{})}transformGraph(e,n={}){const r=e.node,i=[],s=[],o=[],a=r.reduce((x,v)=>(x[v.name]=this.mapNode(v),v.op.startsWith("Placeholder")?i.push(x[v.name]):v.op==="Const"?s.push(x[v.name]):(v.input==null||v.input.length===0)&&o.push(x[v.name]),x),{});let l=[];const c=[];let u={},d={};n!=null&&(u=this.mapSignatureEntries(n.inputs),d=this.mapSignatureEntries(n.outputs));const f=Object.keys(a);f.forEach(x=>{const v=a[x];v.inputNames.forEach((y,b)=>{const[S,,w]=ga(y),E=a[S];if(E.outputs!=null){const A=E.outputs.indexOf(w);if(A!==-1){const T=`${S}:${A}`;v.inputNames[b]=T}}v.inputs.push(E),E.children.push(v)})}),Object.keys(d).length===0?f.forEach(x=>{const v=a[x];v.children.length===0&&c.push(v)}):Object.keys(d).forEach(x=>{const[v]=ga(x),y=a[v];y!=null&&(y.signatureKey=d[x],c.push(y))}),Object.keys(u).length>0?Object.keys(u).forEach(x=>{const[v]=ga(x),y=a[v];y&&(y.signatureKey=u[x],l.push(y))}):l=i;let h={};e.library!=null&&e.library.function!=null&&(h=e.library.function.reduce((x,v)=>(x[v.signature.name]=this.mapFunction(v),x),{}));const p={nodes:a,inputs:l,outputs:c,weights:s,placeholders:i,signature:n,functions:h};return o.length>0&&(p.initNodes=o),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce((n,r)=>(n[e[r].name]=r,n),{})}mapNode(e){const n=$V(e.op)||this.opMappers[e.op]||{};e.attr==null&&(e.attr={});const r={name:e.name,op:e.op,category:n.category,inputNames:(e.input||[]).map(i=>i.startsWith("^")?i.slice(1):i),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:n.outputs};return n.inputs!=null&&(r.inputParams=n.inputs.reduce((i,s)=>(i[s.name]={type:s.type,inputIndexStart:s.start,inputIndexEnd:s.end},i),{})),n.attrs!=null&&(r.attrParams=n.attrs.reduce((i,s)=>{const o=s.type;let a;switch(s.type){case"string":a=vT(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=vT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"string[]":a=ET(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=ET(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number":a=bT(e.attr,s.tfName,s.defaultValue||0),a===void 0&&s.tfDeprecatedName&&(a=bT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"number[]":a=CT(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=CT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool":a=xT(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=xT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"bool[]":a=TT(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=TT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape":a=wT(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=wT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"shape[]":a=AT(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=AT(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype":a=ST(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=ST(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"dtype[]":a=_T(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=_T(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"func":a=LL(e.attr,s.tfName,s.defaultValue),a===void 0&&s.tfDeprecatedName&&(a=LL(e.attr,s.tfDeprecatedName,s.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${s.type} for op: ${e.op}`)}return i[s.name]={value:a,type:o},i},{})),r}mapFunction(e){const n=e.nodeDef,r=[],i=[];let s={};n!=null&&(s=n.reduce((d,f)=>(d[f.name]=this.mapNode(f),f.op==="Const"&&i.push(d[f.name]),d),{}));const o=[],a=[];e.signature.inputArg.forEach(d=>{const[f]=ga(d.name),h={name:f,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:YI(d.type),type:"dtype"}},children:[]};h.signatureKey=d.name,o.push(h),s[f]=h}),Object.keys(s).forEach(d=>{const f=s[d];f.inputNames.forEach((h,p)=>{const[x,,v]=ga(h),y=s[x];if(y.outputs!=null){const b=y.outputs.indexOf(v);if(b!==-1){const S=`${x}:${b}`;f.inputNames[p]=S}}f.inputs.push(y),y.children.push(f)})});const c=e.ret;e.signature.outputArg.forEach(d=>{const[f,h]=ga(c[d.name]),p=s[f];p!=null&&(p.defaultOutput=h,a.push(p))});const u=this.mapArgsToSignature(e);return{nodes:s,inputs:o,outputs:a,weights:i,placeholders:r,signature:u}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r),n),{}),outputs:e.signature.outputArg.reduce((n,r)=>(n[r.name]=this.mapArgToTensorInfo(r,e.ret),n),{})}}mapArgToTensorInfo(e,n){let r=e.name;return n!=null&&(r=n[r]),{name:r,dtype:e.type}}}function pCe(t){const e=ge().global;if(typeof e.atob<"u")return e.atob(t);if(typeof Buffer<"u")return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}function UV(t,e){const n=Array.isArray(t)?String.fromCharCode.apply(null,t):pCe(t);return e?n:n.toLowerCase()}function vT(t,e,n,r=!1){const i=t[e];return i!=null?UV(i.s,r):n}function xT(t,e,n){const r=t[e];return r?r.b:n}function bT(t,e,n){const r=t[e]||{},i=r.i!=null?r.i:r.f!=null?r.f:n;return typeof i=="number"?i:parseInt(i,10)}function YI(t){switch(typeof t=="string"&&(t=Js[t]),t){case Js.DT_FLOAT:case Js.DT_HALF:return"float32";case Js.DT_INT32:case Js.DT_INT64:case Js.DT_INT8:case Js.DT_UINT8:return"int32";case Js.DT_BOOL:return"bool";case Js.DT_DOUBLE:return"float32";case Js.DT_STRING:return"string";default:return null}}function LL(t,e,n){const r=t[e];return r&&r.func?r.func.name:n}function ST(t,e,n){const r=t[e];return r&&r.type?YI(r.type):n}function _T(t,e,n){const r=t[e];return r&&r.list&&r.list.type?r.list.type.map(i=>YI(i)):n}function zV(t){if(!t.unknownRank)return t.dim!=null?t.dim.map(e=>typeof e.size=="number"?e.size:parseInt(e.size,10)):[]}function wT(t,e,n){const r=t[e];return r&&r.shape?zV(r.shape):n}function CT(t,e,n){const r=t[e];return r?((r.list.f&&r.list.f.length?r.list.f:r.list.i)||[]).map(i=>typeof i=="number"?i:parseInt(i,10)):n}function ET(t,e,n,r=!1){const i=t[e];return i&&i.list&&i.list.s?i.list.s.map(s=>UV(s,r)):n}function AT(t,e,n){const r=t[e];return r&&r.list&&r.list.shape?r.list.shape.map(i=>zV(i)):n}function TT(t,e,n){const r=t[e];return r&&r.list&&r.list.b?r.list.b:n}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class mCe{constructor(e,n,r){this.node=e,this.tensorMap=n,this.context=r,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map(i=>this.getInput(i)),e.rawAttrs!=null&&(this.attrs=Object.keys(e.rawAttrs).reduce((i,s)=>(i[s]=this.getAttr(s),i),{}))}getInput(e){return gi(e,this.tensorMap,this.context)}getAttr(e,n){const r=this.node.rawAttrs[e];if(r.tensor!=null)return gi(e,this.tensorMap,this.context);if(r.i!=null||r.f!=null)return bT(this.node.rawAttrs,e,n);if(r.s!=null)return vT(this.node.rawAttrs,e,n);if(r.b!=null)return xT(this.node.rawAttrs,e,n);if(r.shape!=null)return wT(this.node.rawAttrs,e,n);if(r.type!=null)return ST(this.node.rawAttrs,e,n);if(r.list!=null){if(r.list.i!=null||r.list.f!=null)return CT(this.node.rawAttrs,e,n);if(r.list.s!=null)return ET(this.node.rawAttrs,e,n);if(r.list.shape!=null)return AT(this.node.rawAttrs,e,n);if(r.list.b!=null)return TT(this.node.rawAttrs,e,n);if(r.list.type!=null)return _T(this.node.rawAttrs,e,n)}return n}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ti=Object.freeze(Object.defineProperty({__proto__:null,OP_SCOPE_SUFFIX:PG,abs:Zs,acos:j0e,acosh:K0e,add:cr,addN:J0e,all:Q0e,any:eye,argMax:nye,argMin:iye,asin:oye,asinh:lye,atan:uye,atan2:fye,atanh:pye,avgPool:yH,avgPool3d:_ye,basicLSTMCell:Mye,batchNorm:n_,batchNorm2d:kye,batchNorm3d:Oye,batchNorm4d:Bye,batchToSpaceND:vH,bincount:xH,booleanMaskAsync:lSe,broadcastArgs:Uye,broadcastTo:lg,buffer:Vn,cast:hr,ceil:Hye,clipByValue:Wye,clone:_c,complex:Nc,concat:pr,concat1d:Xye,concat2d:TI,concat3d:Jye,concat4d:Qye,conv1d:tve,conv2d:i_,conv2dTranspose:ive,conv3d:ove,conv3dTranspose:uve,cos:fve,cosh:pve,cosineWindow:WI,cumprod:gve,cumsum:vve,denseBincount:bve,depthToSpace:_ve,depthwiseConv2d:MI,diag:Eve,dilation2d:Tve,div:ar,divNoNan:Pve,dot:Dve,dropout:bSe,einsum:Lve,elu:_H,enclosingPowerOfTwo:JH,equal:SH,erf:$ve,euclideanNorm:Kve,exp:bd,expandDims:Qa,expm1:Qve,eye:EH,fft:HI,fill:r_,floor:AH,floorDiv:mH,fused:OSe,gather:TH,gatherND:ySe,greater:a_,greaterEqual:MH,ifft:Q1,imag:t_,image:Gu,inTopKAsync:_Se,irfft:WH,isFinite:oxe,isInf:lxe,isNaN:uxe,leakyRelu:RH,less:hxe,lessEqual:kI,linalg:uwe,linspace:mxe,localResponseNormalization:yxe,log:e0,log1p:IH,logSigmoid:_xe,logSoftmax:Exe,logSumExp:PH,logicalAnd:J1,logicalNot:kH,logicalOr:DH,logicalXor:Nxe,losses:dwe,lowerBound:kxe,matMul:yn,max:Ah,maxPool:OH,maxPool3d:Lxe,maxPoolWithArgmax:Fxe,maximum:Uxe,mean:Y1,meshgrid:Gxe,min:pT,minimum:LH,mirrorPad:Wxe,mod:Xxe,moments:qxe,movingAverage:uSe,mul:Et,multiRNNCell:Yxe,multinomial:Zxe,neg:ul,norm:o_,notEqual:BH,oneHot:E0e,ones:zu,onesLike:n1e,op:ee,outerProduct:i1e,pad:$0,pad1d:a1e,pad2d:c1e,pad3d:d1e,pad4d:h1e,pool:v1e,pow:PI,prelu:$H,print:VG,prod:S1e,raggedGather:w1e,raggedTensorToTensor:E1e,rand:T1e,randomGamma:V1e,randomNormal:zH,randomStandardNormal:X1e,randomUniform:GH,range:t0,real:Qg,reciprocal:J1e,relu:l_,relu6:HH,reshape:Pe,reverse:_d,reverse1d:tbe,reverse2d:rbe,reverse3d:sbe,reverse4d:abe,rfft:VI,round:VH,rsqrt:ube,scalar:fn,scatterND:fSe,searchSorted:DI,selu:fbe,separableConv2d:pbe,setdiff1dAsync:gbe,sigmoid:nd,sign:vbe,signal:cwe,sin:bbe,sinh:_be,slice:Rt,slice1d:Cbe,slice2d:Abe,slice3d:Mbe,slice4d:Ibe,softmax:Pbe,softplus:NH,spaceToBatchND:FH,sparse:fwe,sparseToDense:mSe,spectral:lwe,split:n0,sqrt:mT,square:s_,squaredDifference:jH,squeeze:Ra,stack:wl,step:XH,stridedSlice:Hbe,string:hwe,sub:zt,sum:Rn,tan:Wbe,tanh:hT,tensor:Ma,tensor1d:zr,tensor2d:dl,tensor3d:QG,tensor4d:jbe,tensor5d:Xbe,tensor6d:Kbe,tile:cg,topk:Jbe,transpose:uT,truncatedNormal:Qbe,unique:eSe,unsortedSegmentSum:nSe,unstack:$d,upperBound:iSe,variable:sSe,where:ep,whereAsync:qH,zeros:Sd,zerosLike:RI},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gCe=(t,e,n,r=ti)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[r.add(k("a",t,e,n),k("b",t,e,n))];case"AddN":return[r.addN(k("tensors",t,e,n))];case"FloorMod":case"Mod":return[r.mod(k("a",t,e,n),k("b",t,e,n))];case"Mul":return[r.mul(k("a",t,e,n),k("b",t,e,n))];case"RealDiv":case"Div":return[r.div(k("a",t,e,n),k("b",t,e,n))];case"DivNoNan":return[r.divNoNan(k("a",t,e,n),k("b",t,e,n))];case"FloorDiv":return[r.floorDiv(k("a",t,e,n),k("b",t,e,n))];case"Sub":return[r.sub(k("a",t,e,n),k("b",t,e,n))];case"Minimum":return[r.minimum(k("a",t,e,n),k("b",t,e,n))];case"Maximum":return[r.maximum(k("a",t,e,n),k("b",t,e,n))];case"Pow":return[r.pow(k("a",t,e,n),k("b",t,e,n))];case"SquaredDifference":return[r.squaredDifference(k("a",t,e,n),k("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yCe=(t,e,n,r=ti)=>{switch(t.op){case"Abs":case"ComplexAbs":return[r.abs(k("x",t,e,n))];case"Acos":return[r.acos(k("x",t,e,n))];case"Acosh":return[r.acosh(k("x",t,e,n))];case"Asin":return[r.asin(k("x",t,e,n))];case"Asinh":return[r.asinh(k("x",t,e,n))];case"Atan":return[r.atan(k("x",t,e,n))];case"Atan2":return[r.atan2(k("x",t,e,n),k("y",t,e,n))];case"Atanh":return[r.atanh(k("x",t,e,n))];case"Ceil":return[r.ceil(k("x",t,e,n))];case"Complex":return[r.complex(k("real",t,e,n),k("imag",t,e,n))];case"Cos":return[r.cos(k("x",t,e,n))];case"Cosh":return[r.cosh(k("x",t,e,n))];case"Elu":return[r.elu(k("x",t,e,n))];case"Erf":return[r.erf(k("x",t,e,n))];case"Exp":return[r.exp(k("x",t,e,n))];case"Expm1":return[r.expm1(k("x",t,e,n))];case"Floor":return[r.floor(k("x",t,e,n))];case"Log":return[r.log(k("x",t,e,n))];case"Log1p":return[r.log1p(k("x",t,e,n))];case"Imag":return[r.imag(k("x",t,e,n))];case"Neg":return[r.neg(k("x",t,e,n))];case"Reciprocal":return[r.reciprocal(k("x",t,e,n))];case"Real":return[r.real(k("x",t,e,n))];case"Relu":return[r.relu(k("x",t,e,n))];case"Round":return[r.round(k("x",t,e,n))];case"Selu":return[r.selu(k("x",t,e,n))];case"Sigmoid":return[r.sigmoid(k("x",t,e,n))];case"Sin":return[r.sin(k("x",t,e,n))];case"Sign":return[r.sign(k("x",t,e,n))];case"Sinh":return[r.sinh(k("x",t,e,n))];case"Softplus":return[r.softplus(k("x",t,e,n))];case"Sqrt":return[r.sqrt(k("x",t,e,n))];case"Square":return[r.square(k("x",t,e,n))];case"Tanh":return[r.tanh(k("x",t,e,n))];case"Tan":return[r.tan(k("x",t,e,n))];case"ClipByValue":return[r.clipByValue(k("x",t,e,n),k("clipValueMin",t,e,n),k("clipValueMax",t,e,n))];case"Relu6":return[r.relu6(k("x",t,e,n))];case"Rsqrt":return[r.rsqrt(gi(t.inputNames[0],e,n))];case"Prod":return[r.prod(k("x",t,e,n),k("axes",t,e,n))];case"LeakyRelu":return[r.leakyRelu(k("x",t,e,n),k("alpha",t,e,n))];case"Prelu":return[r.prelu(k("x",t,e,n),k("alpha",t,e,n))];case"IsNan":return[r.isNaN(gi(t.inputNames[0],e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function eo(t,e,n=""){if(!(typeof t=="number"||typeof e=="number")){Y(t.length===e.length,()=>n+` Shapes ${t} and ${e} must match`);for(let r=0;r<t.length;r++){const i=t[r],s=e[r];Y(i<0||s<0||i===s,()=>n+` Shapes ${t} and ${e} must match`)}}}function BL(t){return!(typeof t=="number"||t.some(e=>e<0))}function Im(t,e,n){let r=MT(t,n);const i=!BL(r);if(i&&e.length===0)throw new Error(`Tried to calculate elements of an empty list with non-fully-defined elementShape: ${r}`);if(i&&e.forEach(s=>{r=MT(s.shape,r)}),!BL(r))throw new Error(`Non-fully-defined elementShape: ${r}`);return r}function MT(t,e){if(typeof t=="number")return e;if(typeof e=="number")return t;if(t.length!==e.length)throw new Error(`Incompatible ranks during merge: ${t} vs. ${e}`);const n=[];for(let r=0;r<t.length;++r){const i=t[r],s=e[r];if(i>=0&&s>=0&&i!==s)throw new Error(`Incompatible shape during merge: ${t} vs. ${e}`);n[r]=i>=0?i:s}return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vCe{constructor(e,n,r,i,s,o,a){this.name=e,this.dtype=n,this.maxSize=r,this.elementShape=i,this.identicalElementShapes=s,this.dynamicSize=o,this.clearAfterRead=a,this.tensors=[],this.closed_=!1,this.idTensor=fn(0),uc(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.tensor.id))&&n.tensor.dispose()}),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||e>=this.size())throw new Error(`Tried to read from index ${e}, but array size is: ${this.size()}`);const n=this.tensors[e];if(n.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${e} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(n.cleared=!0),n.read=!0,n.tensor}readMany(e){return e.map(n=>this.read(n))}write(e,n){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error(`Tried to write to index ${e}, but array is not resizeable and size is: ${this.maxSize}`);const r=this.tensors[e]||{};if(n.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e},
          because the value dtype is ${n.dtype}, but TensorArray dtype is ${this.dtype}.`);if(this.size()===0&&(this.elementShape==null||this.elementShape.length===0)&&(this.elementShape=n.shape),eo(this.elementShape,n.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${e}.`),r.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been read.`);if(r.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${e}, because it has already been written.`);r.tensor=n,uc(n),r.written=!0,this.tensors[e]=r}writeMany(e,n){if(e.length!==n.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${e.length} is not the same as tensors size: ${n.length}.`);e.forEach((r,i)=>this.write(r,n[i]))}gather(e,n){if(n&&n!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${n}`);if(e)e=e.slice(0,this.size());else{e=[];for(let i=0;i<this.size();i++)e.push(i)}if(e.length===0)return Ma([],[0].concat(this.elementShape));const r=this.readMany(e);return eo(this.elementShape,r[0].shape,"TensorArray shape mismatch: "),wl(r,0)}concat(e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${e}`);if(this.size()===0)return Ma([],[0].concat(this.elementShape));const n=[];for(let i=0;i<this.size();i++)n.push(i);const r=this.readMany(n);return eo(this.elementShape,r[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${r[0].shape})`),pr(r,0)}scatter(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);if(e.length!==n.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${n.shape[0]}`);const r=Math.max(...e);if(!this.dynamicSize&&r>=this.maxSize)throw new Error(`Max index must be < array size (${r}  vs. ${this.maxSize})`);this.writeMany(e,$d(n,0))}split(e,n){if(n.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${n.dtype}`);let r=0;const i=e.map(l=>(r+=l,r));if(r!==n.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${n.shape}`);if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${e.length}), and the TensorArray is not marked as dynamically resizeable`);const s=r===0?0:n.size/r,o=[];qn(()=>{n=Pe(n,[1,r,s]);for(let l=0;l<e.length;++l){const u=[0,l===0?0:i[l-1],0],d=[1,e[l],s];o[l]=Pe(Rt(n,u,d),this.elementShape)}return o});const a=[];for(let l=0;l<e.length;l++)a[l]=l;this.writeMany(a,o)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cd{constructor(e,n,r,i=-1){this.tensors=e,this.elementShape=n,this.elementDtype=r,e!=null&&e.forEach(s=>{if(r!==s.dtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${s.dtype}`);eo(n,s.shape,"TensorList shape mismatch: "),uc(s)}),this.idTensor=fn(0),this.maxNumElements=i,uc(this.idTensor)}get id(){return this.idTensor.id}copy(){return new Cd([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach(n=>{(e==null||!e.has(n.id))&&n.dispose()}),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,n,r=-1){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(r!==-1&&this.tensors.length!==r)throw new Error(`Operation expected a list with ${r} elements but got a list with ${this.tensors.length} elements.`);eo(e,this.elementShape,"TensorList shape mismatch: ");const i=Im(this.elementShape,this.tensors,e);return qn(()=>{const s=this.tensors.map(o=>Pe(o,i));return wl(s,0)})}popBack(e,n){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);if(this.size()===0)throw new Error("Trying to pop from an empty list.");const r=Im(this.elementShape,this.tensors,e),i=this.tensors.pop();return i.kept=!1,eo(i.shape,e,"TensorList shape mismatch: "),Pe(i,r)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(eo(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");uc(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${e}`);if(this.maxNumElements!==-1&&e>this.maxNumElements)throw new Error(`TensorListResize input size ${e} is greater maxNumElement ${this.maxNumElements}.`);const n=new Cd([],this.elementShape,this.elementDtype,this.maxNumElements);n.tensors.length=e;for(let r=0;r<Math.min(this.tensors.length,e);++r)n.tensors[r]=this.tensors[r];return n}getItem(e,n,r){if(r!==this.elementDtype)throw new Error(`Invalid data types; op elements ${r}, but list elements ${this.elementDtype}`);if(e<0||e>this.tensors.length)throw new Error(`Trying to access element ${e} in a list with ${this.tensors.length} elements.`);if(this.tensors[e]==null)throw new Error(`element at index ${e} is null.`);eo(this.tensors[e].shape,n,"TensorList shape mismatch: ");const i=Im(this.elementShape,this.tensors,n);return Pe(this.tensors[e],i)}setItem(e,n){if(n.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n.dtype}, but list elements ${this.elementDtype}`);if(e<0||this.maxNumElements!==-1&&e>=this.maxNumElements)throw new Error(`Trying to set element ${e} in a list with max ${this.maxNumElements} elements.`);eo(this.elementShape,n.shape,"TensorList shape mismatch: "),uc(n),this.tensors[e]!=null&&(this.tensors[e].kept=!1),this.tensors[e]=n}gather(e,n,r){if(n!==this.elementDtype)throw new Error(`Invalid data types; op elements ${n}, but list elements ${this.elementDtype}`);eo(this.elementShape,r,"TensorList shape mismatch: "),e=e.slice(0,this.size());const i=Im(this.elementShape,this.tensors,r);return e.length===0?Ma([],[0].concat(i)):qn(()=>{const s=e.map(o=>Pe(this.tensors[o],i));return wl(s,0)})}concat(e,n){if(e&&e!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${e}`);eo(this.elementShape,n,"TensorList shape mismatch: ");const r=Im(this.elementShape,this.tensors,n);return this.size()===0?Ma([],[0].concat(r)):qn(()=>{const i=this.tensors.map(s=>Pe(s,r));return pr(i,0)})}}function xCe(t,e,n){const r=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==n)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${n}`);const i=t.shape.slice(1);eo(i,e,"TensorList shape mismatch: ");const s=$d(t);return new Cd(s,e,r)}function bCe(t,e,n,r){return new Cd([],t,e,r)}function SCe(t,e,n,r){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const i=Math.max(...e);if(r!=null&&r!==-1&&i>=r)throw new Error(`Max index must be < array size (${i}  vs. ${r})`);const s=new Cd([],n,t.dtype,r),o=$d(t,0);return e.forEach((a,l)=>{s.setItem(a,o[l])}),s}function _Ce(t,e,n){let r=0;const i=e.map(u=>(r+=u,r));if(r!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to
          tensor.shape[0], but sum of lengths is
        ${r}, and tensor's shape is: ${t.shape}`);const s=t.shape.slice(1),o=MT(s,n),a=r===0?0:t.size/r,l=qn(()=>{const u=[];t=Pe(t,[1,r,a]);for(let d=0;d<e.length;++d){const h=[0,d===0?0:i[d-1],0],p=[1,e[d],a];u[d]=Pe(Rt(t,h,p),o)}return t.dispose(),u}),c=new Cd([],n,t.dtype,e.length);for(let u=0;u<l.length;u++)c.setItem(u,l[u]);return c}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wCe=async(t,e,n)=>{switch(t.op){case"If":case"StatelessIf":{const r=k("thenBranch",t,e,n),i=k("elseBranch",t,e,n),s=k("cond",t,e,n),o=k("args",t,e,n);return(await s.data())[0]?n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[i].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const r=k("body",t,e,n),i=k("cond",t,e,n),s=k("args",t,e,n),o=await n.functionMap[i].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),a=s.map(u=>u.id);let l=await o[0].data();o.forEach(u=>{!u.kept&&a.indexOf(u.id)===-1&&u.dispose()});let c=s;for(;l[0];){const u=c;c=await n.functionMap[r].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);const d=c.map(h=>h.id);u.forEach(h=>{!h.kept&&a.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()});const f=await n.functionMap[i].executeFunctionAsync(c,n.tensorArrayMap,n.tensorListMap);l=await f[0].data(),f.forEach(h=>{!h.kept&&a.indexOf(h.id)===-1&&d.indexOf(h.id)===-1&&h.dispose()})}return c}case"LoopCond":{const r=k("pred",t,e,n);return[Za(r)]}case"Switch":{const r=k("pred",t,e,n);let i=k("data",t,e,n);return i.kept||(i=Za(i)),(await r.data())[0]?[void 0,i]:[i,void 0]}case"Merge":{const r=t.inputNames.find(i=>gi(i,e,n)!==void 0);if(r){const i=gi(r,e,n);return[Za(i)]}return}case"Enter":{const r=k("frameName",t,e,n),i=k("tensor",t,e,n);return n.enterFrame(r),[Za(i)]}case"Exit":{const r=k("tensor",t,e,n);return n.exitFrame(),[Za(r)]}case"NextIteration":{const r=k("tensor",t,e,n);return n.nextIteration(),[Za(r)]}case"TensorArrayV3":{const r=k("size",t,e,n),i=k("dtype",t,e,n),s=k("elementShape",t,e,n),o=k("dynamicSize",t,e,n),a=k("clearAfterRead",t,e,n),l=k("identicalElementShapes",t,e,n),c=k("name",t,e,n),u=new vCe(c,i,r,s,l,o,a);return n.addTensorArray(u),[u.idTensor,fn(1)]}case"TensorArrayWriteV3":{const r=k("tensorArrayId",t,e,n),i=k("index",t,e,n),s=k("tensor",t,e,n),o=n.getTensorArray(r.id);return o.write(i,s),[o.idTensor]}case"TensorArrayReadV3":{const r=k("tensorArrayId",t,e,n),i=k("index",t,e,n);return[n.getTensorArray(r.id).read(i)]}case"TensorArrayGatherV3":{const r=k("tensorArrayId",t,e,n),i=k("indices",t,e,n),s=k("dtype",t,e,n);return[n.getTensorArray(r.id).gather(i,s)]}case"TensorArrayScatterV3":{const r=k("tensorArrayId",t,e,n),i=k("indices",t,e,n),s=k("tensor",t,e,n),o=n.getTensorArray(r.id);return o.scatter(i,s),[o.idTensor]}case"TensorArrayConcatV3":{const r=k("tensorArrayId",t,e,n),i=n.getTensorArray(r.id),s=k("dtype",t,e,n);return[i.concat(s)]}case"TensorArraySplitV3":{const r=k("tensorArrayId",t,e,n),i=k("tensor",t,e,n),s=k("lengths",t,e,n),o=n.getTensorArray(r.id);return o.split(s,i),[o.idTensor]}case"TensorArraySizeV3":{const r=k("tensorArrayId",t,e,n),i=n.getTensorArray(r.id);return[fn(i.size(),"int32")]}case"TensorArrayCloseV3":{const r=k("tensorArrayId",t,e,n),i=n.getTensorArray(r.id);return i.clearAndClose(),[i.idTensor]}case"TensorListSetItem":{const r=k("tensorListId",t,e,n),i=k("index",t,e,n),s=k("tensor",t,e,n),o=n.getTensorList(r.id);return o.setItem(i,s),[o.idTensor]}case"TensorListGetItem":{const r=k("tensorListId",t,e,n),i=k("index",t,e,n),s=k("elementShape",t,e,n),o=k("elementDType",t,e,n);return[n.getTensorList(r.id).getItem(i,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const r=k("indices",t,e,n),i=k("tensor",t,e,n),s=k("elementShape",t,e,n),o=k("numElements",t,e,n),a=SCe(i,r,s,o);return n.addTensorList(a),[a.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const r=k("elementShape",t,e,n),i=k("elementDType",t,e,n);let s;t.op==="TensorListReserve"?s="numElements":s="maxNumElements";const o=k(s,t,e,n),a=t.op==="TensorListReserve"?-1:o,l=bCe(r,i,o,a);return n.addTensorList(l),[l.idTensor]}case"TensorListGather":{const r=k("tensorListId",t,e,n),i=k("indices",t,e,n),s=k("elementShape",t,e,n),o=k("elementDType",t,e,n);return[n.getTensorList(r.id).gather(i,o,s)]}case"TensorListStack":{const r=k("tensorListId",t,e,n),i=k("elementShape",t,e,n),s=k("elementDType",t,e,n),o=k("numElements",t,e,n);return[n.getTensorList(r.id).stack(i,s,o)]}case"TensorListFromTensor":{const r=k("tensor",t,e,n),i=k("elementShape",t,e,n),s=k("elementDType",t,e,n),o=xCe(r,i,s);return n.addTensorList(o),[o.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const r=k("tensorListId",t,e,n),i=n.getTensorList(r.id),s=k("dtype",t,e,n),o=k("elementShape",t,e,n);return[i.concat(s,o)]}case"TensorListPushBack":{const r=k("tensorListId",t,e,n),i=k("tensor",t,e,n),s=n.getTensorList(r.id);return s.pushBack(i),[s.idTensor]}case"TensorListPopBack":{const r=k("tensorListId",t,e,n),i=k("elementShape",t,e,n),s=k("elementDType",t,e,n);return[n.getTensorList(r.id).popBack(i,s)]}case"TensorListSplit":{const r=k("tensor",t,e,n),i=k("elementShape",t,e,n),s=k("lengths",t,e,n),o=_Ce(r,s,i);return n.addTensorList(o),[o.idTensor]}case"TensorListLength":{const r=k("tensorListId",t,e,n),i=n.getTensorList(r.id);return[fn(i.size(),"int32")]}case"TensorListResize":{const r=k("tensorListId",t,e,n),i=k("size",t,e,n),o=n.getTensorList(r.id).resize(i);return n.addTensorList(o),[o.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function FL(t,e,n){const[r,i]=k("fusedOps",t,e,n),s=r==="biasadd",o=!s,a=i==="prelu",l=r==="fusedbatchnorm",c=k("numArgs",t,e,n);if(s){if(a&&c!==2)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&s&&c!==1)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(l)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=k("strides",t,e,n),d=r1(t,e,n),f=k("dataFormat",t,e,n).toUpperCase(),h=k("dilations",t,e,n);let[p,x]=k("args",t,e,n);o&&(x=p,p=void 0);const v=k("leakyreluAlpha",t,e,n);return{stride:u,pad:d,dataFormat:f,dilations:h,biasArg:p,preluArg:x,activationFunc:i,leakyreluAlpha:v}}const CCe=(t,e,n,r=ti)=>{switch(t.op){case"Conv1D":{const i=k("stride",t,e,n),s=k("pad",t,e,n),o=k("dataFormat",t,e,n).toUpperCase(),a=k("dilation",t,e,n);return[r.conv1d(k("x",t,e,n),k("filter",t,e,n),i,s,o,a)]}case"Conv2D":{const i=k("strides",t,e,n),s=r1(t,e,n),o=k("dataFormat",t,e,n).toUpperCase(),a=k("dilations",t,e,n);return[r.conv2d(k("x",t,e,n),k("filter",t,e,n),[i[1],i[2]],s,o,[a[1],a[2]])]}case"_FusedConv2D":{const{stride:i,pad:s,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:d}=FL(t,e,n);return[r.fused.conv2d({x:k("x",t,e,n),filter:k("filter",t,e,n),strides:[i[1],i[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:d})]}case"FusedDepthwiseConv2dNative":{const{stride:i,pad:s,dataFormat:o,dilations:a,biasArg:l,preluArg:c,activationFunc:u,leakyreluAlpha:d}=FL(t,e,n);return[r.fused.depthwiseConv2d({x:k("x",t,e,n),filter:k("filter",t,e,n),strides:[i[1],i[2]],pad:s,dataFormat:o,dilations:[a[1],a[2]],bias:l,activation:u,preluActivationWeights:c,leakyreluAlpha:d})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const i=k("outputShape",t,e,n),s=k("strides",t,e,n),o=r1(t,e,n);return[r.conv2dTranspose(k("x",t,e,n),k("filter",t,e,n),i,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const i=k("strides",t,e,n),s=r1(t,e,n),o=k("dilations",t,e,n),a=k("dataFormat",t,e,n).toUpperCase();return[r.depthwiseConv2d(k("input",t,e,n),k("filter",t,e,n),[i[1],i[2]],s,a,[o[1],o[2]])]}case"Conv3D":{const i=k("strides",t,e,n),s=k("pad",t,e,n),o=k("dataFormat",t,e,n).toUpperCase(),a=k("dilations",t,e,n);return[r.conv3d(k("x",t,e,n),k("filter",t,e,n),[i[1],i[2],i[3]],s,o,[a[1],a[2],a[3]])]}case"AvgPool":{const i=k("strides",t,e,n),s=k("pad",t,e,n),o=k("kernelSize",t,e,n);return[r.avgPool(k("x",t,e,n),[o[1],o[2]],[i[1],i[2]],s)]}case"MaxPool":{const i=k("strides",t,e,n),s=k("pad",t,e,n),o=k("kernelSize",t,e,n);return[r.maxPool(k("x",t,e,n),[o[1],o[2]],[i[1],i[2]],s)]}case"MaxPoolWithArgmax":{const i=k("strides",t,e,n),s=k("pad",t,e,n),o=k("kernelSize",t,e,n),a=k("includeBatchInIndex",t,e,n),{result:l,indexes:c}=r.maxPoolWithArgmax(k("x",t,e,n),[o[1],o[2]],[i[1],i[2]],s,a);return[l,c]}case"AvgPool3D":{const i=k("strides",t,e,n),s=k("pad",t,e,n),o=k("kernelSize",t,e,n);return[r.avgPool3d(k("x",t,e,n),[o[1],o[2],o[3]],[i[1],i[2],i[3]],s)]}case"MaxPool3D":{const i=k("strides",t,e,n),s=k("pad",t,e,n),o=k("kernelSize",t,e,n);return[r.maxPool3d(k("x",t,e,n),[o[1],o[2],o[3]],[i[1],i[2],i[3]],s)]}case"Dilation2D":{const i=k("strides",t,e,n),s=k("pad",t,e,n),o=k("dilations",t,e,n),a=i[1],l=i[2],c=o[1],u=o[2];return[r.dilation2d(k("x",t,e,n),k("filter",t,e,n),[a,l],s,[c,u],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ECe=(t,e,n,r=ti)=>{switch(t.op){case"Fill":{const i=k("shape",t,e,n),s=k("dtype",t,e,n),o=k("value",t,e,n);return[r.fill(i,o,s)]}case"LinSpace":{const i=k("start",t,e,n),s=k("stop",t,e,n),o=k("num",t,e,n);return[r.linspace(i,s,o)]}case"Multinomial":{const i=k("logits",t,e,n),s=k("numSamples",t,e,n),o=k("seed",t,e,n);return[r.multinomial(i,s,o)]}case"OneHot":{const i=k("indices",t,e,n),s=k("depth",t,e,n),o=k("onValue",t,e,n),a=k("offValue",t,e,n),l=k("dtype",t,e,n);return[r.oneHot(i,s,o,a,l)]}case"Ones":return[r.ones(k("shape",t,e,n),k("dtype",t,e,n))];case"OnesLike":return[r.onesLike(k("x",t,e,n))];case"RandomStandardNormal":return[r.randomStandardNormal(k("shape",t,e,n),k("dtype",t,e,n),k("seed",t,e,n))];case"RandomUniform":return[r.randomUniform(k("shape",t,e,n),k("minval",t,e,n),k("maxval",t,e,n),k("dtype",t,e,n))];case"Range":{const i=k("start",t,e,n),s=k("stop",t,e,n),o=k("step",t,e,n);return[r.range(i,s,o,k("dtype",t,e,n))]}case"TruncatedNormal":{const i=k("shape",t,e,n),s=k("mean",t,e,n),o=k("stdDev",t,e,n),a=k("seed",t,e,n);return[r.truncatedNormal(i,s,o,k("dtype",t,e,n),a)]}case"Zeros":return[r.zeros(k("shape",t,e,n),k("dtype",t,e,n))];case"ZerosLike":return[r.zerosLike(k("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gE(t,e,n){const r=k("boxes",t,e,n),i=k("scores",t,e,n),s=k("maxOutputSize",t,e,n),o=k("iouThreshold",t,e,n),a=k("scoreThreshold",t,e,n),l=k("softNmsSigma",t,e,n);return{boxes:r,scores:i,maxOutputSize:s,iouThreshold:o,scoreThreshold:a,softNmsSigma:l}}const ACe=async(t,e,n,r,i=ti)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:s,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c,softNmsSigma:u}=gE(t,e,n),d=await i.image.nonMaxSuppressionWithScoreAsync(s,o,a,l,c,u);return[d.selectedIndices,d.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:s,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=gE(t,e,n),u=k("padToMaxOutputSize",t,e,n),d=await i.image.nonMaxSuppressionPaddedAsync(s,o,a,l,c,u);return[d.selectedIndices,d.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:s,scores:o,maxOutputSize:a,iouThreshold:l,scoreThreshold:c}=gE(t,e,n);return[await i.image.nonMaxSuppressionAsync(s,o,a,l,c)]}case"Where":{const s=i.cast(k("condition",t,e,n),"bool"),o=[await i.whereAsync(s)];return s.dispose(),o}case"ListDiff":return i.setdiff1dAsync(k("x",t,e,n),k("y",t,e,n));default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TCe=(t,e,n,r=ti)=>{switch(t.op){case"LowerBound":{const i=k("sortedSequence",t,e,n),s=k("values",t,e,n);return[r.lowerBound(i,s)]}case"TopKV2":{const i=k("x",t,e,n),s=k("k",t,e,n),o=k("sorted",t,e,n),a=r.topk(i,s,o);return[a.values,a.indices]}case"UpperBound":{const i=k("sortedSequence",t,e,n),s=k("values",t,e,n);return[r.upperBound(i,s)]}case"Unique":{const i=k("x",t,e,n),s=r.unique(i);return[s.values,s.indices]}case"UniqueV2":{const i=k("x",t,e,n),s=k("axis",t,e,n),o=r.unique(i,s);return[o.values,o.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MCe=(t,e,n,r=ti)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const i=k("default",t,e,n);return[gi(t.name,e,n)||i];case"Placeholder":return[gi(t.name,e,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":{const u=k("x",t,e,n);return[Za(u)]}case"IdentityN":return k("x",t,e,n).map(u=>Za(u));case"Snapshot":const s=k("x",t,e,n);return[Za(s)];case"Shape":return[r.tensor1d(k("x",t,e,n).shape,"int32")];case"ShapeN":return k("x",t,e,n).map(u=>r.tensor1d(u.shape));case"Size":return[r.scalar(k("x",t,e,n).size,"int32")];case"Rank":return[r.scalar(k("x",t,e,n).rank,"int32")];case"NoOp":return[r.scalar(1)];case"Print":const o=k("x",t,e,n),a=k("data",t,e,n),l=k("message",t,e,n),c=k("summarize",t,e,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(l);for(let u=0;u<a.length;u++)console.log(Array.prototype.slice.call(a[u].dataSync()).slice(0,c));return[o];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class RCe{constructor(e,n){this.keyDType=e,this.valueDType=n,this.handle=fn(0),this.tensorMap=new Map,uc(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach(e=>e.dispose()),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return fn(this.size(),"int32")}async import(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return this.tensorMap.forEach(i=>i.dispose()),this.tensorMap.clear(),qn(()=>{const i=$d(n),s=r.length,o=i.length;Y(s===o,()=>`The number of elements doesn't match, keys has ${s} elements, the values has ${o} elements.`);for(let a=0;a<s;a++){const l=r[a],c=i[a];uc(c),this.tensorMap.set(l,c)}return this.handle})}async find(e,n){this.checkKeyAndValueTensor(e,n);const r=await e.data();return qn(()=>{const i=[];for(let s=0;s<r.length;s++){const o=r[s],a=this.findWithDefault(o,n);i.push(a)}return wl(i)})}findWithDefault(e,n){const r=this.tensorMap.get(e);return r??n}checkKeyAndValueTensor(e,n){if(e.dtype!==this.keyDType)throw new Error(`Expect key dtype ${this.keyDType}, but got ${e.dtype}`);if(n.dtype!==this.valueDType)throw new Error(`Expect value dtype ${this.valueDType}, but got ${n.dtype}`)}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ICe=async(t,e,n,r)=>{switch(t.op){case"HashTable":case"HashTableV2":{const i=k("keyDType",t,e,n),s=k("valueDType",t,e,n),o=new RCe(i,s);return r.addHashTable(t.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const i=k("tableHandle",t,e,n,r),s=k("keys",t,e,n),o=k("values",t,e,n);return[await r.getHashTableById(i.id).import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const i=k("tableHandle",t,e,n,r),s=k("keys",t,e,n),o=k("defaultValue",t,e,n);return[await r.getHashTableById(i.id).find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const i=k("tableHandle",t,e,n,r);return[r.getHashTableById(i.id).tensorSize()]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const NCe=(t,e,n,r=ti)=>{switch(t.op){case"ResizeBilinear":{const i=k("images",t,e,n),s=k("size",t,e,n),o=k("alignCorners",t,e,n),a=k("halfPixelCenters",t,e,n);return[r.image.resizeBilinear(i,[s[0],s[1]],o,a)]}case"ResizeNearestNeighbor":{const i=k("images",t,e,n),s=k("size",t,e,n),o=k("alignCorners",t,e,n),a=k("halfPixelCenters",t,e,n);return[r.image.resizeNearestNeighbor(i,[s[0],s[1]],o,a)]}case"CropAndResize":{const i=k("image",t,e,n),s=k("boxes",t,e,n),o=k("boxInd",t,e,n),a=k("cropSize",t,e,n),l=k("method",t,e,n),c=k("extrapolationValue",t,e,n);return[r.image.cropAndResize(i,s,o,a,l,c)]}case"ImageProjectiveTransformV3":{const i=k("images",t,e,n),s=k("transforms",t,e,n),o=k("outputShape",t,e,n),a=k("fillValue",t,e,n),l=k("interpolation",t,e,n),c=k("fillMode",t,e,n);return[r.image.transform(i,s,l.toLowerCase(),c.toLowerCase(),a,o)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const PCe=(t,e,n,r=ti)=>{switch(t.op){case"Equal":return[r.equal(k("a",t,e,n),k("b",t,e,n))];case"NotEqual":return[r.notEqual(k("a",t,e,n),k("b",t,e,n))];case"Greater":return[r.greater(k("a",t,e,n),k("b",t,e,n))];case"GreaterEqual":return[r.greaterEqual(k("a",t,e,n),k("b",t,e,n))];case"Less":return[r.less(k("a",t,e,n),k("b",t,e,n))];case"LessEqual":return[r.lessEqual(k("a",t,e,n),k("b",t,e,n))];case"LogicalAnd":return[r.logicalAnd(k("a",t,e,n),k("b",t,e,n))];case"LogicalNot":return[r.logicalNot(k("a",t,e,n))];case"LogicalOr":return[r.logicalOr(k("a",t,e,n),k("b",t,e,n))];case"Select":case"SelectV2":return[r.where(k("condition",t,e,n),k("a",t,e,n),k("b",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kCe=(t,e,n,r=ti)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[r.matMul(k("a",t,e,n),k("b",t,e,n),k("transposeA",t,e,n),k("transposeB",t,e,n))];case"Einsum":return[r.einsum(k("equation",t,e,n),...k("tensors",t,e,n))];case"Transpose":return[r.transpose(k("x",t,e,n),k("perm",t,e,n))];case"_FusedMatMul":const[i,s]=k("fusedOps",t,e,n),o=i==="biasadd",a=s==="prelu",l=k("numArgs",t,e,n),c=k("leakyreluAlpha",t,e,n);if(o){if(a&&l!==2)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!a&&l!==1)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,d]=k("args",t,e,n);return[r.fused.matMul({a:k("a",t,e,n),b:k("b",t,e,n),transposeA:k("transposeA",t,e,n),transposeB:k("transposeB",t,e,n),bias:u,activation:s,preluActivationWeights:d,leakyreluAlpha:c})];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DCe=(t,e,n,r=ti)=>{switch(t.op){case"EuclideanNorm":return[r.euclideanNorm(k("x",t,e,n),k("axis",t,e,n),k("keepDims",t,e,n))];case"FusedBatchNorm":case"FusedBatchNormV2":return[r.batchNorm(k("x",t,e,n),k("mean",t,e,n),k("variance",t,e,n),k("offset",t,e,n),k("scale",t,e,n),k("epsilon",t,e,n))];case"FusedBatchNormV3":return[r.batchNorm(k("x",t,e,n),k("mean",t,e,n),k("variance",t,e,n),k("offset",t,e,n),k("scale",t,e,n),k("epsilon",t,e,n))];case"LRN":return[r.localResponseNormalization(k("x",t,e,n),k("radius",t,e,n),k("bias",t,e,n),k("alpha",t,e,n),k("beta",t,e,n))];case"Softmax":return[r.softmax(k("x",t,e,n))];case"LogSoftmax":return[r.logSoftmax(k("x",t,e,n))];case"SparseToDense":return[r.sparseToDense(k("sparseIndices",t,e,n),k("outputShape",t,e,n),k("sparseValues",t,e,n),k("defaultValue",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const OCe=(t,e,n,r=ti)=>{switch(t.op){case"Max":{const a=k("axis",t,e,n),l=k("keepDims",t,e,n);return[r.max(k("x",t,e,n),a,l)]}case"Mean":{const a=k("axis",t,e,n),l=k("keepDims",t,e,n);return[r.mean(k("x",t,e,n),a,l)]}case"Min":{const a=k("axis",t,e,n),l=k("keepDims",t,e,n);return[r.min(k("x",t,e,n),a,l)]}case"Sum":{const a=k("axis",t,e,n),l=k("keepDims",t,e,n);return[r.sum(k("x",t,e,n),a,l)]}case"All":{const a=k("axis",t,e,n),l=k("keepDims",t,e,n);return[r.all(k("x",t,e,n),a,l)]}case"Any":{const a=k("axis",t,e,n),l=k("keepDims",t,e,n);return[r.any(k("x",t,e,n),a,l)]}case"ArgMax":{const a=k("axis",t,e,n);return[r.argMax(k("x",t,e,n),a)]}case"ArgMin":{const a=k("axis",t,e,n);return[r.argMin(k("x",t,e,n),a)]}case"Prod":{const a=k("axis",t,e,n),l=k("keepDims",t,e,n);return[r.prod(k("x",t,e,n),a,l)]}case"Cumprod":{const a=k("axis",t,e,n),l=k("exclusive",t,e,n),c=k("reverse",t,e,n);return[r.cumprod(k("x",t,e,n),a,l,c)]}case"Cumsum":{const a=k("axis",t,e,n),l=k("exclusive",t,e,n),c=k("reverse",t,e,n);return[r.cumsum(k("x",t,e,n),a,l,c)]}case"Bincount":const i=k("x",t,e,n),s=k("weights",t,e,n),o=k("size",t,e,n);return[r.bincount(i,s,o)];case"DenseBincount":{const a=k("x",t,e,n),l=k("weights",t,e,n),c=k("size",t,e,n),u=k("binaryOutput",t,e,n);return[r.denseBincount(a,l,c,u)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const LCe=(t,e,n,r=ti)=>{switch(t.op){case"ConcatV2":case"Concat":{const i=k("n",t,e,n),s=k("axis",t,e,n);let o=k("tensors",t,e,n);return o=o.slice(0,i),[r.concat(o,s)]}case"Gather":{const i=k("x",t,e,n),s=k("indices",t,e,n);return[r.gather(i,r.cast(s,"int32"),0)]}case"GatherV2":{const i=k("axis",t,e,n),s=k("batchDims",t,e,n),o=k("x",t,e,n),a=k("indices",t,e,n);return[r.gather(o,r.cast(a,"int32"),i,s)]}case"Reverse":{const i=k("dims",t,e,n),s=[];for(let a=0;a<i.length;a++)i[a]&&s.push(a);const o=k("x",t,e,n);return[r.reverse(o,s)]}case"ReverseV2":{const i=k("axis",t,e,n),s=k("x",t,e,n);return[r.reverse(s,i)]}case"Slice":{const i=k("begin",t,e,n),s=k("size",t,e,n);return[r.slice(k("x",t,e,n),i,s)]}case"StridedSlice":{const i=k("begin",t,e,n),s=k("end",t,e,n),o=k("strides",t,e,n),a=k("beginMask",t,e,n),l=k("endMask",t,e,n),c=k("ellipsisMask",t,e,n),u=k("newAxisMask",t,e,n),d=k("shrinkAxisMask",t,e,n),f=k("x",t,e,n);return[r.stridedSlice(f,i,s,o,a,l,c,u,d)]}case"Pack":return qn(()=>{const i=k("axis",t,e,n),s=k("tensors",t,e,n),o=s[0].shape,a=r.squeeze(s[0]).shape,l=s.map(c=>{const u=Yn(c.shape,o);if(!u&&!Yn(r.squeeze(c).shape,a))throw new Error("the input tensors shape does not match");return u?c:r.reshape(c,o)});return[r.stack(l,i)]});case"Unpack":{const i=k("axis",t,e,n),s=k("tensor",t,e,n);return r.unstack(s,i)}case"Tile":{const i=k("reps",t,e,n);return[r.tile(k("x",t,e,n),i)]}case"Split":case"SplitV":{const i=k("axis",t,e,n),s=k("numOrSizeSplits",t,e,n),o=k("x",t,e,n);return r.split(o,s,i)}case"ScatterNd":{const i=k("indices",t,e,n),s=k("values",t,e,n),o=k("shape",t,e,n);return[r.scatterND(i,s,o)]}case"GatherNd":{const i=k("x",t,e,n),s=k("indices",t,e,n);return[r.gatherND(i,s)]}case"SparseToDense":{const i=k("sparseIndices",t,e,n),s=k("outputShape",t,e,n),o=k("sparseValues",t,e,n),a=k("defaultValue",t,e,n);return[r.sparseToDense(i,o,s,o.dtype===a.dtype?a:r.cast(a,o.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BCe=(t,e,n,r=ti)=>{switch(t.op){case"SparseFillEmptyRows":{const{outputIndices:i,outputValues:s,emptyRowIndicator:o,reverseIndexMap:a}=r.sparse.sparseFillEmptyRows(k("indices",t,e,n),k("values",t,e,n),k("denseShape",t,e,n),k("defaultValue",t,e,n));return[i,s,o,a]}case"SparseReshape":{const{outputIndices:i,outputShape:s}=r.sparse.sparseReshape(k("inputIndices",t,e,n),k("inputShape",t,e,n),k("newShape",t,e,n));return[i,s]}case"SparseSegmentMean":return[r.sparse.sparseSegmentMean(k("data",t,e,n),k("indices",t,e,n),k("segmentIds",t,e,n))];case"SparseSegmentSum":return[r.sparse.sparseSegmentSum(k("data",t,e,n),k("indices",t,e,n),k("segmentIds",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const FCe=(t,e,n,r=ti)=>{switch(t.op){case"FFT":return[r.fft(k("x",t,e,n))];case"IFFT":return[r.ifft(k("x",t,e,n))];case"RFFT":return[r.rfft(k("x",t,e,n))];case"IRFFT":return[r.irfft(k("x",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $Ce=(t,e,n,r=ti)=>{switch(t.op){case"StringNGrams":{const{nGrams:i,nGramsSplits:s}=r.string.stringNGrams(k("data",t,e,n),k("dataSplits",t,e,n),k("separator",t,e,n),k("nGramWidths",t,e,n),k("leftPad",t,e,n),k("rightPad",t,e,n),k("padWidth",t,e,n),k("preserveShortSequences",t,e,n));return[i,s]}case"StringSplit":{const{indices:i,values:s,shape:o}=r.string.stringSplit(k("input",t,e,n),k("delimiter",t,e,n),k("skipEmpty",t,e,n));return[i,s,o]}case"StringToHashBucketFast":return[r.string.stringToHashBucketFast(k("input",t,e,n),k("numBuckets",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UCe=(t,e,n,r=ti)=>{switch(t.op){case"Cast":return[r.cast(k("x",t,e,n),k("dtype",t,e,n))];case"ExpandDims":{const i=k("axis",t,e,n);return[r.expandDims(k("x",t,e,n),i)]}case"Squeeze":{const i=k("axis",t,e,n);return[r.squeeze(k("x",t,e,n),i)]}case"Reshape":return[r.reshape(k("x",t,e,n),k("shape",t,e,n))];case"MirrorPad":return[r.mirrorPad(k("x",t,e,n),k("padding",t,e,n),k("mode",t,e,n))];case"PadV2":case"Pad":return[r.pad(k("x",t,e,n),k("padding",t,e,n),k("constantValue",t,e,n))];case"SpaceToBatchND":{const i=k("blockShape",t,e,n),s=k("paddings",t,e,n);return[r.spaceToBatchND(k("x",t,e,n),i,s)]}case"BatchToSpaceND":{const i=k("blockShape",t,e,n),s=k("crops",t,e,n);return[r.batchToSpaceND(k("x",t,e,n),i,s)]}case"DepthToSpace":{const i=k("blockSize",t,e,n),s=k("dataFormat",t,e,n).toUpperCase();return[r.depthToSpace(k("x",t,e,n),i,s)]}case"BroadcastTo":return[r.broadcastTo(k("x",t,e,n),k("shape",t,e,n))];case"BroadcastArgs":return[r.broadcastArgs(k("s0",t,e,n),k("s1",t,e,n))];default:throw TypeError(`Node type ${t.op} is not implemented`)}};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $L(t,e,n,r,i=qn){const s=((o,a,l)=>{switch(o.category){case"arithmetic":return i(()=>gCe(o,a,l));case"basic_math":return i(()=>yCe(o,a,l));case"control":return wCe(o,a,l);case"convolution":return i(()=>CCe(o,a,l));case"creation":return i(()=>ECe(o,a,l));case"dynamic":return ACe(o,a,l);case"evaluation":return i(()=>TCe(o,a,l));case"image":return i(()=>NCe(o,a,l));case"graph":return i(()=>MCe(o,a,l));case"logical":return i(()=>PCe(o,a,l));case"matrices":return i(()=>kCe(o,a,l));case"normalization":return i(()=>DCe(o,a,l));case"reduction":return i(()=>OCe(o,a,l));case"slice_join":return i(()=>LCe(o,a,l));case"sparse":return i(()=>BCe(o,a,l));case"spectral":return i(()=>FCe(o,a,l));case"string":return i(()=>$Ce(o,a,l));case"transformation":return i(()=>UCe(o,a,l));case"hash_table":return ICe(o,a,l,r);case"custom":const c=$V(o.op);if(c&&c.customExecutor)return c.customExecutor(new mCe(o,a,l));throw TypeError(`Custom op ${o.op} is not registered.`);default:throw TypeError(`Unknown op '${o.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,n);return Jh(s)?s.then(o=>[].concat(o)):[].concat(s)}class UL{constructor(e={},n={},r={},i={}){this.weightMap=e,this.tensorArrayMap=n,this.tensorListMap=r,this.functionMap=i,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,n){return{id:e,frameName:n,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let n=0;n<this.contexts.length-1;n++){const r=this.contexts.slice(0,this.contexts.length-n);e.push(this.contextIdforContexts(r))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map(n=>n.id===0&&n.iterationId===0?"":`${n.frameName}-${n.iterationId}`).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(this.contexts&&this.contexts.length>1)this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift();else throw new Error("Cannot exit frame, the context is empty")}nextIteration(){if(this.contexts&&this.contexts.length>0){this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}else throw new Error("Cannot increase frame iteration, the context is empty")}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const n in this.tensorArrayMap)this.tensorArrayMap[n].clearAndClose(e);for(const n in this.tensorListMap)this.tensorListMap[n].clearAndClose(e)}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zL(t,e,n,r){const i=new Set,s=[];let o=null,a=null;const l=new Set,c=Object.keys(t).map(f=>Xi(f)[0]);let u=[];r!=null&&(u=r.map(f=>Xi(f.name)[0]));const d=[...e];for(;d.length>0;){const f=d.pop();if((GV(f)||WCe(f)||jCe(f))&&o==null&&(o=f,a=o.children.map(h=>h.name).filter(h=>i.has(h))),i.add(f.name),n[f.name]==null&&c.indexOf(f.name)===-1&&u.indexOf(f.name)===-1){if(f.inputs.length===0){s.push(f.name);continue}f.inputs.forEach(h=>{l.has(h.name)||(l.add(h.name),d.push(h))})}}return{inputs:t,outputs:e,usedNodes:i,missingInputs:s,dynamicNode:o,syncInputs:a}}function zCe(t,e,n){const{usedNodes:r,inputs:i}=n,s=[],o=Object.keys(i).map(u=>Xi(u)[0]).map(u=>t.nodes[u]),a=t.initNodes;o.forEach(u=>{r.has(u.name)&&s.push(u)}),t.weights.forEach(u=>{r.has(u.name)&&s.push(u)}),a!=null&&a.forEach(u=>{r.has(u.name)&&s.push(u)});const l=new Set,c=[];for(;s.length>0;){const u=s.pop();l.add(u.name),e[u.name]||c.push(u),u.children.forEach(d=>{!l.has(d.name)&&r.has(d.name)&&d.inputs.every(f=>l.has(f.name))&&s.push(d)})}return c}const GCe=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],HCe=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],VCe=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function GV(t){return GCe.indexOf(t.op)>=0}function WCe(t){return HCe.indexOf(t.op)>=0}function jCe(t){return VCe.indexOf(t.op)>=0}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eb{constructor(e,n){this.graph=e,this.parent=n,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,e.functions!=null&&Object.keys(e.functions).forEach(r=>{this._functionExecutorMap[r]=new eb(e.functions[r],this)})}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const n=Object.keys(e).map(r=>e[r].map(i=>i.id));this._weightIds=[].concat(...n),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get outputs(){return this._outputs.map(e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0}))}get inputNodes(){return this._inputs.map(e=>e.signatureKey||e.name)}get outputNodes(){return this._outputs.map(e=>{const n=e.signatureKey||e.name;return e.defaultOutput?`${n}:${e.defaultOutput}`:n})}get functions(){return Object.keys(this._functions).reduce((e,n)=>(e[n]=this._functions[n].signature,e),{})}getCompilationKey(e,n){const r=e.map(s=>s.name).sort(),i=n.map(s=>s.name).sort();return r.join(this.SEPERATOR)+"--"+i.join(this.SEPERATOR)}compile(e,n){const r=zL(e,n,this.weightMap,this._initNodes),{missingInputs:i,dynamicNode:s,syncInputs:o}=r;if(s!=null)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${o}]`);if(i.length>0){const a=n.map(c=>c.name),l=Object.keys(e);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${l}]. Missing the following inputs: [${i}]`)}return zCe(this.graph,this.weightMap,r)}execute(e,n){e=this.mapInputs(e);const r=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n);const i=r.map(d=>this.graph.nodes[Xi(d)[0]]),s=n.map(d=>Xi(d)[0]);let o=s.map(d=>this.graph.nodes[d]);this.resetIntermediateTensors(),o.length===0&&(o=this._outputs);const a=this.getCompilationKey(i,o);let l=this.compiledMap.get(a);l==null&&(l=this.compile(e,o),this.compiledMap.set(a,l));const c={},u={};return qn(()=>{const d=new UL(this.weightMap,c,u,this.functionExecutorMap),f=Object.assign({},this.weightMap);Object.keys(e).forEach(x=>{const[v,y]=Xi(x),b=[];b[y]=e[x],f[v]=b});const h=this.getFrozenTensorIds(f),p={};for(let x=0;x<l.length;x++){const v=l[x];if(!f[v.name]){const y=$L(v,f,d,this._resourceManager);if(Jh(y))throw new Error(`The execution of the op '${v.op}' returned a promise. Please use model.executeAsync() instead.`);f[v.name]=y,this.checkTensorForDisposal(v.name,v,f,d,h,s,p)}}return this.parent==null&&d.dispose(h),n.map(x=>gi(x,f,d))})}getFrozenTensorIds(e){const n=[].concat.apply([],Object.keys(e).map(r=>e[r]).map(r=>r.map(i=>i.id)));return new Set(n)}checkTensorForDisposal(e,n,r,i,s,o,a){n.category==="control"||o.indexOf(e)!==-1||(r[e].forEach(l=>{l!=null&&(a[l.id]=(a[l.id]||0)+n.children.length)}),n.inputs.forEach(l=>{if(l.category!=="control"){const c=Rwe(l.name,r,i);c!=null&&c.forEach(u=>{if(u&&!u.kept&&!s.has(u.id)){const d=a[u.id];if(d===1){if(!this.keepTensorForDebug)u.dispose();else{const[f,h]=ga(n.name,i);this.intermediateTensors[f]?this.intermediateTensors[f][h]=u:(this.intermediateTensors[f]=[],this.intermediateTensors[f][h]=u)}delete a[u.id]}else d!=null&&a[u.id]--}})}}))}async executeAsync(e,n){return this._executeAsync(e,n)}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach(e=>this.intermediateTensors[e].forEach(n=>n.dispose())),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach(e=>{this.tensorsMap[e].forEach(r=>{r&&!r.kept&&!r.isDisposed&&!this.keepIds.has(r.id)&&r.dispose()})})}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach(n=>n.dispose()),delete this.intermediateTensors[e]}async _executeAsync(e,n,r=!1,i={},s={}){r||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),n=this.mapOutputs(n),this.checkOutputs(n));try{this.keepTensorForDebug=ge().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(u){console.warn(u.message)}this.resetIntermediateTensors();const o=new UL(this.weightMap,i,s,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,o,n,r);const a=n.map(u=>gi(u,this.tensorsMap,o)),l=a.map(u=>u.id),c=Object.keys(e).map(u=>e[u].id);return this.keepIds=new Set([...l,...c,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),this.parent==null&&o.dispose(this.keepIds),a}async executeFunctionAsync(e,n,r){const i=e.reduce((s,o,a)=>(s[this.inputs[a].name]=o,s),{});return this._executeAsync(i,this.outputNodes,!0,n,r)}async executeWithControlFlow(e,n,r,i){const s=Object.keys(e),o=s.map(S=>this.graph.nodes[Xi(S)[0]]),a=r.map(S=>Xi(S)[0]);let l=a.map(S=>this.graph.nodes[S]);l.length===0&&(l=this._outputs);const{usedNodes:c,missingInputs:u,dynamicNode:d,syncInputs:f}=zL(e,l,this.weightMap,this._initNodes),h=[...o,...this.graph.weights,...this._initNodes||[]].map(S=>({node:S,contexts:n.currentContext})),p=Object.assign({},this.weightMap);Object.keys(e).forEach(S=>{const[w,E]=Xi(S),A=[];A[E]=e[S],p[w]=A});const x={},v=this.getFrozenTensorIds(p),y={};for(;h.length>0;){const S=this.processStack(o,h,n,p,y,v,a,x,c);await Promise.all(S)}d==null&&!i&&console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const b=l.filter(S=>!GV(S)&&!gi(S.name,p,n)).map(S=>S.name);if(b.length>0){let S="";throw d!=null&&(S=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${f}]`),new Error(`Cannot compute the outputs [${b}] from the provided inputs [${s}]. Consider providing the following inputs: [${u}]. ${S}`)}return p}processStack(e,n,r,i,s,o,a,l,c){const u=[];for(;n.length>0;){const d=n.pop();r.currentContext=d.contexts;let f="";if(d.node.op==="Enter"&&k("isConstant",d.node,i,r)&&([f]=ga(d.node.name,r)),i[d.node.name]==null){const h=$L(d.node,i,r,this._resourceManager);f||([f]=ga(d.node.name,r));const p=r.currentContext;Jh(h)?u.push(h.then(x=>(i[f]=x,r.currentContext=p,this.checkTensorForDisposal(f,d.node,i,r,o,a,l),this.processChildNodes(d.node,n,r,i,s,c),x))):(i[f]=h,this.checkTensorForDisposal(f,d.node,i,r,o,a,l),this.processChildNodes(d.node,n,r,i,s,c))}else this.processChildNodes(d.node,n,r,i,s,c)}return u}processChildNodes(e,n,r,i,s,o){e.children.forEach(a=>{const[l]=ga(a.name,r);s[l]||!o.has(a.name)||(a.op==="Merge"?a.inputNames.some(c=>!!gi(c,i,r))&&(s[l]=!0,n.push({contexts:r.currentContext,node:a})):a.inputNames.every(c=>!!gi(c,i,r))&&(s[l]=!0,n.push({contexts:r.currentContext,node:a})))})}dispose(){Object.keys(this.weightMap).forEach(e=>this.weightMap[e].forEach(n=>n.dispose()))}checkInputShapeAndType(e){Object.keys(e).forEach(n=>{const r=e[n],[i]=Xi(n),s=this.graph.nodes[i];if(s.attrParams.shape&&s.attrParams.shape.value){const o=s.attrParams.shape.value,a=o.length===r.shape.length&&r.shape.every((l,c)=>o[c]===-1||o[c]===l);Y(a,()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${o}], but was [${r.shape}]`)}s.attrParams.dtype&&s.attrParams.dtype.value&&Y(r.dtype===s.attrParams.dtype.value,()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${r.dtype}`)})}mapInputs(e){const n={};for(const r in e)if(this._signature!=null&&this._signature.inputs!=null&&this._signature.inputs[r]!=null){const i=this._signature.inputs[r];n[i.name]=e[r]}else n[r]=e[r];return n}checkInputs(e){const n=Object.keys(e).filter(r=>{const[i]=Xi(r);return this.graph.nodes[i]==null});if(n.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${n}] that are not part of graph`)}mapOutputs(e){return e.map(n=>this._signature!=null&&this._signature.outputs!=null&&this._signature.outputs[n]!=null?this._signature.outputs[n].name:n,{})}checkOutputs(e){e.forEach(n=>{const[r]=Xi(n);if(!this.graph.nodes[r])throw new Error(`The output '${n}' is not found in the graph`)})}}class XCe{constructor(e={},n={}){this.hashTableNameToHandle=e,this.hashTableMap=n}addHashTable(e,n){this.hashTableNameToHandle[e]=n.handle,this.hashTableMap[n.id]=n}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KCe="?tfjs-format=file",qCe="model.json";class JCe{constructor(e,n={},r=JG){this.modelUrl=e,this.loadOptions=n,this.version="n/a",this.io=r,n==null&&(this.loadOptions={}),this.resourceManager=new XCe}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(e.load!=null)this.handler=e;else if(this.loadOptions.requestInit!=null)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const n=this.io.getLoadHandlers(e,this.loadOptions);if(n.length===0)n.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(n.length>1)throw new Error(`Found more than one (${n.length}) load handlers for URL '${[e]}'`);this.handler=n[0]}}load(){if(this.findIOHandler(),this.handler.load==null)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return Jh(e)?e.then(n=>this.loadSync(n)):this.loadSync(e)}loadSync(e){this.artifacts=e;const n=this.artifacts.modelTopology;let r=this.artifacts.signature;if(this.artifacts.userDefinedMetadata!=null){const s=this.artifacts.userDefinedMetadata;s.signature!=null&&(r=s.signature),s.structuredOutputKeys!=null&&(this.structuredOutputKeys=s.structuredOutputKeys)}this.signature=r,this.version=`${n.versions.producer}.${n.versions.minConsumer}`;const i=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new eb(OL.Instance.transformGraph(n,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(i),this.executor.resourceManager=this.resourceManager,e.modelInitializer!=null&&e.modelInitializer.node!=null){const s=OL.Instance.transformGraph(e.modelInitializer);this.initializer=new eb(s),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,n){if(typeof e=="string"){const r=this.io.getSaveHandlers(e);if(r.length===0)throw new Error(`Cannot find any save handlers for URL '${e}'`);if(r.length>1)throw new Error(`Found more than one (${r.length}) save handlers for URL '${e}'`);e=r[0]}if(e.save==null)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,n){const r=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const i=r instanceof Mn?[r]:r,s={};return i.forEach((o,a)=>s[this.structuredOutputKeys[a]]=o),s}return r}normalizeInputs(e){if(!(e instanceof Mn)&&!Array.isArray(e))return e;if(e=Array.isArray(e)?e:[e],e.length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${e.length} input tensors.`);return this.inputNodes.reduce((n,r,i)=>(n[r]=e[i],n),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,n){e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=this.executor.execute(e,n);return r.length>1?r:r[0]}async executeAsync(e,n){e=this.normalizeInputs(e),n=this.normalizeOutputs(n);const r=await this.executor.executeAsync(e,n);return r.length>1?r:r[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce((n,r)=>(n[r]=[e[r]],n),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function tp(t,e={},n=JG){if(t==null)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");e==null&&(e={}),e.fromTFHub&&typeof t=="string"&&(t=YCe(t));const r=new JCe(t,e,n);return await r.load(),r}function YCe(t){return t.endsWith("/")||(t=t+"/"),`${t}${qCe}${KCe}`}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Mu={},mx={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function QCe(t,e){Mu[t]=e}function qo(t,e){if(!(t in Mu)||e!=null){const r=eEe(t,e);if(r!==null)Mu[t]=r;else return console.log("Could not get context for WebGL version",t),null}const n=Mu[t];return n==null||n.isContextLost()?(delete Mu[t],qo(t)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),Mu[t])}function ZCe(t){if(typeof OffscreenCanvas<"u"&&t===2)return new OffscreenCanvas(300,150);if(typeof document<"u")return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}function eEe(t,e){if(t!==1&&t!==2)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=e??ZCe(t);return n.addEventListener("webglcontextlost",r=>{r.preventDefault(),delete Mu[t]},!1),ge().getBool("SOFTWARE_WEBGL_ENABLED")&&(mx.failIfMajorPerformanceCaveat=!1),t===1?n.getContext("webgl",mx)||n.getContext("experimental-webgl",mx):n.getContext("webgl2",mx)}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var i0;(function(t){t[t.DENSE=0]="DENSE",t[t.SHARED_BATCH=1]="SHARED_BATCH"})(i0||(i0={}));var Cs;(function(t){t[t.RENDER=0]="RENDER",t[t.UPLOAD=1]="UPLOAD",t[t.PIXELS=2]="PIXELS",t[t.DOWNLOAD=3]="DOWNLOAD"})(Cs||(Cs={}));var Ur;(function(t){t[t.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",t[t.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",t[t.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",t[t.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",t[t.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"})(Ur||(Ur={}));function U0(t,e){return[e,t]}function tEe(t,e){return t*e}function gx(t){const e=Ve(t),n=Math.ceil(e/4);return G2(n)}function Ap(t,e){return[Math.max(1,Math.ceil(e/2)),Math.max(1,Math.ceil(t/2))]}function nEe(t,e){const[n,r]=Ap(t,e);return n*r*4}function QI(t,e){const n=t;let r,i,s,o,a,l,c,u,d,f;return ge().getNumber("WEBGL_VERSION")===2?(r=n.R32F,i=n.R16F,s=n.RGBA16F,o=n.RGBA32F,a=n.RED,c=4,u=1,d=n.HALF_FLOAT,f=n.FLOAT,l=n.RGBA8):(r=t.RGBA,i=t.RGBA,s=t.RGBA,o=n.RGBA,a=t.RGBA,c=4,u=4,d=e!=null?e.HALF_FLOAT_OES:null,f=t.FLOAT,l=t.RGBA),{internalFormatFloat:r,internalFormatHalfFloat:i,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:a,downloadTextureFormat:l,downloadUnpackNumChannels:c,defaultNumChannels:u,textureTypeHalfFloat:d,textureTypeFloat:f}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ft(t,e){const n=e();return ge().getBool("DEBUG")&&rEe(t),n}function rEe(t){const e=t.getError();if(e!==t.NO_ERROR)throw new Error("WebGL Error: "+aEe(t,e))}const iEe=596e-10,sEe=65504;function oEe(t){return!!(ge().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||t===0||iEe<Math.abs(t)&&Math.abs(t)<sEe)}function aEe(t,e){switch(e){case t.NO_ERROR:return"NO_ERROR";case t.INVALID_ENUM:return"INVALID_ENUM";case t.INVALID_VALUE:return"INVALID_VALUE";case t.INVALID_OPERATION:return"INVALID_OPERATION";case t.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case t.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case t.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return`Unknown error code ${e}`}}function yx(t,e){return Il(t,()=>t.getExtension(e),'Extension "'+e+'" not supported on this browser.')}function lEe(t,e){const n=Il(t,()=>t.createShader(t.VERTEX_SHADER),"Unable to create vertex WebGLShader.");if(ft(t,()=>t.shaderSource(n,e)),ft(t,()=>t.compileShader(n)),t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw console.log(t.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}function cEe(t,e){const n=Il(t,()=>t.createShader(t.FRAGMENT_SHADER),"Unable to create fragment WebGLShader.");if(ft(t,()=>t.shaderSource(n,e)),ft(t,()=>t.compileShader(n)),ge().get("ENGINE_COMPILE_ONLY"))return n;if(t.getShaderParameter(n,t.COMPILE_STATUS)===!1)throw HV(e,t.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}const uEe=/ERROR: [0-9]+:([0-9]+):/g;function HV(t,e){const n=uEe.exec(e);if(n==null){console.log(`Couldn't parse line number in error: ${e}`),console.log(t);return}const r=+n[1],i=t.split(`
`),s=i.length.toString().length+2,o=i.map((d,f)=>wh((f+1).toString(),s)+d);let a=0;for(let d=0;d<o.length;d++)a=Math.max(o[d].length,a);const l=o.slice(0,r-1),c=o.slice(r-1,r),u=o.slice(r);console.log(l.join(`
`)),console.log(e.split(`
`)[0]),console.log(`%c ${wh(c[0],a)}`,"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join(`
`))}function dEe(t){return Il(t,()=>t.createProgram(),"Unable to create WebGLProgram.")}function fEe(t,e){if(ft(t,()=>t.linkProgram(e)),!ge().get("ENGINE_COMPILE_ONLY")&&t.getProgramParameter(e,t.LINK_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Failed to link vertex and fragment shaders.")}function yE(t,e){if(ft(t,()=>t.validateProgram(e)),t.getProgramParameter(e,t.VALIDATE_STATUS)===!1)throw console.log(t.getProgramInfoLog(e)),new Error("Shader program validation failed.")}function hEe(t,e){const n=Il(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return ft(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),ft(t,()=>t.bufferData(t.ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function pEe(t,e){const n=Il(t,()=>t.createBuffer(),"Unable to create WebGLBuffer");return ft(t,()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,n)),ft(t,()=>t.bufferData(t.ELEMENT_ARRAY_BUFFER,e,t.STATIC_DRAW)),n}function mEe(t){return Il(t,()=>t.createTexture(),"Unable to create WebGLTexture.")}function gEe(t,e){const n=ge().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(t<=0||e<=0){const r=`[${t}x${e}]`;throw new Error("Requested texture size "+r+" is invalid.")}if(t>n||e>n){const r=`[${t}x${e}]`,i=`[${n}x${n}]`;throw new Error("Requested texture size "+r+" greater than WebGL maximum on this browser / GPU "+i+".")}}function yEe(t){return Il(t,()=>t.createFramebuffer(),"Unable to create WebGLFramebuffer.")}function GL(t,e,n,r,i,s,o){const a=t.getAttribLocation(e,n);return a===-1?!1:(ft(t,()=>t.bindBuffer(t.ARRAY_BUFFER,r)),ft(t,()=>t.vertexAttribPointer(a,i,t.FLOAT,!1,s,o)),ft(t,()=>t.enableVertexAttribArray(a)),!0)}function vEe(t,e,n){wEe(t,n),ft(t,()=>t.activeTexture(t.TEXTURE0+n)),ft(t,()=>t.bindTexture(t.TEXTURE_2D,e))}function xEe(t,e,n){return Il(t,()=>t.getUniformLocation(e,n),'uniform "'+n+'" not present in program.')}function bEe(t,e,n){return t.getUniformLocation(e,n)}function SEe(t,e,n,r){ft(t,()=>vEe(t,e,r)),ft(t,()=>t.uniform1i(n,r))}function vE(t,e,n){ft(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,n)),ft(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,e,0))}function HL(t,e){ft(t,()=>t.bindFramebuffer(t.FRAMEBUFFER,e)),ft(t,()=>t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,null,0))}function vx(t){const e=t.checkFramebufferStatus(t.FRAMEBUFFER);if(e!==t.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+_Ee(t,e))}function _Ee(t,e){switch(e){case t.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case t.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case t.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return`unknown error ${e}`}}function Il(t,e,n){const r=ft(t,()=>e());if(r==null)throw new Error(n);return r}function wEe(t,e){const n=t.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,r=e+t.TEXTURE0;if(r<t.TEXTURE0||r>n){const i=`[gl.TEXTURE0, gl.TEXTURE${n}]`;throw new Error(`textureUnit must be in ${i}.`)}}function np(t,e=2){return Ve(t.slice(0,t.length-e))}function rp(t){if(t.length===0)throw Error("Cannot get rows and columns of an empty shape array.");return[t.length>1?t[t.length-2]:1,t[t.length-1]]}function xE(t){let e=[1,1,1];return t.length===0||t.length===1&&t[0]===1||(e=[np(t),...rp(t)]),e}function CEe(t,e=!1){let n=ge().getNumber("WEBGL_MAX_TEXTURE_SIZE"),r=ge().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");r===1/0&&ge().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(r=n/2),e&&(n=n*2,r=r*2,t=t.map((a,l)=>l>=t.length-2?lI(t[l]):t[l]),t.length===1&&(t=[2,t[0]])),t.length!==2&&(t=Uc(t).newShape);let i=Ve(t),s=null;t.length<=1&&i<=n?s=[1,i]:t.length===2&&t[0]<=n&&t[1]<=n?s=t:t.length===3&&t[0]*t[1]<=n&&t[2]<=n?s=[t[0]*t[1],t[2]]:t.length===3&&t[0]<=n&&t[1]*t[2]<=n?s=[t[0],t[1]*t[2]]:t.length===4&&t[0]*t[1]*t[2]<=n&&t[3]<=n?s=[t[0]*t[1]*t[2],t[3]]:t.length===4&&t[0]<=n&&t[1]*t[2]*t[3]<=n&&(s=[t[0],t[1]*t[2]*t[3]]);const o=s!=null&&Math.max(...s)>r&&Math.min(...s)<=(e?2:1)&&Math.min(...s)>0;if(s==null||o)if(e){const a=np(t);let l=2,c=2;t.length&&([l,c]=rp(t)),i=a*(l/2)*(c/2),s=G2(i).map(u=>u*2)}else s=G2(i);return s}function xx(t){return t%2===0}function tb(t,e){if(t=t.slice(-2),e=e.slice(-2),Yn(t,e)||!t.length||!e.length||t[0]===0||t[1]===0||e[0]===0||e[1]===0)return!0;if(t.length!==e.length){const n=t.slice(-1)[0],r=e.slice(-1)[0];if(n===r||xx(n)&&xx(r)&&(t[0]===1||e[0]===1))return!0}return t[1]===e[1]&&xx(t[0])&&xx(e[0])}let bE,SE;function EEe(t){if(bE==null){const e=qo(t);bE=e.getParameter(e.MAX_TEXTURE_SIZE)}return bE}function AEe(t){if(SE==null){const e=qo(t);SE=e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,SE)}function TEe(t){if(t===0)return 0;let e;const n=qo(t);return ho(n,"EXT_disjoint_timer_query_webgl2")&&t===2?e=2:ho(n,"EXT_disjoint_timer_query")?e=1:e=0,e}function ho(t,e){return t.getExtension(e)!=null}function VL(t){try{if(qo(t)!=null)return!0}catch(e){return console.log("Error when getting WebGL context: ",e),!1}return!1}function MEe(t){if(t===0)return!1;const e=qo(t);if(t===1){if(!ho(e,"OES_texture_float"))return!1}else if(!ho(e,"EXT_color_buffer_float"))return!1;return RT(e)}function REe(t){if(t===0)return!1;const e=qo(t);if(t===1){if(!ho(e,"OES_texture_float")||!ho(e,"WEBGL_color_buffer_float"))return!1}else{if(ho(e,"EXT_color_buffer_float"))return RT(e);const r="EXT_color_buffer_half_float";if(ho(e,r)){const i=e.getExtension(r);return IEe(e,i)}return!1}return RT(e)}function RT(t){const e=QI(t),n=t.createTexture();t.bindTexture(t.TEXTURE_2D,n),t.texImage2D(t.TEXTURE_2D,0,e.internalFormatFloat,1,1,0,e.textureFormatFloat,e.textureTypeFloat,null);const s=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,s),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,n,0);const o=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(n),t.deleteFramebuffer(s),o}function IEe(t,e){const n=QI(t,e),r=t.createTexture();t.bindTexture(t.TEXTURE_2D,r),t.texImage2D(t.TEXTURE_2D,0,n.internalFormatHalfFloat,1,1,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=t.createFramebuffer();t.bindFramebuffer(t.FRAMEBUFFER,o),t.framebufferTexture2D(t.FRAMEBUFFER,t.COLOR_ATTACHMENT0,t.TEXTURE_2D,r,0);const a=t.checkFramebufferStatus(t.FRAMEBUFFER)===t.FRAMEBUFFER_COMPLETE;return t.bindTexture(t.TEXTURE_2D,null),t.bindFramebuffer(t.FRAMEBUFFER,null),t.deleteTexture(r),t.deleteFramebuffer(o),a}function NEe(t){return t!==2?!1:qo(t).fenceSync!=null}function z0(t,e){Array.isArray(t)||(t=[t]),t.forEach(n=>{n!=null&&Y(n.dtype!=="complex64",()=>`${e} does not support complex64 tensors in the WebGL backend.`)})}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gt=ge();gt.registerFlag("HAS_WEBGL",()=>gt.getNumber("WEBGL_VERSION")>0);gt.registerFlag("WEBGL_VERSION",()=>VL(2)?2:VL(1)?1:0);gt.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",()=>!1);gt.registerFlag("WEBGL_BUFFER_SUPPORTED",()=>gt.get("WEBGL_VERSION")===2);gt.registerFlag("WEBGL_CPU_FORWARD",()=>!0);gt.registerFlag("WEBGL_FORCE_F16_TEXTURES",()=>!1);gt.registerFlag("WEBGL_PACK",()=>gt.getBool("HAS_WEBGL"));gt.registerFlag("WEBGL_PACK_NORMALIZATION",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_CLIP",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_DEPTHWISECONV",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_PACK_REDUCE",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_LAZILY_UNPACK",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_CONV_IM2COL",()=>gt.getBool("WEBGL_PACK"));gt.registerFlag("WEBGL_MAX_TEXTURE_SIZE",()=>EEe(gt.getNumber("WEBGL_VERSION")));gt.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",()=>AEe(gt.getNumber("WEBGL_VERSION")));gt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",()=>{const t=gt.getNumber("WEBGL_VERSION");return t===0?0:TEe(t)});gt.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",()=>gt.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!RG());gt.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",()=>MEe(gt.getNumber("WEBGL_VERSION")));gt.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",()=>gt.getBool("WEBGL_FORCE_F16_TEXTURES")?!1:gt.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"));gt.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",()=>REe(gt.getNumber("WEBGL_VERSION")));gt.registerFlag("WEBGL_FENCE_API_ENABLED",()=>NEe(gt.getNumber("WEBGL_VERSION")));gt.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",()=>gt.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0);gt.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",()=>-1,t=>{if(t<0&&t!==-1)throw new Error(`WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never delete) or at least 0, but got ${t}.`)});gt.registerFlag("WEBGL_FLUSH_THRESHOLD",()=>RG()?1:-1,t=>{if(t<0&&t!==-1)throw new Error(`WEBGL_FLUSH_THRESHOLD must be -1 (indicating never manual flush) or at least 0, but got ${t}.`)});gt.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",()=>128);gt.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",()=>!1);gt.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",()=>1e5);gt.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",()=>128);gt.registerFlag("WEBGL_EXP_CONV",()=>!1);gt.registerFlag("SOFTWARE_WEBGL_ENABLED",()=>gt.getBool("IS_TEST"));gt.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",()=>1/0);gt.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",()=>!1);gt.registerFlag("WEBGL2_ISNAN_CUSTOM",()=>!1);/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function wi(){let t,e,n,r,i,s,o,a,l,c;return ge().getNumber("WEBGL_VERSION")===2?(t="#version 300 es",e="in",n="out",r="in",i="texture",s="outputColor",o="out vec4 outputColor;",a=ge().getBool("WEBGL2_ISNAN_CUSTOM")?`
      bool isnan_custom(float val) {
        uint floatToUint = floatBitsToUint(val);
        return (floatToUint & 0x7fffffffu) > 0x7f800000u;
      }

      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan_custom(val.x),
          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));
      }

      #define isnan(value) isnan_custom(value)
    `:"",l="",c=`
      #define round(value) newRound(value)
      int newRound(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 newRound(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `):(t="",e="attribute",n="varying",r="varying",i="texture2D",s="gl_FragColor",o="",a=`
      #define isnan(value) isnan_custom(value)
      bool isnan_custom(float val) {
        return (val > 0. || val < 1. || val == 0.) ? false : true;
      }
      bvec4 isnan_custom(vec4 val) {
        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));
      }
    `,l=`
      uniform float INFINITY;

      bool isinf(float val) {
        return abs(val) == INFINITY;
      }
      bvec4 isinf(vec4 val) {
        return equal(abs(val), vec4(INFINITY));
      }
    `,c=`
      int round(float value) {
        return int(floor(value + 0.5));
      }

      ivec4 round(vec4 value) {
        return ivec4(floor(value + vec4(0.5)));
      }
    `),{version:t,attribute:e,varyingVs:n,varyingFs:r,texture2D:i,output:s,defineOutput:o,defineSpecialNaN:a,defineSpecialInf:l,defineRound:c}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ud(t,e,n="index"){const r=Vr(e);return r.map((i,s)=>{const o=`int ${t[s]} = ${n} / ${i}`,a=s===r.length-1?`int ${t[s+1]} = ${n} - ${t[s]} * ${i}`:`index -= ${t[s]} * ${i}`;return`${o}; ${a};`}).join("")}function p_(t,e,n="index"){const r=Vr(e);return r.map((i,s)=>{const o=`int ${t[s]} = ${n} / outShapeStrides[${s}]`,a=s===r.length-1?`int ${t[s+1]} = ${n} - ${t[s]} * outShapeStrides[${s}]`:`index -= ${t[s]} * outShapeStrides[${s}]`;return`${o}; ${a};`}).join("")}function PEe(t,e){const n=t.length,r=t.map(s=>`${e}[${s}]`),i=new Array(n-1);i[n-2]=r[n-1];for(let s=n-3;s>=0;--s)i[s]=`(${i[s+1]} * ${r[s+1]})`;return i}function kEe(t,e,n="index"){const r=t.map((s,o)=>o),i=PEe(r,e);return i.map((s,o)=>{const a=`int ${t[o]} = ${n} / ${i[o]}`,l=o===i.length-1?`int ${t[o+1]} = ${n} - ${t[o]} * ${i[o]}`:`index -= ${t[o]} * ${i[o]}`;return`${a}; ${l};`}).join("")}function ZI(t){const e=Vr(t).map(n=>n.toString());return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * ${e[0]} + coords.y * ${e[1]} + coords.z;
  }
`}function eN(){return`
  int getFlatIndex(ivec3 coords) {
    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;
  }
`}const VV=`
  const float FLOAT_MAX = 1.70141184e38;
  const float FLOAT_MIN = 1.17549435e-38;

  lowp vec4 encode_float(highp float v) {
    if (isnan(v)) {
      return vec4(255, 255, 255, 255);
    }

    highp float av = abs(v);

    if(av < FLOAT_MIN) {
      return vec4(0.0, 0.0, 0.0, 0.0);
    } else if(v > FLOAT_MAX) {
      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;
    } else if(v < -FLOAT_MAX) {
      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;
    }

    highp vec4 c = vec4(0,0,0,0);

    highp float e = floor(log2(av));
    highp float m = exp2(fract(log2(av))) - 1.0;

    c[2] = floor(128.0 * m);
    m -= c[2] / 128.0;
    c[1] = floor(32768.0 * m);
    m -= c[1] / 32768.0;
    c[0] = floor(8388608.0 * m);

    highp float ebias = e + 127.0;
    c[3] = floor(ebias / 2.0);
    ebias -= c[3] * 2.0;
    c[2] += floor(ebias) * 128.0;

    c[3] += 128.0 * step(0.0, -v);

    return c / 255.0;
  }
`;/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{getBroadcastDims:WV}=Awe;function DEe(t,e,n){const r=[];if(t.forEach(h=>{const p=Ve(h.shapeInfo.logicalShape);if(h.shapeInfo.isUniform?r.push(`uniform float ${h.name}${p>1?`[${p}]`:""};`):(r.push(`uniform sampler2D ${h.name};`),r.push(`uniform int offset${h.name};`)),n.enableShapeUniforms){const{uniformShape:x}=tN(n.packedInputs,h.shapeInfo.logicalShape,h.shapeInfo.texShape);switch(x.length){case 1:r.push(`uniform int ${h.name}Shape;`);break;case 2:r.push(`uniform ivec2 ${h.name}Shape;`);break;case 3:r.push(`uniform ivec3 ${h.name}Shape;`);break;case 4:r.push(`uniform ivec4 ${h.name}Shape;`);break}r.push(`uniform ivec2 ${h.name}TexShape;`)}}),n.enableShapeUniforms){switch(e.logicalShape.length){case 1:r.push("uniform int outShape;");break;case 2:r.push("uniform ivec2 outShape;"),r.push("uniform int outShapeStrides;");break;case 3:r.push("uniform ivec3 outShape;"),r.push("uniform ivec2 outShapeStrides;");break;case 4:r.push("uniform ivec4 outShape;"),r.push("uniform ivec3 outShapeStrides;");break}r.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach(h=>{r.push(`uniform ${h.type} ${h.name}${h.arrayIndex?`[${h.arrayIndex}]`:""};`)});const i=r.join(`
`),s=t.map(h=>OEe(h,e,n.packedInputs,n.enableShapeUniforms)).join(`
`),o=e.texShape,a=wi(),l=FEe(a);let c,u,d=zEe(a);return e.isPacked?(c=LEe(e.logicalShape,o,n.enableShapeUniforms),u=UEe(a)):(c=BEe(e.logicalShape,o,n.enableShapeUniforms),u=$Ee(a)),n.packedInputs&&(d+=WEe),[d,l,u,i,c,s,n.userCode].join(`
`)}function Tp(t,e=!1){const n=t.shapeInfo.logicalShape;switch(n.length){case 0:return rAe(t,e);case 1:return sAe(t,e);case 2:return aAe(t,e);case 3:return cAe(t,e);case 4:return dAe(t,e);case 5:return fAe(t);case 6:return hAe(t);default:throw new Error(`${n.length}-D input sampling is not yet supported`)}}function jV(t,e){switch(t.shapeInfo.logicalShape.length){case 0:return nAe(t);case 1:return iAe(t,e);case 2:return oAe(t,e);case 3:return lAe(t,e);default:return uAe(t,e)}}function OEe(t,e,n=!1,r){let i="";n?i+=jV(t,r):i+=Tp(t,r);const s=t.shapeInfo.logicalShape,o=e.logicalShape;return s.length<=o.length&&(n?i+=pAe(t,e):i+=mAe(t,e)),i}function LEe(t,e,n){switch(t.length){case 0:return XV();case 1:return jEe(t,e,n);case 2:return eAe(t,e,n);case 3:return KEe(t,e,n);default:return JEe(t,e,n)}}function BEe(t,e,n){switch(t.length){case 0:return XV();case 1:return XEe(t,e,n);case 2:return tAe(t,e,n);case 3:return qEe(t,e,n);case 4:return YEe(t,e,n);case 5:return QEe(t,e);case 6:return ZEe(t,e);default:throw new Error(`${t.length}-D output sampling is not yet supported`)}}function FEe(t){return`
    float sampleTexture(sampler2D textureSampler, vec2 uv) {
      return ${t.texture2D}(textureSampler, uv).r;
    }
  `}function $Ee(t){return`
    void setOutput(float val) {
      ${t.output} = vec4(val, 0, 0, 0);
    }
  `}function UEe(t){return`
    void setOutput(vec4 val) {
      ${t.output} = val;
    }
  `}function zEe(t){return`${t.version}
    precision highp float;
    precision highp int;
    precision highp sampler2D;
    ${t.varyingFs} vec2 resultUV;
    ${t.defineOutput}
    const vec2 halfCR = vec2(0.5, 0.5);

    struct ivec5
    {
      int x;
      int y;
      int z;
      int w;
      int u;
    };

    struct ivec6
    {
      int x;
      int y;
      int z;
      int w;
      int u;
      int v;
    };

    uniform float NAN;
    ${t.defineSpecialNaN}
    ${t.defineSpecialInf}
    ${t.defineRound}

    int imod(int x, int y) {
      return x - y * (x / y);
    }

    int idiv(int a, int b, float sign) {
      int res = a / b;
      int mod = imod(a, b);
      if (sign < 0. && mod != 0) {
        res -= 1;
      }
      return res;
    }

    //Based on the work of Dave Hoskins
    //https://www.shadertoy.com/view/4djSRW
    #define HASHSCALE1 443.8975
    float random(float seed){
      vec2 p = resultUV * seed;
      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);
      p3 += dot(p3, p3.yzx + 19.19);
      return fract((p3.x + p3.y) * p3.z);
    }

    ${GEe}
    ${HEe}
    ${VEe}
  `}const GEe=`
vec2 uvFromFlat(int texNumR, int texNumC, int index) {
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
vec2 packedUVfrom1D(int texNumR, int texNumC, int index) {
  int texelIndex = index / 2;
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,HEe=`
vec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,
  int texNumC, int row, int col) {
  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = texelIndex / texNumC;
  int texC = texelIndex - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,VEe=`
vec2 packedUVfrom3D(int texNumR, int texNumC,
    int texelsInBatch, int texelsInLogicalRow, int b,
    int row, int col) {
  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);
  int texR = index / texNumC;
  int texC = index - texR * texNumC;
  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);
}
`,WEe=`
  float getChannel(vec4 frag, vec2 innerDims) {
    vec2 modCoord = mod(innerDims, 2.);
    return modCoord.x == 0. ?
      (modCoord.y == 0. ? frag.r : frag.g) :
      (modCoord.y == 0. ? frag.b : frag.a);
  }
  float getChannel(vec4 frag, int dim) {
    float modCoord = mod(float(dim), 2.);
    return modCoord == 0. ? frag.r : frag.g;
  }
`;function XV(){return`
    int getOutputCoords() {
      return 0;
    }
  `}function jEe(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];return r[0]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.x * ${r[1]}.0);
      }
    `:r[1]===1?n?`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));
      }
    `:`
      int getOutputCoords() {
        return 2 * int(resultUV.y * ${r[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      return 2 * (resTexRC.x * ${r[1]} + resTexRC.y);
    }
  `}function XEe(t,e,n){return e[0]===1?n?`
      int getOutputCoords() {
        return int(resultUV.x * float(outTexShape[1]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.x * ${e[1]}.0);
      }
    `:e[1]===1?n?`
      int getOutputCoords() {
        return int(resultUV.y * float(outTexShape[0]));
      }
    `:`
      int getOutputCoords() {
        return int(resultUV.y * ${e[0]}.0);
      }
    `:n?`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      return resTexRC.x * outTexShape[1] + resTexRC.y;
    }
  `:`
    int getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      return resTexRC.x * ${e[1]} + resTexRC.y;
    }
  `}function KEe(t,e,n){if(n)return`
    ivec3 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec3(b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(t[2]/2),s=i*Math.ceil(t[1]/2);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec3(b, r, c);
    }
  `}function qEe(t,e,n){if(n)return`
  ivec3 getOutputCoords() {
    ivec2 resTexRC = ivec2(resultUV.yx *
                           vec2(outTexShape[0], outTexShape[1]));
    int index = resTexRC.x * outTexShape[1] + resTexRC.y;
    ${p_(["r","c","d"],t)}
    return ivec3(r, c, d);
  }
`;const r=Ud(["r","c","d"],t);return`
    ivec3 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec3(r, c, d);
    }
  `}function JEe(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));
      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;

      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));
      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));
      int texelsInBatchN = texelsInBatch * outShape[1];

      int b2 = index / texelsInBatchN;
      index -= b2 * texelsInBatchN;

      int b = index / texelsInBatch;
      index -= b * texelsInBatch;

      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec4(b2, b, r, c);
    }
  `;const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)],i=Math.ceil(t[t.length-1]/2),s=i*Math.ceil(t[t.length-2]/2);let o=s,a="",l="b, r, c";for(let c=2;c<t.length-1;c++)o*=t[t.length-c-1],a=`
      int b${c} = index / ${o};
      index -= b${c} * ${o};
    `+a,l=`b${c}, `+l;return`
    ivec${t.length} getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));
      int index = resTexRC.x * ${r[1]} + resTexRC.y;

      ${a}

      int b = index / ${s};
      index -= b * ${s};

      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec${t.length}(${l});
    }
  `}function YEe(t,e,n){if(n)return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      ${p_(["r","c","d","d2"],t)}
      return ivec4(r, c, d, d2);
    }
  `;const r=Ud(["r","c","d","d2"],t);return`
    ivec4 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      ${r}
      return ivec4(r, c, d, d2);
    }
  `}function QEe(t,e){const n=Ud(["r","c","d","d2","d3"],t);return`
    ivec5 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx * vec2(${e[0]},
                             ${e[1]}));

      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec5 outShape = ivec5(r, c, d, d2, d3);
      return outShape;
    }
  `}function ZEe(t,e){const n=Ud(["r","c","d","d2","d3","d4"],t);return`
    ivec6 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
        vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;

      ${n}

      ivec6 result = ivec6(r, c, d, d2, d3, d4);
      return result;
    }
  `}function eAe(t,e,n){const r=[Math.ceil(e[0]/2),Math.ceil(e[1]/2)];if(Yn(t,e))return n?`
      ivec2 getOutputCoords() {
        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return 2 * ivec2(resultUV.yx * vec2(${r[0]}, ${r[1]}));
      }
    `;const i=Math.ceil(t[1]/2);return n?`
    ivec2 getOutputCoords() {
      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));
      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(packedTexShape[0], packedTexShape[1]));

      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;
      int r = 2 * (index / texelsInLogicalRow);
      int c = imod(index, texelsInLogicalRow) * 2;

      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${r[0]}, ${r[1]}));

      int index = resTexRC.x * ${r[1]} + resTexRC.y;
      int r = 2 * (index / ${i});
      int c = imod(index, ${i}) * 2;

      return ivec2(r, c);
    }
  `}function tAe(t,e,n){return Yn(t,e)?n?`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));
      }
    `:`
      ivec2 getOutputCoords() {
        return ivec2(resultUV.yx * vec2(${e[0]}, ${e[1]}));
      }
    `:t[1]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(index, 0);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(index, 0);
      }
    `:t[0]===1?n?`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(outTexShape[0], outTexShape[1]));
        int index = resTexRC.x * outTexShape[1] + resTexRC.y;
        return ivec2(0, index);
      }
    `:`
      ivec2 getOutputCoords() {
        ivec2 resTexRC = ivec2(resultUV.yx *
                               vec2(${e[0]}, ${e[1]}));
        int index = resTexRC.x * ${e[1]} + resTexRC.y;
        return ivec2(0, index);
      }
    `:n?`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(outTexShape[0], outTexShape[1]));
      int index = resTexRC.x * outTexShape[1] + resTexRC.y;
      int r = index / outShape[1];
      int c = index - r * outShape[1];
      return ivec2(r, c);
    }
  `:`
    ivec2 getOutputCoords() {
      ivec2 resTexRC = ivec2(resultUV.yx *
                             vec2(${e[0]}, ${e[1]}));
      int index = resTexRC.x * ${e[1]} + resTexRC.y;
      int r = index / ${t[1]};
      int c = index - r * ${t[1]};
      return ivec2(r, c);
    }
  `}function zd(t){return`offset${t}`}function nAe(t){const e=t.name,n="get"+e.charAt(0).toUpperCase()+e.slice(1),r=wi();return`
    vec4 ${n}() {
      return ${r.texture2D}(${e}, halfCR);
    }
  `}function rAe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`float ${r}() {return ${n};}`;const[i,s]=t.shapeInfo.texShape;if(i===1&&s===1)return`
      float ${r}() {
        return sampleTexture(${n}, halfCR);
      }
    `;const o=zd(n);if(e)return`
    float ${r}() {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], ${o});
      return sampleTexture(${n}, uv);
    }
  `;const[a,l]=t.shapeInfo.texShape;return`
    float ${r}() {
      vec2 uv = uvFromFlat(${a}, ${l}, ${o});
      return sampleTexture(${n}, uv);
    }
  `}function iAe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=t.shapeInfo.texShape,s=wi();if(e)return`
    vec4 ${r}(int index) {
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      vec2 uv = packedUVfrom1D(
        packedTexShape[0], packedTexShape[1], index);
      return ${s.texture2D}(${n}, uv);
    }
  `;const o=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)];return`
    vec4 ${r}(int index) {
      vec2 uv = packedUVfrom1D(
        ${o[0]}, ${o[1]}, index);
      return ${s.texture2D}(${n}, uv);
    }
  `}function sAe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1);if(t.shapeInfo.isUniform)return`
      float ${r}(int index) {
        ${Mp(t)}
      }
    `;const i=t.shapeInfo.texShape,s=i[0],o=i[1];if(o===1&&s===1)return`
      float ${r}(int index) {
        return sampleTexture(${n}, halfCR);
      }
    `;const a=zd(n);return o===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / float(${n}TexShape[0]));
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2(0.5, (float(index + ${a}) + 0.5) / ${s}.0);
        return sampleTexture(${n}, uv);
      }
    `:s===1?e?`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / float(${n}TexShape[1]), 0.5);
        return sampleTexture(${n}, uv);
      }
    `:`
      float ${r}(int index) {
        vec2 uv = vec2((float(index + ${a}) + 0.5) / ${o}.0, 0.5);
        return sampleTexture(${n}, uv);
      }
    `:e?`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${n}TexShape[0], ${n}TexShape[1], index + ${a});
      return sampleTexture(${n}, uv);
    }
  `:`
    float ${r}(int index) {
      vec2 uv = uvFromFlat(${s}, ${o}, index + ${a});
      return sampleTexture(${n}, uv);
    }
  `}function oAe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,o=s[0],a=s[1],l=wi();if(s!=null&&Yn(n,s))return e?`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);

        return ${l.texture2D}(${r}, uv);
      }
    `:`
      vec4 ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${a}.0, ${o}.0);

        return ${l.texture2D}(${r}, uv);
      }
    `;if(e)return`
    vec4 ${i}(int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `;const c=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(n[1]/2);return`
    vec4 ${i}(int row, int col) {
      vec2 uv = packedUVfrom2D(${u}, ${c[0]}, ${c[1]}, row, col);
      return ${l.texture2D}(${r}, uv);
    }
  `}function aAe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape;if(s!=null&&Yn(n,s)){if(e)return`
      float ${i}(int row, int col) {
        vec2 uv = (vec2(col, row) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `;const f=s[0],h=s[1];return`
    float ${i}(int row, int col) {
      vec2 uv = (vec2(col, row) + halfCR) / vec2(${h}.0, ${f}.0);
      return sampleTexture(${r}, uv);
    }
  `}const{newShape:o,keptDims:a}=Uc(n),l=o;if(l.length<n.length){const f=Rp(t,l),h=["row","col"];return`
      ${Tp(f,e)}
      float ${i}(int row, int col) {
        return ${i}(${Ip(h,a)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${i}(int row, int col) {
        int index = round(dot(vec2(row, col), vec2(${n[1]}, 1)));
        ${Mp(t)}
      }
    `;const c=s[0],u=s[1],d=zd(r);return u===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2(0.5, (index + 0.5) / float(${r}TexShape[0]));
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2(0.5, (index + 0.5) / ${c}.0);
      return sampleTexture(${r}, uv);
    }
  `:c===1?e?`
      float ${i}(int row, int col) {
        float index = dot(vec3(row, col, ${d}), vec3(${r}Shape[1], 1, 1));
        vec2 uv = vec2((index + 0.5) / float(${r}TexShape[1]), 0.5);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col) {
      float index = dot(vec3(row, col, ${d}), vec3(${n[1]}, 1, 1));
      vec2 uv = vec2((index + 0.5) / ${u}.0, 0.5);
      return sampleTexture(${r}, uv);
    }
  `:e?`
      float ${i}(int row, int col) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${r}Shape[1] + col + ${d};
        vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
        return sampleTexture(${r}, uv);
      }
    `:`
  float ${i}(int row, int col) {
    // Explicitly use integer operations as dot() only works on floats.
    int index = row * ${n[1]} + col + ${d};
    vec2 uv = uvFromFlat(${c}, ${u}, index);
    return sampleTexture(${r}, uv);
  }
`}function lAe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=t.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(n[0]===1){const f=n.slice(1),h=[1,2],p=Rp(t,f),x=["b","row","col"];return`
        ${jV(p,e)}
        vec4 ${i}(int b, int row, int col) {
          return ${i}(${Ip(x,h)});
        }
      `}const a=wi();if(e)return`
    vec4 ${i}(int b, int row, int col) {
      ivec2 packedTexShape = ivec2(ceil(float(${r}TexShape[0]) / 2.0), ceil(float(${r}TexShape[1]) / 2.0));
      int valuesPerRow = int(ceil(float(${r}Shape[2]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${r}Shape[1]) / 2.0));
      vec2 uv = packedUVfrom3D(
        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `;const l=o[0],c=o[1],u=Math.ceil(n[2]/2),d=u*Math.ceil(n[1]/2);return`
    vec4 ${i}(int b, int row, int col) {
      vec2 uv = packedUVfrom3D(
        ${l}, ${c}, ${d}, ${u}, b, row, col);
      return ${a.texture2D}(${r}, uv);
    }
  `}function cAe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[1]*n[2],o=n[2],{newShape:a,keptDims:l}=Uc(n),c=a;if(c.length<n.length){const x=Rp(t,c),v=["row","col","depth"];return`
        ${Tp(x,e)}
        float ${i}(int row, int col, int depth) {
          return ${i}(${Ip(v,l)});
        }
      `}if(t.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth) {
        int index = round(dot(vec3(row, col, depth),
                          vec3(${s}, ${o}, 1)));
        ${Mp(t)}
      }
    `;const u=t.shapeInfo.texShape,d=u[0],f=u[1],h=t.shapeInfo.flatOffset;if(f===s&&h==null)return e?`
      float ${i}(int row, int col, int depth) {
        int stride1 = ${r}Shape[2];
        float texR = float(row);
        float texC = dot(vec2(col, depth), vec2(stride1, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
        float ${i}(int row, int col, int depth) {
          float texR = float(row);
          float texC = dot(vec2(col, depth), vec2(${o}, 1));
          vec2 uv = (vec2(texC, texR) + halfCR) /
                     vec2(${f}.0, ${d}.0);
          return sampleTexture(${r}, uv);
        }
      `;if(f===o&&h==null)return e?`
      float ${i}(int row, int col, int depth) {
        float texR = dot(vec2(row, col), vec2(${r}Shape[1], 1));
        float texC = float(depth);
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
    float ${i}(int row, int col, int depth) {
      float texR = dot(vec2(row, col), vec2(${n[1]}, 1));
      float texC = float(depth);
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${f}.0, ${d}.0);
      return sampleTexture(${r}, uv);
    }
  `;const p=zd(r);return e?`
    float ${i}(int row, int col, int depth) {
      // Explicitly use integer operations as dot() only works on floats.
      int stride0 = ${r}Shape[1] * ${r}Shape[2];
      int stride1 = ${r}Shape[2];
      int index = row * stride0 + col * stride1 + depth + ${p};
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index);
      return sampleTexture(${r}, uv);
    }
    `:`
      float ${i}(int row, int col, int depth) {
        // Explicitly use integer operations as dot() only works on floats.
        int index = row * ${s} + col * ${o} + depth + ${p};
        vec2 uv = uvFromFlat(${d}, ${f}, index);
        return sampleTexture(${r}, uv);
      }
  `}function uAe(t,e){const n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=wi();if(e)return`
    vec4 ${r}(int b2, int b, int row, int col) {
      int valuesPerRow = int(ceil(float(${n}Shape[3]) / 2.0));
      int texelsInBatch = valuesPerRow * int(ceil(float(${n}Shape[2]) / 2.0));
      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);
      texelsInBatch *= ${n}Shape[1];
      index = b2 * texelsInBatch + index;
      ivec2 packedTexShape = ivec2(ceil(float(${n}TexShape[0]) / 2.0), ceil(float(${n}TexShape[1]) / 2.0));
      int texR = index / packedTexShape[1];
      int texC = index - texR * packedTexShape[1];
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ${i.texture2D}(${n}, uv);
    }
  `;const s=t.shapeInfo.logicalShape,o=s.length,a=t.shapeInfo.texShape,l=[Math.ceil(a[0]/2),Math.ceil(a[1]/2)],c=l[0],u=l[1],d=Math.ceil(s[o-1]/2);let f=d*Math.ceil(s[o-2]/2),h="int b, int row, int col",p=`b * ${f} + (row / 2) * ${d} + (col / 2)`;for(let x=2;x<o-1;x++)h=`int b${x}, `+h,f*=s[o-x-1],p=`b${x} * ${f} + `+p;return`
    vec4 ${r}(${h}) {
      int index = ${p};
      int texR = index / ${u};
      int texC = index - texR * ${u};
      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${u}, ${c});
      return ${i.texture2D}(${n}, uv);
    }
  `}function dAe(t,e){const n=t.shapeInfo.logicalShape,r=t.name,i="get"+r.charAt(0).toUpperCase()+r.slice(1),s=n[3],o=n[2]*s,a=n[1]*o,{newShape:l,keptDims:c}=Uc(n);if(l.length<n.length){const b=Rp(t,l),S=["row","col","depth","depth2"];return`
      ${Tp(b,e)}
      float ${i}(int row, int col, int depth, int depth2) {
        return ${i}(${Ip(S,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${i}(int row, int col, int depth, int depth2) {
        int index = round(dot(vec4(row, col, depth, depth2),
                          vec4(${a}, ${o}, ${s}, 1)));
        ${Mp(t)}
      }
    `;const u=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,f=d[0],h=d[1],p=`int stride2 = ${r}Shape[3];`,x=`int stride1 = ${r}Shape[2] * stride2;`,v=`int stride0 = ${r}Shape[1] * stride1;`;if(h===a&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        ${p}
        ${x}
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(stride1, stride2, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = float(row);
        float texC =
            dot(vec3(col, depth, depth2),
                vec3(${o}, ${s}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;if(h===s&&u==null)return e?`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${r}Shape[1] * ${r}Shape[2], ${r}Shape[2], 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${r}TexShape[1], ${r}TexShape[0]);
        return sampleTexture(${r}, uv);
      }
    `:`
      float ${i}(int row, int col, int depth, int depth2) {
        float texR = dot(vec3(row, col, depth),
                         vec3(${n[1]*n[2]}, ${n[2]}, 1));
        float texC = float(depth2);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${f}.0);
        return sampleTexture(${r}, uv);
      }
    `;const y=zd(r);return e?`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      ${p}
      ${x}
      ${v}
      int index = row * stride0 + col * stride1 +
          depth * stride2 + depth2;
      vec2 uv = uvFromFlat(${r}TexShape[0], ${r}TexShape[1], index + ${y});
      return sampleTexture(${r}, uv);
    }
  `:`
    float ${i}(int row, int col, int depth, int depth2) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} +
          depth * ${s} + depth2;
      vec2 uv = uvFromFlat(${f}, ${h}, index + ${y});
      return sampleTexture(${r}, uv);
    }
  `}function fAe(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),i=e[4],s=e[3]*i,o=e[2]*s,a=e[1]*o,{newShape:l,keptDims:c}=Uc(e);if(l.length<e.length){const x=Rp(t,l),v=["row","col","depth","depth2","depth3"];return`
      ${Tp(x)}
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        return ${r}(${Ip(v,c)});
      }
    `}if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float index = dot(
          vec4(row, col, depth, depth2),
          vec4(${a}, ${o}, ${s}, ${i})) +
          depth3;
        ${Mp(t)}
      }
    `;const u=t.shapeInfo.flatOffset,d=t.shapeInfo.texShape,f=d[0],h=d[1];if(h===a&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
                         vec4(${o}, ${s}, ${i}, 1));
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${h}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(h===i&&u==null)return`
      float ${r}(int row, int col, int depth, int depth2, int depth3) {
        float texR = dot(
          vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]},
               ${e[2]*e[3]}, ${e[3]}, 1));
        int texC = depth3;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${h}.0, ${f}.0);
        return sampleTexture(${n}, uv);
      }
    `;const p=zd(n);return`
    float ${r}(int row, int col, int depth, int depth2, int depth3) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${a} + col * ${o} + depth * ${s} +
          depth2 * ${i} + depth3 + ${p};
      vec2 uv = uvFromFlat(${f}, ${h}, index);
      return sampleTexture(${n}, uv);
    }
  `}function hAe(t){const e=t.shapeInfo.logicalShape,n=t.name,r="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:i,keptDims:s}=Uc(e);if(i.length<e.length){const v=Rp(t,i),y=["row","col","depth","depth2","depth3","depth4"];return`
      ${Tp(v)}
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        return ${r}(${Ip(y,s)});
      }
    `}const o=e[5],a=e[4]*o,l=e[3]*a,c=e[2]*l,u=e[1]*c;if(t.shapeInfo.isUniform)return`
      float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
        int index = round(dot(
          vec4(row, col, depth, depth2),
          vec4(${u}, ${c}, ${l}, ${a})) +
          dot(
            vec2(depth3, depth4),
            vec2(${o}, 1)));
        ${Mp(t)}
      }
    `;const d=t.shapeInfo.flatOffset,f=t.shapeInfo.texShape,h=f[0],p=f[1];if(p===u&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        int texR = row;
        float texC = dot(vec4(col, depth, depth2, depth3),
          vec4(${c}, ${l}, ${a}, ${o})) +
               float(depth4);
        vec2 uv = (vec2(texC, texR) + halfCR) /
                   vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;if(p===o&&d==null)return`
      float ${r}(int row, int col, int depth,
                    int depth2, int depth3, int depth4) {
        float texR = dot(vec4(row, col, depth, depth2),
          vec4(${e[1]*e[2]*e[3]*e[4]},
               ${e[2]*e[3]*e[4]},
               ${e[3]*e[4]},
               ${e[4]})) + float(depth3);
        int texC = depth4;
        vec2 uv = (vec2(texC, texR) + halfCR) /
                  vec2(${p}.0, ${h}.0);
        return sampleTexture(${n}, uv);
      }
    `;const x=zd(n);return`
    float ${r}(int row, int col, int depth,
                  int depth2, int depth3, int depth4) {
      // Explicitly use integer operations as dot() only works on floats.
      int index = row * ${u} + col * ${c} + depth * ${l} +
          depth2 * ${a} + depth3 * ${o} + depth4 + ${x};
      vec2 uv = uvFromFlat(${h}, ${p}, index);
      return sampleTexture(${n}, uv);
    }
  `}function Mp(t){const e=t.name,n=Ve(t.shapeInfo.logicalShape);return n<2?`return ${e};`:`
    for (int i = 0; i < ${n}; i++) {
      if (i == index) {
        return ${e}[i];
      }
    }
  `}function pAe(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),i="get"+r+"AtOutCoords",s=t.shapeInfo.logicalShape.length,o=e.logicalShape.length,a=WV(t.shapeInfo.logicalShape,e.logicalShape),l=An(o),c=o-s;let u;const d=["x","y","z","w","u","v"];s===0?u="":o<2&&a.length>=1?u="coords = 0;":u=a.map(b=>`coords.${d[b+c]} = 0;`).join(`
`);let f="";o<2&&s>0?f="coords":f=t.shapeInfo.logicalShape.map((b,S)=>`coords.${d[S+c]}`).join(", ");let h="return outputValue;";const x=Ve(t.shapeInfo.logicalShape)===1,y=Ve(e.logicalShape)===1;if(s===1&&!x&&!y)h=`
      return vec4(outputValue.xy, outputValue.xy);
    `;else if(x&&!y)o===1?h=`
        return vec4(outputValue.x, outputValue.x, 0., 0.);
      `:h=`
        return vec4(outputValue.x);
      `;else if(a.length){const b=s-2,S=s-1;a.indexOf(b)>-1&&a.indexOf(S)>-1?h="return vec4(outputValue.x);":a.indexOf(b)>-1?h="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":a.indexOf(S)>-1&&(h="return vec4(outputValue.xx, outputValue.zz);")}return`
    vec4 ${i}() {
      ${l} coords = getOutputCoords();
      ${u}
      vec4 outputValue = get${r}(${f});
      ${h}
    }
  `}function mAe(t,e){const n=t.name,r=n.charAt(0).toUpperCase()+n.slice(1),i="get"+r+"AtOutCoords",s=e.texShape,o=t.shapeInfo.texShape,a=t.shapeInfo.logicalShape.length,l=e.logicalShape.length;if(!t.shapeInfo.isUniform&&a===l&&t.shapeInfo.flatOffset==null&&Yn(o,s))return`
      float ${i}() {
        return sampleTexture(${n}, resultUV);
      }
    `;const c=An(l),u=WV(t.shapeInfo.logicalShape,e.logicalShape),d=l-a;let f;const h=["x","y","z","w","u","v"];a===0?f="":l<2&&u.length>=1?f="coords = 0;":f=u.map(x=>`coords.${h[x+d]} = 0;`).join(`
`);let p="";return l<2&&a>0?p="coords":p=t.shapeInfo.logicalShape.map((x,v)=>`coords.${h[v+d]}`).join(", "),`
    float ${i}() {
      ${c} coords = getOutputCoords();
      ${f}
      return get${r}(${p});
    }
  `}function An(t){if(t<=1)return"int";if(t===2)return"ivec2";if(t===3)return"ivec3";if(t===4)return"ivec4";if(t===5)return"ivec5";if(t===6)return"ivec6";throw Error(`GPU for rank ${t} is not yet supported`)}function tN(t,e,n){const{newShape:r,keptDims:i}=Uc(e),s=e.length,o=t&&s===3&&e[0]===1,a=o?e.slice(1):r,l=!t&&s>1&&!Yn(e,n)&&r.length<s||o;return{useSqueezeShape:l,uniformShape:l?a:e,keptDims:i}}function Rp(t,e){const n=JSON.parse(JSON.stringify(t));return n.shapeInfo.logicalShape=e,n}function Ip(t,e){return e.map(n=>t[n]).join(", ")}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gAe(t,e,n,r){const i=n.map((u,d)=>{const f={logicalShape:u.shape,texShape:u.isUniform?null:u.texData.texShape,isUniform:u.isUniform,isPacked:u.isUniform?!1:u.texData.isPacked,flatOffset:null};return u.texData!=null&&u.texData.slice!=null&&u.texData.slice.flatOffset>0&&(f.flatOffset=u.texData.slice.flatOffset),{name:e.variableNames[d],shapeInfo:f}}),s=i.map(u=>u.shapeInfo),o={logicalShape:r.shape,texShape:r.texData.texShape,isUniform:!1,isPacked:r.texData.isPacked,flatOffset:null},a=DEe(i,o,e),l=cEe(t.gl,a),c=t.createProgram(l);return ge().get("ENGINE_COMPILE_ONLY")?{program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o,uniformLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,inShapesLocations:null,inTexShapesLocations:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:Object.assign({program:e,fragmentShader:l,source:a,webGLProgram:c,inShapeInfos:s,outShapeInfo:o},KV(t,e,c))}function KV(t,e,n){const r={},i={},s={},o=[];let a,l,c,u=null,d=null;d=t.getUniformLocation(n,"NAN",!1),ge().getNumber("WEBGL_VERSION")===1&&(u=t.getUniformLocation(n,"INFINITY",!1));const f=!1;for(let h=0;h<e.variableNames.length;h++){const p=e.variableNames[h];r[p]=t.getUniformLocation(n,p,f),r[`offset${p}`]=t.getUniformLocation(n,`offset${p}`,f),e.enableShapeUniforms&&(i[`${p}Shape`]=t.getUniformLocation(n,`${p}Shape`,f),s[`${p}TexShape`]=t.getUniformLocation(n,`${p}TexShape`,f))}return e.enableShapeUniforms&&(a=t.getUniformLocation(n,"outShape",f),c=t.getUniformLocation(n,"outShapeStrides",f),l=t.getUniformLocation(n,"outTexShape",f)),e.customUniforms&&e.customUniforms.forEach((h,p)=>{o[p]=t.getUniformLocation(n,h.name,f)}),{uniformLocations:r,customUniformLocations:o,infLoc:u,nanLoc:d,inShapesLocations:i,inTexShapesLocations:s,outShapeLocation:a,outShapeStridesLocation:c,outTexShapeLocation:l}}function WL(t,e){if(t.length!==e.length)throw Error(`Binary was compiled with ${t.length} inputs, but was executed with ${e.length} inputs`);t.forEach((n,r)=>{const i=n.logicalShape,s=e[r],o=s.shape;if(!Yn(i,o))throw Error(`Binary was compiled with different shapes than the current args. Shapes ${i} and ${o} must match`);if(n.isUniform&&s.isUniform)return;const a=n.texShape,l=s.isUniform?null:s.texData.texShape;if(!Yn(a,l))throw Error(`Binary was compiled with different texture shapes than the current args. Shape ${a} and ${l} must match`)})}function yAe(t,e,n,r,i){e.program.enableShapeUniforms||(WL(e.inShapeInfos,n),WL([e.outShapeInfo],[r]));const s=r.texData.texture,o=r.texData.texShape;r.texData.isPacked?t.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):t.setOutputMatrixTexture(s.texture,o[0],o[1]),t.setProgram(e.webGLProgram),ge().getNumber("WEBGL_VERSION")===1&&e.infLoc!==null&&t.gl.uniform1f(e.infLoc,1/0),e.nanLoc!==null&&t.gl.uniform1f(e.nanLoc,NaN),n.forEach((l,c)=>{const u=e.program.variableNames[c],d=e.uniformLocations[u],f=e.uniformLocations[`offset${u}`],h=e.inShapesLocations[`${u}Shape`],p=e.inTexShapesLocations[`${u}TexShape`];if(h){const{uniformShape:x}=tN(e.program.packedInputs,l.shape,l.texData.texShape);switch(x.length){case 1:t.gl.uniform1iv(h,new Int32Array(x));break;case 2:t.gl.uniform2iv(h,new Int32Array(x));break;case 3:t.gl.uniform3iv(h,new Int32Array(x));break;case 4:t.gl.uniform4iv(h,new Int32Array(x));break}}if(p&&t.gl.uniform2i(p,l.texData.texShape[0],l.texData.texShape[1]),d!=null){if(l.isUniform){if(Ve(l.shape)<2)t.gl.uniform1f(d,l.uniformValues[0]);else{let x=l.uniformValues;x instanceof Float32Array||(x=new Float32Array(x)),t.gl.uniform1fv(d,x)}return}l.texData.slice!=null&&f!=null&&t.gl.uniform1i(f,l.texData.slice.flatOffset),t.setInputMatrixTexture(l.texData.texture.texture,d,c)}});const a=e.outShapeLocation;if(a)switch(r.shape.length){case 1:t.gl.uniform1iv(a,new Int32Array(r.shape));break;case 2:t.gl.uniform2iv(a,new Int32Array(r.shape));break;case 3:t.gl.uniform3iv(a,new Int32Array(r.shape));break;case 4:t.gl.uniform4iv(a,new Int32Array(r.shape));break}if(e.outShapeStridesLocation){const l=Vr(r.shape);switch(r.shape.length){case 2:t.gl.uniform1iv(e.outShapeStridesLocation,new Int32Array(l));break;case 3:t.gl.uniform2iv(e.outShapeStridesLocation,new Int32Array(l));break;case 4:t.gl.uniform3iv(e.outShapeStridesLocation,new Int32Array(l));break}}e.outTexShapeLocation&&t.gl.uniform2i(e.outTexShapeLocation,r.texData.texShape[0],r.texData.texShape[1]),e.program.customUniforms&&i&&e.program.customUniforms.forEach((l,c)=>{const u=e.customUniformLocations[c],d=i[c];if(l.type==="float")t.gl.uniform1fv(u,d);else if(l.type==="vec2")t.gl.uniform2fv(u,d);else if(l.type==="vec3")t.gl.uniform3fv(u,d);else if(l.type==="vec4")t.gl.uniform4fv(u,d);else if(l.type==="int")t.gl.uniform1iv(u,d);else if(l.type==="ivec2")t.gl.uniform2iv(u,d);else if(l.type==="ivec3")t.gl.uniform3iv(u,d);else if(l.type==="ivec4")t.gl.uniform4iv(u,d);else throw Error(`uniform type ${l.type} is not supported yet.`)}),t.executeProgram()}function vAe(t,e,n){let r="";e.concat(n).forEach(o=>{const a=o.texData!=null&&o.texData.slice!=null&&o.texData.slice.flatOffset>0;if(t.enableShapeUniforms&&!o.isUniform){const l=o.texData.texShape,{useSqueezeShape:c,uniformShape:u,keptDims:d}=tN(t.packedInputs,o.shape,l);let f="",h="",p="";if(u.length===1&&t.packedInputs){const E=[Math.ceil(l[0]/2),Math.ceil(l[1]/2)];f=`${E[0]>1}_${E[1]>1}`}else if(u.length===2&&!t.packedInputs)h=`${u[0]>1}_${u[1]>1}`;else if(u.length>2&&!t.packedInputs){const E=Vr(u);p=`${E[0]===l[1]}_${E[E.length-1]===l[1]}`}const x=o.shape.length,v=u.length===2&&Yn(o.shape,l),y=Ve(o.shape)===1,b=K1(o.shape,n.shape),S=!t.packedInputs&&x===n.shape.length&&Yn(l,n.texData.texShape),w=t.packedInputs||u.length>2?"":`${l[0]>1}_${l[1]>1}`;r+=`${x}_${S}_${c?d:""}_${u.length}_${y}_${b}_${v}_${f}_${h}_${p}_${w}_${a}`}else{const l=o.isUniform?"uniform":o.texData.texShape;r+=`${o.shape}_${l}_${a}`}});const i=t.userCode;let s=t.constructor.name;return s+="_"+r+"_"+i+`${ge().getNumber("WEBGL_VERSION")}`,s}function Ci(t){return ge().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&t<=4}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xAe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=i0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=wi();this.outputShape=e,this.enableShapeUniforms=Ci(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?p_(["r","c","d"],e):Ud(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getA(rc.x, rc.y, rc.z);
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bAe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=i0.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=wi();this.outputShape=e,this.enableShapeUniforms=Ci(this.outputShape.length),this.userCode=`
      ivec3 outCoordsFromFlatIndex(int index) {
        ${this.enableShapeUniforms?p_(["r","c","d"],e):Ud(["r","c","d"],e)}
        return ivec3(r, c, d);
      }

      void main() {
        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));
        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);

        vec4 result = vec4(0.);

        for (int i=0; i<4; i++) {
          int flatIndex = index + i;
          ivec3 rc = outCoordsFromFlatIndex(flatIndex);
          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SAe{constructor(e){this.variableNames=["A"],this.outTexUsage=Cs.DOWNLOAD;const n=wi();this.outputShape=e,this.userCode=`
      ${VV}

      void main() {
        float x = getAAtOutCoords();
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _Ae{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=Cs.DOWNLOAD;const n=wi();this.outputShape=e,this.userCode=`
      ${VV}

      void main() {
        ivec3 coords = getOutputCoords();
        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));
        ${n.output} = encode_float(x);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wAe{constructor(e,n=!1){this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=wi();this.outputShape=e,this.enableShapeUniforms=Ci(this.outputShape.length);let i="result";n&&(i="floor(result * 255. + 0.5)"),this.userCode=`
      ${this.enableShapeUniforms?eN():ZI(e)}

      void main() {
        ivec3 coords = getOutputCoords();

        int flatIndex = getFlatIndex(coords);
        int offset = imod(flatIndex, 4);

        flatIndex = idiv(flatIndex, 4, 1.);

        int r = flatIndex / texShape[1];
        int c = imod(flatIndex, texShape[1]);
        vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
        vec4 values = ${r.texture2D}(A, uv);

        float result;

        if(offset == 0) {
          result = values[0];
        } else if(offset == 1) {
          result = values[1];
        } else if(offset == 2) {
          result = values[2];
        } else {
          result = values[3];
        }

        ${r.output} = vec4(${i}, 0., 0., 0.);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CAe{constructor(e,n=!1){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const r=wi();this.outputShape=e,this.enableShapeUniforms=Ci(this.outputShape.length);let i="",s="result";n&&(s="floor(result * 255. + 0.5)");for(let o=0;o<=1;o++)for(let a=0;a<=1;a++){const l=o*2+a;i+=`
          localCoords = coords;
          if(localCoords[2] + ${a} < ${this.enableShapeUniforms?"outShape[2]":`${e[2]}`}) {
          localCoords[2] += ${a};
          if (localCoords[1] + ${o} < ${this.enableShapeUniforms?"outShape[1]":`${e[1]}`}) {
            localCoords[1] += ${o};

            flatIndex = getFlatIndex(localCoords);
            offset = imod(flatIndex, 4);

            flatIndex = idiv(flatIndex, 4, 1.);

            int r = flatIndex / texShape[1];
            int c = imod(flatIndex, texShape[1]);
            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);
            values = ${r.texture2D}(A, uv);

            if (offset == 0) {
              result[${l}] = values[0];
            } else if (offset == 1) {
              result[${l}] = values[1];
            } else if (offset == 2) {
              result[${l}] = values[2];
            } else {
              result[${l}] = values[3];
            }
          }
        }
        `}this.userCode=`
        ${this.enableShapeUniforms?eN():ZI(e)}

        void main() {
          ivec3 coords = getOutputCoords();

          vec4 result = vec4(0.);
          int flatIndex, r, c, offset;
          ivec3 localCoords;
          vec2 uv;
          vec4 values;

          ${i}

          ${r.output} = ${s};
        }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EAe(t){const e=wi(),n=`${e.version}
    precision highp float;
    ${e.attribute} vec3 clipSpacePos;
    ${e.attribute} vec2 uv;
    ${e.varyingVs} vec2 resultUV;

    void main() {
      gl_Position = vec4(clipSpacePos, 1);
      resultUV = uv;
    }`;return lEe(t,n)}function AAe(t){const e=new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]);return hEe(t,e)}function TAe(t){const e=new Uint16Array([0,1,2,2,1,3]);return pEe(t,e)}function G0(t,e,n,r,i,s){gEe(e,n);const o=mEe(t),a=t.TEXTURE_2D;return ft(t,()=>t.bindTexture(a,o)),ft(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_S,t.CLAMP_TO_EDGE)),ft(t,()=>t.texParameteri(a,t.TEXTURE_WRAP_T,t.CLAMP_TO_EDGE)),ft(t,()=>t.texParameteri(a,t.TEXTURE_MIN_FILTER,t.NEAREST)),ft(t,()=>t.texParameteri(a,t.TEXTURE_MAG_FILTER,t.NEAREST)),ge().getNumber("WEBGL_VERSION")===1?ft(t,()=>t.texImage2D(a,0,r,e,n,0,i,s,null)):ft(t,()=>t.texStorage2D(a,1,r,e,n)),ft(t,()=>t.bindTexture(t.TEXTURE_2D,null)),{texture:o,texShape:[n,e]}}function qV(t){return t.internalFormatFloat}function MAe(t,e,n,r){const[i,s]=U0(e,n);return G0(t,i,s,qV(r),r.textureFormatFloat,t.FLOAT)}function JV(t){return t.internalFormatHalfFloat}function RAe(t,e,n,r){const[i,s]=U0(e,n);return G0(t,i,s,JV(r),r.textureFormatFloat,r.textureTypeHalfFloat)}function YV(t){return t.downloadTextureFormat}function IAe(t,e,n,r){const[i,s]=U0(e,n);return G0(t,i,s,YV(r),t.RGBA,t.UNSIGNED_BYTE)}function QV(t){return t.internalFormatPackedFloat}function NAe(t,e,n,r){const[i,s]=Ap(e,n);return G0(t,i,s,QV(r),t.RGBA,t.FLOAT)}function ZV(t){return t.internalFormatPackedHalfFloat}function PAe(t,e,n,r){const[i,s]=Ap(e,n);return G0(t,i,s,ZV(r),t.RGBA,r.textureTypeHalfFloat)}function kAe(t,e,n){return ft(t,()=>t.bindBuffer(t.ARRAY_BUFFER,n)),GL(t,e,"clipSpacePos",n,3,20,0)&&GL(t,e,"uv",n,2,20,12)}function DAe(t,e,n,r,i,s){ft(t,()=>t.bindTexture(t.TEXTURE_2D,e));let o,a,l;i instanceof Uint8Array?(o=new Uint8Array(n*r*4),a=t.UNSIGNED_BYTE,l=t.RGBA):(o=new Float32Array(n*r*4),a=t.FLOAT,l=s.internalFormatPackedFloat),o.set(i),ge().getNumber("WEBGL_VERSION")===2?ft(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n,r,t.RGBA,a,o)):ft(t,()=>t.texImage2D(t.TEXTURE_2D,0,l,n,r,0,t.RGBA,a,o)),ft(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function OAe(t,e,n){ft(t,()=>t.bindTexture(t.TEXTURE_2D,e)),n.data instanceof Uint8Array?ge().getNumber("WEBGL_VERSION")===2?ft(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,n.width,n.height,t.RGBA,t.UNSIGNED_BYTE,n.data)):ft(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,n.width,n.height,0,t.RGBA,t.UNSIGNED_BYTE,n.data)):ge().getNumber("WEBGL_VERSION")===2?ft(t,()=>t.texSubImage2D(t.TEXTURE_2D,0,0,0,t.RGBA,t.UNSIGNED_BYTE,n)):ft(t,()=>t.texImage2D(t.TEXTURE_2D,0,t.RGBA,t.RGBA,t.UNSIGNED_BYTE,n)),ft(t,()=>t.bindTexture(t.TEXTURE_2D,null))}function LAe(t,e,n,r){const i=t.createBuffer();ft(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,i));const a=4*4*e*n;return ft(t,()=>t.bufferData(t.PIXEL_PACK_BUFFER,a,t.STREAM_READ)),ft(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,0)),ft(t,()=>t.bindBuffer(t.PIXEL_PACK_BUFFER,null)),i}function BAe(t,e,n){const r=t,i=new Float32Array(n);return r.bindBuffer(r.PIXEL_PACK_BUFFER,e),r.getBufferSubData(r.PIXEL_PACK_BUFFER,0,i),r.bindBuffer(r.PIXEL_PACK_BUFFER,null),i}function FAe(t,e,n,r){const[i,s]=U0(e,n),o=4,a=new Uint8Array(tEe(e*n,o));return ft(t,()=>t.readPixels(0,0,i,s,r.downloadTextureFormat,t.UNSIGNED_BYTE,a)),new Float32Array(a.buffer)}function $Ae(t,e,n,r,i,s,o,a){const l=t,c=new Float32Array(nEe(s,o));return l.bindBuffer(l.PIXEL_PACK_BUFFER,e),l.getBufferSubData(l.PIXEL_PACK_BUFFER,0,c),l.bindBuffer(l.PIXEL_PACK_BUFFER,null),c}function UAe(t,e,n){const r=new Float32Array(e*n*4);return ft(t,()=>t.readPixels(0,0,n,e,t.RGBA,t.FLOAT,r)),r}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class _E{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.vertexAttrsAreBound=!1,this.itemsToPoll=[];const n=ge().getNumber("WEBGL_VERSION");e!=null?(this.gl=e,QCe(n,e)):this.gl=qo(n);let r="WEBGL_color_buffer_float";const i="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),ge().getNumber("WEBGL_VERSION")===1){const s="OES_texture_float",o="OES_texture_half_float";if(this.textureFloatExtension=yx(this.gl,s),ho(this.gl,o))this.textureHalfFloatExtension=yx(this.gl,o);else if(ge().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(r),ho(this.gl,i))this.colorBufferHalfFloatExtension=yx(this.gl,i);else if(ge().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(r="EXT_color_buffer_float",ho(this.gl,r))this.colorBufferFloatExtension=this.gl.getExtension(r);else if(ho(this.gl,i))this.colorBufferHalfFloatExtension=this.gl.getExtension(i);else throw new Error("GL context does not support color renderable floats");this.vertexBuffer=AAe(this.gl),this.indexBuffer=TAe(this.gl),this.framebuffer=yEe(this.gl),this.textureConfig=QI(this.gl,this.textureHalfFloatExtension)}get debug(){return ge().getBool("DEBUG")}dispose(){if(this.disposed)return;this.program!=null&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),this.outputTexture!=null&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;ft(e,()=>e.finish()),ft(e,()=>e.bindFramebuffer(e.FRAMEBUFFER,null)),ft(e,()=>e.deleteFramebuffer(this.framebuffer)),ft(e,()=>e.bindBuffer(e.ARRAY_BUFFER,null)),ft(e,()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null)),ft(e,()=>e.deleteBuffer(this.indexBuffer)),this.disposed=!0}createFloat32MatrixTexture(e,n){return this.throwIfDisposed(),MAe(this.gl,e,n,this.textureConfig)}createFloat16MatrixTexture(e,n){return this.throwIfDisposed(),RAe(this.gl,e,n,this.textureConfig)}createUnsignedBytesMatrixTexture(e,n){return this.throwIfDisposed(),IAe(this.gl,e,n,this.textureConfig)}uploadPixelDataToTexture(e,n){this.throwIfDisposed(),OAe(this.gl,e,n)}uploadDenseMatrixToTexture(e,n,r,i){this.throwIfDisposed(),DAe(this.gl,e,n,r,i,this.textureConfig)}createFloat16PackedMatrixTexture(e,n){return this.throwIfDisposed(),PAe(this.gl,e,n,this.textureConfig)}createPackedMatrixTexture(e,n){return this.throwIfDisposed(),NAe(this.gl,e,n,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(HL(this.gl,this.framebuffer),this.outputTexture=null),ft(this.gl,()=>this.gl.deleteTexture(e))}downloadByteEncodedFloatMatrixFromOutputTexture(e,n,r){return this.downloadMatrixDriver(e,()=>FAe(this.gl,n,r,this.textureConfig))}downloadPackedMatrixFromBuffer(e,n,r,i,s,o){return $Ae(this.gl,e,n,r,i,s,o,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,n){return BAe(this.gl,e,n)}createBufferFromTexture(e,n,r){this.bindTextureToFrameBuffer(e);const i=LAe(this.gl,n,r,this.textureConfig);return this.unbindTextureToFrameBuffer(),i}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let n,r;if(ge().getBool("WEBGL_FENCE_API_ENABLED")){const i=e,s=i.fenceSync(i.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),r=()=>{const o=i.clientWaitSync(s,0,0);return o===i.ALREADY_SIGNALED||o===i.CONDITION_SATISFIED},n=s}else ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(n=this.beginQuery(),this.endQuery(),r=()=>this.isQueryAvailable(n,ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):r=()=>!0;return{query:n,isFencePassed:r}}downloadMatrixFromPackedTexture(e,n,r){return this.downloadMatrixDriver(e,()=>UAe(this.gl,n,r))}createProgram(e){this.throwIfDisposed();const n=this.gl;this.vertexShader==null&&(this.vertexShader=EAe(n));const r=dEe(n);return ft(n,()=>n.attachShader(r,this.vertexShader)),ft(n,()=>n.attachShader(r,e)),fEe(n,r),this.debug&&yE(n,r),this.vertexAttrsAreBound||(this.setProgram(r),this.vertexAttrsAreBound=kAe(n,this.program,this.vertexBuffer)),r}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),e!=null&&ft(this.gl,()=>this.gl.deleteProgram(e))}setProgram(e){this.throwIfDisposed(),this.program=e,this.program!=null&&this.debug&&yE(this.gl,this.program),ft(this.gl,()=>this.gl.useProgram(e))}getUniformLocation(e,n,r=!0){return this.throwIfDisposed(),r?xEe(this.gl,e,n):bEe(this.gl,e,n)}getAttributeLocation(e,n){return this.throwIfDisposed(),ft(this.gl,()=>this.gl.getAttribLocation(e,n))}getUniformLocationNoThrow(e,n){return this.throwIfDisposed(),this.gl.getUniformLocation(e,n)}setInputMatrixTexture(e,n,r){this.throwIfDisposed(),this.throwIfNoProgram(),SEe(this.gl,e,n,r)}setOutputMatrixTexture(e,n,r){this.setOutputMatrixTextureDriver(e,r,n)}setOutputPackedMatrixTexture(e,n,r){this.throwIfDisposed();const[i,s]=Ap(n,r);this.setOutputMatrixTextureDriver(e,i,s)}setOutputMatrixWriteRegion(e,n,r,i){this.setOutputMatrixWriteRegionDriver(r,e,i,n)}setOutputPackedMatrixWriteRegion(e,n,r,i){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){this.program!=null&&yE(this.gl,this.program),vx(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;this.debug&&this.debugValidate(),ft(e,()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),ft(this.gl,()=>this.gl.finish())}getQueryTimerExtension(){return this.disjointQueryTimerExtension==null&&(this.disjointQueryTimerExtension=yx(this.gl,ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),s=r.createQuery();return r.beginQuery(i.TIME_ELAPSED_EXT,s),s}const e=this.getQueryTimerExtensionWebGL1(),n=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,n),n}endQuery(){if(ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")===2){const n=this.gl,r=this.getQueryTimerExtensionWebGL2();n.endQuery(r.TIME_ELAPSED_EXT);return}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await uL(()=>this.disposed||this.isQueryAvailable(e,ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))),this.getQueryTime(e,ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,n){if(n===0)return null;if(n===2){const r=this.gl;return r.getQueryParameter(e,r.QUERY_RESULT)/1e6}else{const r=this.getQueryTimerExtensionWebGL1();return r.getQueryObjectEXT(e,r.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,n){if(n===0)return!0;if(n===2){const r=this.gl,i=this.getQueryTimerExtensionWebGL2(),s=r.getQueryParameter(e,r.QUERY_RESULT_AVAILABLE);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(i.GPU_DISJOINT_EXT)),s&&!this.disjoint}else{const r=this.getQueryTimerExtensionWebGL1(),i=r.getQueryObjectEXT(e,r.QUERY_RESULT_AVAILABLE_EXT);return this.disjoint==null&&(this.disjoint=this.gl.getParameter(r.GPU_DISJOINT_EXT)),i&&!this.disjoint}}pollFence(e){return new Promise(n=>{this.addItemToPoll(()=>e.isFencePassed(),()=>n())})}pollItems(){const e=zAe(this.itemsToPoll.map(n=>n.isDoneFn));for(let n=0;n<=e;++n){const{resolveFn:r}=this.itemsToPoll[n];r()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,n){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:n}),this.itemsToPoll.length>1)return;let r;"setTimeoutCustom"in ge().platform&&(r=ge().platform.setTimeoutCustom.bind(ge().platform)),uL(()=>(this.pollItems(),this.itemsToPoll.length===0),()=>0,null,r)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),vE(this.gl,e,this.framebuffer),this.debug&&vx(this.gl)}unbindTextureToFrameBuffer(){this.outputTexture!=null?(vE(this.gl,this.outputTexture,this.framebuffer),this.debug&&vx(this.gl)):HL(this.gl,this.framebuffer)}downloadMatrixDriver(e,n){this.bindTextureToFrameBuffer(e);const r=n();return this.unbindTextureToFrameBuffer(),r}setOutputMatrixTextureDriver(e,n,r){this.throwIfDisposed();const i=this.gl;vE(i,e,this.framebuffer),this.debug&&vx(i),this.outputTexture=e,ft(i,()=>i.viewport(0,0,n,r)),ft(i,()=>i.scissor(0,0,n,r))}setOutputMatrixWriteRegionDriver(e,n,r,i){this.throwIfDisposed(),ft(this.gl,()=>this.gl.scissor(e,n,r,i))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(this.program==null)throw new Error("No GPU program is currently set.")}}function zAe(t){let e=0;for(;e<t.length&&t[e]();++e);return e-1}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GAe(t){const e=new Float32Array(t.length);for(let n=0;n<t.length;++n)e[n]=Math.abs(t[n]);return e}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $s(t){return(e,n,r,i,s)=>{const o=Qt(e,n),a=o.length,l=Vr(o),c=Ve(o),u=Sl(s,c),d=e.length,f=n.length,h=Vr(e),p=Vr(n),x=K1(e,o),v=K1(n,o);if(x.length+v.length===0)for(let y=0;y<u.length;++y)u[y]=t(r[y%r.length],i[y%i.length]);else for(let y=0;y<u.length;++y){const b=cI(y,a,l),S=b.slice(-d);x.forEach(T=>S[T]=0);const w=j2(S,d,h),E=b.slice(-f);v.forEach(T=>E[T]=0);const A=j2(E,f,p);u[y]=t(r[w],i[A])}return[u,o]}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HAe(t,e,n,r){if(r==="int32"){const i=Int32Array.from(t);return[e,"int32",i]}if(r==="bool"){const i=e_([0],n),[s,o]=$s((a,l)=>a!==l?1:0)(e,[],t,i,"bool");return[o,"bool",s]}throw new Error(`Error in Cast: failed to cast ${n} to ${r}`)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const VAe=$s((t,e)=>t+e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WAe(t,e,n,r,i){const s=Ve(r),o=Ic(i,n);for(let a=0;a<t.length;a++){const l=t[a];if(l<0)throw new Error("Input x must be non-negative!");l>=i||(s>0?o[l]+=e[a]:o[l]+=1)}return o}function jAe(t,e,n,r=!1){const i=t.shape[0],s=t.shape[1],o=Vn([i,n],e.dtype);for(let a=0;a<i;a++)for(let l=0;l<s;l++){const c=t.get(a,l);if(c<0)throw new Error("Input x must be non-negative!");c>=n||(r?o.set(1,a,c):e.size>0?o.set(o.get(a,c)+e.get(a,l),a,c):o.set(o.get(a,c)+1,a,c))}return o}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Hc(t){return(e,n,r)=>{const i=Sl(n,e.length);for(let s=0;s<e.length;++s)i[s]=t(e[s],r);return i}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XAe=Hc(t=>Math.ceil(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KAe(t,e,n,r){const i=Oi(n,Ve(e));if(r&&n!=="string"){let s=0;t.forEach(o=>{const a=Ve(o.shape);i.set(o.vals,s),s+=a})}else{let s=0;t.forEach(o=>{const a=n==="string"?r0(o.vals):o.vals;let l=0;for(let c=0;c<o.shape[0];++c){const u=c*e[1]+s;for(let d=0;d<o.shape[1];++d)i[u+d]=a[l++]}s+=o.shape[1]})}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qAe=$s((t,e)=>t===e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const JAe=Hc(t=>Math.exp(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YAe=Hc(t=>Math.expm1(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QAe=Hc(t=>Math.floor(t));/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZAe(t,e,n,r,i,s,o,a,l){const c=Vn([r,s],n);for(let u=0;u<r;u++){const d=[];let f=0;for(let h=0;h<i;h++){const p=t[u*i+h];f+=p*o[h],d.push(p)}if(f<0||f>=l/s)throw new Error(`Invalid indices: ${d} does not index into ${a}`);for(let h=0;h<s;h++)c.values[u*s+h]=e.get(...e.indexToLoc(f*s+h))}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function e2e(t,e,n){const r=Vn(n,t.dtype);for(let i=0;i<r.size;++i){const o=r.indexToLoc(i).slice(),a=o[0],l=o[2],c=e.locToIndex([a,l]);o[2]=e.values[c];const u=t.locToIndex(o);0<=u&&u<t.values.length&&(r.values[i]=t.values[u])}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t2e=$s((t,e)=>t>e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const n2e=$s((t,e)=>t>=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const r2e=$s((t,e)=>t<e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i2e=$s((t,e)=>t<=e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s2e(t,e,n){const r=(e-t)/(n-1),i=Ic(n,"float32");i[0]=t;for(let s=1;s<i.length;s++)i[s]=i[s-1]+r;return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const o2e=Hc(t=>Math.log(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function a2e(t,e,n,r){const i=Sl(r,Ve(n));for(let s=0;s<i.length;++s){const o=s*e;let a=t[o];for(let l=0;l<e;++l){const c=t[o+l];(Number.isNaN(c)||c>a)&&(a=c)}i[s]=a}return i}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const l2e=$s((t,e)=>Math.max(t,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c2e=$s((t,e)=>Math.min(t,e));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const e7=$s((t,e)=>t*e);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function u2e(t,e,n){const r=wp(-1,n);return e7([],e,r,t,n)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const d2e=$s((t,e)=>t!==e?1:0);/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function f2e(t,e,n,r,i){const s=e.length,o=Ve(e),a=Vr(e),l=Vr(i),c=Sl(n,Ve(i));for(let u=0;u<o;++u){const d=cI(u,s,a),f=new Array(d.length);for(let p=0;p<f.length;p++)f[p]=d[r[p]];const h=j2(f,s,l);c[h]=t[u]}return c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h2e(t,e,n,r){const[i,s]=Oa(t,r),o=Pa(e,"int32"),a=Ic(Ve(i),o),l=Ve(s);for(let c=0;c<a.length;++c){const u=c*l;let d=1;for(let f=0;f<l;++f)d*=n[u+f];a[c]=d}return{outVals:a,outShape:i,outDtype:o}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function p2e(t,e,n){t.forEach((r,i)=>{if(r<0||r>=n){const s=cI(i,e.length,Vr(e)).join(",");throw new Error(`indices[${s}] = ${r} is not in [0, ${n})`)}})}function m2e(t,e){for(let n=0;n<t.length;++n){const r=t[n],i=n===t.length-1?e:t[n+1].length;if(r.length===0)throw new Error("Ragged splits may not be empty");if(r[0]<0)throw new Error("Ragged splits must be non-negative");if(r[r.length-1]>i)throw new Error("Ragged splits must not point past values");for(let s=1;s<r.length;++s)if(r[s-1]>r[s])throw new Error("Ragged splits must be sorted in ascending order")}}function g2e(t,e,n,r){const i=[];let s=0;const o=e.length-1+n.length,a=new Array(o).fill(null).map(()=>[0]);m2e(n,r);let l=1;for(let c=0;c<e.length-1;++c){l*=e[c];const u=e[c+1];for(let d=1;d<l+1;++d)a[c].push(d*u)}for(let c=0;c<t.length;++c){let u=t[c],d=t[c]+1;for(let f=0;f<n.length;++f){const h=n[f],p=f+e.length-1;if(p>=0){const x=a[p],v=x[x.length-1]-h[u];for(let y=u;y<d;++y)a[p].push(h[y+1]+v)}u=h[u],d=h[d]}d!==u&&(i.push([u,d]),s+=d-u)}return{outSplits:a,valueSlices:i,numValues:s}}function y2e(t){const e=[];for(let n=0;n<t.length;++n){const r=t[n].length,i=Oi("int32",r);e.push(i),t[n].forEach((s,o)=>i[o]=s)}return e}function jL(t,e){const n=t.slice(0,e);for(;n.length<e;)n.push(1);for(let r=e;r<t.length;r++)n[e-1]*=t[r];return n}function v2e(t,e,n,r,i,s){const o=jL(e,2)[1],a=jL(s,2)[1];let l=0;for(const c of n)for(let u=c[0];u<c[1];++u){for(let d=0;d<r;++d)i[l*a+d]=t[u*o+d];++l}}function x2e(t,e,n,r,i){const s=e.slice();s[0]=i;const o=Oi(n,Ve(s)),a=t.length,l=a===0?0:a/e[0];return v2e(t,e,r,l,o,s),[o,s]}function b2e(t,e,n,r,i,s,o,a){if(t.length===0)throw new Error("paramsNestedSplits must be non empty");if(e[0].length===0)throw new Error("Split tensors must not be scalars");const l=e[0][0]-1;if(p2e(s,o,l),r.length===0)throw new Error("params.rank must be nonzero");const c=r[0],{outSplits:u,valueSlices:d,numValues:f}=g2e(s,o,t,c),h=y2e(u),p=x2e(n,r,i,d,f);return[h,p[0],p[1]]}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */var qs=$o;class nb{constructor(e,n,r,i,s,o,a,l,c,u){this.shape=e,this.shapeShape=n,this.values=r,this.valuesShape=i,this.valuesDType=s,this.defaultValue=o,this.defaultValueShape=a,this.rowPartitionValues=l,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=iV(u),this.raggedRank=sV(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===qs.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===qs.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const n=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case qs.VALUE_ROWIDS:return nb.getMaxWidthValueRowID(n);case qs.ROW_SPLITS:return nb.getMaxWidthRowSplit(n);default:throw new Error(`Cannot handle partition type ${qs[this.getRowPartitionTypeByDimension(e-1)]}`)}}static getMaxWidthRowSplit(e){const n=e.length;if(n===0||n===1)return 0;let r=0;for(let i=0;i<n-1;++i){const s=e[i+1]-e[i];s>r&&(r=s)}return r}static getMaxWidthValueRowID(e){const n=e.length;if(n===0)return 0;let r=0,i=e[0],s=0;for(let o=1;o<n;++o){const a=e[o];a!==i&&(i=a,s=Math.max(o-r,s),r=o)}return Math.max(n-r,s)}tensorShapeFromTensor(e,n,r=!0){if(n.length===0){if(e[0]===-1)return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return KL(e,r)}calculateOutputSize(e){const n=this.valuesShape,r=this.defaultValueShape;oV(r,n);const i=this.tensorShapeFromTensor(this.shape,this.shapeShape),o=rV(this.raggedRank,i,n);o[0]<0&&(o[0]=e);for(let a=1;a<=this.raggedRank;++a)o[a]<0&&(o[a]=this.getMaxWidth(a));return o}calculateFirstParentOutputIndex(e,n,r){const i=Math.min(e,r),s=[];let o=0;for(let a=0;a<i;++a,o+=n)s.push(o);for(let a=i;a<e;++a)s.push(-1);return Y(s.length===e,()=>"Final length of result must be equal to firstDimension."),s}calculateOutputIndexRowSplit(e,n,r,i){const s=e.length,o=[];for(let a=0;a<s-1;++a){const l=e[a+1]-e[a];let c=Math.min(i,l),u=n[a];u===-1&&(c=0);for(let d=0;d<c;++d)o.push(u),u+=r;for(let d=0;d<l-c;++d)o.push(-1)}if(s>0&&o.length!==e[s-1])throw new Error("Invalid row split size.");return o}calculateOutputIndexValueRowID(e,n,r,i){const s=e.length,o=[];if(s===0)return[];let a=0,l=e[0];if(l>=n.length)throw new Error(`Got currentValueRowId=${l}, which is not less than ${n.length}`);let c=n[l];o.push(c);for(let u=1;u<s;++u){const d=e[u];if(d===l)c>=0&&(++a,a<i?c+=r:c=-1);else{if(a=0,l=d,d>=n.length)throw new Error(`Got nextValueRowId=${d} which is not less than ${n.length}`);c=n[d]}o.push(c)}if(o.length!==e.length)throw new Error("Invalid row ids.");return o}calculateOutputIndex(e,n,r,i){const s=this.getRowPartitionTensor(e),o=this.getRowPartitionTypeByDimension(e);switch(o){case qs.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(s,n,r,i);case qs.ROW_SPLITS:if(s.length-1>n.length)throw new Error(`Row partition size is greater than output size: ${s.length-1} > ${n.length}`);return this.calculateOutputIndexRowSplit(s,n,r,i);default:throw new Error(`Unsupported partition type: ${qs[o]}`)}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(this.rowPartitionTypes.length===0)throw new Error("No row_partition_types given.");const n=this.rowPartitionTypes[0];switch(n){case qs.FIRST_DIM_SIZE:return e[0];case qs.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case qs.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error(`Cannot handle type ${qs[n]}`)}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const n=this.getFirstDimensionSize(),r=this.calculateOutputSize(n),i=new Array(this.raggedRank+1);i[i.length-1]=1;for(let l=i.length-2;l>=0;--l)i[l]=i[l+1]*r[l+1];const s=KL(r,!1),o=Oi(this.valuesDType,Ve(s));if(i[0]*r[0]>0){let l=this.calculateFirstParentOutputIndex(n,i[0],r[0]);for(let c=1;c<=this.raggedRank;++c)l=this.calculateOutputIndex(c-1,l,i[c],r[c]);this.setOutput(this.raggedRank,l,o,s)}return[s,o]}setOutput(e,n,r,i){if(r.length===0)return;const s=this.values,o=r;let a=i.slice();a=a.slice(e+1);const l=Ve(a),c=n.length;let u=this.defaultValue;if(u.length!==l&&u.length!==1){const p=this.defaultValueShape;qn(()=>{const x=Pe(u,p);u=lg(x,a).dataSync()})}let d=0,f=0,h=0;for(let p=0;p<=c;++p){let x=p<c?n[p]:-1;if(x===h){++h;continue}if(f<h){const v=s.subarray(d*l),y=o.subarray(f*l),b=(h-f)*l;XL(y,v,b)}if(p>=c){const v=r.length;x=Math.floor(v/l)}if(x>h)if(this.defaultValue.length===1)o.subarray(h*l,x*l).fill(this.defaultValue[0]),h=x;else for(;x>h;){const v=o.slice(h*l);XL(v,u,l),++h}x<0?(d=p+1,f=h):(d=p,f=h,h=f+1)}}}function XL(t,e,n){for(let r=0;r<n;r++)t[r]=e[r]}function KL(t,e){const n=[];for(let r of t){if(r<0){if(!e)throw new Error(`Dimension ${r} must be >= 0`);if(r<-1)throw new Error(`Dimension ${r} must be >= -1`);r=-1}n.push(r)}return n}function S2e(t,e,n,r,i,s,o,a,l,c){return new nb(t,e,n,r,i,s,o,a,l,c).compute()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _2e(t,e,n,r){const i=t===e,s=t<e&&n<0,o=e<t&&n>1;if(i||s||o)return Ic(0,r);const a=Math.abs(Math.ceil((e-t)/n)),l=Ic(a,r);e<t&&n===1&&(n=-1),l[0]=t;for(let c=1;c<l.length;c++)l[c]=l[c-1]+n;return l}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const w2e=Hc(t=>1/Math.sqrt(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function C2e(t,e,n,r,i,s,o,a,l,c){const u=[r/i,i],d=t.values,f=e.values;if(r===0)return Vn(n,e.dtype);const h=Vn(u,e.dtype);typeof l=="string"||typeof l=="number"?h.values.fill(l):typeof l=="boolean"&&h.values.fill(+l);for(let p=0;p<s;p++){const x=[];let v=0;for(let y=0;y<o;y++){const b=d[p*o+y];x.push(b),v+=b*a[y]}if(v<0||v>=r/i)throw new Error(`Invalid indices: ${x} does not index into ${n}`);for(let y=0;y<i;y++)c?h.values[v*i+y]+=f[p*i+y]:h.values[v*i+y]=e.rank===0?f[0]:f[p*i+y]}return h}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const E2e=Hc(t=>1/(1+Math.exp(-t)));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A2e(t,e,n,r,i){const s=CI(r,e,n),o=Ve(n),a=Vr(r);if(s){const d=EI(e,a);return i==="string"?t.slice(d,d+o):t.subarray(d,d+o)}const l=i==="string"?r0(t):t,c=Vn(r,i,l),u=Vn(n,i);for(let d=0;d<u.size;++d){const f=u.indexToLoc(d),h=f.map((p,x)=>p+e[x]);u.set(c.get(...h),...f)}return i==="string"?FV(u.values):u.values}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T2e(t,e,n,r,i,s,o){const a=e[0],l=s[0],c=new Array(l),u=new Array(a),d=e[1];if(l===0){if(a!==0)throw new Error(CV(a));const v=Oi(n,0),y=Oi(i,0);return[v,[0,d],y,c,u]}let f=!0,h=0;const p=new Array(l).fill(0);for(let v=0;v<a;++v){const y=t[v*d];if(y<0)throw new Error(EV(v,y));if(y>=l)throw new Error(AV(v,y,l));++p[y],f=f&&y>=h,h=y}let x=!0;for(let v=0;v<l;++v){const y=p[v]===0;c[v]=y,x=x&&!y,p[v]=Math.max(p[v],1),v>0&&(p[v]+=p[v-1])}if(x&&f){const v=t,y=r;for(let b=0;b<a;++b)u[b]=b;return[v,[a,d],y,c,u]}else{const v=p[l-1],y=Oi(n,v*d),b=Oi(i,v),S=new Array(l).fill(0);for(let w=0;w<a;++w){const E=t[w*d],A=S[E],T=(E===0?0:p[E-1])+A;S[E]++;for(let I=0;I<d;++I)y[T*d+I]=t[w*d+I];b[T]=r[w],u[w]=T}for(let w=0;w<l;++w)if(S[w]===0){const A=w===0?0:p[w-1];y[A*d+0]=w;for(let T=1;T<d;++T)y[A*d+T]=0;b[A]=o}return[y,[v,d],b,c,u]}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M2e(t,e,n,r,i){const s=Ve(r),o=e[0],a=i.length,l=[];let c=1,u=-1;for(let v=0;v<a;++v){const y=i[v];if(y===-1){if(u!==-1)throw new Error(TV(u,v));u=v,l.push(1)}else{if(y<0)throw new Error(MV(v,y));c*=y,l.push(y)}}if(u!==-1){if(c<=0)throw new Error(RV());const v=Math.trunc(s/c);if(c*v!==s)throw new Error(IV(r,l));l[u]=v}if(Ve(l)!==s)throw new Error(NV(r,l));const f=r.length,h=[];if(f>0){h[f-1]=1;for(let v=f-2;v>=0;--v)h[v]=h[v+1]*r[v+1]}const p=[];if(a>0){p[a-1]=1;for(let v=a-2;v>=0;--v)p[v]=p[v+1]*l[v+1]}const x=Oi(n,o*a);for(let v=0;v<o;++v){let y=0;for(let b=0;b<f;++b)y+=t[v*f+b]*h[b];for(let b=0;b<a;++b)x[v*a+b]=Math.trunc(y/p[b]),y%=p[b]}return[x,[o,a],l]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function R2e(t,e,n,r,i,s=!1,o=0){const a=r.length,l=[e[0],t.length/e[0]],c=l[1],d=a>0?i[a-1]+1:0;if(d<0)throw new Error(yT());const f=e.slice();f[0]=d;const h=f.reduce((S,w)=>S*w,1),p=Oi(n,h);if(a===0)return d>0&&p.fill(o),[p,f];if(d<=0)throw new Error(yT());let x=0,v=1,y=0,b=i[x];for(;;){let S=0;if(v<a){if(S=i[v],b===S){++v;continue}if(b>=S)throw new Error(PV())}if(b<0||b>=d)throw new Error(kV(b,d));b>y&&p.fill(o,y*c,b*c);for(let w=x;w<v;++w){const E=r[w];if(E<0||E>=l[0])throw new Error(DV(w,r[w],l[0]));for(let A=0;A<c;A++)p[b*c+A]+=t[E*c+A]}if(s)for(let w=0;w<c;w++)p[b*c+w]/=v-x;if(x=v,++v,y=b+1,b=S,v>a)break}return y<d&&p.fill(o,y*c,d*c),[p,f]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const I2e=Hc(t=>Math.sqrt(t));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N2e=$s((t,e)=>{const n=t-e;return n*n});/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P2e(t,e,n,r){const i=Vn(t,e.dtype);for(let s=0;s<i.size;s++){const o=i.indexToLoc(s),a=new Array(o.length);for(let l=0;l<a.length;l++)a[l]=o[l]*n[l]+r[l];i.set(e.get(...a),...o)}return i}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class k2e{constructor(e,n,r,i,s,o){this.separator=ed(e),this.nGramWidths=n,this.leftPad=ed(r),this.rightPad=ed(i),this.padWidth=s,this.preserveShort=o}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,n){const r=this.getPadWidth(n);return Math.max(0,e+2*r-n+1)}createNGrams(e,n,r,i,s,o){for(let a=0;a<s;++a){const l=this.getPadWidth(o),c=Math.max(0,l-a),u=Math.max(0,l-(s-(a+1))),d=o-(c+u),f=n+(c>0?0:a-l);let h=0;h+=c*this.leftPad.length;for(let b=0;b<d;++b)h+=e[f+b].length;h+=u*this.rightPad.length;const p=c+u+d-1;h+=p*this.separator.length,r[i+a]=new Uint8Array(h);const x=r[i+a];let v=0;const y=b=>b.forEach(S=>x[v++]=S);for(let b=0;b<c;++b)y(this.leftPad),y(this.separator);for(let b=0;b<d-1;++b)y(e[f+b]),y(this.separator);if(d>0){y(e[f+d-1]);for(let b=0;b<u;++b)y(this.separator),y(this.rightPad)}else{for(let b=0;b<u-1;++b)y(this.rightPad),y(this.separator);y(this.rightPad)}}}compute(e,n){const r=e.length,i=n.length;if(i>0){let l=n[0];if(l!==0)throw new Error(`First split value must be 0, got ${l}`);for(let c=1;c<i;++c){let u=n[c]>=l;if(u=u&&n[c]<=r,!u)throw new Error(`Invalid split value ${n[c]}, must be in [${l}, ${r}]`);l=n[c]}if(l!==r)throw new Error(`Last split value must be data size. Expected ${r}, got ${l}`)}const s=i-1,o=Oi("int32",i);if(r===0||i===0){const l=new Array(r);for(let c=0;c<=s;++c)o[c]=0;return[l,o]}o[0]=0;for(let l=1;l<=s;++l){const c=n[l]-n[l-1];let u=0;this.nGramWidths.forEach(d=>{u+=this.getNumNGrams(c,d)}),this.preserveShort&&c>0&&u===0&&(u=1),o[l]=o[l-1]+u}const a=new Array(o[s]);for(let l=0;l<s;++l){const c=n[l];let u=o[l];if(this.nGramWidths.forEach(d=>{const f=n[l+1]-n[l],h=this.getNumNGrams(f,d);this.createNGrams(e,c,a,u,h,d),u+=h}),this.preserveShort&&u===o[l]){const d=n[l+1]-n[l];if(d===0)continue;const f=d+2*this.padWidth;this.createNGrams(e,c,a,u,1,f)}}return[a,o]}}function D2e(t,e,n,r,i,s,o,a){return new k2e(n,r,i,s,o,a).compute(t,e)}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function O2e(t,e,n,r){if(!t.length)return;if(e.length===0){for(let s=0;s<t.length;++s)r.push(t.subarray(s,s+1));return}if(e.length===1){const s=e[0];let o=t.indexOf(s);for(;o!==-1;){const a=t.subarray(0,o);(!n||a.length!==0)&&r.push(a),t=t.subarray(o+1),o=t.indexOf(s)}(!n||t.length!==0)&&r.push(t);return}let i=0;for(let s=0;s<t.length+1;s++)if(s===t.length||e.indexOf(t[s])!==-1){const o=t.subarray(i,s);(!n||o.length!==0)&&r.push(o),i=s+1}}function L2e(t,e,n){const r=t.length,i=[];let s=0,o=0;const a=new Array(r);for(let f=0;f<r;++f){const h=i.length;O2e(t[f],e,n,i);const p=i.length-h;a[f]=p,s+=p,o=Math.max(o,p)}const l=Oi("int32",s*2),c=new Array(s),u=[r,o];let d=0;for(let f=0;f<r;++f)for(let h=0;h<a[f];++h)l[d*2]=f,l[d*2+1]=h,c[d]=i[d],++d;return[l,c,u]}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function B2e(t,e){const n=Oi("int32",t.length);for(let r=0;r<t.length;++r)n[r]=age(t[r]).modulo(e).getLowBitsUnsigned();return n}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const F2e=$s((t,e)=>t-e);/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function $2e(t,e){const n=new Array(t.rank);for(let i=0;i<n.length;i++)n[i]=t.shape[i]*e[i];const r=Vn(n,t.dtype);for(let i=0;i<r.values.length;++i){const s=r.indexToLoc(i),o=new Array(t.rank);for(let l=0;l<o.length;l++)o[l]=s[l]%t.shape[l];const a=t.locToIndex(o);r.values[i]=t.values[a]}return r}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vm=(t,e)=>{const n=e.value-t.value;return n===0?t.index-e.index:n};function t7(t,e,n=0,r=t.length-1){for(;r>n;){if(r-n>600){const a=r-n+1,l=e-n+1,c=Math.log(a),u=.5*Math.exp(2*c/3),d=.5*Math.sqrt(c*u*(a-u)/a)*Math.sign(l-a/2),f=Math.max(n,Math.floor(e-l*u/a+d)),h=Math.min(r,Math.floor(e+(a-l)*u/a+d));t7(t,e,f,h)}const i=t[e];let s=n,o=r;for(Mm(t,n,e),Vm(t[r],i)>0&&Mm(t,n,r);s<o;){for(Mm(t,s,o),s++,o--;Vm(t[s],i)<0;)s=s+1;for(;Vm(t[o],i)>0;)o=o-1}Vm(t[n],i)===0?Mm(t,n,o):(o=o+1,Mm(t,o,r)),o<=e&&(n=o+1),e<=o&&(r=o-1)}}function U2e(t,e,n,r,i){const s=e[e.length-1],[o,a]=[t.length/s,s],l=Sl(n,o*r),c=Sl("int32",o*r);for(let d=0;d<o;d++){const f=d*a,h=t.subarray(f,f+a);let p=new Array(h.length);h.forEach((b,S)=>p[S]={value:b,index:S}),r<p.length&&(t7(p,r),p=p.slice(0,r)),i&&p.sort(Vm);const x=d*r,v=l.subarray(x,x+r),y=c.subarray(x,x+r);for(let b=0;b<r;b++)v[b]=p[b].value,y[b]=p[b].index}const u=e.slice();return u[u.length-1]=r,[Vn(u,n,l),Vn(u,"int32",c)]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function z2e(t,e,n,r){const i=Dr(e,n)[0],s=[1,n[0],1];for(let p=0;p<i;p++)s[0]*=n[p];s[1]=n[i];for(let p=i+1;p<n.length;p++)s[2]*=n[p];const o={},a=new Int32Array(n[i]),l=new Yg(s,r,t),c=[],u=s[0]===1&&s[2]===1;for(let p=0;p<n[i];p++){let x;if(u)x=t[p].toString();else{const v=[];for(let y=0;y<s[0];y++)for(let b=0;b<s[2];b++)v.push(l.get(y,p,b));x=v.join(",")}if(o[x]!==void 0)a[p]=o[x];else{const v=Object.keys(o).length;o[x]=v,a[p]=v,c.push(p)}}const d=s.slice();d[1]=Object.keys(o).length;const f=new Yg(d,r);c.forEach((p,x)=>{for(let v=0;v<s[0];v++)for(let y=0;y<s[2];y++)f.set(l.get(v,p,y),v,x,y)});const h=n.slice();return h[i]=d[1],{outputValues:f.values,outputShape:h,indices:a}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const G2e=Object.freeze(Object.defineProperty({__proto__:null,addImpl:VAe,bincountImpl:WAe,bincountReduceImpl:jAe,castImpl:HAe,ceilImpl:XAe,concatImpl:KAe,equalImpl:qAe,expImpl:JAe,expm1Impl:YAe,floorImpl:QAe,gatherNdImpl:ZAe,gatherV2Impl:e2e,greaterEqualImpl:n2e,greaterImpl:t2e,lessEqualImpl:i2e,lessImpl:r2e,linSpaceImpl:s2e,logImpl:o2e,maxImpl:a2e,maximumImpl:l2e,minimumImpl:c2e,multiplyImpl:e7,negImpl:u2e,notEqualImpl:d2e,prodImpl:h2e,raggedGatherImpl:b2e,raggedTensorToTensorImpl:S2e,rangeImpl:_2e,rsqrtImpl:w2e,scatterImpl:C2e,sigmoidImpl:E2e,simpleAbsImpl:GAe,sliceImpl:A2e,sparseFillEmptyRowsImpl:T2e,sparseReshapeImpl:M2e,sparseSegmentReductionImpl:R2e,sqrtImpl:I2e,squaredDifferenceImpl:N2e,stridedSliceImpl:P2e,stringNGramsImpl:D2e,stringSplitImpl:L2e,stringToHashBucketFastImpl:B2e,subImpl:F2e,tileImpl:$2e,topKImpl:U2e,transposeImpl:f2e,uniqueImpl:z2e},Symbol.toStringTag,{value:"Module"}));/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const{addImpl:H2e,bincountImpl:n7,bincountReduceImpl:V2e,castImpl:W2e,ceilImpl:j2e,concatImpl:X2e,equalImpl:K2e,expImpl:q2e,expm1Impl:J2e,floorImpl:Y2e,gatherNdImpl:Q2e,gatherV2Impl:Z2e,greaterImpl:eTe,greaterEqualImpl:tTe,lessImpl:nTe,lessEqualImpl:rTe,linSpaceImpl:iTe,logImpl:sTe,maxImpl:oTe,maximumImpl:aTe,minimumImpl:lTe,multiplyImpl:cTe,negImpl:uTe,notEqualImpl:dTe,prodImpl:fTe,raggedGatherImpl:hTe,raggedTensorToTensorImpl:pTe,rangeImpl:mTe,rsqrtImpl:gTe,scatterImpl:yTe,sigmoidImpl:vTe,simpleAbsImpl:r7,sliceImpl:xTe,sparseFillEmptyRowsImpl:bTe,sparseReshapeImpl:STe,sparseSegmentReductionImpl:i7,sqrtImpl:_Te,stridedSliceImpl:wTe,stringNGramsImpl:CTe,stringSplitImpl:ETe,stringToHashBucketFastImpl:ATe,subImpl:TTe,tileImpl:MTe,topKImpl:RTe,transposeImpl:nN,uniqueImpl:ITe}=G2e;/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function s7(t,e){return["x","y","z","w","u","v"].slice(0,e).map(n=>`${t}.${n}`)}function yi(t,e){return e===1?[t]:s7(t,e)}function NTe(t,e){if(t===1)return"rc";let n="";for(let r=0;r<t;r++)n+=e[r],r<t-1&&(n+=",");return n}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PTe{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=Ci(this.outputShape.length),this.rank===0)this.userCode=`
        void main() {
          setOutput(vec4(getA(), 0., 0., 0.));
        }
      `;else{const n=yi("rc",this.rank),r=An(this.rank),i=this.getOutOfBoundsCondition(n),s=this.getSetup(n),o=this.getOutput(n);this.userCode=`
        void main() {
          ${r} rc = getOutputCoords();

          if(${i}) {
            setOutput(vec4(0));
          } else {
            ${s}

            setOutput(vec4(${o}));
          }
        }
      `}}getSourceCoordsArr(e){const n=[];for(let r=0;r<=1;r++)for(let i=0;i<=1;i++){let s=`${r===0?"r":"rp1"}, ${i===0?"c":"cp1"}`;for(let o=2;o<this.rank;o++)s=`${e[e.length-1-o]},`+s;n.push(s)}return n}getOutOfBoundsCondition(e){if(this.rank===1)return`rc > ${this.enableShapeUniforms?"outShape":this.outputShape[0]}`;let n="";for(let r=this.rank-2;r<this.rank;r++)n+=`${e[r]} >= ${this.enableShapeUniforms?`outShape[${r}]`:this.outputShape[r]}`,r<this.rank-1&&(n+="||");return n}getSetup(e){if(this.rank===1)return"";const n=e.slice(-2),r=this.enableShapeUniforms?`outShape[${this.rank} - 1]`:this.outputShape[this.rank-1],i=this.enableShapeUniforms?`outShape[${this.rank} - 2]`:this.outputShape[this.rank-2];return`
      int r = ${n[0]};
      int c = ${n[1]};
      int rp1 = r + 1;
      int cp1 = c + 1;

      bool cEdge = cp1 >= ${r};
      bool rEdge = rp1 >= ${i};
    `}getOutput(e){const n=this.getSourceCoordsArr(e);return this.rank===1?`getA(rc), (rc + 1 >= ${this.enableShapeUniforms?"outShape":this.outputShape[0]} ? 0. : getA(rc + 1)), 0, 0`:`getA(${n[0]}),
            cEdge ? 0. : getA(${n[1]}),
            rEdge ? 0. : getA(${n[2]}),
            rEdge || cEdge ? 0. : getA(${n[3]})`}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o7{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=Ci(this.outputShape.length);let r="";for(let i=0;i<4;i++){let s="thisRC = rc;";i%2===1&&(s+="thisRC.z += 1;"),i>1&&(s+="thisRC.y += 1;"),r+=`
        ${s}
        ${i>0?"if(thisRC.y < rows && thisRC.z < cols){":""}
          int flatIndex = getFlatIndex(thisRC);

          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);
          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));

          result[${i}] =
            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);
        ${i>0?"}":""}
      `}this.userCode=`
      ${kTe(n,this.enableShapeUniforms)}
      ${this.enableShapeUniforms?eN():ZI(e)}

      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0.);

        ivec3 thisRC;
        int rows = ${this.enableShapeUniforms?"outShape[1]":e[1]};
        int cols = ${this.enableShapeUniforms?"outShape[2]":e[2]};

        ${r}

        setOutput(result);
      }
    `}}function kTe(t,e){return`
    ivec3 inputCoordsFromReshapedOutCoords(int index) {
      ${e?kEe(["r","c","d"],"inputShape"):Ud(["r","c","d"],t)}
      return ivec3(r, c, d);
    }
  `}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class DTe{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.logEnabled=!1,this.usedTextures={}}acquireTexture(e,n,r){const i=JL(n,r),s=YL(e,i,r);s in this.freeTextures||(this.freeTextures[s]=[]),s in this.usedTextures||(this.usedTextures[s]=[]);const o=qL(e,i,this.gpgpu.gl,this.gpgpu.textureConfig,r);if(this.freeTextures[s].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=o,this.log();const l=this.freeTextures[s].shift();return this.usedTextures[s].push(l),l}let a;return i===Ur.PACKED_2X2_FLOAT32?a=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):i===Ur.PACKED_2X2_FLOAT16?a=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):i===Ur.UNPACKED_FLOAT32?a=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):i===Ur.UNPACKED_FLOAT16?a=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):i===Ur.PACKED_4X1_UNSIGNED_BYTE&&(a=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[s].push(a),this.numUsedTextures++,this._numBytesAllocated+=o,this.log(),a}releaseTexture(e,n,r,i){if(this.freeTextures==null)return;const s=JL(r,i),o=YL(n,s,i);o in this.freeTextures||(this.freeTextures[o]=[]);const a=qL(n,s,this.gpgpu.gl,this.gpgpu.textureConfig,i),l=ge().get("WEBGL_DELETE_TEXTURE_THRESHOLD");l!==-1&&this._numBytesAllocated>l?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=a):(this.freeTextures[o].push(e),this.numFreeTextures++,this._numBytesFree+=a),this.numUsedTextures--;const c=this.usedTextures[o],u=c.indexOf(e);if(u<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c.splice(u,1),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used",`${this.numFreeTextures} / ${this.numUsedTextures}`,`(${e})`);const n=this._numBytesFree/this._numBytesAllocated;console.log(`Bytes allocated: ${this._numBytesAllocated}`),console.log(`Bytes unused: ${this._numBytesFree} (${Math.round(100*n)}%)`)}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(this.freeTextures!=null){for(const e in this.freeTextures)this.freeTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});for(const e in this.usedTextures)this.usedTextures[e].forEach(n=>{this.gpgpu.deleteMatrixTexture(n.texture)});this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function OTe(t,e){const n=t;if(e===n.R32F)return 4;if(e===n.R16F)return 2;if(e===n.RGBA32F)return 16;if(e===t.RGBA)return 16;if(e===n.RGBA16F)return 8;if(e===n.RGBA8)return 4;throw new Error(`Unknown internal format ${e}`)}function qL(t,e,n,r,i){const s=LTe(e,r);let o;if(i){const[l,c]=Ap(t[0],t[1]);o=l*c}else{const[l,c]=U0(t[0],t[1]);o=l*c}const a=OTe(n,s);return o*a}function LTe(t,e){switch(t){case Ur.PACKED_2X2_FLOAT32:return QV(e);case Ur.PACKED_2X2_FLOAT16:return ZV(e);case Ur.UNPACKED_FLOAT32:return qV(e);case Ur.UNPACKED_FLOAT16:return JV(e);case Ur.PACKED_4X1_UNSIGNED_BYTE:return YV(e);default:throw new Error(`Unknown physical texture type ${t}`)}}function BTe(t){return ge().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?t?Ur.PACKED_2X2_FLOAT32:Ur.UNPACKED_FLOAT32:t?Ur.PACKED_2X2_FLOAT16:Ur.UNPACKED_FLOAT16}function JL(t,e){if(t===Cs.UPLOAD)return Ur.PACKED_2X2_FLOAT32;if(t===Cs.RENDER||t==null)return BTe(e);if(t===Cs.DOWNLOAD||t===Cs.PIXELS)return Ur.PACKED_4X1_UNSIGNED_BYTE;throw new Error(`Unknown logical texture type ${t}`)}function YL(t,e,n){return`${t[0]}_${t[1]}_${e}_${n}`}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class al{constructor(e,n){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=Ci(this.outputShape.length),this.userCode=`
      float unaryOperation(float x) {
        ${n}
      }

      void main() {
        float x = getAAtOutCoords();
        float y = unaryOperation(x);

        setOutput(y);
      }
    `}}const Co="if (isnan(x)) return x;",FTe="return x;",QL="return abs(x);",$Te="return (x >= 0.0) ? x : (exp(x) - 1.0);",UTe=Co+`
  return (x < 0.0) ? 0.0 : x;
`,zTe=Co+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Df="return x;",GTe="return 1.0 / (1.0 + exp(-1.0 * x));";/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HTe="return x;",VTe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,WTe=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,jTe=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,XTe="return 1.0 / (1.0 + exp(-1.0 * x));";class Hu{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=Ci(this.outputShape.length),this.userCode=`
      vec4 unaryOperation(vec4 x) {
        ${n}
      }

      void main() {
        vec4 x = getAAtOutCoords();
        vec4 y = unaryOperation(x);

        setOutput(y);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class KTe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=Ci(this.outputShape.length);const n=e.length,r=yi("rc",n),i=An(n),s=NTe(n,r),o=r.slice(-2),a=n<=1?"rc":`vec2(${o.join(",")})`;this.userCode=`
      void main() {
        ${i} rc = getOutputCoords();
        vec4 packedInput = getA(${s});

        setOutput(getChannel(packedInput, ${a}));
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qTe=KH,JTe=1e-7,YTe=1e-4,bx={};function QTe(t){return t in bx||(bx[t]={}),bx[t]}const ZTe=ge().getNumber("CPU_HANDOFF_SIZE_THRESHOLD"),eMe=600;function tMe(){return ge().global.screen==null?1024:ge().global.screen.height*ge().global.screen.width*window.devicePixelRatio*eMe/1024/1024}class m_ extends E6{constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!ge().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let n;if(e!=null){if(e instanceof _E)n=e;else{const r=qo(ge().getNumber("WEBGL_VERSION"),e);n=new _E(r)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const r=qo(ge().getNumber("WEBGL_VERSION"));n=new _E(r),this.binaryCache=QTe(ge().getNumber("WEBGL_VERSION")),this.gpgpuCreatedLocally=!0}this.gpgpu=n,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new DTe(this.gpgpu),this.numMBBeforeWarning=tMe(),this.texData=new Tme(this,kf())}nextDataId(){return m_.nextDataId++}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}write(e,n,r){if((ge().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||ge().getBool("DEBUG"))&&this.checkNumericalProblems(e),r==="complex64"&&e!=null)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const i={id:this.nextDataId()};return this.texData.set(i,{shape:n,dtype:r,values:e,usage:Cs.UPLOAD,refCount:1}),i}refCount(e){return this.texData.has(e)?this.texData.get(e).refCount:0}incRef(e){const n=this.texData.get(e);n.refCount++}decRef(e){if(this.texData.has(e)){const n=this.texData.get(e);n.refCount--}}move(e,n,r,i,s){if(ge().getBool("DEBUG")&&this.checkNumericalProblems(n),i==="complex64")throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:r,dtype:i,values:n,usage:Cs.UPLOAD,refCount:s})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const n=this.texData.get(e),{values:r,dtype:i,complexTensorInfos:s,slice:o,shape:a,isPacked:l}=n;if(o!=null){let f;l?f=new Hu(a,Df):f=new al(a,Df);const h=this.runWebGLProgram(f,[{dataId:e,shape:a,dtype:i}],i),p=this.readSync(h.dataId);return this.disposeIntermediateTensorInfo(h),p}if(r!=null)return this.convertAndCacheOnCPU(e);if(i==="string")return r;const c=this.activeTimers!=null;let u;c&&(u=Oo());let d;if(i==="complex64"){const f=this.readSync(s.real.dataId),h=this.readSync(s.imag.dataId);d=gT(f,h)}else d=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=Oo()-u),this.convertAndCacheOnCPU(e,d)}async read(e){if(this.pendingRead.has(e)){const p=this.pendingRead.get(e);return new Promise(x=>p.push(x))}const n=this.texData.get(e),{values:r,shape:i,slice:s,dtype:o,complexTensorInfos:a,isPacked:l}=n;if(s!=null){let p;l?p=new Hu(i,Df):p=new al(i,Df);const x=this.runWebGLProgram(p,[{dataId:e,shape:i,dtype:o}],o),v=this.read(x.dataId);return this.disposeIntermediateTensorInfo(x),v}if(r!=null)return this.convertAndCacheOnCPU(e);if(ge().getBool("DEBUG")&&!ge().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&ge().getNumber("WEBGL_VERSION")===2)throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c=null,u;if(o!=="complex64"&&ge().get("WEBGL_BUFFER_SUPPORTED")){u=this.decode(e);const p=this.texData.get(u.dataId);c=this.gpgpu.createBufferFromTexture(p.texture.texture,...gx(i))}this.pendingRead.set(e,[]),o!=="complex64"&&await this.gpgpu.createAndWaitForFence();let d;if(o==="complex64"){const p=await Promise.all([this.read(a.real.dataId),this.read(a.imag.dataId)]),x=p[0],v=p[1];d=gT(x,v)}else if(c==null)d=this.getValuesFromTexture(e);else{const p=Ve(i);d=this.gpgpu.downloadFloat32MatrixFromBuffer(c,p)}if(u!=null&&this.disposeIntermediateTensorInfo(u),c!=null){const p=this.gpgpu.gl;ft(p,()=>p.deleteBuffer(c))}const f=this.convertAndCacheOnCPU(e,d),h=this.pendingRead.get(e);return this.pendingRead.delete(e),h.forEach(p=>p(f)),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&kf().removeDataId(e,this),this.pendingDeletes--),f}readToGPU(e,n={}){const r=this.texData.get(e),{values:i,shape:s,slice:o,dtype:a,isPacked:l,texture:c}=r;if(a==="complex64")throw new Error("Does not support reading texture for complex64 dtype.");if(o!=null){let h;l?h=new Hu(s,Df):h=new al(s,Df);const p=this.runWebGLProgram(h,[{dataId:e,shape:s,dtype:a}],a),x=this.readToGPU(p,n);return this.disposeIntermediateTensorInfo(p),x}if(c==null)throw i!=null?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const u=this.decode(e,n.customTexShape),d=kf().makeTensorFromTensorInfo(u),f=this.texData.get(u.dataId);return Object.assign({tensorRef:d},f.texture)}bufferSync(e){const n=this.readSync(e.dataId);if(e.dtype==="string")try{const r=n.map(i=>Qh(i));return Vn(e.shape,e.dtype,r)}catch{throw new Error("Failed to decode encoded string bytes into utf-8")}return Vn(e.shape,e.dtype,n)}checkNumericalProblems(e){if(e!=null)for(let n=0;n<e.length;n++){const r=e[n];if(!oEe(r))throw ge().getBool("WEBGL_RENDER_FLOAT32_CAPABLE")?Error(`The value ${r} cannot be represented with your current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'`):Error(`The value ${r} cannot be represented on this device.`)}}getValuesFromTexture(e){const{shape:n,dtype:r,isPacked:i}=this.texData.get(e),s=Ve(n);if(ge().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const f=this.decode(e),h=this.texData.get(f.dataId),p=this.gpgpu.downloadMatrixFromPackedTexture(h.texture.texture,...gx(n)).subarray(0,s);return this.disposeIntermediateTensorInfo(f),p}const o=ge().getBool("WEBGL_PACK")&&i===!0,a=o?xE(n):n,l=o?new _Ae(a):new SAe(a),c=this.runWebGLProgram(l,[{shape:a,dtype:r,dataId:e}],"float32"),u=this.texData.get(c.dataId),d=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(u.texture.texture,u.texShape[0],u.texShape[1]).subarray(0,s);return this.disposeIntermediateTensorInfo(c),d}timerAvailable(){return ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const n=this.activeTimers,r=[];let i=!1;this.programTimersStack==null?(this.programTimersStack=r,i=!0):this.activeTimers.push(r),this.activeTimers=r,e();const s=Kh(this.activeTimers.map(l=>l.query)).filter(l=>l!=null),o=Kh(this.activeTimers.map(l=>l.name)).filter(l=>l!=null);this.activeTimers=n,i&&(this.programTimersStack=null);const a={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const l=await Promise.all(s);a.kernelMs=Mme(l),a.getExtraProfileInfo=()=>l.map((c,u)=>({name:o[u],ms:c})).map(c=>`${c.name}: ${c.ms}`).join(", ")}else a.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,a})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:Oo(),endMs:null}}endTimer(e){return ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=Oo(),e)}async getQueryTime(e){if(ge().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const n=e;return n.endMs-n.startMs}disposeData(e,n=!1){if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(n?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!n&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:r}=this.texData.get(e);return r!=null&&(this.disposeData(r.real.dataId,n),this.disposeData(r.imag.dataId,n)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:n,dtype:r,texShape:i,usage:s,isPacked:o,slice:a}=this.texData.get(e),l=a&&a.origDataId||e,c=this.dataRefCount.get(l);c>1?this.dataRefCount.set(l,c-1):(this.dataRefCount.delete(l),n!=null&&(this.numBytesInGPU-=this.computeBytes(i,r),this.textureManager.releaseTexture(n,i,s,o)));const u=this.texData.get(e);u.texture=null,u.texShape=null,u.isPacked=!1,u.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e,n=ZTe){return ge().getBool("WEBGL_CPU_FORWARD")&&e.every(r=>this.texData.get(r.dataId).texture==null&&Ve(r.shape)<n)}getGPGPUContext(){return this.gpgpu}where(e){zo("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const n=e.dataSync();return qTe(e.shape,n)}packedUnaryOp(e,n,r){const i=new Hu(e.shape,n),s=this.compileAndRun(i,[e],r);return kf().makeTensorFromTensorInfo(s)}abs(e){if(this.shouldExecuteOnCPU([e])&&e.dtype!=="complex64"){const i=r7(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,i)}if(ge().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,QL,e.dtype);const n=new al(e.shape,QL),r=this.compileAndRun(n,[e]);return kf().makeTensorFromTensorInfo(r)}makeTensorInfo(e,n,r){let i;if(n==="string"&&r!=null&&r.length>0&&YS(r[0])){const s=r.map(o=>ed(o));i=this.write(s,e,n)}else i=this.write(r,e,n);return this.texData.get(i).usage=null,{dataId:i,shape:e,dtype:n}}makeOutput(e,n,r){return kf().makeTensorFromTensorInfo(this.makeTensorInfo(e,n,r),this)}unpackTensor(e){const n=new KTe(e.shape);return this.runWebGLProgram(n,[e],e.dtype)}packTensor(e){const n=new PTe(e.shape);return this.runWebGLProgram(n,[e],e.dtype,null,!0)}packedReshape(e,n){const r=[np(e.shape),...rp(e.shape)],i={dtype:e.dtype,shape:r,dataId:e.dataId},s=[np(n),...rp(n)],o=new o7(s,r),a=!0,l=[r],c=this.runWebGLProgram(o,[i],e.dtype,l,a);return{dataId:c.dataId,shape:n,dtype:c.dtype}}decode(e,n){const r=this.texData.get(e),{isPacked:i,shape:s,dtype:o}=r;if(n!=null){const f=Ve(s),h=n[0]*n[1]*4;Y(f<=h,()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data.")}const a=xE(s);let l;i?l=new bAe(a):l=new xAe(a);const c=!0,u=[n??gx(a)],d=this.runWebGLProgram(l,[{shape:a,dtype:o,dataId:e}],o,u,c,n);return{dtype:o,shape:s,dataId:d.dataId}}runWebGLProgram(e,n,r,i,s=!1,o){const a=this.makeTensorInfo(e.outputShape,r),l=this.texData.get(a.dataId);if(e.packedOutput&&(l.isPacked=!0),e.outPackingScheme===i0.DENSE){const y=o??gx(e.outputShape);l.texShape=y.map(b=>b*2)}if(e.outTexUsage!=null&&(l.usage=e.outTexUsage),Ve(a.shape)===0)return l.values=Sl(a.dtype,0),a;const c=[],u=n.map(y=>{if(y.dtype==="complex64")throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let b=this.texData.get(y.dataId);if(b.texture==null){if(!e.packedInputs&&Ve(y.shape)<=ge().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:y.shape,texData:null,isUniform:!0,uniformValues:b.values};e.packedInputs&&(b.isPacked=!0,b.shape=y.shape)}if(this.uploadToGPU(y.dataId),!!b.isPacked!=!!e.packedInputs)y=b.isPacked?this.unpackTensor(y):this.packTensor(y),c.push(y),b=this.texData.get(y.dataId);else if(b.isPacked&&!tb(b.shape,y.shape)){const S=y,w=y.shape;y.shape=b.shape,y=this.packedReshape(y,w),c.push(y),b=this.texData.get(y.dataId),S.shape=w}return{shape:y.shape,texData:b,isUniform:!1}});this.uploadToGPU(a.dataId);const d={shape:a.shape,texData:l,isUniform:!1},f=vAe(e,u,d),h=this.getAndSaveBinary(f,()=>gAe(this.gpgpu,e,u,d)),p=this.activeTimers!=null;let x;p&&(x=this.startTimer()),ge().get("ENGINE_COMPILE_ONLY")||yAe(this.gpgpu,h,u,d,i),c.forEach(y=>this.disposeIntermediateTensorInfo(y)),p&&(x=this.endTimer(x),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(x)}));const v=ge().get("WEBGL_FLUSH_THRESHOLD");if(v>0){const y=Oo();y-this.lastGlFlushTime>v&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=y)}if(!ge().getBool("WEBGL_LAZILY_UNPACK")&&l.isPacked&&s===!1){const y=this.unpackTensor(a);return this.disposeIntermediateTensorInfo(a),y}return a}compileAndRun(e,n,r,i,s=!1){return r=r||n[0].dtype,this.runWebGLProgram(e,n,r,i,s)}getAndSaveBinary(e,n){return e in this.binaryCache||(this.binaryCache[e]=n()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){this.disposed||(ge().getBool("IS_TEST")||Object.keys(this.binaryCache).forEach(n=>{this.gpgpu.deleteProgram(this.binaryCache[n].webGLProgram),delete this.binaryCache[n]}),this.textureManager.dispose(),this.canvas!=null&&typeof HTMLCanvasElement<"u"&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0)}floatPrecision(){return this.floatPrecisionValue==null&&(this.floatPrecisionValue=qn(()=>{if(!ge().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=ge().getBool("DEBUG");ge().set("DEBUG",!1);const n=this.abs(fn(1e-8)).dataSync()[0];if(ge().set("DEBUG",e),n>0)return 32}return 16})),this.floatPrecisionValue}epsilon(){return this.floatPrecision()===32?JTe:YTe}uploadToGPU(e){const n=this.texData.get(e),{shape:r,dtype:i,values:s,texture:o,usage:a,isPacked:l}=n;if(o!=null)return;const c=this.activeTimers!=null;let u;c&&(u=Oo());let d=n.texShape;if(d==null&&(d=CEe(r,l),n.texShape=d),s!=null){const f=xE(r);let h,p=d[1],x=d[0];const v=s instanceof Uint8Array||s instanceof Uint8ClampedArray;(l||!v)&&([p,x]=Ap(d[0],d[1])),l?h=new CAe(f,v):h=new wAe(f,v);const y=v?[x,p]:d,b=this.makeTensorInfo(y,i),S=this.texData.get(b.dataId);v?S.usage=Cs.PIXELS:S.usage=Cs.UPLOAD,S.texShape=y,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(b.dataId),p,x,s);const w=[[x,p]],A=this.runWebGLProgram(h,[b],i,w,!0),T=this.texData.get(A.dataId);n.texShape=T.texShape,n.isPacked=T.isPacked,n.usage=T.usage,ge().get("ENGINE_COMPILE_ONLY")?this.disposeData(A.dataId):(n.texture=T.texture,n.values=null,this.texData.delete(A.dataId)),this.disposeIntermediateTensorInfo(b),c&&(this.uploadWaitMs+=Oo()-u)}else{const f=this.acquireTexture(d,a,i,l);n.texture=f}}convertAndCacheOnCPU(e,n){const r=this.texData.get(e),{dtype:i}=r;return this.releaseGPUData(e),n!=null&&(r.values=nMe(n,i)),r.values}acquireTexture(e,n,r,i){if(this.numBytesInGPU+=this.computeBytes(e,r),!this.warnedAboutMemory&&this.numBytesInGPU>this.numMBBeforeWarning*1024*1024){const s=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn(`High memory usage in GPU: ${s} MB, most likely due to a memory leak`)}return this.textureManager.acquireTexture(e,n,i)}computeBytes(e,n){return e[0]*e[1]*H2(n)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,n]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(n));return Promise.all(e)}else{for(const[,n]of Object.entries(this.binaryCache)){const r=new Promise(i=>{try{this.checkCompletion_(n),i(!0)}catch(s){throw s}});e.push(r)}return Promise.all(e)}}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await mwe(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)===!1)throw console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS)===!1?(HV(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.")):new Error("Failed to link vertex and fragment shaders.");return!0}getUniformLocations(){for(const[,e]of Object.entries(this.binaryCache)){const{uniformLocations:n,customUniformLocations:r,infLoc:i,nanLoc:s,inShapesLocations:o,inTexShapesLocations:a,outShapeLocation:l,outShapeStridesLocation:c,outTexShapeLocation:u}=KV(this.gpgpu,e.program,e.webGLProgram);e.uniformLocations=n,e.customUniformLocations=r,e.infLoc=i,e.nanLoc=s,e.inShapesLocations=o,e.inTexShapesLocations=a,e.outShapeLocation=l,e.outShapeStridesLocation=c,e.outTexShapeLocation=u}}}m_.nextDataId=0;function nMe(t,e){if(e==="float32"||e==="complex64")return t;if(e==="int32"||e==="bool"){const n=e==="int32"?new Int32Array(t.length):new Uint8Array(t.length);for(let r=0;r<n.length;++r)n[r]=Math.round(t[r]);return n}else throw new Error(`Unknown dtype ${e}`)}/**
 * @license
 * Copyright 2020 Google Inc. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */IG()&&R0e("webgl",()=>new m_,2);/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rN=`
  if (isnan(a)) return a;
  if (isnan(b)) return b;
`;class ip{constructor(e,n,r){this.variableNames=["A","B"],this.outputShape=Qt(n,r),this.enableShapeUniforms=Ci(this.outputShape.length),this.userCode=`
      float binaryOperation(float a, float b) {
        ${e}
      }

      void main() {
        float a = getAAtOutCoords();
        float b = getBAtOutCoords();
        setOutput(binaryOperation(a, b));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H0=`
  result.r = isNaN.r ? NAN : result.r;
  result.g = isNaN.g ? NAN : result.g;
  result.b = isNaN.b ? NAN : result.b;
  result.a = isNaN.a ? NAN : result.a;
`;class V0{constructor(e,n,r,i=!1){this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Qt(n,r);const s=this.outputShape.length;this.enableShapeUniforms=Ci(s);let o="";if(i)if(s===0||Ve(this.outputShape)===1)o=`
          result.y = 0.;
          result.z = 0.;
          result.w = 0.;
        `;else if(o=`
          ${An(s)} coords = getOutputCoords();
        `,s===1)this.enableShapeUniforms?o+=`
            result.y = (coords + 1) >= outShape ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `:o+=`
            result.y = (coords + 1) >= ${this.outputShape[0]} ? 0. : result.y;
            result.z = 0.;
            result.w = 0.;
          `;else{const l=yi("coords",s);this.enableShapeUniforms?o+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= outShape[${s} - 2];
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= outShape[${s} - 1];
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `:o+=`
            bool nextRowOutOfBounds =
              (${l[s-2]} + 1) >= ${this.outputShape[s-2]};
            bool nextColOutOfBounds =
              (${l[s-1]} + 1) >= ${this.outputShape[s-1]};
            result.y = nextColOutOfBounds ? 0. : result.y;
            result.z = nextRowOutOfBounds ? 0. : result.z;
            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;
          `}this.userCode=`
      vec4 binaryOperation(vec4 a, vec4 b) {
        ${e}
      }

      void main() {
        vec4 a = getAAtOutCoords();
        vec4 b = getBAtOutCoords();

        vec4 result = binaryOperation(a, b);
        ${o}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function os(t){const{inputs:e,backend:n}=t,{x:r}=e;return n.incRef(r.dataId),{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}const rMe={kernelName:hI,backendName:"webgl",kernelFunc:os};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Vc(t){const{inputs:e,backend:n}=t,{real:r,imag:i}=e,s=n.makeTensorInfo(r.shape,"complex64"),o=n.texData.get(s.dataId),a=os({inputs:{x:r},backend:n}),l=os({inputs:{x:i},backend:n});return o.complexTensorInfos={real:a,imag:l},s}const iMe={kernelName:Q6,backendName:"webgl",kernelFunc:Vc};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a7="return (a < 0.) ? b * a : a;",l7=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function sMe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{alpha:s}=r,o=n.makeTensorInfo([],"float32",wp(s,"float32")),a=ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new V0(l7,i.shape,o.shape):new ip(a7,i.shape,o.shape),l=n.runWebGLProgram(a,[i,o],"float32");return n.disposeIntermediateTensorInfo(o),l}const oMe={kernelName:zz,backendName:"webgl",kernelFunc:sMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const c7="return (a < 0.) ? b * a : a;",u7=`
  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));
  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);
`;function aMe(t){const{inputs:e,backend:n}=t,{x:r,alpha:i}=e,s=ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new V0(u7,r.shape,i.shape):new ip(c7,r.shape,i.shape);return n.runWebGLProgram(s,[r,i],"float32")}const lMe={kernelName:x8,backendName:"webgl",kernelFunc:aMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Np="if (isnan(x)) return x;";function qt({opSnippet:t,packedOpSnippet:e,cpuKernelImpl:n,dtype:r}){return({inputs:i,backend:s})=>{const{x:o}=i,a=s,l=r||o.dtype;if(a.shouldExecuteOnCPU([o])&&n!=null){const d=a.texData.get(o.dataId),f=n(d.values,l);return a.makeTensorInfo(o.shape,l,f)}const c=ge().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&e!=null;let u;return c?u=new Hu(o.shape,e):u=new al(o.shape,t),a.runWebGLProgram(u,[o],l)}}function Xr({opSnippet:t,packedOpSnippet:e,checkOutOfBounds:n=!1,supportsComplex:r=!1,cpuKernelImpl:i,dtype:s}){return({inputs:o,backend:a})=>{const{a:l,b:c}=o,u=a;if(r&&l.dtype==="complex64"){const p=u.texData.get(l.dataId),x=u.texData.get(c.dataId),[v,y]=[[p.complexTensorInfos.real,x.complexTensorInfos.real],[p.complexTensorInfos.imag,x.complexTensorInfos.imag]].map(S=>{const[w,E]=S,A={dataId:w.dataId,dtype:w.dtype,shape:l.shape},T={dataId:E.dataId,dtype:E.dtype,shape:c.shape},I=new ip(t,l.shape,c.shape);return u.runWebGLProgram(I,[A,T],Pa(w.dtype,E.dtype))}),b=Vc({inputs:{real:v,imag:y},backend:u});return u.disposeIntermediateTensorInfo(v),u.disposeIntermediateTensorInfo(y),b}const d=s||Pa(l.dtype,c.dtype);if((l.dtype==="string"||c.dtype==="string"||u.shouldExecuteOnCPU([l,c]))&&i!=null){const p=u.texData.get(l.dataId).values,x=u.texData.get(c.dataId).values,v=l.dtype==="string"?r0(p):p,y=l.dtype==="string"?r0(x):x,[b,S]=i(l.shape,c.shape,v,y,d),w=u.makeTensorInfo(S,d),E=u.texData.get(w.dataId);return E.values=b,w}const f=ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&e!=null;let h;return f?h=new V0(e,l.shape,c.shape,n):h=new ip(t,l.shape,c.shape),u.runWebGLProgram(h,[l,c],d)}}function s0(t,e=!1){if(t==="linear")return e?HTe:FTe;if(t==="relu")return e?WTe:UTe;if(t==="elu")return e?VTe:$Te;if(t==="relu6")return e?jTe:zTe;if(t==="prelu")return e?u7:c7;if(t==="leakyrelu")return e?l7:a7;if(t==="sigmoid")return e?XTe:GTe;throw new Error(`Activation ${t} has not been implemented for the WebGL backend.`)}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class d7{constructor(e,n,r,i=!1,s=!1,o=!1,a=null,l=!1,c=!1){this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=r,this.enableShapeUniforms=Ci(this.outputShape.length);const u=i?e[1]:e[2],d=Math.ceil(u/2),f=i?"i * 2, rc.y":"rc.y, i * 2",h=s?"rc.z, i * 2":"i * 2, rc.z",p=i?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],x=s?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let v="",y="";a&&(l?v=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${a}
        }`:c?v=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${a}
        }`:v=`vec4 activation(vec4 x) {
          ${a}
        }`,y="result = activation(result);");const b=o?"result += getBiasAtOutCoords();":"";o&&this.variableNames.push("bias"),l&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let S="rc.x",w="rc.x";e[0]<n[0]?S=`int(min(float(rc.x), ${e[0]-1}.))`:n[0]<e[0]&&(w=`int(min(float(rc.x), ${n[0]-1}.))`),this.userCode=`
      ${v}
      // Don't use uniform for sharedDimensionPacked for performance.
      const float sharedDimension = ${d}.0;

      vec4 dot2x2ARowBCol(ivec3 rc) {
        vec4 result = vec4(0);
        for (int i = 0; i < ${d}; i++) {
          int batchA = ${S};
          int batchB = ${w};
          vec4 a = getMatrixA(batchA, ${f});
          vec4 b = getMatrixB(batchB, ${h});

          // These swizzled products need to be separately added.
          // See: https://github.com/tensorflow/tfjs/issues/1735
          result += (${p[0]} * ${x[0]});
          result += (${p[1]} * ${x[1]});
        }
        return result;
      }

      void main() {
        ivec3 rc = getOutputCoords();
        vec4 result = dot2x2ARowBCol(rc);

        ${b}

        ${y}

        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const ZL={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class eB{constructor(e,n,r){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Qt(n,r),this.userCode=`
      float binaryOpComplex(
          float areal, float aimag, float breal, float bimag) {
        ${e}
      }

      void main() {
        float areal = getARealAtOutCoords();
        float aimag = getAImagAtOutCoords();
        float breal = getBRealAtOutCoords();
        float bimag = getBImagAtOutCoords();
        setOutput(binaryOpComplex(areal, aimag, breal, bimag));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tB="return a * b;";function iN(t){const{inputs:e,backend:n}=t,{a:r,b:i}=e,s=Pa(r.dtype,i.dtype);if(r.dtype==="complex64"){const a=n.texData.get(r.dataId),l=n.texData.get(i.dataId),c=new eB(ZL.REAL,r.shape,i.shape),u=new eB(ZL.IMAG,r.shape,i.shape),d=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:r.shape},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:r.shape},{dataId:l.complexTensorInfos.real.dataId,dtype:l.complexTensorInfos.real.dtype,shape:i.shape},{dataId:l.complexTensorInfos.imag.dataId,dtype:l.complexTensorInfos.imag.dtype,shape:i.shape}],f=n.runWebGLProgram(c,d,"float32"),h=n.runWebGLProgram(u,d,"float32"),p=Vc({inputs:{real:f,imag:h},backend:n});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),p}if(n.shouldExecuteOnCPU([r,i])){const a=n.texData.get(r.dataId),l=n.texData.get(i.dataId),[c,u]=cTe(r.shape,i.shape,a.values,l.values,s),d=n.makeTensorInfo(u,s),f=n.texData.get(d.dataId);return f.values=c,d}let o;return ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")?o=new V0(tB,r.shape,i.shape):o=new ip(tB,r.shape,i.shape),n.runWebGLProgram(o,[r,i],s)}const cMe={kernelName:l8,backendName:"webgl",kernelFunc:iN};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uMe(t,e,n){const r=[np(t.shape),...rp(t.shape)],i={dtype:t.dtype,shape:r,dataId:t.dataId},s=[np(e),...rp(e)],o=new o7(s,r),a=!0,l=[r],c=n.runWebGLProgram(o,[i],t.dtype,l,a);return{dataId:c.dataId,shape:e,dtype:c.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{shape:s}=r,o=n,a=Ve(i.shape),l=Rme(s,a),c=Ve(l);Y(a===c,()=>`The new shape (${l}) has ${c} elements and the old shape (${i.shape}) has ${a} elements. The new shape and old shape must have the same number of elements.`);const u=o.texData.get(i.dataId);return u.isPacked&&!tb(i.shape,l)&&!(u.texture!==null&&tb(u.shape,l))?uMe(i,l,o):(o.incRef(i.dataId),{dataId:i.dataId,shape:l,dtype:i.dtype})}const dMe={kernelName:T8,backendName:"webgl",kernelFunc:qe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class nB{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:s,outSize:o}=e;this.outputShape=[i,o];const a=Math.floor(r/4)*4,l=r%4;let c="sumValue += dot(values, ones);";if(n!=null){const d=1/n;c=`sumValue += dot(values * ${qh(d)?d.toPrecision(2):d}, ones);`}let u="";s%r>0&&(u=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return 0.0;
        }
      `),this.userCode=`
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${u}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        float sumValue = 0.0;

        for (int i = 0; i < ${a}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${c}
        }

        int inIdx = inOffset + ${a};
        if (${l===1}) {
          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);

          ${c}
        } else if (${l===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1), 0.0, 0.0);

          ${c}
        } else if (${l===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2), 0.0);

          ${c}
        }
        setOutput(sumValue);
      }
    `}}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class fMe{constructor(e,n){this.variableNames=["x"];const{windowSize:r,batchSize:i,inSize:s,outSize:o}=e;this.outputShape=[i,o];let a="0.0",l="";n==="prod"?a="1.0":n==="min"?(a="1.0 / 1e-20",l="min"):n==="max"&&(a="-1.0 / 1e-20",l="max");let c=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="sum"?c="sumValue":n==="prod"?c="prodValue":n==="all"?c="allValue":n==="any"&&(c="anyValue");const u=Math.floor(r/4)*4,d=r%4;let f=`
      if (${n==="sum"}) {
        sumValue += dot(values, ones);
      } else if (${n==="prod"}) {
        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);
        prodValue *= tmp[0] * tmp[1];
      } else {
        minMaxValue = ${l}(values, minMaxValue);
        if (${n==="min"} || ${n==="max"}) {
          minMaxValue = ${l}(values, minMaxValue);
          bvec4 isNaN = isnan(values);
          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {
            minMaxValue = vec4(NAN);
          }
        }
      }
    `,h="vec4";n==="all"?(a="1.0",f=`
        bool reducedAllValue = all(values);
        float floatedReducedAllValue = float(reducedAllValue);
        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);
      `,h="bvec4"):n==="any"&&(a="0.0",f=`
        bool reducedAnyValue = any(values);
        float floatedReducedAnyValue = float(reducedAnyValue);
        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);
      `,h="bvec4");let p="";s%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `),this.userCode=`
      const float initializationValue = ${a};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float getValue(int batch, int inIdx) {
        ${p}
        return getX(batch, inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${r};

        vec4 minMaxValue = vec4(${a});
        float prodValue = 1.0;
        float sumValue = 0.0;
        float allValue = 1.0;
        float anyValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${d===1}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${d===2}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          ${f}
        } else if (${d===3}) {
          ${h} values = ${h}(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          ${f}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hMe(t){const e=[];for(;e.length===0||e[e.length-1].outSize!==1;){const n=e.length?e[e.length-1].outSize:t[1],r=h_(n);e.push({inSize:n,windowSize:r,outSize:Math.ceil(n/r)})}return e}function Gd(t,e,n,r){const i=hMe(t.shape);let s=t;for(let o=0;o<i.length;o++){const{inSize:a,windowSize:l,outSize:c}=i[o];let u,d;n==="mean"?u=o===0?new nB({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},a):new nB({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c}):u=new fMe({windowSize:l,inSize:a,batchSize:t.shape[0],outSize:c},n),d=s,s=r.runWebGLProgram(u,[s],e),d.dataId!==t.dataId&&r.disposeIntermediateTensorInfo(d)}return s}/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pMe{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[n[o]];this.outputShape=r,this.rank=r.length;const i=An(this.rank),s=mMe(n);this.userCode=`
    void main() {
      ${i} resRC = getOutputCoords();
      setOutput(getA(${s}));
    }
    `}}function mMe(t){const e=t.length;if(e>6)throw Error(`Transpose for rank ${e} is not yet supported`);const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],r=new Array(e);for(let i=0;i<t.length;i++)r[t[i]]=n[i];return r.join()}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class gMe{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const r=new Array(e.length);for(let u=0;u<r.length;u++)r[u]=e[n[u]];if(this.outputShape=r,this.rank=r.length,this.rank>6)throw Error(`Packed transpose for rank ${this.rank} is not yet supported.`);const i=An(this.rank),s=s7("rc",this.rank),o=new Array(this.rank);for(let u=0;u<n.length;u++)o[n[u]]=s[u];const a=`vec2(${o.slice(-2).join()})`,l=`++${s[this.rank-1]} < ${r[this.rank-1]}`,c=`getChannel(getA(${o.join()}), ${a})`;this.userCode=`
    void main() {
      ${i} rc = getOutputCoords();
      vec4 result = vec4(0.);
      result[0] = ${c};
      if(${l}) {
        result[1] = ${c};
      }
      --${s[this.rank-1]};
      if(++${s[this.rank-2]} < ${r[this.rank-2]}) {
        result[2] = ${c};
        if(${l}) {
          result[3] = ${c};
        }
      }
      setOutput(result);
    }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function g_(t,e,n){const r=ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new gMe(t.shape,e):new pMe(t.shape,e);return n.runWebGLProgram(r,[t],t.dtype)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yMe(t,e,n,r){const i=e,s=t.shape.length,o=Dr(i,t.shape);let a=o;const l=_o(a,s),c=l!=null;let u=t;c&&(u=g_(t,l,r),a=wo(a.length,s)),ta("sum",a,s);const[d,f]=Oa(u.shape,a);let h=d;n&&(h=Fs(d,o));const p=Ve(f),v=Ve(t.shape)/p,y=qe({inputs:{x:u},attrs:{shape:[v,p]},backend:r}),b=gI(t.dtype),S=Gd(y,b,"sum",r),w=qe({inputs:{x:S},attrs:{shape:h},backend:r});return r.disposeIntermediateTensorInfo(y),r.disposeIntermediateTensorInfo(S),c&&r.disposeIntermediateTensorInfo(u),w}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y_(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:o}=r;return yMe(i,s,o,n)}const vMe={kernelName:W8,backendName:"webgl",kernelFunc:y_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bi(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{perm:s}=r,o=n,a=i.shape.length,l=new Array(a);for(let u=0;u<l.length;u++)l[u]=i.shape[s[u]];let c;if(o.shouldExecuteOnCPU([i])){const d=o.texData.get(i.dataId).values,f=nN(d,i.shape,i.dtype,s,l);c=o.makeTensorInfo(l,i.dtype);const h=o.texData.get(c.dataId);h.values=f}else c=g_(i,s,o);return c}const xMe={kernelName:e1,backendName:"webgl",kernelFunc:bi};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const f7=1e3;function rb({a:t,b:e,transposeA:n,transposeB:r,backend:i,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:a=0,activation:l=null}){const c=t.shape.length,u=e.shape.length,d=n?t.shape[c-2]:t.shape[c-1],f=r?e.shape[u-1]:e.shape[u-2],h=n?t.shape[c-1]:t.shape[c-2],p=r?e.shape[u-2]:e.shape[u-1],x=t.shape.slice(0,-2),v=e.shape.slice(0,-2),y=Ve(x),b=Ve(v),w=Qt(t.shape.slice(0,-2),e.shape.slice(0,-2)).concat([h,p]);Y(d===f,()=>`Error in matMul: inner shapes (${d}) and (${f}) of Tensors with shapes ${t.shape} and ${e.shape} and transposeA=${n} and transposeB=${r} must match.`);const E=n?[y,d,h]:[y,h,d],A=r?[b,p,f]:[b,f,p],T=qe({inputs:{x:t},backend:i,attrs:{shape:E}}),I=qe({inputs:{x:e},backend:i,attrs:{shape:A}}),N=[T,I],M=Math.max(y,b),P=n?T.shape[1]:T.shape[2],B=s!=null,F=o!=null,U=l==="leakyrelu",j=l!=null?s0(l,!0):null,Z=B||F||U||j!=null;let ne;if((h===1||p===1)&&P>f7&&Z===!1){let G=T,q=I;n&&(G=bi({inputs:{x:T},backend:i,attrs:{perm:[0,2,1]}}),N.push(G)),r&&(q=bi({inputs:{x:I},backend:i,attrs:{perm:[0,2,1]}}),N.push(q));const se=p!==1,he=p===1;let ke=G;se&&(ke=qe({inputs:{x:G},backend:i,attrs:{shape:[M,P,1]}}),N.push(ke));const re=p===1?2:1;let pe=q;he&&(pe=qe({inputs:{x:q},backend:i,attrs:{shape:[M,1,P]}}),N.push(pe));const fe=iN({inputs:{a:ke,b:pe},backend:i});ne=y_({inputs:{x:fe},backend:i,attrs:{axis:re,keepDims:!0}}),N.push(fe)}else{const G=Pa(t.dtype,e.dtype),q=new d7(E,A,[M,h,p],n,r,B,j,F,U),se=[T,I];if(s!=null&&se.push(s),F&&se.push(o),U){const he=i.makeTensorInfo([],"float32",wp(a,"float32"));se.push(he),N.push(he)}ne=i.runWebGLProgram(q,se,G)}const O=qe({inputs:{x:ne},backend:i,attrs:{shape:w}});N.push(ne);for(const G of N)i.disposeIntermediateTensorInfo(G);return O}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function bMe(t){const{inputs:e,backend:n,attrs:r}=t,{a:i,b:s,bias:o,preluActivationWeights:a}=e,{transposeA:l,transposeB:c,activation:u,leakyreluAlpha:d}=r;return rb({a:i,b:s,transposeA:l,transposeB:c,backend:n,bias:o,preluActivationWeights:a,leakyreluAlpha:d,activation:u})}const SMe={kernelName:K2,backendName:"webgl",kernelFunc:bMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const rB="return abs(x);";function _Me(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])&&r.dtype!=="complex64"){const s=n.texData.get(r.dataId),o=r7(s.values);return n.makeTensorInfo(r.shape,r.dtype,o)}let i;return ge().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Hu(r.shape,rB):i=new al(r.shape,rB),n.runWebGLProgram(i,[r],r.dtype)}const wMe={kernelName:N6,backendName:"webgl",kernelFunc:_Me};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CMe=Co+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return acos(x);
`,EMe=qt({opSnippet:CMe}),AMe={kernelName:P6,backendName:"webgl",kernelFunc:EMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TMe=Co+`
  if (x < 1.0) return NAN;
return log(x + sqrt(x * x - 1.0));`,MMe=qt({opSnippet:TMe}),RMe={kernelName:k6,backendName:"webgl",kernelFunc:MMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iB="return a + b;",IMe=Xr({opSnippet:iB,packedOpSnippet:iB,supportsComplex:!0,cpuKernelImpl:H2e}),NMe={kernelName:dI,backendName:"webgl",kernelFunc:IMe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PMe{constructor(e,n){this.outputShape=[],this.outputShape=e,this.variableNames=n.map((s,o)=>`T${o}`);const r=[];this.variableNames.forEach(s=>{r.push(`float v${s} = get${s}AtOutCoords();`)});const i=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        float result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kMe{constructor(e,n){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=n.map((s,o)=>`T${o}`);const r=[];this.variableNames.forEach(s=>{r.push(`vec4 v${s} = get${s}AtOutCoords();`)});const i=this.variableNames.map(s=>`v${s}`).join(" + ");this.userCode=`
      void main() {
        ${r.join(`
        `)}

        vec4 result = ${i};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function i1(t){const{inputs:e,backend:n}=t,r=e;if(r.length===1)return os({inputs:{x:r[0]},backend:n});if(r.length>ge().get("WEBGL_MAX_TEXTURES_IN_SHADER")){const l=Math.floor(r.length/2),c=i1({inputs:r.slice(0,l),backend:n}),u=i1({inputs:r.slice(l),backend:n});return i1({inputs:[c,u],backend:n})}const i=r.map(l=>l.dtype).reduce((l,c)=>Pa(l,c)),s=r.map(l=>l.shape),a=ge().getBool("WEBGL_PACK")?new kMe(r[0].shape,s):new PMe(r[0].shape,s);return n.runWebGLProgram(a,r,i)}const DMe={kernelName:D6,backendName:"webgl",kernelFunc:i1};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function OMe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:o}=r,a=i.shape.length,l=Dr(s,i.shape);let c=l;const u=_o(c,a);let d=i;u!=null&&(d=bi({inputs:{x:i},backend:n,attrs:{perm:u}}),c=wo(c.length,a)),ta("all",c,a);const[f,h]=Oa(d.shape,c),p=Ve(h),x=qe({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}}),v=Gd(x,x.dtype,"all",n);let y;if(o){const b=Fs(f,l);y=qe({inputs:{x:v},backend:n,attrs:{shape:b}})}else y=qe({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),u!=null&&n.disposeIntermediateTensorInfo(d),y}const LMe={kernelName:O6,backendName:"webgl",kernelFunc:OMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BMe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:o}=r,a=i.shape.length,l=Dr(s,i.shape);let c=l;const u=_o(c,a);let d=i;u!=null&&(d=bi({inputs:{x:i},backend:n,attrs:{perm:u}}),c=wo(c.length,a)),ta("any",c,a);const[f,h]=Oa(d.shape,c),p=Ve(h),x=qe({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}}),v=Gd(x,x.dtype,"any",n);let y;if(o){const b=Fs(f,l);y=qe({inputs:{x:v},backend:n,attrs:{shape:b}})}else y=qe({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),u!=null&&n.disposeIntermediateTensorInfo(d),y}const FMe={kernelName:L6,backendName:"webgl",kernelFunc:BMe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $Me{constructor(e,n,r){this.variableNames=["A"];const{windowSize:i,batchSize:s,outSize:o}=e;r||this.variableNames.push("bestIndicesA"),this.outputShape=[s,o];const a=n==="max"?">":"<",l=r?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = outIdx * ${i};

        int bestIndex = inOffset;
        float bestValue = getA(batch, bestIndex);

        for (int i = 0; i < ${i}; i++) {
          int inIdx = ${l};
          float candidate = getA(batch, inIdx);
          if (candidate ${a} bestValue) {
            bestValue = candidate;
            bestIndex = inIdx;
          }
        }
        setOutput(float(bestIndex));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class UMe{constructor(e,n,r,i){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,Y(e.length>2,()=>`Packed arg${r.charAt(0).toUpperCase()+r.slice(1)} supports only inputs with rank above 2.`);const s=e[e.length-1],o=Math.ceil(s/n);this.outputShape=e.slice(0,-1),o>1&&this.outputShape.push(o),i||this.variableNames.push("bestIndicesA");const a=this.outputShape,l=a.length,c=An(l),u=yi("coords",l);let d,f;if(o===1){f=l+1;const I=An(f);d=`
        ${I} sourceLocR = ${I}(${u.join()}, 0);
        ++${u[l-1]};
        ${I} sourceLocG = ${I}(${u.join()}, 0);
        ++${u[l-2]};
        ${I} sourceLocA = ${I}(${u.join()}, 0);
        --${u[l-1]};
        ${I} sourceLocB = ${I}(${u.join()}, 0);
        --${u[l-2]};`}else f=l,d=`
        ${c} sourceLocR = coords;
        ++${u[l-1]};
        ${c} sourceLocG = coords;
        ++${u[l-2]};
        ${c} sourceLocA = coords;
        --${u[l-1]};
        ${c} sourceLocB = coords;
        --${u[l-2]};`;const h=["x","y","z","w","u","v"].slice(0,f),p="."+h[f-1],x=h.map(I=>"int "+I),v=yi("sourceLocR",f-1).concat("inIdx.r"),y=yi("sourceLocG",f-1).concat("inIdx.g"),b=yi("sourceLocB",f-1).concat("inIdx.b"),S=yi("sourceLocA",f-1).concat("inIdx.a"),w=r==="max"?"greaterThan":"lessThan",E=i?"":`
          inIdx = round(vec4(getBestIndicesAChannel(${v.join()}),
                             getBestIndicesAChannel(${y.join()}),
                             getBestIndicesAChannel(${b.join()}),
                             getBestIndicesAChannel(${S.join()})));`,A=`vec4(
            getAChannel(${v.join()}),
            hasNextCol ? getAChannel(${y.join()}) : 0.,
            hasNextRow ? getAChannel(${b.join()}) : 0.,
            hasNextRow && hasNextCol ? getAChannel(${S.join()}) : 0.)`,T=i?"":`
      float getBestIndicesAChannel(${x.join()}) {
        return getChannel(getBestIndicesA(${h.join()}),
                                          vec2(${h.slice(-2).join()}));
      }`;this.userCode=`
      float getAChannel(${x.join()}) {
        return getChannel(getA(${h.join()}),
                               vec2(${h.slice(-2).join()}));
      }
      ${T}
      void main() {
        ${c} coords = getOutputCoords();
        bool hasNextCol = ${u[l-1]} < ${a[l-1]-1};
        bool hasNextRow = ${u[l-2]} < ${a[l-2]-1};
        ${d}
        ivec4 srcIdx = ivec4(sourceLocR${p}, sourceLocG${p},
          sourceLocB${p}, sourceLocA${p}) * ${n};
        ivec4 inIdx = srcIdx;
        vec4 bestIndex = vec4(inIdx);
        vec4 bestValue = ${A};

        for (int i = 0; i < ${n}; i++) {
          inIdx = srcIdx;
          ${E}
          vec4 candidate = ${A};
          bvec4 nan = isnan(candidate);
          bvec4 replace = bvec4(
            vec4(${w}(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));

          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,
                           replace.y  ? candidate.y : bestValue.y,
                           replace.z  ? candidate.z : bestValue.z,
                           replace.w  ? candidate.w : bestValue.w);
          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));
          srcIdx++;
        }
        setOutput(bestIndex);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function h7(t,e,n,r=null){let i=e.shape[0],s=e.shape[1];r!=null&&(i=r.shape[0],s=r.shape[1]);const o=h_(s),a={windowSize:o,inSize:s,batchSize:i,outSize:Math.ceil(s/o)},l=new $Me(a,n,r==null),c=[e];r!=null&&c.push(r);const u=t.runWebGLProgram(l,c,"int32");if(u.shape[1]===1)return u;const d=h7(t,e,n,u);return t.disposeIntermediateTensorInfo(u),d}function p7(t,e,n,r=null){const i=r!=null?r.shape:e.shape,s=i[i.length-1],o=h_(s),a=new UMe(i,o,n,r==null),l=r==null?[e]:[e,r],c=t.runWebGLProgram(a,l,"int32");if(c.shape.length===e.shape.length){const u=p7(t,e,n,c);return t.disposeIntermediateTensorInfo(c),u}return c}function m7(t,e,n,r){const i=[n];if(ta("arg"+r.charAt(0).toUpperCase()+r.slice(1),i,e.shape.length),!ge().getBool("WEBGL_PACK_REDUCE")||e.shape.length<=2){const s=[],o=t.texData.get(e.dataId),a=o!==null&&o.isPacked;let l=e;a&&(l=t.unpackTensor(e),s.push(l));const[c,u]=Oa(l.shape,i),d=Ve(u),f=qe({inputs:{x:l},backend:t,attrs:{shape:[-1,d]}});s.push(f);const h=h7(t,f,r);s.push(h);const p=qe({inputs:{x:h},backend:t,attrs:{shape:c}});return s.forEach(x=>t.disposeIntermediateTensorInfo(x)),p}return p7(t,e,r)}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function zMe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s}=r;let o=Dr(s,i.shape);const a=_o(o,i.shape.length);let l=i;const c=[];a!=null&&(l=bi({inputs:{x:i},backend:n,attrs:{perm:a}}),c.push(l),o=wo(o.length,l.shape.length)),ta("argMax",[o[0]],l.shape.length);const u=m7(n,l,o[0],"max");return c.forEach(d=>n.disposeIntermediateTensorInfo(d)),u}const GMe={kernelName:B6,backendName:"webgl",kernelFunc:zMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function HMe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s}=r;let o=Dr(s,i.shape);const a=_o(o,i.shape.length);let l=i;const c=[];a!=null&&(l=bi({inputs:{x:i},backend:n,attrs:{perm:a}}),c.push(l),o=wo(o.length,l.shape.length)),ta("argMin",[o[0]],l.shape.length);const u=m7(n,l,o[0],"min");return c.forEach(d=>n.disposeIntermediateTensorInfo(d)),u}const VMe={kernelName:F6,backendName:"webgl",kernelFunc:HMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WMe=Co+`
  if (abs(x) > 1.) {
    return NAN;
  }
  return asin(x);
`,jMe=qt({opSnippet:WMe}),XMe={kernelName:$6,backendName:"webgl",kernelFunc:jMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const KMe=Co+"return log(x + sqrt(x * x + 1.0));",qMe=qt({opSnippet:KMe}),JMe={kernelName:U6,backendName:"webgl",kernelFunc:qMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const YMe=Co+`
  return atan(x);
`,QMe=qt({opSnippet:YMe}),ZMe={kernelName:z6,backendName:"webgl",kernelFunc:QMe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const eRe=rN+`
  return atan(a, b);
`,tRe=`
  vec4 result = atan(a, b);
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+H0+`
  return result;
`,nRe=Xr({opSnippet:eRe,packedOpSnippet:tRe}),rRe={kernelName:H6,backendName:"webgl",kernelFunc:nRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iRe=Co+`
  if ((x < -1.0) || (x > 1.0)) return NAN;
return (log(1.0 + x) - log(1.0 - x)) / 2.0;`,sRe=qt({opSnippet:iRe}),oRe={kernelName:G6,backendName:"webgl",kernelFunc:sRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class o0{constructor(e,n,r,i=!1,s=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideHeight,l=e.strideWidth,c=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterHeight,f=e.effectiveFilterWidth,h=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const x=n==="avg",v=`((batch  * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + d`,y=`(xR * ${e.inWidth} + xC) * ${e.inChannels} + d`;let b="0.0";if(x||(b="-1.0 / 1e-20"),r){const I=">=";this.userCode=`
        const ivec2 strides = ivec2(${a}, ${l});
        const ivec2 pads = ivec2(${h}, ${p});

        void main() {
          ivec4 coords = getOutputCoords();
          int batch = coords[0];
          int d = coords[3];

          ivec2 xRCCorner = coords.yz * strides - pads;
          int xRCorner = xRCCorner.x;
          int xCCorner = xRCCorner.y;

          // max/min x(?, ?, d) to get y(yR, yC, d).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;
          float avgValue = 0.0;

          for (int wR = 0; wR < ${d};
              wR += ${c}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${f};
                wC += ${u}) {
              int xC = xCCorner + wC;

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float value = getX(batch, xR, xC, d);

              // If a min / max value has already been found, use it. If not,
              // use the current value.
              float currMinMaxValue = mix(
                  value, minMaxValue, minMaxValueFound);
              if (value ${I} currMinMaxValue) {
                minMaxValue = value;
                minMaxValueFound = 1.0;
                minMaxPosition = ${i?s?v:y:`wR * ${f} + wC`};
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const S="max";let w=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(w="avgValue / count");const E=Math.floor(o/4)*4,A=o%4,T=`
      if (${x}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${S}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec2 strides = ivec2(${a}, ${l});
      const ivec2 pads = ivec2(${h}, ${p});
      const float initializationValue = ${b};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xR, int xC, int d) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xR, xC, d);
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d = coords[3];

        ivec2 xRCCorner = coords.yz * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // max/min x(?, ?, d) to get y(yR, yC, d).
        // ? = to be determined
        vec4 minMaxValue = vec4(${b});
        float avgValue = 0.0;
        count = 0.0;

        for (int wR = 0; wR < ${d};
            wR += ${c}) {
          int xR = xRCorner + wR;

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${E}; wC += 4) {
            int xC = xCCorner + wC * ${u};

            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              getValue(batch, xR, xC + 3 * ${u}, d)
            );

            ${T}
          }

          int xC = xCCorner + ${E};
          if (${A===1}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              initializationValue,
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${A===2}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              initializationValue,
              initializationValue
            );

            ${T}
          } else if (${A===3}) {
            vec4 values = vec4(
              getValue(batch, xR, xC, d),
              getValue(batch, xR, xC + ${u}, d),
              getValue(batch, xR, xC + 2 * ${u}, d),
              initializationValue
            );

            ${T}
          }
        }
        setOutput(${w});
      }
    `}}class sN{constructor(e,n,r,i=!1,s=!1){if(this.variableNames=["x"],n==="avg"&&r)throw new Error("Cannot compute positions for average pool.");const o=e.filterWidth,a=e.strideDepth,l=e.strideHeight,c=e.strideWidth,u=e.dilationDepth,d=e.dilationHeight,f=e.dilationWidth,h=e.effectiveFilterDepth,p=e.effectiveFilterHeight,x=e.effectiveFilterWidth,v=e.padInfo.front,y=e.padInfo.top,b=e.padInfo.left;this.outputShape=e.outShape;const S=n==="avg";let w="0.0";if(S||(w="-1.0 / 1e-20"),r){const M=">=";this.userCode=`
        const ivec3 strides =
            ivec3(${a}, ${l}, ${c});
        const ivec3 pads = ivec3(${v}, ${y}, ${b});

        void main() {
          ivec5 coords = getOutputCoords();
          int batch = coords.x;
          int ch = coords.u;

          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
          int xDCorner = xCorner.x;
          int xRCorner = xCorner.y;
          int xCCorner = xCorner.z;

          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).
          // ? = to be determined
          float minMaxValue = 0.0;
          float minMaxValueFound = 0.0;
          int minMaxPosition = 0;

          for (int wD = 0; wD < ${h};
              wD += ${u}) {
            int xD = xDCorner + wD;

            if (xD < 0 || xD >= ${e.inDepth}) {
              continue;
            }

            for (int wR = 0; wR < ${p};
                wR += ${d}) {
              int xR = xRCorner + wR;

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int wC = 0; wC < ${x};
                  wC += ${f}) {
                int xC = xCCorner + wC;

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float value = getX(batch, xD, xR, xC, ch);

                // If a min / max value has already been found, use it. If not,
                // use the current value.
                float currMinMaxValue = mix(
                    value, minMaxValue, minMaxValueFound);
                if (value ${M} currMinMaxValue) {
                  minMaxValue = value;
                  minMaxValueFound = 1.0;
                  minMaxPosition = ${i?s?`(((batch * ${e.inDepth} + xD) * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`((xD * ${e.inHeight} + xR) * ${e.inWidth} + xC) * ${e.inChannels} + ch`:`wD * ${p} * ${x} +
                      wR * ${x} + wC`};
                }
              }
            }
          }
          setOutput(float(minMaxPosition));
        }
      `;return}const E="max";let A=`${n}(${n}(${n}(minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])`;n==="avg"&&(A="avgValue / count");const T=Math.floor(o/4)*4,I=o%4,N=`
      if (${S}) {
        avgValue += dot(values, ones);
      } else {
        minMaxValue = ${E}(values, minMaxValue);
      }
    `;this.userCode=`
      const ivec3 strides =
        ivec3(${a}, ${l}, ${c});
      const ivec3 pads = ivec3(${v}, ${y}, ${b});
      const float initializationValue = ${w};
      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);

      float count = 0.0;

      float getValue(int batch, int xD, int xR, int xC, int ch) {
        if (xC < 0 || xC >= ${e.inWidth}) {
          return initializationValue;
        }
        count += 1.0;
        return getX(batch, xD, xR, xC, ch);
      }

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xDCorner = xCorner.x;
        int xRCorner = xCorner.y;
        int xCCorner = xCorner.z;

        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).
        // ? = to be determined
        vec4 minMaxValue = vec4(${w});
        float avgValue = 0.0;
        count = 0.0;

        for (int wD = 0; wD < ${h};
            wD += ${u}) {
          int xD = xDCorner + wD;

          if (xD < 0 || xD >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${p};
            wR += ${d}) {
            int xR = xRCorner + wR;

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${T}; wC += 4) {
              int xC = xCCorner + wC * ${f};

              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                getValue(batch, xD, xR, xC + 3 * ${f}, ch)
              );

              ${N}
            }

            int xC = xCCorner + ${T};
            if (${I===1}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                initializationValue,
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${I===2}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                initializationValue,
                initializationValue
              );

              ${N}
            } else if (${I===3}) {
              vec4 values = vec4(
                getValue(batch, xD, xR, xC, ch),
                getValue(batch, xD, xR, xC + ${f}, ch),
                getValue(batch, xD, xR, xC + 2 * ${f}, ch),
                initializationValue
              );

              ${N}
            }
          }
          setOutput(${A});
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aRe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;z0(i,"avgPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=r,c=1;Y(ls(o,c),()=>`Error in avgPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=Bd(i.shape,s,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Yn(u.inShape,u.outShape))return os({inputs:{x:i},backend:n});const d=new o0(u,"avg",!1);return n.runWebGLProgram(d,[i],"float32")}const lRe={kernelName:V6,backendName:"webgl",kernelFunc:aRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cRe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:s,strides:o,pad:a,dimRoundingMode:l,dataFormat:c}=r,u=[1,1,1],d=B0(i.shape,s,o,u,a,l,c),f=new sN(d,"avg",!1);return n.runWebGLProgram(f,[i],"float32")}const uRe={kernelName:W6,backendName:"webgl",kernelFunc:cRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dRe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,i=e.strideHeight,s=e.strideWidth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterHeight,c=e.effectiveFilterWidth,u=l-1-e.padInfo.top,d=c-1-e.padInfo.left,f=1/(n*r);this.userCode=`
      const ivec2 pads = ivec2(${u}, ${d});
      const float avgMultiplier = float(${f});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${l};
            wR += ${o}) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${c};
            wC+= ${a}) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);

            dotProd += dyValue * avgMultiplier;
          }
        }
        setOutput(dotProd);
      }
    `}}class fRe{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,i=e.filterWidth,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,d=e.effectiveFilterDepth,f=e.effectiveFilterHeight,h=e.effectiveFilterWidth,p=d-1-e.padInfo.front,x=f-1-e.padInfo.top,v=h-1-e.padInfo.left,y=1/(n*r*i);this.userCode=`
      const ivec3 pads = ivec3(${p}, ${x}, ${v});
      const float avgMultiplier = float(${y});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${d};
            wD += ${l}) {
          float dyD = float(dyDCorner + wD) / ${s}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${f};
              wR += ${c}) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${h};
                wC += ${u}) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);

              dotProd += dyValue * avgMultiplier;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function hRe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,d=[1,1,1],f=B0(o.shape,a,l,d,c,u),h=new fRe(f);return n.runWebGLProgram(h,[i],o.dtype)}const pRe={kernelName:Hme,backendName:"webgl",kernelFunc:hRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mRe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,o=s;z0([i,s],"avgPoolGrad");const{filterSize:a,strides:l,pad:c}=r,u=Bd(o.shape,a,l,1,c),d=new dRe(u);return n.runWebGLProgram(d,[i],o.dtype)}const gRe={kernelName:Gme,backendName:"webgl",kernelFunc:mRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yRe(t){const{inputs:e,backend:n,attrs:r}=t,{a:i,b:s}=e,{transposeA:o,transposeB:a}=r;return rb({a:i,b:s,transposeA:o,transposeB:a,backend:n})}const vRe={kernelName:j6,backendName:"webgl",kernelFunc:yRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class xRe{constructor(e,n,r,i,s,o){this.outputShape=[],this.variableNames=["x","mean","variance"],Qt(e,n),Qt(e,r);let a="0.0";i!=null&&(Qt(e,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="1.0";s!=null&&(Qt(e,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        float x = getXAtOutCoords();
        float mean = getMeanAtOutCoords();
        float variance = getVarianceAtOutCoords();
        float offset = ${a};
        float scale = ${l};
        float inv = scale * inversesqrt(variance + float(${o}));
        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class bRe{constructor(e,n,r,i,s,o){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Qt(e,n),Qt(e,r);let a="vec4(0.0)";i!=null&&(Qt(e,i),this.variableNames.push("offset"),a="getOffsetAtOutCoords()");let l="vec4(1.0)";s!=null&&(Qt(e,s),this.variableNames.push("scale"),l="getScaleAtOutCoords()"),this.outputShape=e,this.userCode=`
      void main() {
        vec4 offset = ${a};
        vec4 scale = ${l};

        vec4 x = getXAtOutCoords();
        vec4 mean = getMeanAtOutCoords();
        vec4 variance = getVarianceAtOutCoords();

        vec4 inv = scale * inversesqrt(variance + vec4(${o}));

        setOutput((x - mean) * inv + offset);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SRe=({inputs:t,backend:e,attrs:n})=>{const{x:r,mean:i,variance:s,offset:o,scale:a}=t;Y(i.shape.length===s.shape.length,()=>"Batch normalization gradient requires mean and variance to have equal ranks."),Y(o==null||i.shape.length===o.shape.length,()=>"Batch normalization gradient requires mean and offset to have equal ranks."),Y(a==null||i.shape.length===a.shape.length,()=>"Batch normalization gradient requires mean and scale to have equal ranks.");let{varianceEpsilon:l}=n;l==null&&(l=.001);const c=[r,i,s];let u=null;o!=null&&(u=o.shape,c.push(o));let d=null;a!=null&&(d=a.shape,c.push(a));const f=ge().getBool("WEBGL_PACK_NORMALIZATION")?new bRe(r.shape,i.shape,s.shape,u,d,l):new xRe(r.shape,i.shape,s.shape,u,d,l);return e.runWebGLProgram(f,c,c[0].dtype)},_Re={kernelName:Nz,backendName:"webgl",kernelFunc:SRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wRe{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const n=An(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const r=CRe(this.rank);let i;const s=e.map((o,a)=>`sourceLoc.${IT[a]} = start[${a}] + coords.${IT[a]};`);i=`
        ${n} sourceLoc;
        ${n} coords = getOutputCoords();
        ${s.join(`
`)}
      `,this.userCode=`
      void main() {
        ${i}
        setOutput(getSource(${r}));
      }
    `}}const IT=["x","y","z","w","u","v"];function CRe(t){if(t===1)return"sourceLoc";if(t<=6)return IT.slice(0,t).map(e=>"sourceLoc."+e).join(",");throw Error(`Slicing for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ERe{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=An(this.rank),r=yi("coords",this.rank),i=yi("sourceLoc",this.rank),s=this.rank===1?"sourceLoc":`vec2(${i.slice(-2).join()})`,o=`getChannel(getSource(${i.join()}), ${s})`,a=`
      result.x = ${o};
      if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
        ++${i[this.rank-1]};
        result.y = ${o};
        --${i[this.rank-1]};
      }
    `,l=this.rank===1?"":`
      --${r[this.rank-1]};
      if (++${r[this.rank-2]} < ${e[this.rank-2]}) {
        ++${i[this.rank-2]};
        result.z = ${o};
        if (++${r[this.rank-1]} < ${e[this.rank-1]}) {
          ++${i[this.rank-1]};
          result.w = ${o};
        }
      }
    `,c=this.rank<=4?`sourceLoc = coords +
            ${n}(${e.map((u,d)=>`start[${d}]`).join()});`:e.map((u,d)=>`${i[d]} = ${r[d]} + start[${d}];`).join(`
`);this.userCode=`
      void main() {
        ${n} coords = getOutputCoords();
        ${n} sourceLoc;
        ${c}
        vec4 result = vec4(0.);
        ${a}
        ${l}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ARe(t,e,n,r){const i=r.texData.get(t.dataId),s=r.makeTensorInfo(n,t.dtype),o=r.texData.get(s.dataId);Object.assign(o,i),o.refCount=1,o.shape=n,o.dtype=t.dtype;let a=EI(e,Vr(t.shape));i.slice&&(a+=i.slice.flatOffset),o.slice={flatOffset:a,origDataId:i.slice&&i.slice.origDataId||t.dataId};const l=r.dataRefCount.get(o.slice.origDataId)||1;return r.dataRefCount.set(o.slice.origDataId,l+1),s}function Pp(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{begin:s,size:o}=r,[a,l]=hH(i,s,o);if(rH(i,a,l),Ve(l)===0)return n.makeTensorInfo(l,i.dtype,[]);if(n.shouldExecuteOnCPU([i])||i.dtype==="string"){const d=n.texData.get(i.dataId),f=xTe(d.values,a,l,i.shape,i.dtype);return n.makeTensorInfo(l,i.dtype,f)}const{isPacked:c}=n.texData.get(i.dataId),u=CI(i.shape,a,l);if(c||!u){const d=ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ERe(l):new wRe(l),f=[a];return n.runWebGLProgram(d,[i],i.dtype,f)}return n.uploadToGPU(i.dataId),ARe(i,a,l,n)}const TRe={kernelName:F8,backendName:"webgl",kernelFunc:Pp};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const MRe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:s,crops:o}=r;Y(i.shape.length<=4,()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((b,S)=>b*S),l=KI(i.shape,s,a),c=qI(l.length,s.length),u=JI(i.shape,s,a),d=lV(o,s.length),f=cV(u,o,s.length),h=[],p=qe({inputs:{x:i},backend:n,attrs:{shape:l}}),x=bi({inputs:{x:p},backend:n,attrs:{perm:c}}),v=qe({inputs:{x},backend:n,attrs:{shape:u}}),y=Pp({inputs:{x:v},backend:n,attrs:{begin:d,size:f}});return h.push(p),h.push(x),h.push(v),h.forEach(b=>n.disposeIntermediateTensorInfo(b)),y},RRe={kernelName:X6,backendName:"webgl",kernelFunc:MRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function IRe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,weights:s}=e,{size:o}=r,a=n.readSync(i.dataId),l=n.readSync(s.dataId),c=n7(a,l,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,c)}const NRe={kernelName:K6,backendName:"webgl",kernelFunc:IRe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PRe(t){const{inputs:e,backend:n}=t,{s0:r,s1:i}=e,s=n.readSync(r.dataId),o=n.readSync(i.dataId),a=Qt(Array.from(s),Array.from(o));return n.makeTensorInfo([a.length],"int32",Int32Array.from(a))}const kRe={kernelName:q6,backendName:"webgl",kernelFunc:PRe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const DRe="return float(a != b);",g7=Xr({opSnippet:DRe,cpuKernelImpl:dTe,dtype:"bool"}),ORe={kernelName:u8,backendName:"webgl",kernelFunc:g7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W0(t){const{inputs:e,backend:n}=t,{input:r}=e,i=n.texData.get(r.dataId);return os({inputs:{x:i.complexTensorInfos.real},backend:n})}const LRe={kernelName:C8,backendName:"webgl",kernelFunc:W0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BRe="return float(int(x));";function FRe(t,e){const n=new al(t.shape,BRe),r=e.runWebGLProgram(n,[t],"int32");return{dataId:r.dataId,shape:r.shape,dtype:r.dtype}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NT(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dtype:s}=r;if(s==="complex64"){if(i.dtype==="complex64")return os({inputs:{x:i},backend:n});const o=Sd(i.shape),a=NT({inputs:{x:i},backend:n,attrs:{dtype:"float32"}}),l=Vc({inputs:{real:a,imag:o},backend:n});return o.dispose(),n.disposeIntermediateTensorInfo(a),l}if(i.dtype==="complex64"){const o=W0({inputs:{input:i},backend:n}),a=NT({inputs:{x:o},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(o),a}if(!Pme(i.dtype,s)){const o=os({inputs:{x:i},backend:n});return{dataId:o.dataId,shape:o.shape,dtype:s}}if(n.shouldExecuteOnCPU([i])){const o=n.texData.get(i.dataId).values,[a,l,c]=W2e(o,i.shape,i.dtype,s);return n.makeTensorInfo(a,l,c)}if(s==="int32")return FRe(i,n);if(s==="bool"){const o=n.makeTensorInfo([],"bool",Sl("bool",1)),l=g7({inputs:{a:i,b:o},backend:n});return n.disposeIntermediateTensorInfo(o),l}throw new Error(`Error in Cast: failed to cast ${i.dtype} to ${s}`)}const $Re={kernelName:fI,backendName:"webgl",kernelFunc:NT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const sB="return ceil(x);",URe=qt({opSnippet:sB,packedOpSnippet:sB,cpuKernelImpl:j2e}),zRe={kernelName:J6,backendName:"webgl",kernelFunc:URe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GRe{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`

      void main() {
        float value = getAAtOutCoords();
        if (isnan(value)) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, minVal, maxVal));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class HRe{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode=`
      void main() {
        vec4 value = getAAtOutCoords();

        if (any(isnan(value))) {
          setOutput(value);
          return;
        }

        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VRe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{clipValueMin:s,clipValueMax:o}=r;let a;ge().getBool("WEBGL_PACK_CLIP")?a=new HRe(i.shape):a=new GRe(i.shape);const l=[[s],[o]];return n.runWebGLProgram(a,[i],i.dtype,l)}const WRe={kernelName:Y6,backendName:"webgl",kernelFunc:VRe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jRe{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode=`
      void main() {
        float re = abs(getRealAtOutCoords());
        float im = abs(getImagAtOutCoords());
        float mx = max(re, im);

        // sadly the length function in glsl is not underflow-safe
        // (at least not on Intel GPUs). So the safe solution is
        // to ensure underflow-safety in all cases.
        setOutput(
          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))
        );
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oB(t,e){return{dataId:e.dataId,dtype:e.dtype,shape:t.shape}}function XRe(t){const{inputs:e,backend:n}=t,{x:r}=e,i=n.texData.get(r.dataId),s=new jRe(r.shape),o=[oB(r,i.complexTensorInfos.real),oB(r,i.complexTensorInfos.imag)];return n.runWebGLProgram(s,o,o[0].dtype)}const KRe={kernelName:Z6,backendName:"webgl",kernelFunc:XRe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class qRe{constructor(e){this.outputShape=[],this.outputShape=wd(e,1),this.variableNames=e.map((o,a)=>`T${a}`);const n=new Array(e.length-1);n[0]=e[0][1];for(let o=1;o<n.length;o++)n[o]=n[o-1]+e[o][1];const r=[`if (yC < ${n[0]}) setOutput(getT0(yR, yC));`];for(let o=1;o<n.length;o++){const a=n[o-1];r.push(`else if (yC < ${n[o]}) setOutput(getT${o}(yR, yC-${a}));`)}const i=n.length,s=n[n.length-1];r.push(`else setOutput(getT${i}(yR, yC-${s}));`),this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int yR = coords.x;
        int yC = coords.y;

        ${r.join(`
        `)}
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class JRe{constructor(e,n){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=wd(e,n);const r=this.outputShape,i=r.length,s=An(i),o=yi("coords",i),a=["x","y","z","w","u","v"].slice(0,i);this.variableNames=e.map((x,v)=>`T${v}`);const l=new Array(e.length-1);l[0]=e[0][n];for(let x=1;x<l.length;x++)l[x]=l[x-1]+e[x][n];const c=a[n],u=a.slice(-2),d=a.join();let f=`if (${c} < ${l[0]}) {
        return getChannel(
            getT0(${d}), vec2(${u.join()}));
        }`;for(let x=1;x<l.length;x++){const v=l[x-1];f+=`
        if (${c} < ${l[x]}  && ${c} >= ${l[x-1]}) {
          return getChannel(
            getT${x}(${Sx(a,c,v)}),
            vec2(${Sx(u,c,v)}));
        }`}const h=l.length,p=l[l.length-1];f+=`
        return getChannel(
          getT${h}(${Sx(a,c,p)}),
          vec2(${Sx(u,c,p)}));`,this.userCode=`
      float getValue(${a.map(x=>"int "+x)}) {
        ${f}
      }

      void main() {
        ${s} coords = getOutputCoords();
        vec4 result = vec4(getValue(${o}), 0., 0., 0.);

        ${o[i-1]} = ${o[i-1]} + 1;
        if (${o[i-1]} < ${r[i-1]}) {
          result.g = getValue(${o});
        }

        ${o[i-2]} = ${o[i-2]} + 1;
        if (${o[i-2]} < ${r[i-2]}) {
          result.a = getValue(${o});
        }

        ${o[i-1]} = ${o[i-1]} - 1;
        if (${o[i-2]} < ${r[i-2]} &&
            ${o[i-1]} < ${r[i-1]}) {
          result.b = getValue(${o});
        }
        setOutput(result);
      }
    `}}function Sx(t,e,n){const r=t.indexOf(e);return t.map((s,o)=>o===r?`${s} - ${n}`:s).join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v_(t){const{inputs:e,backend:n}=t,{input:r}=e,i=n.texData.get(r.dataId);return os({inputs:{x:i.complexTensorInfos.imag},backend:n})}const YRe={kernelName:Bz,backendName:"webgl",kernelFunc:v_};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Wm(t,e,n){const r=t[0].dtype;if(r==="complex64"){const d=t.map(v=>W0({inputs:{input:v},backend:n})),f=t.map(v=>v_({inputs:{input:v},backend:n})),h=Wm(d,e,n),p=Wm(f,e,n),x=Vc({inputs:{real:h,imag:p},backend:n});return d.forEach(v=>n.disposeIntermediateTensorInfo(v)),f.forEach(v=>n.disposeIntermediateTensorInfo(v)),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),x}let i=n.shouldExecuteOnCPU(t);if(r==="string"&&(i=!0),i){const d=t.map(b=>{const w=[-1,Ve(b.shape.slice(e))];return qe({inputs:{x:b},backend:n,attrs:{shape:w}})}),f=d.map(b=>({vals:n.readSync(b.dataId),shape:b.shape})),h=wd(d.map(b=>b.shape),1),p=d[0].shape[0]===1,x=X2e(f,h,r,p),v=wd(t.map(b=>b.shape),e),y=n.makeTensorInfo(v,r,x);return d.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}const s=ge().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(t.length>s){const d=[];for(let h=0;h<t.length;h+=s){const p=t.slice(h,h+s);d.push(Wm(p,e,n))}const f=Wm(d,e,n);for(const h of d)n.disposeIntermediateTensorInfo(h);return f}if(ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&t[0].shape.length>1){const d=new JRe(t.map(f=>f.shape),e);return n.runWebGLProgram(d,t,r)}const{tensors2D:o,outShape:a}=QRe(t,e,n),l=new qRe(o.map(d=>d.shape)),c=n.runWebGLProgram(l,o,r);o.forEach(d=>n.disposeIntermediateTensorInfo(d));const u=qe({inputs:{x:c},attrs:{shape:a},backend:n});return n.disposeIntermediateTensorInfo(c),u}function QRe(t,e,n){const r=wd(t.map(s=>s.shape),e);return{tensors2D:t.map(s=>qe({inputs:{x:s},attrs:{shape:[-1,Ve(s.shape.slice(e))]},backend:n})),outShape:r}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function y7(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r,s=Dr(i,e[0].shape)[0],o=e.map(c=>c.shape);nV(o,s);const a=wd(e.map(c=>c.shape),s);if(Ve(a)===0)return n.makeTensorInfo(a,e[0].dtype,[]);const l=e.filter(c=>Ve(c.shape)>0);return l.length===1?os({inputs:{x:l[0]},backend:n}):Wm(l,s,n)}const ZRe={kernelName:ez,backendName:"webgl",kernelFunc:y7};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class v7{constructor(e,n=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.outputShape=e.outShape;const o=e.padInfo.top,a=e.padInfo.left,l=e.strideHeight,c=e.strideWidth,u=e.dilationHeight,d=e.dilationWidth,f=e.filterHeight,h=e.filterWidth,p=Math.floor(e.inChannels/4)*4,x=e.inChannels%4,v=e.dataFormat==="channelsLast",y=v?1:2,b=v?2:3,S=v?3:1;let w="",E="";r&&(i?w=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?w=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:w=`
          float activation(float x) {
            ${r}
          }
        `,E="result = activation(result);");const A=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${w}

      const ivec2 strides = ivec2(${l}, ${c});
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d2 = coords[${S}];

        ivec2 xRCCorner =
            ivec2(coords[${y}], coords[${b}]) * strides - pads;
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${f}; wR++) {
          int xR = xRCorner + wR * ${u};

          if (xR < 0 || xR >= ${e.inHeight}) {
            continue;
          }

          for (int wC = 0; wC < ${h}; wC++) {
            int xC = xCCorner + wC * ${d};

            if (xC < 0 || xC >= ${e.inWidth}) {
              continue;
            }

            for (int d1 = 0; d1 < ${p}; d1 += 4) {
              vec4 wValues = vec4(
                getW(wR, wC, d1, d2),
                getW(wR, wC, d1 + 1, d2),
                getW(wR, wC, d1 + 2, d2),
                getW(wR, wC, d1 + 3, d2)
              );

              if (${v}) {
                vec4 xValues = vec4(
                  getX(batch, xR, xC, d1),
                  getX(batch, xR, xC, d1 + 1),
                  getX(batch, xR, xC, d1 + 2),
                  getX(batch, xR, xC, d1 + 3)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec4 xValues = vec4(
                  getX(batch, d1, xR, xC),
                  getX(batch, d1 + 1, xR, xC),
                  getX(batch, d1 + 2, xR, xC),
                  getX(batch, d1 + 3, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }
            }

            if (${x===1}) {

              if (${v}) {
                dotProd +=
                    getX(batch, xR, xC, ${p}) *
                    getW(wR, wC, ${p}, d2);
              } else {
                dotProd +=
                    getX(batch, ${p}, xR, xC) *
                    getW(wR, wC, ${p}, d2);
              }

            } else if (${x===2}) {
              vec2 wValues = vec2(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2)
              );

              if (${v}) {
                vec2 xValues = vec2(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec2 xValues = vec2(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            } else if (${x===3}) {
              vec3 wValues = vec3(
                getW(wR, wC, ${p}, d2),
                getW(wR, wC, ${p} + 1, d2),
                getW(wR, wC, ${p} + 2, d2)
              );

              if (${v}) {
                vec3 xValues = vec3(
                  getX(batch, xR, xC, ${p}),
                  getX(batch, xR, xC, ${p} + 1),
                  getX(batch, xR, xC, ${p} + 2)
                );
                dotProd += dot(xValues, wValues);
              } else {
                vec3 xValues = vec3(
                  getX(batch, ${p}, xR, xC),
                  getX(batch, ${p} + 1, xR, xC),
                  getX(batch, ${p} + 2, xR, xC)
                );
                dotProd += dot(xValues, wValues);
              }

            }
          }
        }

        float result = dotProd;
        ${A}
        ${E}
        setOutput(result);
      }
    `}}class eIe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const n=e.padInfo.front,r=e.padInfo.top,i=e.padInfo.left,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=e.dilationDepth,c=e.dilationHeight,u=e.dilationWidth,d=e.filterDepth,f=e.filterHeight,h=e.filterWidth,p=Math.floor(e.inChannels/4)*4,x=e.inChannels%4;this.userCode=`
      const ivec3 strides = ivec3(${s}, ${o}, ${a});
      const ivec3 pads = ivec3(${n}, ${r}, ${i});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d2 = coords.u;

        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;
        int xFCorner = xFRCCorner.x;
        int xRCorner = xFRCCorner.y;
        int xCCorner = xFRCCorner.z;

        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get
        // y(yF, yR, yC, d2). ? = to be determined. : = across all
        // values in that axis.
        float dotProd = 0.0;
        for (int wF = 0; wF < ${d}; wF++) {
          int xF = xFCorner + wF * ${l};

          if (xF < 0 || xF >= ${e.inDepth}) {
            continue;
          }

          for (int wR = 0; wR < ${f}; wR++) {
            int xR = xRCorner + wR * ${c};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int wC = 0; wC < ${h}; wC++) {
              int xC = xCCorner + wC * ${u};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              for (int d1 = 0; d1 < ${p}; d1 += 4) {
                vec4 xValues = vec4(
                  getX(batch, xF, xR, xC, d1),
                  getX(batch, xF, xR, xC, d1 + 1),
                  getX(batch, xF, xR, xC, d1 + 2),
                  getX(batch, xF, xR, xC, d1 + 3)
                );
                vec4 wValues = vec4(
                  getW(wF, wR, wC, d1, d2),
                  getW(wF, wR, wC, d1 + 1, d2),
                  getW(wF, wR, wC, d1 + 2, d2),
                  getW(wF, wR, wC, d1 + 3, d2)
                );

                dotProd += dot(xValues, wValues);
              }

              if (${x===1}) {
                dotProd +=
                  getX(batch, xF, xR, xC, ${p}) *
                  getW(wF, wR, wC, ${p}, d2);
              } else if (${x===2}) {
                vec2 xValues = vec2(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1)
                );
                vec2 wValues = vec2(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2)
                );
                dotProd += dot(xValues, wValues);
              } else if (${x===3}) {
                vec3 xValues = vec3(
                  getX(batch, xF, xR, xC, ${p}),
                  getX(batch, xF, xR, xC, ${p} + 1),
                  getX(batch, xF, xR, xC, ${p} + 2)
                );
                vec3 wValues = vec3(
                  getW(wF, wR, wC, ${p}, d2),
                  getW(wF, wR, wC, ${p} + 1, d2),
                  getW(wF, wR, wC, ${p} + 2, d2)
                );
                dotProd += dot(xValues, wValues);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class x7{constructor(e,n=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ci(this.outputShape.length);const o=e.padInfo.left,a=e.strideWidth,l=e.dilationWidth,c=e.filterHeight,u=e.filterWidth,d=u;let f=`
       int xR; int xC; int xCOffset;
       vec4 wTexel; vec4 previous; vec4 final;`;for(let v=0;v<u;v++)f+=`
           vec4 xTexelC${v*2};
           int xTexelC${v*2}Ready;
           vec4 xTexelC${v*2+1};
           int xTexelC${v*2+1}Ready;
           vec4 xC${v};`;f+=`
     for (int r = 0; r < ${c}; r++) {
      for (int d1 = 0; d1 < ${e.inChannels}; d1 += 2) {
       `;for(let v=0;v<u;v++)f+=`
           xTexelC${v*2} = vec4(0.0);
           xTexelC${v*2}Ready = 0;
           xTexelC${v*2+1} = vec4(0.0);
           xTexelC${v*2+1}Ready = 0;
           xC${v} = vec4(0.0);`;f+=`
         xR = xRCorner + r * dilations[0];
         if (xR >=0 && xR < inDims[0]) {
       `;for(let v=0;v<(d+1)/2;v++){const y=v*2;if(f+=`
           xC = xCCorner + ${y*l};
           `,a===1){if(y<u&&(o%2===1?(f+=`
                 xCOffset = xC + 1;
                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);

                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }
               `,l===1&&y>0?f+=`
                 xC${y} = vec4(xTexelC${y-2}.zw, xTexelC${y}.xy);
                 `:f+=`
                   xCOffset = xC + 1 - 2;

                   if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       previous.zw = vec2(0.0);
                     }

                     xC${y} = vec4(previous.zw, xTexelC${y}.xy);
                   } else {
                     xC${y} = vec4(0.0, 0.0, xTexelC${y}.xy);
                   }
                   `):f+=`
                 if (xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xC${y} = xTexelC${y};
                 `,y+1<u)){const b=o%2===0?lI(l):l;l%2===0&&o%2===1||l%2!==0&&o%2!==1?(f+=`
                   xCOffset = xC + imod(pads[1], 2) + ${b};

                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                     xTexelC${y+1} = getX(batch, xR, xCOffset, d1);

                     // Need to manually clear unused channels in case
                     // we're reading from recycled texture.
                     if (xCOffset + 1 >= inDims[1]) {
                       xTexelC${y+1}.zw = vec2(0.0);
                     }
                     xTexelC${y+1}Ready = 1;
                   }
                   `,l>1?f+=`
                     xCOffset -= 2;
                     if (xCOffset >= 0 && xCOffset < inDims[1]) {
                      previous = getX(batch, xR, xCOffset, d1);
                      xC${y+1} = vec4(previous.zw, xTexelC${y+1}.xy);
                     } else {
                      xC${y+1} = vec4(0.0, 0.0, xTexelC${y+1}.xy);
                     }
                     `:f+=`
                     xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.xy);
                     `):b===1?f+=`
                     xC${y+1} = xTexelC${y};
                     `:f+=`
                     xCOffset = xC + ${b};

                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                       xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                       if (xCOffset + 1 >= inDims[1]) {
                         xTexelC${y+1}.zw = vec2(0.0);
                       }
                       xTexelC${y+1}Ready = 1;
                     }

                     xC${y+1} = xTexelC${y+1};
                     `}}else y<u&&(o%2===1?(f+=`
                 xCOffset = xC + 1 - strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xCOffset, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xC + 1, d1);
                   // Need to manually clear unused channels in case
                   // we're reading from recycled texture.
                   if (xC + 2 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.0);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
               `,y+1<u&&(f+=`
                   final = vec4(0.0);
                   xCOffset = xC + 1 + strides[1];
                   if(xCOffset >= 0 && xCOffset < inDims[1]) {
                     final = getX(batch, xR, xCOffset, d1);
                   }
                   xC${y+1} = vec4(xTexelC${y+1}.xy, final.xy);
                 `)):(f+=`
                 if(xC >= 0 && xC < inDims[1] && xTexelC${y}Ready == 0) {
                   xTexelC${y} = getX(batch, xR, xC, d1);
                   if (xC + 1 >= inDims[1]) {
                     xTexelC${y}.zw = vec2(0.0);
                   }
                   xTexelC${y}Ready = 1;
                 }

                 xCOffset = xC + strides[1];
                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${y+1}Ready == 0) {
                   xTexelC${y+1} = getX(batch, xR, xCOffset, d1);
                   if (xCOffset + 1 >= inDims[1]) {
                     xTexelC${y+1}.zw = vec2(0.);
                   }
                   xTexelC${y+1}Ready = 1;
                 }

                 xC${y} = vec4(
                   xTexelC${y}.xy, xTexelC${y+1}.xy);
               `,y+1<u&&(f+=`
                   xC${y+1} = vec4(xTexelC${y}.zw, xTexelC${y+1}.zw);
                 `)));y<u&&(f+=`
             wTexel = getW(r, ${y}, d1, d2);
             dotProd += xC${y}.xxzz * vec4(wTexel.xy, wTexel.xy);
             if(d1 + 1 < ${e.inChannels}) {
               dotProd += xC${y}.yyww * vec4(wTexel.zw, wTexel.zw);
             }
           `,y+1<u&&(f+=`
               wTexel = getW(r, ${y+1}, d1, d2);
               dotProd += xC${y+1}.xxzz * vec4(wTexel.xy, wTexel.xy);
               if(d1 + 1 < ${e.inChannels}) {
                 dotProd += xC${y+1}.yyww * vec4(wTexel.zw, wTexel.zw);
               }
             `))}f+=`
     }
   `,f+=`
     }
   `,f+=`
     }
   `;let h="",p="";r&&(i?h=`vec4 activation(vec4 a) {
           vec4 b = getPreluActivationWeightsAtOutCoords();
           ${r}
         }`:s?h=`vec4 activation(vec4 a) {
           vec4 b = getLeakyreluAlphaAtOutCoords();
           ${r}
         }`:h=`vec4 activation(vec4 x) {
           ${r}
         }`,p="result = activation(result);");const x=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
       ${h}

       void main() {
         ivec4 coords = getOutputCoords();
         int batch = coords.x;
         ivec2 xRCCorner = coords.yz * strides - pads;
         int d2 = coords.w;
         int xRCorner = xRCCorner.x;
         int xCCorner = xRCCorner.y;

         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
         vec4 dotProd = vec4(0.000000000000001);

         ${f}

         vec4 result = dotProd - vec4(0.000000000000001);
         ${x}
         ${p}
         setOutput(result);
       }
     `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tIe{constructor(e,n){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=Ci(this.outputShape.length);const{dataFormat:r}=n,i=wi(),s=r==="channelsLast",o=s?1:2,a=s?2:3,l=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":`if(blockIndex < ${e[2]} && pos < ${e[1]}) {`;let c="";for(let u=0;u<=1;u++)for(let d=0;d<=1;d++)c+=`
          blockIndex = rc.z + ${d};
          pos = rc.y + ${u};

          ${l}
            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];
            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);

            if(d0 < inputShape[${o}] && d0 >= 0) {
              // Use custom imod instead mod. On Intel GPU, mod may generate
              // unexpected value.
              // https://github.com/tensorflow/tfjs/issues/5447
              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];
              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /
                  inChannels);

              if(d1 < inputShape[${a}] && d1 >= 0) {

                ch = imod(pos, inChannels);

                if (${s}) {
                  innerDims = vec2(d1, ch);
                  result[${u*2+d}] = getChannel(
                    getA(rc.x, d0, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                } else {
                  innerDims = vec2(d0, d1);
                  result[${u*2+d}] = getChannel(
                    getA(rc.x, ch, int(innerDims.x),
                    int(innerDims.y)), innerDims);
                }
              }
            }
          }
        `;this.userCode=`
      void main() {
        ivec3 rc = getOutputCoords();

        vec4 result = vec4(0);

        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;
        vec2 innerDims;

        ${c}

        ${i.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ib(t,e){const n=t.length;return n>=3?e?[...t.slice(0,-3),t[n-3]*t[n-2],t[n-1]]:[...t.slice(0,-3),t[n-3],t[n-2]*t[n-1]]:!e&&n===1&&t[0]>1?[t[0],1]:null}function b7({x:t,filter:e,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const l=t.shape,c=r.texData.get(t.dataId),u=n.inChannels,d=l[0]*l[1]*l[2],f=n.outChannels,h=n.dataFormat==="channelsLast",p=!1,x=!1;let v;const y=[];if(s!=null){const w=ib(s.shape,h);w!=null&&(s=qe({inputs:{x:s},backend:r,attrs:{shape:w}}),y.push(s))}if(i!=null){const w=ib(i.shape,h);w!=null&&(i=qe({inputs:{x:i},backend:r,attrs:{shape:w}}),y.push(i))}if(!((d===1||f===1)&&u>f7)&&c.isPacked&&h&&c.texture!=null&&l[2]%2!==0&&Yn(c.shape.slice(-3),l.slice(-3))){const w=l[0]*l[1]*(l[2]+1),E={dataId:t.dataId,shape:[1,w,n.inChannels],dtype:t.dtype},A=c.shape;c.shape=c.shape.slice(),c.shape[c.shape.length-2]++,Y(tb(c.shape,E.shape),()=>`packed reshape ${c.shape} to ${E.shape} isn't free`);const T=qe({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}});y.push(T);const I=rb({a:E,b:T,backend:r,transposeA:p,transposeB:x,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o}),N=r.texData.get(I.dataId);Y(N.isPacked,()=>"batchMatMul result is expected to be packed"),c.shape=A,N.shape=n.outShape,v=os({inputs:{x:I},backend:r}),v.shape=n.outShape,y.push(I)}else{const w=n.outHeight*n.outWidth,E=qe({inputs:{x:t},backend:r,attrs:{shape:h?[n.batchSize,w,n.inChannels]:[n.batchSize,n.inChannels,w]}}),A=qe({inputs:{x:e},backend:r,attrs:{shape:[1,n.inChannels,n.outChannels]}}),T=rb({a:h?E:A,b:h?A:E,transposeA:!h,transposeB:x,backend:r,bias:i,activation:a,preluActivationWeights:s,leakyreluAlpha:o});v=qe({inputs:{x:T},backend:r,attrs:{shape:n.outShape}}),y.push(E),y.push(A),y.push(T)}for(const w of y)r.disposeIntermediateTensorInfo(w);return v}function S7({x:t,filter:e,convInfo:n,backend:r,bias:i=null,preluActivationWeights:s=null,leakyreluAlpha:o=0,activation:a=null}){const{filterWidth:l,filterHeight:c,inChannels:u,outWidth:d,outHeight:f,dataFormat:h}=n,p=h==="channelsLast",x=l*c*u,v=f*d,y=[n.batchSize,x,v],b=!0,S=!1,w=[];if(s!=null){const O=ib(s.shape,p);O!=null&&(s=qe({inputs:{x:s},backend:r,attrs:{shape:O}}),w.push(s))}if(i!=null){const O=ib(i.shape,p);O!=null&&(i=qe({inputs:{x:i},backend:r,attrs:{shape:O}}),w.push(i))}const E=qe({inputs:{x:e},backend:r,attrs:{shape:[1,x,Ve(e.shape)/x]}});w.push(E);const A=new tIe(y,n),T=[t.shape,[n.padInfo.top,n.padInfo.left],[n.strideHeight,n.strideWidth],[n.dilationHeight,n.dilationWidth],[n.inChannels],[n.filterWidth*n.inChannels],[n.outWidth]],I=r.runWebGLProgram(A,[t],"float32",T),N=qe({inputs:{x:I},backend:r,attrs:{shape:y}});w.push(I),w.push(N);const M=i!=null,P=s!=null,B=a==="leakyrelu",F=a?s0(a,!0):null,U=new d7(p?N.shape:E.shape,p?E.shape:N.shape,p?[n.batchSize,v,n.outChannels]:[n.batchSize,n.outChannels,v],b,S,M,F,P,B),j=p?[N,E]:[E,N];if(i&&j.push(i),P&&j.push(s),B){const O=r.makeTensorInfo([],"float32",wp(o,"float32"));j.push(O),w.push(O)}const Z=r.runWebGLProgram(U,j,"float32"),ne=qe({inputs:{x:Z},backend:r,attrs:{shape:n.outShape}});w.push(Z);for(const O of w)r.disposeIntermediateTensorInfo(O);return ne}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nIe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:o,pad:a,dataFormat:l,dilations:c,dimRoundingMode:u}=r,d=Cp(l),f=Bs(i.shape,s.shape,o,c,a,u,!1,d);let h;if(f.filterHeight===1&&f.filterWidth===1&&f.dilationHeight===1&&f.dilationWidth===1&&f.strideHeight===1&&f.strideWidth===1&&(f.padInfo.type==="SAME"||f.padInfo.type==="VALID"))h=b7({x:i,filter:s,convInfo:f,backend:n});else if(f.strideWidth<=2&&d==="channelsLast"&&ge().getBool("WEBGL_EXP_CONV")){const x=new x7(f),v=[[f.padInfo.top,f.padInfo.left],[f.strideHeight,f.strideWidth],[f.dilationHeight,f.dilationWidth],[f.inHeight,f.inWidth]];h=n.runWebGLProgram(x,[i,s],"float32",v)}else if(ge().getBool("WEBGL_CONV_IM2COL"))h=S7({x:i,filter:s,convInfo:f,backend:n});else{const x=new v7(f);h=n.runWebGLProgram(x,[i,s],"float32")}const p=qe({inputs:{x:h},backend:n,attrs:{shape:f.outShape}});return n.disposeIntermediateTensorInfo(h),p}const rIe={kernelName:tz,backendName:"webgl",kernelFunc:nIe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class iIe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,i=e.padInfo.top,s=e.padInfo.left,o=e.dataFormat==="channelsLast";this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int d2 = coords.w;

        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              if (${o}) {
                float dyValue = getDy(b, yR, yC, d2);
                float xValue = getX(b, xR, xC, d1);
                dotProd += (xValue * dyValue);
              } else {
                float dyValue = getDy(b, d2, yR, yC);
                float xValue = getX(b, d1, xR, xC);
                dotProd += (xValue * dyValue);
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class sIe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,i=e.strideHeight,s=e.strideWidth,o=e.dataFormat==="channelsLast",a=n-1-e.padInfo.top,l=r-1-e.padInfo.left,c=o?1:2,u=o?2:3,d=o?3:1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[${d}];

        ivec2 dyCorner = ivec2(coords[${c}], coords[${u}]) - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            for (int d2 = 0; d2 < ${e.outChannels}; d2++) {

              if (${o}) {
                float xValue = getDy(batch, idyR, idyC, d2);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              } else {
                float xValue = getDy(batch, d2, idyR, idyC);
                float wValue = getW(wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }

            }
          }
        }
        setOutput(dotProd);
      }
    `}}class oIe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideDepth,r=e.strideHeight,i=e.strideWidth,s=e.padInfo.front,o=e.padInfo.top,a=e.padInfo.left;this.userCode=`
      void main() {
        ivec5 coords = getOutputCoords();
        int wF = coords.x;
        int wR = coords.y;
        int wC = coords.z;
        int d1 = coords.w;
        int d2 = coords.u;

        float dotProd = 0.0;

        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yF = 0; yF < ${e.outDepth}; yF++) {
            int xF = wF + yF * ${n} - ${s};

            if (xF < 0 || xF >= ${e.inDepth}) {
              continue;
            }

            for (int yR = 0; yR < ${e.outHeight}; yR++) {
              int xR = wR + yR * ${r} - ${o};

              if (xR < 0 || xR >= ${e.inHeight}) {
                continue;
              }

              for (int yC = 0; yC < ${e.outWidth}; yC++) {
                int xC = wC + yC * ${i} - ${a};

                if (xC < 0 || xC >= ${e.inWidth}) {
                  continue;
                }

                float dyValue = getDy(b, yF, yR, yC, d2);
                float xValue = getX(b, xF, xR, xC, d1);
                dotProd += (xValue * dyValue);
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class aIe{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterDepth,r=e.filterHeight,i=e.filterWidth,s=e.strideDepth,o=e.strideHeight,a=e.strideWidth,l=n-1-e.padInfo.front,c=r-1-e.padInfo.top,u=i-1-e.padInfo.left;this.userCode=`
      const ivec3 pads = ivec3(${l}, ${c}, ${u});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.u;


        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyFCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        float dotProd = 0.0;
        for (int wF = 0; wF < ${n}; wF++) {
          float dyF = float(dyFCorner + wF) / ${s}.0;

          if (dyF < 0.0 || dyF >= ${e.outDepth}.0 || fract(dyF) > 0.0) {
            continue;
          }
          int idyF = int(dyF);

          int wFPerm = ${n} - 1 - wF;

          for (int wR = 0; wR < ${r}; wR++) {
            float dyR = float(dyRCorner + wR) / ${o}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
              fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            int wRPerm = ${r} - 1 - wR;

            for (int wC = 0; wC < ${i}; wC++) {
              float dyC = float(dyCCorner + wC) / ${a}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              int wCPerm = ${i} - 1 - wC;

              for (int d2 = 0; d2 < ${e.outChannels}; d2++) {
                float xValue = getDy(batch, idyF, idyR, idyC, d2);
                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);
                dotProd += xValue * wValue;
              }
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lIe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:o,pad:a,dataFormat:l,dimRoundingMode:c,filterShape:u}=r,d=Cp(l),f=Bs(i.shape,u,o,1,a,c,!1,d),h=new iIe(f);return n.runWebGLProgram(h,[i,s],"float32")}const cIe={kernelName:nz,backendName:"webgl",kernelFunc:lIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uIe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{inputShape:o,strides:a,pad:l,dataFormat:c,dimRoundingMode:u}=r,d=Cp(c),f=Bs(o,s.shape,a,1,l,u,!1,d),h=new sIe(f);return n.runWebGLProgram(h,[i,s],"float32")}const dIe={kernelName:rz,backendName:"webgl",kernelFunc:uIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function fIe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:o,pad:a,dilations:l}=r,c=F0(i.shape,s.shape,o,l,a),u=new eIe(c);return n.runWebGLProgram(u,[i,s],"float32")}const hIe={kernelName:iz,backendName:"webgl",kernelFunc:fIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pIe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:o,pad:a,filterShape:l}=r,c=F0(i.shape,l,o,1,a),u=new oIe(c);return n.runWebGLProgram(u,[i,s],"float32")}const mIe={kernelName:Vme,backendName:"webgl",kernelFunc:pIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function gIe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{pad:o,strides:a,inputShape:l}=r,c=F0(l,s.shape,a,1,o),u=new aIe(c);return n.runWebGLProgram(u,[i,s],"float32")}const yIe={kernelName:sz,backendName:"webgl",kernelFunc:gIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const vIe=Np+`
  return cos(x);
`,xIe=qt({opSnippet:vIe}),bIe={kernelName:oz,backendName:"webgl",kernelFunc:xIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SIe=`
  float e2x = exp(-x);
  return (e2x + 1.0 / e2x) / 2.0;
`,_Ie=qt({opSnippet:SIe}),wIe={kernelName:az,backendName:"webgl",kernelFunc:_Ie};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class CIe{constructor(e,n,r,i,s){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[o,a,l,c]=e,[u]=n,[d,f]=r;this.outputShape=[u,d,f,c];const h=i==="bilinear"?1:0,[p,x]=[`${a-1}.0`,`${l-1}.0`],[v,y,b]=d>1?[`${(a-1)/(d-1)}`,"(y2-y1) * height_ratio",`y1*${p} + float(y)*(height_scale)`]:["0.0","0.0",`0.5 * (y1+y2) * ${p}`],[S,w,E]=f>1?[`${(l-1)/(f-1)}`,"(x2-x1) * width_ratio",`x1*${x} + float(x)*(width_scale)`]:["0.0","0.0",`0.5 * (x1+x2) * ${x}`];this.userCode=`
      const float height_ratio = float(${v});
      const float width_ratio = float(${S});
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int y = coords[1];
        int x = coords[2];
        int d = coords[3];

        // get box vals
        float y1 = getBoxes(b,0);
        float x1 = getBoxes(b,1);
        float y2 = getBoxes(b,2);
        float x2 = getBoxes(b,3);

        // get image in batch index
        int bInd = round(getBoxInd(b));
        if(bInd < 0 || bInd >= ${o}) {
          return;
        }

        float height_scale = ${y};
        float width_scale = ${w};

        float in_y = ${b};
        if( in_y < 0.0 || in_y > ${p} ) {
          setOutput(float(${s}));
          return;
        }
        float in_x = ${E};
        if( in_x < 0.0 || in_x > ${x} ) {
          setOutput(float(${s}));
          return;
        }

        vec2 sourceFracIndexCR = vec2(in_x,in_y);
        if(${h} == 1) {
          // Compute the four integer indices.
          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);
          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));

          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);
          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);
          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);
          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);

          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);

          float top = topLeft + (topRight - topLeft) * fracCR.x;
          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;
          float newValue = top + (bottom - top) * fracCR.y;
          setOutput(newValue);
        } else {
          // Compute the coordinators of nearest neighbor point.
          ivec2 sourceNearestCR = ivec2(floor(
            sourceFracIndexCR + vec2(0.5,0.5)));
          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);
          setOutput(newValue);
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const EIe=t=>{const{inputs:e,backend:n,attrs:r}=t,{image:i,boxes:s,boxInd:o}=e,{cropSize:a,method:l,extrapolationValue:c}=r,u=new CIe(i.shape,s.shape,a,l,c);return n.runWebGLProgram(u,[i,s,o],"float32")},AIe={kernelName:uz,backendName:"webgl",kernelFunc:EIe};var a0;(function(t){t.Prod="*",t.Sum="+"})(a0||(a0={}));class aB{constructor(e,n,r,i){this.op=e,this.outputShape=n,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const s=this.outputShape.length,o=this.op===a0.Prod?"1.0":"0.0",a=r?o:`getX(${lB(s,"coords",this.op)})`,l=this.outputShape[this.outputShape.length-1];let c="",u="";r?(c=i?`end != ${l-1}`:"end != 0",u=i?"end + 1":"end - 1"):(c=i?`end + pow2 < ${l}`:"end >= pow2",u=i?"end + pow2":"end - pow2"),this.userCode=`
      void main() {
        ${An(s)} coords = getOutputCoords();
        int end = ${cB(s,"coords",this.op)};
        float val = ${a};
        int pow2 = int(pow(2.0, index));
        if (${c}) {
          int idx = ${u};
          ${cB(s,"coords",this.op)} = idx;
          val ${this.op}= getX(${lB(s,"coords",this.op)});
        }
        setOutput(val);
      }
    `}}function lB(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.x, ${e}.y`;if(t===3)return`${e}.x, ${e}.y, ${e}.z`;if(t===4)return`${e}.x, ${e}.y, ${e}.z, ${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}function cB(t,e,n){if(t===1)return`${e}`;if(t===2)return`${e}.y`;if(t===3)return`${e}.z`;if(t===4)return`${e}.w`;throw new Error(`Cumulative ${n} for rank ${t} is not yet supported`)}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _7(t,e,n,r,i,s){const o=e.shape.length,a=_o([r],o);let l=e;a!=null&&(l=bi({inputs:{x:e},backend:n,attrs:{perm:a}}));const c=wo(1,o)[0];if(c!==o-1)throw new Error(`WebGL cumprod shader expects an inner-most axis=${e.shape.length-1} but got axis=${r}`);const u=l.shape[c];let d=os({inputs:{x:l},backend:n});for(let f=0;f<=Math.ceil(Math.log2(u))-1;f++){const h=new aB(t,l.shape,!1,s),p=[[f]],x=d;d=n.runWebGLProgram(h,[d],d.dtype,p),n.disposeIntermediateTensorInfo(x)}if(i){const f=new aB(t,l.shape,i,s),h=d;d=n.runWebGLProgram(f,[d],d.dtype),n.disposeIntermediateTensorInfo(h)}if(a!=null){const f=NI(a),h=bi({inputs:{x:d},backend:n,attrs:{perm:f}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(l),h}return d}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TIe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,exclusive:o,reverse:a}=r;return _7(a0.Prod,i,n,s,o,a)}const MIe={kernelName:lz,backendName:"webgl",kernelFunc:TIe};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RIe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,exclusive:o,reverse:a}=r;return _7(a0.Sum,i,n,s,o,a)}const IIe={kernelName:cz,backendName:"webgl",kernelFunc:RIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NIe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,weights:s}=e,{size:o,binaryOutput:a}=r;if(i.shape.length===1){const l=n.readSync(i.dataId),c=n.readSync(s.dataId),u=n7(l,c,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,u)}else if(i.shape.length===2){const l=n.bufferSync(i),c=n.bufferSync(s),u=V2e(l,c,o,a);return n.makeTensorInfo(u.shape,s.dtype,u.values)}throw new Error(`Error in denseBincount: input must be at most rank 2, but got rank${i.shape.length}.`)}const PIe={kernelName:dz,backendName:"webgl",kernelFunc:NIe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class kIe{constructor(e,n,r){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=n,this.dataFormat=r,this.userCode=`
    void main() {
      ivec4 coords = getOutputCoords();
      int b = coords[0];
      int h = ${this.getHeightCoordString()};
      int w = ${this.getWidthCoordString()};
      int d = ${this.getDepthCoordString()};

      int in_h = h / ${n};
      int offset_h = imod(h, ${n});
      int in_w = w / ${n};
      int offset_w = imod(w, ${n});
      int offset_d = (offset_h * ${n} + offset_w) *
        ${this.getOutputDepthSize()};
      int in_d = d + offset_d;

      float result = ${this.getInputSamplingString()};
      setOutput(result);
    }
  `}getHeightCoordString(){return this.dataFormat==="NHWC"?"coords[1]":"coords[2]"}getWidthCoordString(){return this.dataFormat==="NHWC"?"coords[2]":"coords[3]"}getDepthCoordString(){return this.dataFormat==="NHWC"?"coords[3]":"coords[1]"}getOutputDepthSize(){return this.dataFormat==="NHWC"?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return this.dataFormat==="NHWC"?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function DIe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockSize:s,dataFormat:o}=r,a=i.shape[0],l=o==="NHWC"?i.shape[1]:i.shape[2],c=o==="NHWC"?i.shape[2]:i.shape[3],u=o==="NHWC"?i.shape[3]:i.shape[1],d=l*s,f=c*s,h=u/(s*s),p=o==="NHWC"?[a,d,f,h]:[a,h,d,f],x=new kIe(p,s,o);return n.runWebGLProgram(x,[i],i.dtype)}const OIe={kernelName:fz,backendName:"webgl",kernelFunc:DIe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class w7{constructor(e,n=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ci(this.outputShape.length);const o=e.filterHeight,a=e.filterWidth,l=e.outChannels/e.inChannels;let c="",u="";r&&(i?c=`float activation(float a) {
          float b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?c=`float activation(float a) {
          float b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:c=`
          float activation(float x) {
            ${r}
          }
        `,u="result = activation(result);");const d=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${c}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${l};
        int q = d2 - d1 * ${l};

        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.
        for (int wR = 0; wR < ${o}; wR++) {
          int xR = xRCorner + wR * dilations[0];

          if (xR < 0 || xR >= inDims[0]) {
            continue;
          }

          for (int wC = 0; wC < ${a}; wC++) {
            int xC = xCCorner + wC * dilations[1];

            if (xC < 0 || xC >= inDims[1]) {
              continue;
            }

            float xVal = getX(batch, xR, xC, d1);
            float wVal = getW(wR, wC, d1, q);
            dotProd += xVal * wVal;
          }
        }

        float result = dotProd;
        ${d}
        ${u}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class C7{constructor(e,n=!1,r=null,i=!1,s=!1){this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=Ci(this.outputShape.length);const o=e.outChannels/e.inChannels,a=e.padInfo.left,l=e.strideWidth,c=e.dilationWidth,u=e.filterHeight,d=e.filterWidth,f=d;let h=`
      int xR; int xC; int xCOffset;
      vec4 wTexel; vec4 previous; vec4 final;`;for(let y=0;y<d;y++)h+=`
          vec4 xTexelC${y*2};
          int xTexelC${y*2}Ready;
          vec4 xTexelC${y*2+1};
          int xTexelC${y*2+1}Ready;
          vec4 xC${y};`;h+=`
    for (int r = 0; r < ${u}; r++) {
      `;for(let y=0;y<d;y++)h+=`
          xTexelC${y*2} = vec4(0.0);
          xTexelC${y*2}Ready = 0;
          xTexelC${y*2+1} = vec4(0.0);
          xTexelC${y*2+1}Ready = 0;
          xC${y} = vec4(0.0);`;h+=`
        xR = xRCorner + r * dilations[0];
        if (xR >=0 && xR < inDims[0]) {
      `;for(let y=0;y<(f+1)/2;y++){const b=y*2;if(h+=`
          xC = xCCorner + ${b*c};
          `,l===1){if(b<d&&(a%2===1?(h+=`
                xCOffset = xC + 1;
                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);

                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }
              `,c===1&&b>0?h+=`
                xC${b} = vec4(xTexelC${b-2}.zw, xTexelC${b}.xy);
                `:h+=`
                  xCOffset = xC + 1 - 2;

                  if (xCOffset >= 0 && xCOffset < inDims[1]) {
                    previous = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      previous.zw = vec2(0.0);
                    }

                    xC${b} = vec4(previous.zw, xTexelC${b}.xy);
                  } else {
                    xC${b} = vec4(0.0, 0.0, xTexelC${b}.xy);
                  }
                  `):h+=`
                if (xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xC${b} = xTexelC${b};
                `,b+1<d)){const S=a%2===0?lI(c):c;c%2===0&&a%2===1||c%2!==0&&a%2!==1?(h+=`
                  xCOffset = xC + imod(pads[1], 2) + ${S};

                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                    xTexelC${b+1} = getX(batch, xR, xCOffset, d1);

                    // Need to manually clear unused channels in case
                    // we're reading from recycled texture.
                    if (xCOffset + 1 >= inDims[1]) {
                      xTexelC${b+1}.zw = vec2(0.0);
                    }
                    xTexelC${b+1}Ready = 1;
                  }
                  `,c>1?h+=`
                    xCOffset -= 2;
                    if (xCOffset >= 0 && xCOffset < inDims[1]) {
                     previous = getX(batch, xR, xCOffset, d1);
                     xC${b+1} = vec4(previous.zw, xTexelC${b+1}.xy);
                    } else {
                     xC${b+1} = vec4(0.0, 0.0, xTexelC${b+1}.xy);
                    }
                    `:h+=`
                    xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.xy);
                    `):S===1?h+=`
                    xC${b+1} = xTexelC${b};
                    `:h+=`
                    xCOffset = xC + ${S};

                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                      xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                      if (xCOffset + 1 >= inDims[1]) {
                        xTexelC${b+1}.zw = vec2(0.0);
                      }
                      xTexelC${b+1}Ready = 1;
                    }

                    xC${b+1} = xTexelC${b+1};
                    `}}else b<d&&(a%2===1?(h+=`
                xCOffset = xC + 1 - strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xCOffset, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xC + 1, d1);
                  // Need to manually clear unused channels in case
                  // we're reading from recycled texture.
                  if (xC + 2 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.0);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
              `,b+1<d&&(h+=`
                  final = vec4(0.0);
                  xCOffset = xC + 1 + strides[1];
                  if(xCOffset >= 0 && xCOffset < inDims[1]) {
                    final = getX(batch, xR, xCOffset, d1);
                  }
                  xC${b+1} = vec4(xTexelC${b+1}.xy, final.xy);
                `)):(h+=`
                if(xC >= 0 && xC < inDims[1] && xTexelC${b}Ready == 0) {
                  xTexelC${b} = getX(batch, xR, xC, d1);
                  if (xC + 1 >= inDims[1]) {
                    xTexelC${b}.zw = vec2(0.0);
                  }
                  xTexelC${b}Ready = 1;
                }

                xCOffset = xC + strides[1];
                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC${b+1}Ready == 0) {
                  xTexelC${b+1} = getX(batch, xR, xCOffset, d1);
                  if (xCOffset + 1 >= inDims[1]) {
                    xTexelC${b+1}.zw = vec2(0.);
                  }
                  xTexelC${b+1}Ready = 1;
                }

                xC${b} = vec4(
                  xTexelC${b}.xy, xTexelC${b+1}.xy);
              `,b+1<d&&(h+=`
                  xC${b+1} = vec4(xTexelC${b}.zw, xTexelC${b+1}.zw);
                `)));b<d&&(h+=`
            wTexel = getW(r, ${b}, d1, q);
            dotProd += xC${b} * vec4(wTexel.xz, wTexel.xz);
          `,b+1<d&&(h+=`
              wTexel = getW(r, ${b+1}, d1, q);
              dotProd += xC${b+1} * vec4(wTexel.xz, wTexel.xz);
            `))}h+=`
    }
  `,h+=`
      }
    `;let p="",x="";r&&(i?p=`vec4 activation(vec4 a) {
          vec4 b = getPreluActivationWeightsAtOutCoords();
          ${r}
        }`:s?p=`vec4 activation(vec4 a) {
          vec4 b = getLeakyreluAlphaAtOutCoords();
          ${r}
        }`:p=`vec4 activation(vec4 x) {
          ${r}
        }`,x="result = activation(result);");const v=n?"result += getBiasAtOutCoords();":"";n&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),s&&this.variableNames.push("leakyreluAlpha"),this.userCode=`
      ${p}

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        ivec2 xRCCorner = coords.yz * strides - pads;
        int d2 = coords.w;
        int d1 = d2 / ${o};
        int q = d2 - d1 * ${o};
        int xRCorner = xRCCorner.x;
        int xCCorner = xRCCorner.y;

        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.
        vec4 dotProd = vec4(0.000000000000001);

        ${h}

        vec4 result = dotProd - vec4(0.000000000000001);
        ${v}
        ${x}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function LIe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:o,pad:a,dilations:l,dimRoundingMode:c}=r;let u=l;u==null&&(u=[1,1]),Y(ls(o,u),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${o} and dilations '${u}'`);const d=Bs(i.shape,s.shape,o,u,a,c,!0);let f;ge().getBool("WEBGL_PACK_DEPTHWISECONV")&&d.strideWidth<=2&&d.outChannels/d.inChannels===1?f=new C7(d):f=new w7(d);const h=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];return n.runWebGLProgram(f,[i,s],"float32",h)}const BIe={kernelName:hz,backendName:"webgl",kernelFunc:LIe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class FIe{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const n=e.strideHeight,r=e.strideWidth,i=e.padInfo.top,s=e.padInfo.left,o=e.outChannels/e.inChannels;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int wR = coords.x;
        int wC = coords.y;
        int d1 = coords.z;
        int dm = coords.w;
        int d2 = d1 * ${o} + dm;

        float dotProd = 0.0;

        // TO DO: Vec4 over the batch size
        for (int b = 0; b < ${e.batchSize}; b++) {
          for (int yR = 0; yR < ${e.outHeight}; yR++) {
            int xR = wR + yR * ${n} - ${i};

            if (xR < 0 || xR >= ${e.inHeight}) {
              continue;
            }

            for (int yC = 0; yC < ${e.outWidth}; yC++) {
              int xC = wC + yC * ${r} - ${s};

              if (xC < 0 || xC >= ${e.inWidth}) {
                continue;
              }

              float dyValue = getDy(b, yR, yC, d2);
              float xValue = getX(b, xR, xC, d1);
              dotProd += (xValue * dyValue);
            }
          }
        }
        setOutput(dotProd);
      }
    `}}class $Ie{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const n=e.filterHeight,r=e.filterWidth,i=e.strideHeight,s=e.strideWidth,o=n-1-e.padInfo.top,a=r-1-e.padInfo.left,l=e.outChannels/e.inChannels;this.userCode=`
      const ivec2 pads = ivec2(${o}, ${a});

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords[0];
        int d1 = coords[3];
        ivec2 dyCorner = coords.yz - pads;
        int dyRCorner = dyCorner.x;
        int dyCCorner = dyCorner.y;

        float dotProd = 0.0;

        for (int wR = 0; wR < ${n}; wR++) {
          float dyR = float(dyRCorner + wR) / ${i}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          int wRPerm = ${n} - 1 - wR;

          for (int wC = 0; wC < ${r}; wC++) {
            float dyC = float(dyCCorner + wC) / ${s}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            int wCPerm = ${r} - 1 - wC;

            // TO DO: Vec4 over the channelMul
            for (int dm = 0; dm < ${l}; dm++) {
              int d2 = d1 * ${l} + dm;
              float xValue = getDy(batch, idyR, idyC, d2);
              float wValue = getW(wRPerm, wCPerm, d1, dm);
              dotProd += xValue * wValue;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UIe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,dy:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,filterShape:u}=r,d=Bs(i.shape,u,o,a,l,c,!0),f=new FIe(d);return n.runWebGLProgram(f,[i,s],"float32")}const zIe={kernelName:pz,backendName:"webgl",kernelFunc:UIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function GIe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,filter:s}=e,{strides:o,dilations:a,pad:l,dimRoundingMode:c,inputShape:u}=r,d=Bs(u,s.shape,o,a,l,c,!0),f=new $Ie(d);return n.runWebGLProgram(f,[i,s],"float32")}const HIe={kernelName:mz,backendName:"webgl",kernelFunc:GIe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class VIe{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode=`
      void main() {
          ivec2 coords = getOutputCoords();
          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;
          setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function WIe(t){const{inputs:e,backend:n}=t,{x:r}=e,i=[...r.shape,...r.shape],s=Ve(r.shape),o=qe({inputs:{x:r},backend:n,attrs:{shape:[s]}}),a=new VIe(s),l=n.runWebGLProgram(a,[o],o.dtype),c=qe({inputs:{x:l},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(l),c}const jIe={kernelName:gz,backendName:"webgl",kernelFunc:WIe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class XIe{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:n,inWidth:r,padInfo:i,strideHeight:s,strideWidth:o,filterHeight:a,filterWidth:l,dilationHeight:c,dilationWidth:u}=e,{top:d,left:f}=i;this.userCode=`
      const ivec2 strides = ivec2(${s}, ${o});
      const ivec2 pads = ivec2(${d}, ${f});
      const float neg_infinity = -3.4e38;

      void main() {
        ivec4 coords = getOutputCoords();
        int batch = coords.x;
        int d1 = coords.w;
        ivec2 outTopLeftCorner =
            coords.yz * strides - pads;
        int hBeg = outTopLeftCorner.x;
        int wBeg = outTopLeftCorner.y;

        float curVal = neg_infinity;
        for (int h = 0; h < ${a}; h++) {
          int hIn = hBeg + h * ${c};

          if (hIn >= 0 && hIn < ${n}) {
            for (int w = 0; w < ${l}; w++) {
              int wIn = wBeg + w * ${u};

              if (wIn >= 0 && wIn < ${r}) {
                float xVal = getX(batch, hIn, wIn, d1);
                float wVal = getW(h, w, d1);

                float val = xVal + wVal;
                if (val > curVal) {
                  curVal = val;
                }
              }
            }
          }
        }

        float result = curVal;
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function KIe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s}=e,{strides:o,pad:a,dilations:l}=r,c=gH(i.shape,s.shape,o,a,"NHWC",l);let u;const d=new XIe(c);u=n.runWebGLProgram(d,[i,s],"float32");const f=qe({inputs:{x:u},backend:n,attrs:{shape:c.outShape}});return n.disposeIntermediateTensorInfo(u),f}const qIe={kernelName:yz,backendName:"webgl",kernelFunc:KIe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function JIe(t){const{inputs:e,backend:n,attrs:r}=t,{equation:i}=r,s=e,{allDims:o,summedDims:a,idDims:l}=vV(i,s.length);bV(o.length,l,s);const{path:c,steps:u}=SV(a,l),d=u.length;let f=null,h=o.length;const p=[];for(let x=0;x<d;++x){for(const v of u[x]){const{permutationIndices:y,expandDims:b}=xV(h,l[v]);let S;_V(y)?S=s[v]:(S=bi({inputs:{x:s[v]},backend:n,attrs:{perm:y}}),p.push(S));const w=S.shape.slice();for(let E=0;E<b.length;++E)w.splice(b[E],0,1);Yn(S.shape,w)||(S=qe({inputs:{x:S},backend:n,attrs:{shape:w}}),p.push(S)),f===null?f=S:(f=iN({inputs:{a:S,b:f},backend:n}),p.push(f))}x<d-1&&(c[x]>=0&&(f=y_({inputs:{x:f},backend:n,attrs:{axis:c[x]-(o.length-h),keepDims:!1}}),p.push(f)),h--)}for(const x of p)x!==f&&n.disposeIntermediateTensorInfo(x);return f}const YIe={kernelName:xz,backendName:"webgl",kernelFunc:JIe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const QIe="return (x >= 0.0) ? x : (exp(x) - 1.0);",ZIe=`
  vec4 result;

  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);
  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);
  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);
  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);

  return result;
`,eNe=qt({opSnippet:QIe,packedOpSnippet:ZIe}),tNe={kernelName:bz,backendName:"webgl",kernelFunc:eNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nNe="return (b >= 1.0) ? a : a * (b + 1.0);",rNe=`
  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));
  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));
`,iNe=t=>{const{inputs:e,backend:n}=t,{dy:r,y:i}=e,s=ge().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new V0(rNe,r.shape,i.shape):new ip(nNe,r.shape,i.shape);return n.runWebGLProgram(s,[r,i],r.dtype)},sNe={kernelName:Wme,backendName:"webgl",kernelFunc:iNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const oNe=`
  return vec4(equal(a, b));
`,aNe="return float(a == b);",lNe=Xr({opSnippet:aNe,packedOpSnippet:oNe,dtype:"bool",cpuKernelImpl:K2e}),cNe={kernelName:_z,backendName:"webgl",kernelFunc:lNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uNe=`
  // Error function is calculated approximately with elementary function.
  // See "Handbook of Mathematical Functions with Formulas,
  // Graphs, and Mathematical Tables", Abramowitz and Stegun.
  float p = ${fV};
  float a1 = ${hV};
  float a2 = ${pV};
  float a3 = ${mV};
  float a4 = ${gV};
  float a5 = ${yV};

  float sign = sign(x);
  x = abs(x);
  float t = 1.0 / (1.0 + p * x);
  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));
`,dNe=qt({opSnippet:uNe}),fNe={kernelName:Sz,backendName:"webgl",kernelFunc:dNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hNe=Np+`
  return exp(x);
`,pNe=`
  vec4 result = exp(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,E7=qt({opSnippet:hNe,packedOpSnippet:pNe,cpuKernelImpl:q2e,dtype:"float32"}),mNe={kernelName:wz,backendName:"webgl",kernelFunc:E7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function PT(t){const{inputs:e,attrs:n,backend:r}=t,{dim:i}=n,{input:s}=e,o=s.shape.length,a=s.shape.slice();let l=i;return i<0&&(Y(-(o+1)<=i,()=>`Axis must be in the interval [${-(o+1)}, ${o}]`),l=o+i+1),a.splice(l,0,1),qe({inputs:{x:s},backend:r,attrs:{shape:a}})}const gNe={kernelName:Cz,backendName:"webgl",kernelFunc:PT};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uB="return exp(x) - 1.0;",yNe=qt({opSnippet:uB,packedOpSnippet:uB,cpuKernelImpl:J2e}),vNe={kernelName:Ez,backendName:"webgl",kernelFunc:yNe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class dB{constructor(e,n,r){this.variableNames=["real","imag"];const i=n[1];this.outputShape=n;const s=r?`2.0 * ${Math.PI}`:`-2.0 * ${Math.PI}`,o=r?`${i}.0`:"1.0";let a;if(e==="real")a="return real * expR - imag * expI;";else if(e==="imag")a="return real * expI + imag * expR;";else throw new Error(`FFT component must be either "real" or "imag", got ${e}.`);this.userCode=`
      const float exponentMultiplier = ${s};

      float unaryOpComplex(float real, float expR, float imag, float expI) {
        ${a}
      }

      float mulMatDFT(int batch, int index) {
        float indexRatio = float(index) / float(${i});
        float exponentMultiplierTimesIndexRatio =
            exponentMultiplier * indexRatio;

        float result = 0.0;

        for (int i = 0; i < ${i}; i++) {
          // x = (-2|2 * PI / N) * index * i;
          float x = exponentMultiplierTimesIndexRatio * float(i);
          float expR = cos(x);
          float expI = sin(x);
          float real = getReal(batch, i);
          float imag = getImag(batch, i);

          result +=
              unaryOpComplex(real, expR, imag, expI) / ${o};
        }

        return result;
      }

      void main() {
        ivec2 coords = getOutputCoords();
        setOutput(mulMatDFT(coords[0], coords[1]));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function A7(t,e,n){const r=n.texData.get(t.dataId),i=Ve(t.shape),s=t.shape[t.shape.length-1],o=i/s,a=qe({inputs:{x:t},backend:n,attrs:{shape:[o,s]}}),l=a.shape,c=new dB("real",l,e),u=new dB("imag",l,e),d=[{dataId:r.complexTensorInfos.real.dataId,dtype:r.complexTensorInfos.real.dtype,shape:l},{dataId:r.complexTensorInfos.imag.dataId,dtype:r.complexTensorInfos.imag.dtype,shape:l}],f=n.runWebGLProgram(c,d,"float32"),h=n.runWebGLProgram(u,d,"float32"),p=Vc({inputs:{real:f,imag:h},backend:n});n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h);const x=qe({inputs:{x:p},backend:n,attrs:{shape:t.shape}});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(p),x}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xNe(t){const{inputs:e,backend:n}=t,{input:r}=e;return A7(r,!1,n)}const bNe={kernelName:Az,backendName:"webgl",kernelFunc:xNe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SNe{constructor(e,n){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode=`
      void main() {
        // Input can be obtained from uniform value.
        setOutput(value);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function j0(t){const{backend:e,attrs:n}=t,{shape:r,value:i}=n;let{dtype:s}=n;if(s=s||QS(i),s==="string"){const o=Oi(s,Ve(r));return o.fill(i),e.makeTensorInfo(r,s,o)}else{const o=new SNe(r,i),a=[[i]];return e.runWebGLProgram(o,[],s,a)}}const _Ne={kernelName:Tz,backendName:"webgl",kernelFunc:j0};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class wNe{constructor(e){this.variableNames=["Image"],this.outputShape=[];const n=e[2];this.outputShape=e,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];

          int coordX = ${n} - x - 1;
          float outputValue;
          if(coordX >= 0 && coordX < ${n}) {
            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);
          } else {
            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const CNe={kernelName:Mz,backendName:"webgl",kernelFunc:({inputs:t,backend:e})=>{const{image:n}=t,r=e,i=new wNe(n.shape);return r.runWebGLProgram(i,[n],n.dtype)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const fB="return floor(x);",ENe=qt({opSnippet:fB,packedOpSnippet:fB,cpuKernelImpl:Y2e}),ANe={kernelName:Rz,backendName:"webgl",kernelFunc:ENe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const TNe=`
  float s = sign(a) * sign(b);
  int ia = round(a);
  int ib = round(b);
  if (ib != 0) {
    // Windows (D3D) wants guaranteed non-zero int division at compile-time.
    return float(idiv(ia, ib, s));
  } else {
    return NAN;
  }
`,MNe=`
  ivec4 ia = round(a);
  ivec4 ib = round(b);
  bvec4 cond = notEqual(ib, ivec4(0));
  ivec4 result = ivec4(0);
  vec4 s = sign(a) * sign(b);

  // Windows (D3D) wants guaranteed non-zero int division at compile-time.
  if (cond[0]) {
    result[0] = idiv(ia[0], ib[0], s[0]);
  }
  if (cond[1]) {
    result[1] = idiv(ia[1], ib[1], s[1]);
  }
  if (cond[2]) {
    result[2] = idiv(ia[2], ib[2], s[2]);
  }
  if (cond[3]) {
    result[3] = idiv(ia[3], ib[3], s[3]);
  }
  return vec4(result);
`,RNe=Xr({opSnippet:TNe,packedOpSnippet:MNe,dtype:"int32"}),INe={kernelName:Iz,backendName:"webgl",kernelFunc:RNe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class NNe{constructor(e){this.variableNames=["A"];const n=wi(),[r,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];
        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(${i}.0, ${r}.0);

        vec4 values = ${n.texture2D}(A, uv);
        float value;
        if (depth == 0) {
          value = values.r;
        } else if (depth == 1) {
          value = values.g;
        } else if (depth == 2) {
          value = values.b;
        } else if (depth == 3) {
          value = values.a;
        }

        setOutput(floor(value * 255.0 + 0.5));
      }
    `}}/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class PNe{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const n=wi(),[r,i]=e;this.outputShape=e,this.userCode=`
      void main() {
        ivec3 coords = getOutputCoords();
        int texR = coords[0];
        int texC = coords[1];
        int depth = coords[2];

        vec4 result = vec4(0.);

        for(int row=0; row<=1; row++) {
          for(int col=0; col<=1; col++) {
            texC = coords[1] + row;
            depth = coords[2] + col;

            vec2 uv = (vec2(texC, texR) + halfCR) /
                       vec2(${i}.0, ${r}.0);
            vec4 values = ${n.texture2D}(A, uv);
            float value;
            if (depth == 0) {
              value = values.r;
            } else if (depth == 1) {
              value = values.g;
            } else if (depth == 2) {
              value = values.b;
            } else if (depth == 3) {
              value = values.a;
            }

            result[row * 2 + col] = floor(value * 255.0 + 0.5);
          }
        }

        ${n.output} = result;
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kNe={kernelName:X2,backendName:"webgl",kernelFunc:DNe};let Of,wE=ge().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");function DNe(t){const{inputs:e,backend:n,attrs:r}=t;let{pixels:i}=e;const{numChannels:s}=r,o=typeof HTMLVideoElement<"u"&&i instanceof HTMLVideoElement,a=typeof HTMLImageElement<"u"&&i instanceof HTMLImageElement,[l,c]=o?[i.videoWidth,i.videoHeight]:[i.width,i.height],u=[c,l],d=[c,l,s];if(a||o){const x=ge().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");(Of==null||x!==wE)&&(wE=x,Of=document.createElement("canvas").getContext("2d",{willReadFrequently:wE})),Of.canvas.width=l,Of.canvas.height=c,Of.drawImage(i,0,0,l,c),i=Of.canvas}const f=n.makeTensorInfo(u,"int32");n.texData.get(f.dataId).usage=Cs.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(f.dataId),i);const h=ge().getBool("WEBGL_PACK")?new PNe(d):new NNe(d),p=n.runWebGLProgram(h,[f],"int32");return n.disposeData(f.dataId),p}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ONe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dataFormat:u,dilations:d,dimRoundingMode:f,activation:h,leakyreluAlpha:p}=r,x=Cp(u),v=Bs(i.shape,s.shape,l,d,c,f,!1,x);let y;const b=[],S=o!=null,w=a!=null,E=h==="leakyrelu",A=()=>{const I=[i,s],N=(M,P)=>{if(P==="NCHW"&&M.shape.length===1&&M.shape[0]!==1){const B=qe({inputs:{x:M},backend:n,attrs:{shape:[M.shape[0],1,1]}});return b.push(B),B}return M};if(S&&I.push(N(o,u)),w&&I.push(N(a,u)),E){const M=n.makeTensorInfo([],"float32",wp(p,"float32"));I.push(M),b.push(M)}return I};if(v.filterHeight===1&&v.filterWidth===1&&v.dilationHeight===1&&v.dilationWidth===1&&v.strideHeight===1&&v.strideWidth===1&&(v.padInfo.type==="SAME"||v.padInfo.type==="VALID"))y=b7({x:i,filter:s,convInfo:v,backend:n,bias:o,activation:h,preluActivationWeights:a,leakyreluAlpha:p});else if(v.strideWidth<=2&&x==="channelsLast"&&ge().getBool("WEBGL_EXP_CONV")){const I=h?s0(h,!0):null,N=new x7(v,S,I,w,E),M=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],P=A();y=n.runWebGLProgram(N,P,"float32",M)}else if(ge().getBool("WEBGL_CONV_IM2COL"))y=S7({x:i,filter:s,convInfo:v,backend:n,bias:o,activation:h,preluActivationWeights:a,leakyreluAlpha:p});else{const I=h?s0(h,!1):null,N=new v7(v,S,I,w,E),M=A();y=n.runWebGLProgram(N,M,"float32")}const T=qe({inputs:{x:y},backend:n,attrs:{shape:v.outShape}});return b.push(y),b.forEach(I=>n.disposeIntermediateTensorInfo(I)),T}const LNe={kernelName:q2,backendName:"webgl",kernelFunc:ONe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function BNe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,filter:s,bias:o,preluActivationWeights:a}=e,{strides:l,pad:c,dilations:u,dimRoundingMode:d,activation:f,leakyreluAlpha:h}=r,p=[];let x=u;x==null&&(x=[1,1]),Y(ls(l,x),()=>`Error in depthwiseConv2d: Either strides or dilations must be 1. Got strides ${l} and dilations '${x}'`);const v=Bs(i.shape,s.shape,l,x,c,d,!0),y=ge().getBool("WEBGL_PACK_DEPTHWISECONV")&&v.strideWidth<=2&&v.outChannels/v.inChannels===1,b=f?s0(f,y):null,S=[i,s],w=o!=null,E=a!=null,A=f==="leakyrelu";if(w&&S.push(o),E&&S.push(a),A){const M=n.makeTensorInfo([],"float32",wp(h,"float32"));S.push(M),p.push(M)}let T;y?T=new C7(v,w,b,E,A):T=new w7(v,w,b,E,A);const I=[[v.padInfo.top,v.padInfo.left],[v.strideHeight,v.strideWidth],[v.dilationHeight,v.dilationWidth],[v.inHeight,v.inWidth]],N=n.runWebGLProgram(T,S,"float32",I);return p.forEach(M=>n.disposeIntermediateTensorInfo(M)),N}const FNe={kernelName:J2,backendName:"webgl",kernelFunc:BNe};class $Ne{constructor(e,n,r,i){this.sliceDim=e,this.strides=n,this.paramsShape=i,this.variableNames=["x","indices"],this.outputShape=r;const s=An(r.length);let o=`
    int index;`;for(let a=0;a<this.sliceDim;a++)o+=`
          index = round(getIndices(coords[0], ${a}));
          out_of_bounds = out_of_bounds || index < 0;
          out_of_bounds = out_of_bounds || index >= ${this.paramsShape[a]};
          flattenIndex += index * ${this.strides[a]};`;this.userCode=`
         void main() {
          ${s} coords = getOutputCoords();
          int flattenIndex = 0;
          bool out_of_bounds = false;

          ${o}

          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function UNe(t){const{inputs:e,backend:n}=t,{params:r,indices:i}=e,s=i.shape,o=s[s.length-1],a=Ve(r.shape),[l,c,u,d]=eH(r,i),f=qe({inputs:{x:i},backend:n,attrs:{shape:[c,o]}}),h=qe({inputs:{x:r},backend:n,attrs:{shape:[Ve(r.shape)/u,u]}});if(n.shouldExecuteOnCPU([r,i])||r.dtype==="string"){const y=n.readSync(i.dataId),b=n.bufferSync(r),S=Q2e(y,b,r.dtype,c,o,u,d,r.shape,a);return n.makeTensorInfo(l,r.dtype,S.values)}const p=new $Ne(o,d,[c,u],r.shape),x=n.runWebGLProgram(p,[h,f],h.dtype),v=qe({inputs:{x},backend:n,attrs:{shape:l}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(x),v}const zNe={kernelName:kz,backendName:"webgl",kernelFunc:UNe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class GNe{constructor(e,n){this.variableNames=["A","indices"],this.outputShape=n,this.rank=n.length;const r=An(this.rank),i=HNe(e);this.userCode=`
      void main() {
        ${r} resRC = getOutputCoords();
        int index = int(getIndices(resRC.x, resRC.z));
        float inBounds = (index >= 0) && (index < ${e[2]}) ? 1.0 : 0.0;
        setOutput(inBounds * getA(${i}));
      }
    `}}function HNe(t,e){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],r=[];for(let i=0;i<t.length;i++)i===2?r.push("index"):r.push(`${n[i]}`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function T7(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,indices:s}=e,{axis:o,batchDims:a}=r,l=Dr(o,i.shape)[0];if(ge().get("DEBUG")){const b=n.readSync(s.dataId),S=i.shape[l];for(let w=0;w<b.length;++w){const E=b[w];Y(E<=S-1&&E>=0,()=>`GatherV2: the index value ${E} is not in [0, ${S-1}]`)}}const c=BV(i,s,l,a),u=Ve(s.shape),d=[],f=qe({inputs:{x:i},backend:n,attrs:{shape:[c.batchSize,c.outerSize,c.dimSize,c.sliceSize]}}),h=qe({inputs:{x:s},backend:n,attrs:{shape:[c.batchSize,u/c.batchSize]}});d.push(f),d.push(h);const p=[c.batchSize,c.outerSize,u/c.batchSize,c.sliceSize];if(n.shouldExecuteOnCPU([i,s])||i.dtype==="string"){const b=n.bufferSync(h),S=n.bufferSync(f),w=Z2e(S,b,p);return d.forEach(E=>n.disposeIntermediateTensorInfo(E)),n.makeTensorInfo(c.outputShape,w.dtype,w.values)}const x=new GNe(f.shape,p),v=n.runWebGLProgram(x,[f,h],f.dtype);d.push(v);const y=qe({inputs:{x:v},backend:n,attrs:{shape:c.outputShape}});return d.forEach(b=>n.disposeIntermediateTensorInfo(b)),y}const VNe={kernelName:Pz,backendName:"webgl",kernelFunc:T7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const WNe="return float(a > b);",jNe=`
  return vec4(greaterThan(a, b));
`,XNe=Xr({opSnippet:WNe,packedOpSnippet:jNe,cpuKernelImpl:eTe,dtype:"bool"}),KNe={kernelName:Dz,backendName:"webgl",kernelFunc:XNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const qNe="return float(a >= b);",JNe=`
  return vec4(greaterThanEqual(a, b));
`,YNe=Xr({opSnippet:qNe,packedOpSnippet:JNe,dtype:"bool",cpuKernelImpl:tTe}),QNe={kernelName:Oz,backendName:"webgl",kernelFunc:YNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZNe(t){const{inputs:e,backend:n}=t,{input:r}=e;return A7(r,!0,n)}const e3e={kernelName:Lz,backendName:"webgl",kernelFunc:ZNe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const t3e="return float(!isnan(x) && !isinf(x));",n3e=qt({opSnippet:t3e,dtype:"bool"}),r3e={kernelName:Fz,backendName:"webgl",kernelFunc:n3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const i3e="return float(isinf(x));",s3e=qt({opSnippet:i3e,dtype:"bool"}),o3e={kernelName:$z,backendName:"webgl",kernelFunc:s3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const a3e="return float(isnan(x));",l3e=qt({opSnippet:a3e,dtype:"bool"}),c3e={kernelName:Uz,backendName:"webgl",kernelFunc:l3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const u3e="return float(a < b);",d3e=`
  return vec4(lessThan(a, b));
`,f3e=Xr({opSnippet:u3e,packedOpSnippet:d3e,cpuKernelImpl:nTe,dtype:"bool"}),h3e={kernelName:Gz,backendName:"webgl",kernelFunc:f3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const p3e="return float(a <= b);",m3e=`
  return vec4(lessThanEqual(a, b));
`,g3e=Xr({opSnippet:p3e,packedOpSnippet:m3e,cpuKernelImpl:rTe,dtype:"bool"}),y3e={kernelName:Hz,backendName:"webgl",kernelFunc:g3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function v3e(t){const{backend:e,attrs:n}=t,{start:r,stop:i,num:s}=n,o=iTe(r,i,s);return e.makeTensorInfo([o.length],"float32",o)}const x3e={kernelName:Vz,backendName:"webgl",kernelFunc:v3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const b3e=Np+`
  return x < 0.0 ? 0./0. : log(x);
`,S3e=`
  vec4 result = log(x);
  bvec4 isNaN = isnan(x);
  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);
  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);
  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);
  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);
  return result;
`,_3e=qt({opSnippet:b3e,packedOpSnippet:S3e,cpuKernelImpl:sTe}),w3e={kernelName:Wz,backendName:"webgl",kernelFunc:_3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const C3e=Np+`
  return log(1.0 + x);
`,E3e=qt({opSnippet:C3e}),A3e={kernelName:jz,backendName:"webgl",kernelFunc:E3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const T3e="return float(a >= 1.0 && b >= 1.0);",M3e=`
  return vec4(
    vec4(greaterThanEqual(a, vec4(1.0))) *
    vec4(greaterThanEqual(b, vec4(1.0))));
`,R3e=Xr({opSnippet:T3e,packedOpSnippet:M3e,dtype:"bool"}),I3e={kernelName:Xz,backendName:"webgl",kernelFunc:R3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const N3e="return float(!(x >= 1.0));",P3e=qt({opSnippet:N3e}),k3e={kernelName:Kz,backendName:"webgl",kernelFunc:P3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D3e="return float(a >= 1.0 || b >= 1.0);",O3e=`
  return min(
    vec4(greaterThanEqual(a, vec4(1.0))) +
    vec4(greaterThanEqual(b, vec4(1.0))),
    vec4(1.0));
`,L3e=Xr({opSnippet:D3e,packedOpSnippet:O3e,dtype:"bool"}),B3e={kernelName:qz,backendName:"webgl",kernelFunc:L3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class F3e{constructor(e,n,r,i,s){this.variableNames=["x"],this.outputShape=[];const o=n,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${i}) * sum`;s===.5?l=`inversesqrt(${c})`:s===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];
        int d = coords[3];
        float x = getX(b, r, c, d);
        float sum = 0.0;
        for (int j = -${o}; j <= ${o}; j++) {
          int idx = d + j;
          if (idx >= 0 && idx <=  ${a}) {
            float z = getX(b, r, c, idx);
            sum += z * z;
          }
        }
        float val = x * ${l};
        setOutput(val);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $3e{constructor(e,n,r,i,s){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const o=n,a=e[3]-1;this.outputShape=e;let l;const c=`float(${r}) + float(${i}) * sum`;s===.5?l=`inversesqrt(${c})`:s===1?l=`1.0/(${c})`:l=`exp(log(${c}) * float(-${s}));`,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords.x;
        int r = coords.y;
        int c = coords.z;
        int d = coords.w;

        bool hasNextCol = d < ${this.outputShape[3]};
        bool hasNextRow = c < ${this.outputShape[2]};

        vec4 sum = vec4(0.);
        vec4 xFragAtOutputCoords = getX(b, r, c, d);

        vec4 xAtOutputCoords = vec4(
          getChannel(xFragAtOutputCoords, vec2(c, d)),
          hasNextCol ?
            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,
          hasNextRow ?
            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,
          (hasNextRow && hasNextCol) ?
            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0
        );

        int firstChannel = d - ${o};
        vec2 cache = vec2(0.);
        if(firstChannel >= 0){
          vec4 firstChannelFrag = getX(b, r, c, firstChannel);
          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));
            if(hasNextRow){
              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));
            }
        }

        ivec2 depth = ivec2(d, d + 1);
        for (int j = - ${o}; j <= ${o}; j++) {
          ivec2 idx = depth + j;
          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));
          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(${a}));

          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;
          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;

          if(depthInRange || depthPlusOneInRange){
            vec4 z = vec4(0.);
            vec4 xFragAtCurrentDepth;
            z.xz = cache.xy;
            if(depthPlusOneInRange && hasNextCol){
              xFragAtCurrentDepth = idx.y != d ?
                getX(b, r, c, idx.y) : xFragAtOutputCoords;
              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));
              if(hasNextRow){
                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));
              }
            }
            cache.xy = z.yw;
            sum += z * z;
          }
        }
        vec4 result = xAtOutputCoords * ${l};
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const U3e=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{depthRadius:s,bias:o,alpha:a,beta:l}=r,c=ge().getBool("WEBGL_PACK_NORMALIZATION")?new $3e(i.shape,s,o,a,l):new F3e(i.shape,s,o,a,l);return n.runWebGLProgram(c,[i],i.dtype)},z3e={kernelName:Jz,backendName:"webgl",kernelFunc:U3e};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class G3e{constructor(e,n,r,i,s){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=n,this.bias=r,this.alpha=i,this.beta=s,this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int r = coords[1];
        int c = coords[2];

        float result = 0.0;
        for (int d = 0; d < ${this.depth}; ++d) {
          int depthBegin = int(max(0.0, float(d - ${n})));
          int depthEnd = int(min(float(${this.depth}),
              float(d + ${n} + 1)));

          const int MIN_DEPTH_BEGIN = 0;
          const int MAX_DEPTH_END = ${this.depth};

          float norm = 0.0;
          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd) {
              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);
            }
            else {
              break;
            }
          }

          norm = float(${i}) * norm + float(${r});

          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){
            if (k < depthBegin){
              continue;
            }
            else if (k >= depthBegin && k < depthEnd){
              float dyi = -2.0 * float(${i})
                * float(${s})
                * getInputImage(b ,r ,c, k) * getOutputImage(b, r, c, d)
                / norm;
              if (k == d) {
                dyi += pow(norm, -1.0 * ${s});
              }
              if (k == coords[3]) {
                dyi *= getDy(b, r, c, d);
                result += dyi;
              }
            }
            else {
              break;
            }
          }
      }
      setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const H3e=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i,y:s,dy:o}=e,{depthRadius:a,bias:l,alpha:c,beta:u}=r,d=new G3e(i.shape,a,l,c,u);return n.runWebGLProgram(d,[i,s,o],i.dtype)},V3e={kernelName:jme,backendName:"webgl",kernelFunc:H3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function W3e(t,e,n,r){const i=Ve(e),o=Ve(t.shape)/i,a=qe({inputs:{x:t},attrs:{shape:[o,i]},backend:r}),l=Gd(a,t.dtype,"max",r),c=qe({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function M7(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reductionIndices:s,keepDims:o}=r,a=i.shape.length,l=Dr(s,i.shape);let c=l;const u=_o(c,a),d=u!=null,f=n.shouldExecuteOnCPU([i]);let h=i;if(d){if(f){const S=n.texData.get(h.dataId).values,w=new Array(a);for(let T=0;T<w.length;T++)w[T]=i.shape[u[T]];const E=nN(S,i.shape,i.dtype,u,w);h=n.makeTensorInfo(w,i.dtype);const A=n.texData.get(h.dataId);A.values=E}else h=g_(i,u,n);c=wo(c.length,a)}ta("max",c,a);const[p,x]=Oa(h.shape,c);let v=p;o&&(v=Fs(p,l));let y;if(f){const S=n.texData.get(h.dataId).values,w=oTe(S,Ve(x),v,i.dtype);y=n.makeTensorInfo(v,i.dtype);const E=n.texData.get(y.dataId);E.values=w}else y=W3e(h,x,v,n);return d&&n.disposeIntermediateTensorInfo(h),y}const j3e={kernelName:Yz,backendName:"webgl",kernelFunc:M7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const X3e=rN+`
  return max(a, b);
`,K3e=`
  vec4 result = vec4(max(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+H0+`
  return result;
`,q3e=Xr({opSnippet:X3e,packedOpSnippet:K3e,cpuKernelImpl:aTe}),J3e={kernelName:Qz,backendName:"webgl",kernelFunc:q3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Y3e(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e;z0(i,"maxPool");const{filterSize:s,strides:o,pad:a,dimRoundingMode:l}=r,c=1;Y(ls(o,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${o} and dilations '${c}'`);const u=Bd(i.shape,s,o,c,a,l);if(u.filterWidth===1&&u.filterHeight===1&&Yn(u.inShape,u.outShape))return os({inputs:{x:i},backend:n});const d=new o0(u,"max",!1);return n.runWebGLProgram(d,[i],i.dtype)}const Q3e={kernelName:Zz,backendName:"webgl",kernelFunc:Y3e};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Z3e(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{filterSize:s,strides:o,pad:a,dataFormat:l,dimRoundingMode:c}=r,u=[1,1,1],d=B0(i.shape,s,o,u,a,c,l),f=new sN(d,"max",!1);return n.runWebGLProgram(f,[i],i.dtype)}const ePe={kernelName:e8,backendName:"webgl",kernelFunc:Z3e};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tPe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideHeight,r=e.strideWidth,i=e.dilationHeight,s=e.effectiveFilterHeight,o=e.effectiveFilterWidth,a=s-1-e.padInfo.top,l=o-1-e.padInfo.left,c=s*o-1;this.userCode=`
      const ivec2 pads = ivec2(${a}, ${l});

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];

        ivec2 dyRCCorner = coords.yz - pads;
        int dyRCorner = dyRCCorner.x;
        int dyCCorner = dyRCCorner.y;

        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;
        for (int wR = 0; wR < ${s};
          wR += ${i}) {
          float dyR = float(dyRCorner + wR) / ${n}.0;

          if (dyR < 0.0 || dyR >= ${e.outHeight}.0 || fract(dyR) > 0.0) {
            continue;
          }
          int idyR = int(dyR);

          for (int wC = 0; wC < ${o}; wC++) {
            float dyC = float(dyCCorner + wC) / ${r}.0;

            if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                fract(dyC) > 0.0) {
              continue;
            }
            int idyC = int(dyC);

            float dyValue = getDy(b, idyR, idyC, d);
            int maxPosValue = ${c} - int(getMaxPos(b, idyR, idyC, d));

            // Get the current value, check it against the value from the
            // position matrix.
            int curPosValue = wR * ${o} + wC;
            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

            dotProd += dyValue * mask;
          }
        }
        setOutput(dotProd);
      }
    `}}class nPe{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const n=e.strideDepth,r=e.strideHeight,i=e.strideWidth,s=e.dilationDepth,o=e.dilationHeight,a=e.dilationWidth,l=e.effectiveFilterDepth,c=e.effectiveFilterHeight,u=e.effectiveFilterWidth,d=l-1-e.padInfo.front,f=c-1-e.padInfo.top,h=u-1-e.padInfo.left,p=l*c*u-1;this.userCode=`
      const ivec3 pads = ivec3(${d}, ${f}, ${h});

      void main() {
        ivec5 coords = getOutputCoords();
        int batch = coords.x;
        int ch = coords.u;

        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;
        int dyDCorner = dyCorner.x;
        int dyRCorner = dyCorner.y;
        int dyCCorner = dyCorner.z;

        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get
        // dx(xD, xR, xC, ch).
        // ? = to be determined. : = across all values in that axis.
        float dotProd = 0.0;

        for (int wD = 0; wD < ${l};
           wD += ${s}) {
          float dyD = float(dyDCorner + wD) / ${n}.0;

          if (dyD < 0.0 || dyD >= ${e.outDepth}.0 || fract(dyD) > 0.0) {
            continue;
          }
          int idyD = int(dyD);

          for (int wR = 0; wR < ${c};
              wR += ${o}) {
            float dyR = float(dyRCorner + wR) / ${r}.0;

            if (dyR < 0.0 || dyR >= ${e.outHeight}.0 ||
                fract(dyR) > 0.0) {
              continue;
            }
            int idyR = int(dyR);

            for (int wC = 0; wC < ${u};
                wC += ${a}) {
              float dyC = float(dyCCorner + wC) / ${i}.0;

              if (dyC < 0.0 || dyC >= ${e.outWidth}.0 ||
                  fract(dyC) > 0.0) {
                continue;
              }
              int idyC = int(dyC);

              float dyValue = getDy(batch, idyD, idyR, idyC, ch);
              int maxPosValue = ${p} -
                  int(getMaxPos(batch, idyD, idyR, idyC, ch));

              // Get the current value, check it against the value from the
              // position matrix.
              int curPosValue =
                  wD * ${c} * ${u} +
                  wR * ${u} + wC;
              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);

              dotProd += dyValue * mask;
            }
          }
        }
        setOutput(dotProd);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function rPe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s}=e,o=s,{filterSize:a,strides:l,pad:c,dimRoundingMode:u}=r,d=[1,1,1],f=B0(o.shape,a,l,d,c,u),h=new sN(f,"max",!0),p=n.runWebGLProgram(h,[o],o.dtype),x=new nPe(f),v=n.runWebGLProgram(x,[i,p],o.dtype);return n.disposeIntermediateTensorInfo(p),v}const iPe={kernelName:Kme,backendName:"webgl",kernelFunc:rPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sPe(t){const{inputs:e,backend:n,attrs:r}=t,{dy:i,input:s,output:o}=e,a=s;z0([s,o],"maxPoolGrad");const{filterSize:l,strides:c,pad:u,dimRoundingMode:d}=r,f=Bd(a.shape,l,c,1,u,d),h=!0,p=new o0(f,"max",h),x=n.runWebGLProgram(p,[a],a.dtype),v=new tPe(f),y=n.runWebGLProgram(v,[i,x],a.dtype);return n.disposeIntermediateTensorInfo(x),y}const oPe={kernelName:Xme,backendName:"webgl",kernelFunc:sPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function aPe(t,e,n,r){let i=new o0(n,"max",!1);const s=r.runWebGLProgram(i,[t],"float32");i=new o0(n,"max",!0,!0,e);const o=r.runWebGLProgram(i,[t],"float32");return[s,o]}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const lPe={kernelName:t8,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{filterSize:i,strides:s,pad:o,includeBatchInIndex:a}=e,l=n;Y(r.shape.length===4,()=>`Error in maxPool: input must be rank 4 but got rank ${r.shape.length}.`);const c=[1,1];Y(ls(s,c),()=>`Error in maxPool: Either strides or dilations must be 1. Got strides ${s} and dilations '${c}'`);const u=Bd(r.shape,i,s,c,o),[d,f]=aPe(r,a,u,l);return[d,f]}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function cPe(t,e,n,r){const i=Ve(e),o=Ve(t.shape)/i,a=qe({inputs:{x:t},attrs:{shape:[o,i]},backend:r}),l=Gd(a,"float32","mean",r),c=qe({inputs:{x:l},attrs:{shape:n},backend:r});return r.disposeIntermediateTensorInfo(a),r.disposeIntermediateTensorInfo(l),c}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const uPe={kernelName:n8,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{x:r}=t,{keepDims:i,axis:s}=e,o=n,a=r.shape.length,l=Dr(s,r.shape);let c=l;const u=_o(c,a),d=u!=null,f=o.shouldExecuteOnCPU([r]),h=[];let p=r;if(d){if(f){const w=o.texData.get(p.dataId).values,E=new Array(a);for(let I=0;I<E.length;I++)E[I]=r.shape[u[I]];const A=nN(w,r.shape,r.dtype,u,E);p=o.makeTensorInfo(E,r.dtype);const T=o.texData.get(p.dataId);T.values=A}else p=g_(r,u,o);h.push(p),c=wo(c.length,a)}ta("sum",c,a);const[x,v]=Oa(p.shape,c);let y=x;i&&(y=Fs(x,l));const b=cPe(p,v,y,o);for(const S of h)o.disposeIntermediateTensorInfo(S);return b}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function dPe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:o}=r,a=i.shape.length,l=Dr(s,i.shape);let c=l;const u=_o(c,a);let d=i;u!=null&&(d=bi({inputs:{x:i},backend:n,attrs:{perm:u}}),c=wo(c.length,i.shape.length)),ta("min",c,a);const[f,h]=Oa(d.shape,c),p=Ve(h),x=qe({inputs:{x:d},backend:n,attrs:{shape:[-1,p]}}),v=Gd(x,x.dtype,"min",n);let y;if(o){const b=Fs(f,l);y=qe({inputs:{x:v},backend:n,attrs:{shape:b}})}else y=qe({inputs:{x:v},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(v),u!=null&&n.disposeIntermediateTensorInfo(d),y}const fPe={kernelName:r8,backendName:"webgl",kernelFunc:dPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hPe=rN+`
  return min(a, b);
`,pPe=`
  vec4 result = vec4(min(a, b));
  bvec4 isNaNA = isnan(a);
  bvec4 isNaNB = isnan(b);
  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);
  `+H0+`
  return result;
`,mPe=Xr({opSnippet:hPe,packedOpSnippet:pPe,cpuKernelImpl:lTe}),gPe={kernelName:i8,backendName:"webgl",kernelFunc:mPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class yPe{constructor(e,n,r){this.variableNames=["x"],this.outputShape=n.map((u,d)=>u[0]+e[d]+u[1]);const i=e.length,s=An(i),o=n.map(u=>u[0]).join(","),a=n.map((u,d)=>u[0]+e[d]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i),c=r==="reflect"?0:1;if(i===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start) {
            outC = start * 2 - outC - ${c};
          } else if(outC >= end) {
            outC = (end - 1) * 2 - outC + ${c};
          }
          setOutput(getX(outC - start));
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${o});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        for (int i = 0; i < ${i}; i++) {
          if (outC[i] < start[i]) {
            outC[i] = start[i] * 2 - outC[i] - ${c};
          } else if(outC[i] >= end[i]) {
            outC[i] = (end[i] - 1) * 2 - outC[i] + ${c};
          }
        }
        ${s} coords = outC - start;
        setOutput(getX(${l}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class vPe{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n.map((p,x)=>p[0]+e[x]+p[1]);const i=e.length,s=An(i),o=n.map(p=>p[0]).join(","),a=n.map((p,x)=>p[0]+e[x]).join(","),l=yi("rc",i),c=yi("source",i),u=`${l[i-1]} < ${this.outputShape[i-1]}`,d=i===1?"source":`vec2(${c.slice(-2).join()})`,f=r==="reflect"?0:1;let h="";if(i===1){const p=`
        ${s} source = rc;
        if (source < start) {
          source = start * 2 - source - ${f};
        } else if (source >= end) {
          source = (end - 1) * 2 - source + ${f};
        }
        source -= start;
      `;h=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[i-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
      `}else{const p=`
        ${s} source = rc;
        ${s} lt = ${s}(lessThan(source, start));
        ${s} gte = ${s}(greaterThanEqual(source, end));
        ${s} orig = 1 - (lt + gte);
        source = orig * source +
                lt * (start * 2 - source - ${f}) +
                gte * ((end - 1) * 2 - source + ${f});
        source -= start;
      `;h=`
        ${s} rc = outputLoc;
        ${p}
        result[0] = getChannel(getX(${c.join()}), ${d});
        ${l[i-1]} += 1;
        if(${u}) {
          ${p}
          result[1] = getChannel(getX(${c.join()}), ${d});
        }
        rc = outputLoc;
        ${l[i-2]} += 1;
        if(${l[i-2]} < ${this.outputShape[i-2]}) {
          ${p}
          result[2] = getChannel(getX(${c.join()}), ${d});
          ${l[i-1]} += 1;
          if(${u}) {
            ${p}
            result[3] = getChannel(getX(${c.join()}), ${d});
          }
        }
      `}this.userCode=`
      const ${s} start = ${s}(${o});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${h}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const xPe=({inputs:t,backend:e,attrs:n})=>{const{x:r}=t,{paddings:i,mode:s}=n,o=ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new vPe(r.shape,i,s):new yPe(r.shape,i,s);return e.runWebGLProgram(o,[r],r.dtype)},bPe={kernelName:s8,backendName:"webgl",kernelFunc:xPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const SPe=`if (b == 0.0) return NAN;
  return mod(a, b);`,_Pe=`
  vec4 result = mod(a, b);
  bvec4 isNaN = equal(b, vec4(0.0));
  `+H0+`
  return result;
`,wPe=Xr({opSnippet:SPe,packedOpSnippet:_Pe}),CPe={kernelName:o8,backendName:"webgl",kernelFunc:wPe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class EPe{constructor(e,n,r){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,r],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];

        float r = random(seed);
        float cdf = 0.0;

        for (int i = 0; i < ${n-1}; i++) {
          cdf += getProbs(batch, i);

          if (r < cdf) {
            setOutput(float(i));
            return;
          }
        }

        // If no other event happened, last event happened.
        setOutput(float(${n-1}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const APe=`
if (a == b) {
  return 1.0;
};
return a / b;`,TPe=`
  // vec4 one = vec4(equal(a, b));
  // return one + (vec4(1.0) - one) * a / b;
  vec4 result = a / b;
  if(a.x == b.x) {
    result.x = 1.;
  }
  if(a.y == b.y) {
    result.y = 1.;
  }
  if(a.z == b.z) {
    result.z = 1.;
  }
  if(a.w == b.w) {
    result.w = 1.;
  }

  return result;
`,R7=Xr({opSnippet:APe,packedOpSnippet:TPe,checkOutOfBounds:!0}),MPe={kernelName:vz,backendName:"webgl",kernelFunc:R7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hB="return a - b;",I7=Xr({opSnippet:hB,packedOpSnippet:hB,supportsComplex:!0,cpuKernelImpl:TTe}),RPe={kernelName:sG,backendName:"webgl",kernelFunc:I7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function N7(t){const{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{dim:s}=r,o=Dr([s],i.shape),a=M7({inputs:{x:i},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),l=Fs(a.shape,o),c=qe({inputs:{x:a},backend:n,attrs:{shape:l}}),u=I7({inputs:{a:i,b:c},backend:n}),d=E7({inputs:{x:u},backend:n}),f=y_({inputs:{x:d},backend:n,attrs:{axis:o,keepDims:!1}}),h=qe({inputs:{x:f},backend:n,attrs:{shape:l}}),p=R7({inputs:{a:d,b:h},backend:n});return n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(h),p}const IPe={kernelName:K8,backendName:"webgl",kernelFunc:N7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NPe(t){const{inputs:e,backend:n,attrs:r}=t,{logits:i}=e,{numSamples:s,seed:o,normalized:a}=r,l=a?i:N7({inputs:{logits:i},backend:n,attrs:{dim:i.shape.length-1}}),c=l.shape[0],u=l.shape[1],d=new EPe(c,u,s),f=[[o]],h=n.runWebGLProgram(d,[l],"int32",f);return a||n.disposeIntermediateTensorInfo(l),h}const PPe={kernelName:a8,backendName:"webgl",kernelFunc:NPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const kPe=Co+`
  return -x;
`,DPe=`
  vec4 result = -x;
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`;function OPe(t){const{inputs:e,backend:n}=t,{x:r}=e;if(n.shouldExecuteOnCPU([r])){const s=n.texData.get(r.dataId),[o,a]=uTe(s.values,r.shape,r.dtype);return n.makeTensorInfo(a,r.dtype,o)}let i;return ge().getBool("WEBGL_PACK_UNARY_OPERATIONS")?i=new Hu(r.shape,DPe):i=new al(r.shape,kPe),n.runWebGLProgram(i,[r],r.dtype)}const LPe={kernelName:c8,backendName:"webgl",kernelFunc:OPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const BPe=ZH;function FPe(t){zo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l}=r,c=n.readSync(i.dataId),u=n.readSync(s.dataId),{selectedIndices:d}=BPe(c,u,o,a,l);return n.makeTensorInfo([d.length],"int32",new Int32Array(d))}const $Pe={kernelName:d8,backendName:"webgl",kernelFunc:FPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const UPe=eV;function zPe(t){zo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,padToMaxOutputSize:c}=r,u=n.readSync(i.dataId),d=n.readSync(s.dataId),{selectedIndices:f,validOutputs:h}=UPe(u,d,o,a,l,c);return[n.makeTensorInfo([f.length],"int32",new Int32Array(f)),n.makeTensorInfo([],"int32",new Int32Array([h]))]}const GPe={kernelName:f8,backendName:"webgl",kernelFunc:zPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const HPe=tV;function VPe(t){zo("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:e,backend:n,attrs:r}=t,{boxes:i,scores:s}=e,{maxOutputSize:o,iouThreshold:a,scoreThreshold:l,softNmsSigma:c}=r,u=n.readSync(i.dataId),d=n.readSync(s.dataId),f=o,h=a,p=l,x=c,{selectedIndices:v,selectedScores:y}=HPe(u,d,f,h,p,x);return[n.makeTensorInfo([v.length],"int32",new Int32Array(v)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}const WPe={kernelName:h8,backendName:"webgl",kernelFunc:VPe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jPe{constructor(e,n,r,i){this.variableNames=["indices"],this.outputShape=[e,n],this.userCode=`
      void main() {
        ivec2 coords = getOutputCoords();
        int index = round(getIndices(coords.x));
        setOutput(mix(float(${i}), float(${r}),
                      float(index == coords.y)));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const XPe=t=>{const{inputs:e,backend:n,attrs:r}=t,{indices:i}=e,{dtype:s,depth:o,onValue:a,offValue:l}=r,c=Ve(i.shape),u=new jPe(c,o,a,l),d=qe({inputs:{x:i},backend:n,attrs:{shape:[c]}}),f=n.runWebGLProgram(u,[d],s);n.disposeIntermediateTensorInfo(d);const h=[...i.shape,o],p=qe({inputs:{x:f},backend:n,attrs:{shape:h}});return n.disposeIntermediateTensorInfo(f),p},KPe={kernelName:m8,backendName:"webgl",kernelFunc:XPe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function sb(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="complex64"){const i=W0({inputs:{input:r},backend:n}),s=sb({inputs:{x:i},backend:n}),o=v_({inputs:{input:r},backend:n}),a=sb({inputs:{x:o},backend:n}),l=Vc({inputs:{real:s,imag:a},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return j0({attrs:{shape:r.shape,dtype:r.dtype,value:r.dtype==="string"?"":0},backend:n})}const qPe={kernelName:hG,backendName:"webgl",kernelFunc:sb};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function P7(t){const{inputs:e,backend:n}=t,{x:r}=e;if(r.dtype==="string")throw new Error("onesLike is not supported under string dtype");if(r.dtype==="complex64"){const i=W0({inputs:{input:r},backend:n}),s=P7({inputs:{x:i},backend:n}),o=v_({inputs:{input:r},backend:n}),a=sb({inputs:{x:o},backend:n}),l=Vc({inputs:{real:s,imag:a},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(a),l}else return j0({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:n})}const JPe={kernelName:p8,backendName:"webgl",kernelFunc:P7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YPe(t){const{inputs:e,backend:n,attrs:r}=t,{axis:i}=r;if(e.length===1)return PT({inputs:{input:e[0]},backend:n,attrs:{dim:i}});const s=e[0].shape,o=e[0].dtype;e.forEach(u=>{Ls(s,u.shape,"All tensors passed to stack must have matching shapes"),Y(o===u.dtype,()=>"All tensors passed to stack must have matching dtypes")});const a=[],l=e.map(u=>{const d=PT({inputs:{input:u},backend:n,attrs:{dim:i}});return a.push(d),d}),c=y7({inputs:l,backend:n,attrs:{axis:i}});return a.forEach(u=>n.disposeIntermediateTensorInfo(u)),c}const QPe={kernelName:g8,backendName:"webgl",kernelFunc:YPe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class ZPe{constructor(e,n,r){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((c,u)=>c[0]+e[u]+c[1]);const i=e.length,s=An(i),o=n.map(c=>c[0]).join(","),a=n.map((c,u)=>c[0]+e[u]).join(","),l=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,i);if(i===1){this.userCode=`
        int start = ${o};
        int end = ${a};

        void main() {
          int outC = getOutputCoords();
          if (outC < start || outC >= end) {
            setOutput(value);
          } else {
            setOutput(getX(outC - start));
          }
        }
      `;return}this.userCode=`
      ${s} start = ${s}(${o});
      ${s} end = ${s}(${a});

      void main() {
        ${s} outC = getOutputCoords();
        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {
          setOutput(value);
        } else {
          ${s} coords = outC - start;
          setOutput(getX(${l}));
        }
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class eke{constructor(e,n,r){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=n.map((x,v)=>x[0]+e[v]+x[1]);const i=e.length,s=An(i),o=n.map(x=>x[0]).join(","),a=n.map((x,v)=>x[0]+e[v]).join(","),l=yi("rc",i),c=yi("source",i),u=`${l[i-1]} < ${this.outputShape[i-1]}`,d=i===1?"source":`vec2(${c.slice(-2).join()})`,f=[`${s} rc = outputLoc;`,`${l[i-1]} += 1;
       if(${u}) {
      `,i===1?"":`}
       rc = outputLoc;
       ${l[i-2]} += 1;
       if(${l[i-2]} < ${this.outputShape[i-2]}) {`,i===1?"":`  ${l[i-1]} += 1;
         if(${u}) {`],h=i===1?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let x=0,v=i===1?2:4;x<v;x++)p+=`
        ${f[x]}
        if (${h}) {
          result[${x}] = float(value);
        } else {
          ${s} source = rc - start;
          result[${x}] = getChannel(getX(${c.join()}), ${d});
        }
      `;p+=i===1?"} ":"}}",this.userCode=`
      const ${s} start = ${s}(${o});
      const ${s} end = ${s}(${a});

      void main() {
        ${s} outputLoc = getOutputCoords();
        vec4 result = vec4(0.);
        ${p}
        setOutput(result);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const k7=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{paddings:s,constantValue:o}=r;if(Ve(i.shape)===0){const c=s.map((u,d)=>u[0]+i.shape[d]+u[1]);return j0({backend:n,attrs:{shape:c,value:o,dtype:i.dtype}})}const a=ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new eke(i.shape,s,o):new ZPe(i.shape,s,o),l=[[o]];return n.runWebGLProgram(a,[i],i.dtype,l)},tke={kernelName:y8,backendName:"webgl",kernelFunc:k7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const nke=`
  if(a < 0.0 && floor(b) < b){
    return NAN;
  }
  if (b == 0.0) {
    return 1.0;
  }
  return (round(mod(b, 2.0)) != 1) ?
      pow(abs(a), b) : sign(a) * pow(abs(a), b);
`,rke=`
  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.
  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));
  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);
  vec4 result = multiplier * pow(abs(a), b);

  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS
  bvec4 isExpZero = equal(b, vec4(0.0));
  result.r = isExpZero.r ? 1.0 : result.r;
  result.g = isExpZero.g ? 1.0 : result.g;
  result.b = isExpZero.b ? 1.0 : result.b;
  result.a = isExpZero.a ? 1.0 : result.a;

  bvec4 isNaN1 = lessThan(a, vec4(0.0));
  bvec4 isNaN2 = lessThan(floor(b), b);
  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);
  `+H0+`
  return result;
`,ike=Xr({opSnippet:nke,packedOpSnippet:rke}),ske={kernelName:v8,backendName:"webgl",kernelFunc:ike};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function oke(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{axis:s,keepDims:o}=r,a=i.shape.length,l=[],c=Dr(s,i.shape);let u=c;const d=_o(u,a);let f=i;d!=null&&(f=bi({inputs:{x:i},backend:n,attrs:{perm:d}}),u=wo(u.length,a),l.push(f)),ta("prod",u,a);let h;if(n.shouldExecuteOnCPU([f])){const p=n.texData.get(f.dataId).values,{outVals:x,outShape:v,outDtype:y}=fTe(f.shape,f.dtype,p,u);h=n.makeTensorInfo(v,y,x)}else{const[p,x]=Oa(f.shape,u),v=Ve(x),y=qe({inputs:{x:f},backend:n,attrs:{shape:[-1,v]}}),b=gI(i.dtype),S=Gd(y,b,"prod",n);h=qe({inputs:{x:S},backend:n,attrs:{shape:p}}),l.push(y),l.push(S)}if(o){l.push(h);const p=Fs(h.shape,c);h=qe({inputs:{x:h},backend:n,attrs:{shape:p}})}return l.forEach(p=>n.disposeIntermediateTensorInfo(p)),h}const ake={kernelName:b8,backendName:"webgl",kernelFunc:oke};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function lke(t){const{inputs:e,backend:n,attrs:r}=t,{paramsNestedSplits:i,paramsDenseValues:s,indices:o}=e,{outputRaggedRank:a}=r,l=i.map(y=>n.readSync(y.dataId)),c=i.map(y=>y.shape),u=n.readSync(s.dataId),d=n.readSync(o.dataId),[f,h,p]=hTe(l,c,u,s.shape,s.dtype,d,o.shape,a),x=f.map(y=>n.makeTensorInfo([y.length],"int32",y)),v=n.makeTensorInfo(p,s.dtype,h);return x.concat([v])}const cke={kernelName:S8,backendName:"webgl",kernelFunc:lke};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function uke(t){const{inputs:e,backend:n,attrs:r}=t,{shape:i,values:s,defaultValue:o,rowPartitionTensors:a}=e,{rowPartitionTypes:l}=r,c=n.readSync(i.dataId),u=n.readSync(s.dataId),d=n.readSync(o.dataId),f=a.map(v=>n.readSync(v.dataId)),h=a.map(v=>v.shape),[p,x]=pTe(c,i.shape,u,s.shape,s.dtype,d,o.shape,f,h,l);return n.makeTensorInfo(p,s.dtype,x)}const dke={kernelName:_8,backendName:"webgl",kernelFunc:uke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const D7=t=>{const{backend:e,attrs:n}=t,{start:r,stop:i,step:s,dtype:o}=n,a=mTe(r,i,s,o);return e.makeTensorInfo([a.length],o,a)},fke={kernelName:w8,backendName:"webgl",kernelFunc:D7};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const hke="return 1.0 / x;",pke=qt({opSnippet:hke}),mke={kernelName:E8,backendName:"webgl",kernelFunc:pke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const gke=Co+`
  return (x < 0.0) ? 0.0 : x;
`,yke=`
  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,vke=qt({opSnippet:gke,packedOpSnippet:yke}),xke={kernelName:A8,backendName:"webgl",kernelFunc:vke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bke=Co+`
  return (x < 0.0) ? 0.0 : min(6.0, x);
`,Ske=`
  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,_ke=qt({opSnippet:bke,packedOpSnippet:Ske}),wke={kernelName:I8,backendName:"webgl",kernelFunc:_ke};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Cke{constructor(e,n,r,i,s){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,n,r,c];const u=[i&&n>1?a-1:a,i&&r>1?l-1:l],d=[i&&n>1?n-1:n,i&&r>1?r-1:r];let f;s?f="(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":f="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/d[0]},
          ${u[1]/d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));
        ivec2 sourceCeilRC = ivec2(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);
        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);
        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);
        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);

        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);

        float top = topLeft + (topRight - topLeft) * fracRC.y;
        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;
        float newValue = top + (bottom - top) * fracRC.x;

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Eke{constructor(e,n,r,i,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,n,r,c];const u=[i&&n>1?a-1:a,i&&r>1?l-1:l],d=[i&&n>1?n-1:n,i&&r>1?r-1:r];let f;s?f="(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":f="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/d[0]},
          ${u[1]/d[1]},
          ${u[1]/d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${f};

        // Compute the four integer indices.
        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));
        ivec3 sourceCeilRC = ivec3(
          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        // In parallel, construct four corners for all four components in
        // packed 2x2 cell.
        vec4 topLeft = vec4(
          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 bottomLeft = vec4(
          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);

        vec4 topRight = vec4(
          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec4 bottomRight = vec4(
          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),
          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);

        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);

        vec4 top = mix(topLeft, topRight, fracRC.yyzz);
        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);
        vec4 newValue = mix(top, bottom, fracRC.x);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Ake(t){const{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:s,halfPixelCenters:o,size:a}=r,[l,c]=a,u=ge().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Eke(i.shape,l,c,s,o):new Cke(i.shape,l,c,s,o);return n.runWebGLProgram(u,[i],"float32")}const Tke={kernelName:R8,backendName:"webgl",kernelFunc:Ake};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Mke{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,i,s]=n,[,o,a]=e,l=[r&&o>1?i-1:i,r&&a>1?s-1:s],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],f=1/u,h=1/d,p=Math.ceil(f)*2+2,x=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${d});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${h});

        const int winHeight = int(${p});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(startRLerp - float(winHeight / 2));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(startCLerp - float(winWidth / 2));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float dxR = float(dyR) * heightScale;
            int topDxRIndex = int(floor(dxR));
            int bottomDxRIndex = int(min(ceil(dxR), ${i-1}.0));
            float dxRLerp = dxR - float(topDxRIndex);
            float inverseDxRLerp = 1.0 - dxRLerp;

            float dxC = float(dyC) * widthScale;
            int leftDxCIndex = int(floor(dxC));
            int rightDxCIndex = int(min(ceil(dxC), ${s-1}.0));
            float dxCLerp = dxC - float(leftDxCIndex);
            float inverseDxCLerp = 1.0 - dxCLerp;

            if (r == topDxRIndex && c == leftDxCIndex) {
              // topLeft
              accumulator +=
                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;
            }

            if (r == topDxRIndex && c == rightDxCIndex) {
              // topRight
              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;
            }

            if (r == bottomDxRIndex && c == leftDxCIndex) {
              // bottomLeft
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;
            }

            if (r == bottomDxRIndex && c == rightDxCIndex) {
              // bottomRight
              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Rke(t){const{inputs:e,backend:n,attrs:r}=t,{images:i,dy:s}=e,{alignCorners:o}=r,a=new Mke(s.shape,i.shape,o);return n.runWebGLProgram(a,[s],s.dtype)}const Ike={kernelName:Jme,backendName:"webgl",kernelFunc:Rke};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Nke{constructor(e,n,r,i,s){this.variableNames=["A"],this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,n,r,c];const u=[i&&n>1?a-1:a,i&&r>1?l-1:l],d=[i&&n>1?n-1:n,i&&r>1?r-1:r],f=i?"0.5":"0.0";let h;s?h="max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":h="vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec2 effectiveInputOverOutputRatioRC = vec2(
          ${u[0]/d[0]},
          ${u[1]/d[1]});
      const vec2 inputShapeRC = vec2(${a}.0, ${l}.0);

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        ivec2 yRC = coords.yz;

        // Fractional source index.
        vec2 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec2 sourceNearestRC = ivec2(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));
        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Pke{constructor(e,n,r,i,s){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[o,a,l,c]=e;this.outputShape=[o,n,r,c];const u=[i&&n>1?a-1:a,i&&r>1?l-1:l],d=[i&&n>1?n-1:n,i&&r>1?r-1:r],f=i?"0.5":"0.0";let h;s?h="max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":h="vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode=`
      const vec3 effectiveInputOverOutputRatioRC = vec3(
          ${u[0]/d[0]},
          ${u[1]/d[1]},
          ${u[1]/d[1]});
      const vec3 inputShapeRC = vec3(${a}.0, ${l}.0,
                                     ${l}.0);

      float getAValue(int b, int r, int c, int d) {
        return getChannel(getA(b, r, c, d), vec2(c, d));
      }

      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        // Calculate values for next column in yRC.z.
        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);

        // Fractional source index.
        vec3 sourceFracIndexRC = ${h};

        // Compute the coordinators of nearest neighbor point.
        ivec3 sourceNearestRC = ivec3(
          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ${f})));

        // Should we calculate next column and row elements in 2x2 packed cell.
        bool hasNextCol = d < ${c-1};
        bool hasNextRow = coords.z < ${r-1};

        vec4 newValue = vec4(
          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),
          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)
                     : 0.0,
          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)
                     : 0.0,
          (hasNextRow && hasNextCol) ?
            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);

        setOutput(newValue);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kke(t){const{inputs:e,backend:n,attrs:r}=t,{images:i}=e,{alignCorners:s,halfPixelCenters:o,size:a}=r,[l,c]=a,u=ge().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new Pke(i.shape,l,c,s,o):new Nke(i.shape,l,c,s,o);return n.runWebGLProgram(u,[i],i.dtype)}const Dke={kernelName:M8,backendName:"webgl",kernelFunc:kke};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Oke{constructor(e,n,r){this.variableNames=["dy"],this.outputShape=[],this.outputShape=n;const[,i,s]=n,[,o,a]=e,l=[r&&o>1?i-1:i,r&&a>1?s-1:s],c=[r&&o>1?o-1:o,r&&a>1?a-1:a],u=l[0]/c[0],d=l[1]/c[1],f=1/u,h=1/d,p=Math.ceil(f)*2+2,x=Math.ceil(h)*2+2;this.userCode=`
      void main() {
        ivec4 coords = getOutputCoords();
        int b = coords[0];
        int d = coords[3];
        int r = coords[1];
        int c = coords[2];

        float accumulator = 0.0;

        const float heightScale = float(${u});
        const float widthScale = float(${d});

        const float invHeightScale = float(${f});
        const float invWidthScale = float(${h});

        const int winHeight = int(${p});
        const int winWidth = int(${x});

        // Compute bounds for where in dy we will look
        float startRLerp = floor(float(r) * invHeightScale);
        int startDyR = int(floor(startRLerp - float(winHeight / 2)));

        float startCLerp = floor(float(c) * invWidthScale);
        int startDyC = int(floor(startCLerp - float(winWidth / 2)));

        // Loop over dy
        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {
          int dyR = dyROffset + startDyR;

          // Guard against the window exceeding the bounds of dy
          if (dyR < 0 || dyR >= ${o}) {
            continue;
          }

          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {
            int dyC = dyCOffset + startDyC;

            // Guard against the window exceeding the bounds of dy
            if (dyC < 0 || dyC >= ${a}) {
              continue;
            }

            float sourceFracRow =
              float(${l[0]}) *
                (float(dyR) / float(${c[0]}));

            float sourceFracCol =
                float(${l[1]}) *
                  (float(dyC) / float(${c[1]}));

            int sourceNearestRow = int(min(
                float(int(${i}) - 1),
                ${r} ? float(round(sourceFracRow)) :
                                  float(floor(sourceFracRow))));

            int sourceNearestCol = int(min(
                float(int(${s}) - 1),
                ${r} ? float(round(sourceFracCol)) :
                                  float(floor(sourceFracCol))));

            if (r == sourceNearestRow && c == sourceNearestCol) {
              accumulator += getDy(b, dyR, dyC, d);
            }
          }
        }
        // End loop over dy

        setOutput(accumulator);
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Lke(t){const{inputs:e,backend:n,attrs:r}=t,{images:i,dy:s}=e,{alignCorners:o}=r,a=new Oke(s.shape,i.shape,o);return n.runWebGLProgram(a,[s],s.dtype)}const Bke={kernelName:qme,backendName:"webgl",kernelFunc:Lke};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Fke{constructor(e,n){this.variableNames=["x"];const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);if(this.outputShape=e,r===1){this.userCode=`
        void main() {
          int coord = getOutputCoords();
          setOutput(getX(${e[0]} - coord - 1));
        }
      `;return}const i=a=>n.indexOf(a)!==-1&&e[a]!==1?`${e[a]} - coords[${a}] - 1`:`coords[${a}]`,s=e.map((a,l)=>i(l)).join(","),o=An(r);this.userCode=`
      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${s}));
      }
    `}}/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class $ke{constructor(e,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const r=e.length;if(r>4)throw new Error(`WebGL backend: Reverse of rank-${r} tensor is not yet supported`);this.outputShape=e;const i=yi("rc",r),s=`${i[r-1]} + 1 < ${this.outputShape[r-1]}`,o=`${i[r-2]} + 1 < ${this.outputShape[r-2]}`,a=An(r);r===1?this.userCode=`
        void main(){
          int rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = getChannel(getX(${e[0]} - rc - 1),
            ${e[0]} - rc - 1);
          if(${s}){
              result.g = getChannel(getX(${e[0]} - (rc  + 1) - 1),
                ${e[0]} - (rc  + 1) - 1);
          }
          setOutput(result);
        }
      `:this.userCode=`
        void main() {
          ${a} rc = getOutputCoords();
          vec4 result = vec4(0.);
          result.r = ${l(i.slice())};
          if(${s}){
            result.g = ${c(i.slice())};
          }
          if(${o}) {
            result.b = ${u(i.slice())};
            if(${s}) {
              result.a = ${d(i.slice())};
            }
          }
          setOutput(result);
        }
    `;function l(p){return f(p)}function c(p){return p[r-1]="("+p[r-1]+" + 1)",f(p)}function u(p){return p[r-2]="("+p[r-2]+" + 1)",f(p)}function d(p){return p[r-1]="("+p[r-1]+" + 1)",p[r-2]="("+p[r-2]+" + 1)",f(p)}function f(p){const x=e.map((b,S)=>h(S,p)),v=x.join(","),y=x.slice(-2).join(",");return`getChannel(getX(${v}), vec2(${y}))`}function h(p,x){return n.indexOf(p)!==-1&&e[p]!==1?`${e[p]} - ${x[p]} - 1`:`${x[p]}`}}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Uke(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{dims:s}=r,o=i.shape.length,a=Dr(s,i.shape);if(o===0)return os({inputs:{x:i},backend:n});const l=ge().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new $ke(i.shape,a):new Fke(i.shape,a);return n.runWebGLProgram(l,[i],i.dtype)}const zke={kernelName:N8,backendName:"webgl",kernelFunc:Uke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Gke{constructor(e,n){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const r=e[1],i=e[2];this.outputShape=e;let s="";typeof n=="number"?s=`float outputValue = ${n.toFixed(2)};`:s=`
        vec3 fill = vec3(${n.join(",")});
        float outputValue = fill[coords[3]];`,this.userCode=`
        void main() {
          ivec4 coords = getOutputCoords();
          int x = coords[2];
          int y = coords[1];
          float coordXFloat = (float(x) - params[0]) * params[3] -
            (float(y) - params[1]) * params[2];
          float coordYFloat = (float(x) - params[0]) * params[2] +
            (float(y) - params[1]) * params[3];
          int coordX = int(round(coordXFloat + params[0]));
          int coordY = int(round(coordYFloat + params[1]));
          ${s}
          if(coordX >= 0 && coordX < ${i} && coordY >= 0 && coordY < ${r}) {
            outputValue = getImage(coords[0], coordY, coordX, coords[3]);
          }
          setOutput(outputValue);
        }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Hke={kernelName:mG,backendName:"webgl",kernelFunc:({inputs:t,attrs:e,backend:n})=>{const{image:r}=t,{radians:i,fillValue:s,center:o}=e,a=n,l=new Gke(r.shape,s),[c,u]=aV(o,r.shape[1],r.shape[2]),d=[[c,u,Math.sin(i),Math.cos(i)]];return a.runWebGLProgram(l,[r],r.dtype,d)}};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Vke=`
  // OpenGL ES does not support round function.
  // The algorithm is based on banker's rounding.
  float base = floor(x);
  if ((x - base) < 0.5) {
    return floor(x);
  } else if ((x - base) > 0.5) {
    return ceil(x);
  } else {
    if (mod(base, 2.0) == 0.0) {
      return base;
    } else {
      return base + 1.0;
    }
  }
`,Wke=qt({opSnippet:Vke}),jke={kernelName:P8,backendName:"webgl",kernelFunc:Wke};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const Xke="return inversesqrt(x);",Kke=qt({opSnippet:Xke,cpuKernelImpl:gTe}),qke={kernelName:k8,backendName:"webgl",kernelFunc:Kke};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class O7{constructor(e,n,r,i,s,o,a=!0){this.variableNames=["updates","indices","defaultValue"],this.outputShape=o;const l=An(s.length),c=An(o.length);let u="";r===1?u="i":r===2&&(u="i, j");const d=`getIndices(${u})`;let f="";i===1?f="i":i===2&&(f="i, coords[1]");const h=`getUpdates(${f})`,p=n>1?"strides[j]":"strides";this.userCode=`
        ${l} strides = ${l}(${s});

        void main() {
          ${c} coords = getOutputCoords();
          float sum = 0.0;
          bool found = false;
          for (int i = 0; i < ${e}; i++) {
            int flattenedIndex = 0;
            for (int j = 0; j < ${n}; j++) {
              int index = round(${d});
              flattenedIndex += index * ${p};
            }
            if (flattenedIndex == coords[0]) {
              sum += ${h};
              found = true;
            }
          }
          setOutput(mix(getDefaultValue(), sum, float(found)));
        }
      `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Jke(t){const{inputs:e,backend:n,attrs:r}=t,{indices:i,updates:s}=e,{shape:o}=r,{sliceRank:a,numUpdates:l,sliceSize:c,strides:u,outputSize:d}=wI(s,i,o),f=[d/c,c];if(d===0)return n.makeTensorInfo(o,i.dtype);const h=qe({inputs:{x:i},backend:n,attrs:{shape:[l,a]}}),p=qe({inputs:{x:s},backend:n,attrs:{shape:[l,c]}}),x=n.makeTensorInfo([],"float32",new Float32Array([0])),v=new O7(l,a,h.shape.length,p.shape.length,u,f),y=n.runWebGLProgram(v,[p,h,x],p.dtype),b=qe({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(x),b}const Yke={kernelName:D8,backendName:"webgl",kernelFunc:Jke};/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class Qke{constructor(e,n,r,i){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,r];const s="while (left < right) {",o=`for (int i = 0; i < ${Math.ceil(Math.log2(n+1))}; ++i) { if (left >= right) break;`,a=ge().getNumber("WEBGL_VERSION")===2?s:o,l=i==="left"?"<":"<=";this.userCode=`
       int findBound(int batch, float value) {
         int left = 0;
         int right = numInputs;
         int mid;
         ${a}
           mid = (left + right) / 2;
           if (getSortedSequence(batch, mid) ${l} value) {
             left = mid + 1;
           } else {
             right = mid;
           }
         }
         return right;
       }

       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int valueIndex = coords[1];

         float value = getValues(batch, valueIndex);

         setOutput(float(findBound(batch, value)));
       }
     `}}/**
 * @license
 * Copyright 2022 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function Zke(t){const{inputs:e,backend:n,attrs:r}=t,{sortedSequence:i,values:s}=e,{side:o}=r,a=new Qke(i.shape[0],i.shape[1],s.shape[1],o),l=[[i.shape[1]]];return n.runWebGLProgram(a,[i,s],"int32",l)}const eDe={kernelName:O8,backendName:"webgl",kernelFunc:Zke};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class tDe{constructor(e,n,r){this.variableNames=["c","a","b"],this.outputShape=n;let i,s;if(r>4)throw Error(`Where for rank ${r} is not yet supported`);if(r===1)s="resRC",i="resRC";else{const a=["resRC.x","resRC.y","resRC.z","resRC.w"],l=[],c=[];for(let u=0;u<n.length;u++)c.push(`${a[u]}`),u<e&&l.push(`${a[u]}`);i=l.join(),s=c.join()}const o=An(r);this.userCode=`
      void main() {
        ${o} resRC = getOutputCoords();
        float cVal = getC(${i});
        if (cVal >= 1.0) {
          setOutput(getA(${s}));
        } else {
          setOutput(getB(${s}));
        }
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function nDe(t){const{inputs:e,backend:n}=t,{condition:r,t:i,e:s}=e,o=new tDe(r.shape.length,i.shape,i.shape.length);return n.runWebGLProgram(o,[r,i,s],Pa(i.dtype,s.dtype))}const rDe={kernelName:L8,backendName:"webgl",kernelFunc:nDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iDe=`
  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.
  // see: https://arxiv.org/abs/1706.02515
  float scaleAlpha = ${uV};
  float scale = ${dV};
  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);
`,sDe=qt({opSnippet:iDe}),oDe={kernelName:B8,backendName:"webgl",kernelFunc:sDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const aDe=Np+`
  return 1.0 / (1.0 + exp(-1.0 * x));
`,lDe=`
  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));
  bvec4 isNaN = isnan(x);

  result.r = isNaN.r ? x.r : result.r;
  result.g = isNaN.g ? x.g : result.g;
  result.b = isNaN.b ? x.b : result.b;
  result.a = isNaN.a ? x.a : result.a;

  return result;
`,cDe=qt({opSnippet:aDe,packedOpSnippet:lDe,cpuKernelImpl:vTe}),uDe={kernelName:G8,backendName:"webgl",kernelFunc:cDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const dDe=`
  if (isnan(x)) { return 0.0; }
  return sign(x);
`,fDe=qt({opSnippet:dDe}),hDe={kernelName:z8,backendName:"webgl",kernelFunc:fDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pDe=Np+`
  return sin(x);
`,mDe=qt({opSnippet:pDe}),gDe={kernelName:$8,backendName:"webgl",kernelFunc:mDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const yDe=`
  float e2x = exp(x);
  return (e2x - 1.0 / e2x) / 2.0;
`,vDe=qt({opSnippet:yDe}),xDe={kernelName:U8,backendName:"webgl",kernelFunc:vDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const bDe=`
  float epsilon = 1.1920928955078125e-7;
  float threshold = log(epsilon) + 2.0;

  bool too_large = x > -threshold;
  bool too_small = x < threshold;

  float result;
  float exp_x = exp(x);

  if (too_large){
    result = x;
  }
  else if (too_small){
    result = exp_x;
  }
  else{
    result = log(exp_x + 1.0);
  }
  return result;
`,SDe=qt({opSnippet:bDe}),_De={kernelName:H8,backendName:"webgl",kernelFunc:SDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const wDe=t=>{const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{blockShape:s,paddings:o}=r;Y(i.shape.length<=4,()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet");const a=s.reduce((y,b)=>y*b),l=[[0,0]];l.push(...o);for(let y=1+s.length;y<i.shape.length;++y)l.push([0,0]);const c=[],u=k7({inputs:{x:i},backend:n,attrs:{paddings:l,constantValue:0}}),d=KI(u.shape,s,a,!1),f=qI(d.length,s.length,!1),h=JI(u.shape,s,a,!1),p=qe({inputs:{x:u},backend:n,attrs:{shape:d}}),x=bi({inputs:{x:p},backend:n,attrs:{perm:f}}),v=qe({inputs:{x},backend:n,attrs:{shape:h}});return c.push(u),c.push(p),c.push(x),c.forEach(y=>n.disposeIntermediateTensorInfo(y)),v},CDe={kernelName:j8,backendName:"webgl",kernelFunc:wDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function EDe(t){const{inputs:e,backend:n}=t,{indices:r,values:i,denseShape:s,defaultValue:o}=e;if(s.shape.length!==1)throw new Error(`Dense shape must be a vector, saw:
         ${s.shape}`);if(r.shape.length!==2)throw new Error(`Indices must be a matrix, saw:
         ${r.shape}`);if(i.shape.length!==1)throw new Error(`Values must be a vector, saw:
         ${i.shape}`);if(o.shape.length!==0)throw new Error(`Default value must be a scalar, saw:
        ${o.shape}`);const a=n.readSync(r.dataId),l=n.readSync(i.dataId),c=n.readSync(s.dataId),u=n.readSync(o.dataId)[0],[d,f,h,p,x]=bTe(a,r.shape,r.dtype,l,i.dtype,c,u);return[n.makeTensorInfo(f,r.dtype,d),n.makeTensorInfo([f[0]],i.dtype,h),n.makeTensorInfo([p.length],"bool",new Uint8Array(p.map(v=>Number(v)))),n.makeTensorInfo([x.length],r.dtype,new Int32Array(x))]}const ADe={kernelName:q8,backendName:"webgl",kernelFunc:EDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function TDe(t){const{inputs:e,backend:n}=t,{inputIndices:r,inputShape:i,newShape:s}=e;if(r.shape.length!==2)throw new Error(`Input indices should be a matrix but received shape ${r.shape}`);if(i.shape.length!==1)throw new Error(`Input shape should be a vector but received shape ${i.shape}`);if(s.shape.length!==1)throw new Error(`Target shape should be a vector but received shape ${s.shape}`);const o=Array.from(n.readSync(i.dataId)),a=n.readSync(r.dataId),l=Array.from(n.readSync(s.dataId)),[c,u,d]=STe(a,r.shape,r.dtype,o,l);return[n.makeTensorInfo(u,r.dtype,c),n.makeTensorInfo([d.length],s.dtype,new Int32Array(d))]}const MDe={kernelName:J8,backendName:"webgl",kernelFunc:TDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function RDe(t){const{inputs:e,backend:n}=t,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
              ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
              ${s.shape}`);const o=n.readSync(r.dataId),a=n.readSync(i.dataId),l=n.readSync(s.dataId),[c,u]=i7(o,r.shape,r.dtype,a,l,!0);return n.makeTensorInfo(u,r.dtype,c)}const IDe={kernelName:Y8,backendName:"webgl",kernelFunc:RDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function NDe(t){const{inputs:e,backend:n}=t,{data:r,indices:i,segmentIds:s}=e;if(r.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(i.shape.length!==1)throw new Error(`Indices should be a vector but received shape
             ${i.shape}`);if(s.shape.length!==1)throw new Error(`Segment ids should be a vector but received shape
             ${s.shape}`);const o=n.readSync(r.dataId),a=n.readSync(i.dataId),l=n.readSync(s.dataId),[c,u]=i7(o,r.shape,r.dtype,a,l);return n.makeTensorInfo(u,r.dtype,c)}const PDe={kernelName:Q8,backendName:"webgl",kernelFunc:NDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function kDe(t){const{inputs:e,backend:n,attrs:r}=t,{sparseIndices:i,sparseValues:s,defaultValue:o}=e,{outputShape:a}=r,{sliceRank:l,numUpdates:c,sliceSize:u,strides:d,outputSize:f}=wI(s,i,a),h=!1;if(s.dtype==="string"){const y=n.bufferSync(i),b=n.bufferSync(s),S=Qh(n.readSync(o.dataId)[0]),w=yTe(y,b,a,f,u,c,l,d,S,h);return n.makeTensorInfo(a,w.dtype,w.values)}const p=new O7(c,l,i.shape.length,s.shape.length,d,[f,1],h),x=n.runWebGLProgram(p,[s,i,o],s.dtype),v=qe({inputs:{x},backend:n,attrs:{shape:a}});return n.disposeIntermediateTensorInfo(x),v}const DDe={kernelName:Z8,backendName:"webgl",kernelFunc:kDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ODe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{numOrSizeSplits:s,axis:o}=r,a=Dr(o,i.shape)[0],l=wV(i,s,a),c=i.shape.length,u=new Array(c).fill(0),d=i.shape.slice();return l.map(f=>{const h=[...d];h[a]=f;const p=Pp({inputs:{x:i},backend:n,attrs:{begin:u,size:h}});return u[a]+=f,p})}const LDe={kernelName:X8,backendName:"webgl",kernelFunc:ODe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const pB="return sqrt(x);",BDe=qt({opSnippet:pB,packedOpSnippet:pB,cpuKernelImpl:_Te}),FDe={kernelName:V8,backendName:"webgl",kernelFunc:BDe};/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const $De="return x * x;",UDe=qt({opSnippet:$De}),zDe={kernelName:Yme,backendName:"webgl",kernelFunc:UDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const mB="return (a - b) * (a - b);",GDe=Xr({opSnippet:mB,packedOpSnippet:mB}),HDe={kernelName:eG,backendName:"webgl",kernelFunc:GDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function VDe({inputs:t,attrs:e,backend:n}){const{x:r}=t,i=Co+`
    return x > 0.0 ? 1.0 : float(${e.alpha});
  `,s=new al(r.shape,i);return n.runWebGLProgram(s,[r],r.dtype)}const WDe={kernelName:pG,backendName:"webgl",kernelFunc:VDe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class jDe{constructor(e,n,r){this.variableNames=["x"],this.outputShape=r;const i=r.length,s=An(r.length),o=An(r.length);let a="";if(i===1)a="coords * strides + begin";else{let l=0;a=r.map((c,u)=>(l++,r.length===1?`coords * strides[${u}] + begin[${u}]`:`coords[${l-1}] * strides[${u}] + begin[${u}]`)).join(",")}this.userCode=`
      ${s} begin = ${s}(${e});
      ${s} strides = ${s}(${n});

      void main() {
        ${o} coords = getOutputCoords();
        setOutput(getX(${a}));
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function XDe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{begin:s,end:o,strides:a,beginMask:l,endMask:c,ellipsisMask:u,newAxisMask:d,shrinkAxisMask:f}=r,{finalShapeSparse:h,finalShape:p,isIdentity:x,sliceDim0:v,isSimpleSlice:y,begin:b,end:S,strides:w}=pH(i.shape,s,o,a,l,c,u,d,f);let E;if(x)E=qe({inputs:{x:i},backend:n,attrs:{shape:p}});else if(v||y){Y(i.shape.length>=1,()=>`Input must have rank at least 1, got: ${i.shape.length}`);const T=iH(b,S,w),I=Pp({inputs:{x:i},backend:n,attrs:{begin:b,size:T}});E=qe({inputs:{x:I},backend:n,attrs:{shape:p}}),n.disposeIntermediateTensorInfo(I)}else if(n.shouldExecuteOnCPU([i])){const I=n.readSync(i.dataId),N=Vn(i.shape,i.dtype,I),M=wTe(h,N,w,b);E=n.makeTensorInfo(p,i.dtype,M.values)}else{const I=new jDe(b,w,h);E=n.runWebGLProgram(I,[i],i.dtype)}const A=qe({inputs:{x:E},backend:n,attrs:{shape:p}});return n.disposeIntermediateTensorInfo(E),A}const KDe={kernelName:tG,backendName:"webgl",kernelFunc:XDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function qDe(t){const{inputs:e,backend:n,attrs:r}=t,{separator:i,nGramWidths:s,leftPad:o,rightPad:a,padWidth:l,preserveShortSequences:c}=r,{data:u,dataSplits:d}=e,f=n.readSync(u.dataId),h=n.readSync(d.dataId),[p,x]=CTe(f,h,i,s,o,a,l,c);return[n.makeTensorInfo([p.length],"string",p),n.makeTensorInfo(d.shape,"int32",x)]}const JDe={kernelName:nG,backendName:"webgl",kernelFunc:qDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function YDe(t){const{inputs:e,backend:n,attrs:r}=t,{skipEmpty:i}=r,{input:s,delimiter:o}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(s.shape.length!==1)throw new Error(`Input must be a vector, got shape: ${s.shape}`);if(o.shape.length!==0)throw new Error(`Delimiter must be a scalar, got shape: ${o.shape}`);const a=n.readSync(s.dataId),l=n.readSync(o.dataId)[0],[c,u,d]=ETe(a,l,i),f=u.length;return[n.makeTensorInfo([f,2],"int32",c),n.makeTensorInfo([f],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(d))]}const QDe={kernelName:rG,backendName:"webgl",kernelFunc:YDe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function ZDe(t){const{inputs:e,backend:n,attrs:r}=t,{numBuckets:i}=r,{input:s}=e;if(s.dtype!=="string")throw new Error("Input must be of datatype string");if(i<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(s.dataId),a=ATe(o,i);return n.makeTensorInfo(s.shape,"int32",a)}const eOe={kernelName:iG,backendName:"webgl",kernelFunc:ZDe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const tOe="return tan(x);",nOe=qt({opSnippet:tOe}),rOe={kernelName:oG,backendName:"webgl",kernelFunc:nOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const iOe=`
  float e2x = exp(-2.0 * abs(x));
  return sign(x) * (1.0 - e2x) / (1.0 + e2x);
`,sOe=qt({opSnippet:iOe}),oOe={kernelName:aG,backendName:"webgl",kernelFunc:sOe};/**
 * @license
 * Copyright 2017 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class aOe{constructor(e,n){this.variableNames=["A"];const r=new Array(e.length);for(let o=0;o<r.length;o++)r[o]=e[o]*n[o];this.outputShape=r,this.rank=r.length;const i=An(this.rank),s=lOe(e);this.userCode=`
      void main() {
        ${i} resRC = getOutputCoords();
        setOutput(getA(${s}));
      }
    `}}function lOe(t){const e=t.length;if(e>5)throw Error(`Tile for rank ${e} is not yet supported`);if(e===1)return`imod(resRC, ${t[0]})`;const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],r=[];for(let i=0;i<t.length;i++)r.push(`imod(${n[i]}, ${t[i]})`);return r.join()}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function L7(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{reps:s}=r;if(i.dtype==="string"||i.shape.length>5){const l=n.readSync(i.dataId),c=i.dtype==="string"?l.map(f=>Qh(f)):l,u=Vn(i.shape,i.dtype,c),d=MTe(u,s);return n.makeTensorInfo(d.shape,d.dtype,d.values)}const o=new aOe(i.shape,s);return n.runWebGLProgram(o,[i],i.dtype)}const cOe={kernelName:pI,backendName:"webgl",kernelFunc:L7};class uOe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode=`
       void main() {
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // We compare elements pair-wise within a group of size 2 * inc.
         // The comparing rule for each group alternates between ascending
         // and descending. Within each group, we compare each pair at
         // positions i and i+inc. To decide whether an element at position i
         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than
         // inc, it is in the first half of the group, we denote it as x0,
         // otherwise we denote it as x1.
         // For example, as shown in the Bitonic top K paper referenced above,
         // Figure5(a) shows that element[1] is in the
         // second half of the group when group size is 2, but it is in the
         // first half of the group when group size is 4.

         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;
         int i = isFirstInPair ? elemIdx : elemIdx - inc;

         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));
         float x0 = i0 < n ? getX(batch, i0) : negativeInf;
         float x1 = i1 < n ? getX(batch, i1) : negativeInf;

         // Denotes which direction indices are in (ascending or descending).
         bool reverse = imod(elemIdx, 2 * dir) >= dir;
         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);
         if (reverse == isGreater) { // Elements in opposite order of direction
           int iTemp = i0;
           i0 = i1;
           i1 = iTemp;
         }
         if (isFirstInPair) {
            setOutput(float(i0));
         } else {
            setOutput(float(i1));
         }
       }
     `}}class dOe{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode=`
    void main() {
         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...
         ivec2 coords = getOutputCoords();
         int batch = coords[0];
         int elemIdx = coords[1];

         // The output size is half of the previous size.
         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),
         // we only need to output the indices at positions |, the indices at
         // positions _ can be thrown away, see Figure5(b) After Phase 2
         // (Merge phase) in the Bitonic Top K paper referenced above.
         // For example, the paper shows we only need to output the orange bars.
         // The output sequence should look like this | | | | | | | |.
         // Because the sequence is halved, to map the output index back
         // to the previous sequence to find the corresponding value,
         // we need to double the index. When we double the index,
         // we basically interpolate a position, so 2i looks like
         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position
         // of each 2k positions by - elemIdx % k. E.g. for output at
         // index 4,5,6,7, we want to get the corresponding element at
         // original index 8,9,10,11, for output at index 8,9,10,11,
         // we want to get the corresponding element at original index
         // 16,17,18,19, so on and so forth.

         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));
         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));
         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));

         float x0 = getX(batch, i0);
         float x1 = i1 < n ? getX(batch, i1) : x0;

         setOutput(x0 >= x1 ? float(i0) : float(i1));
       }
     `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function pu(t,e){e!==null&&t.disposeIntermediateTensorInfo(e)}function gB(t){let e=1;for(;e<t;)e*=2;return e}function fOe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i}=e,{k:s,sorted:o}=r,a=ge().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),l=ge().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),c=i.shape,u=c[c.length-1];if(n.shouldExecuteOnCPU([i])||u<a||s>l){const M=n.readSync(i.dataId),[P,B]=RTe(M,c,i.dtype,s,o);return[n.makeTensorInfo(P.shape,P.dtype,P.values),n.makeTensorInfo(B.shape,B.dtype,B.values)]}if(s===0)return c[c.length-1]=0,[n.makeTensorInfo(c,i.dtype,[]),n.makeTensorInfo(c,"int32",[])];if(u===1)return[i,j0({attrs:{shape:c,dtype:"int32",value:0},backend:n})];const d=n.texData.get(i.dataId),f=d!==null&&d.isPacked,h=f?n.unpackTensor(i):i,x=Ve(c)/u,v=qe({inputs:{x:h},attrs:{shape:[x,u]},backend:n});f&&pu(n,h);const y=gB(s),b=gB(u);let S=null;const w=()=>S===null?[v,v]:[v,S],E=(M,P,B)=>{const F=w(),U=new uOe(B),Z=[[u],[S===null?1:0],[Number.NEGATIVE_INFINITY],[M],[P]],ne=S;S=n.runWebGLProgram(U,F,"int32",Z),pu(n,ne)};for(let M=1;M<y;M*=2){const P=M*2;for(let B=M;B>=1;B/=2)E(P,B,[x,b])}for(let M=b;M>y;M/=2){const P=w(),B=new dOe([x,M/2]),U=[[u],[S===null?1:0],[y]],j=S;S=n.runWebGLProgram(B,P,"int32",U),pu(n,j);const Z=y/2,ne=Z*2;for(let O=Z;O>=1;O/=2)E(ne,O,S.shape)}let A=S;S=Pp({inputs:{x:S},backend:n,attrs:{begin:0,size:[x,s]}}),pu(n,A);let T=T7({inputs:{x:v,indices:S},backend:n,attrs:{axis:1,batchDims:1}});pu(n,v);const I=c.slice(0,-1);I.push(s),A=S,S=qe({inputs:{x:S},attrs:{shape:I},backend:n}),pu(n,A);const N=T;return T=qe({inputs:{x:T},attrs:{shape:I},backend:n}),pu(n,N),[T,S]}const hOe={kernelName:lG,backendName:"webgl",kernelFunc:fOe};/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class pOe{constructor(e,n,r,i,s,o){this.variableNames=["Image","Transforms"],this.outputShape=o;const a=r==="nearest"?1:2;let l;switch(i){case"constant":l=1;break;case"reflect":l=2;break;case"wrap":l=3;break;case"nearest":l=4;break;default:l=1;break}this.userCode=`
            float mapCoord(float outCoord, float len) {
              float inCoord = outCoord;
              if(${l} == 2) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    if (inCoord < sz2) {
                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +
                      inCoord;
                    }
                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz2 = 2.0 * len;
                    inCoord -= sz2 * float(int(float(inCoord / sz2)));
                    if (inCoord >= len) {
                      inCoord = sz2 - inCoord - 1.0;
                    }
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 3) {
                if (inCoord < 0.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);
                  }
                } else if (inCoord > len - 1.0) {
                  if (len <= 1.0) {
                    inCoord = 0.0;
                  } else {
                    float sz = len - 1.0;
                    inCoord -= len * float(int(float(inCoord / sz)));
                  }
                }
                return clamp(inCoord, 0.0, len - 1.0);
              } else if (${l} == 4) {
                return clamp(outCoord, 0.0, len - 1.0);
              } else {
                return outCoord;
              }
            }

            float readWithFillValue(int batch, int coordY, int coordX,
              int channel) {
              float outputValue;
              if (0 <= coordY && coordY < ${e} && 0 <= coordX && coordX < ${n}) {
                  outputValue = getImage(batch, coordY, coordX, channel);
              } else {
                outputValue = float(${s});
              }
              return outputValue;
            }

            void main() {
              ivec4 coords = getOutputCoords();
              float outputValue;
              int batch = coords[0];
              int x = coords[2];
              int y = coords[1];
              int channel = coords[3];
              float xf = float(x);
              float yf = float(y);
              float a1 = getTransforms(batch, 0);
              float a2 = getTransforms(batch, 1);
              float a3 = getTransforms(batch, 2);
              float b1 = getTransforms(batch, 3);
              float b2 = getTransforms(batch, 4);
              float b3 = getTransforms(batch, 5);
              float c1 = getTransforms(batch, 6);
              float c2 = getTransforms(batch, 7);
              float projection = c1 * xf + c2 * yf + 1.0;
              if (projection == 0.0) {
                outputValue = float(${s});
              } else {
                float inX = (a1 * xf + a2 * yf + a3) / projection;
                float inY = (b1 * xf + b2 * yf + b3) / projection;
                float mapX = mapCoord(inX, float(${n}));
                float mapY = mapCoord(inY, float(${e}));

                if (${a} == 1) {
                  int coordY = int(round(mapY));
                  int coordX = int(round(mapX));
                  outputValue = readWithFillValue(batch, coordY, coordX,
                    channel);
                } else {
                  float yFloor = floor(mapY);
                  float xFloor = floor(mapX);
                  float yCeil = yFloor + 1.0;
                  float xCeil = xFloor + 1.0;
                  float valueYFloor = (xCeil - mapX) *
                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);
                  float valueYCeil = (xCeil - mapX) *
                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +
                  (mapX - xFloor) *
                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);
                  outputValue = (yCeil - mapY) * valueYFloor +
                  (mapY - yFloor) * valueYCeil;
                }
              }
              setOutput(outputValue);
            }
        `}}/**
 * @license
 * Copyright 2021 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function mOe(t){const{inputs:e,backend:n,attrs:r}=t,{image:i,transforms:s}=e,{interpolation:o,fillMode:a,fillValue:l,outputShape:c}=r,[u,d,f,h]=i.shape,[p,x]=c??[d,f],v=[u,p,x,h],y=new pOe(d,f,o,a,l,v);return n.runWebGLProgram(y,[i,s],"float32")}const gOe={kernelName:cG,backendName:"webgl",kernelFunc:mOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the License);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function yOe(t){const{inputs:e,attrs:n,backend:r}=t,{axis:i}=n,{x:s}=e;z0(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=r.readSync(s.dataId),{outputValues:a,outputShape:l,indices:c}=ITe(o,i,s.shape,s.dtype);return[r.makeTensorInfo(l,s.dtype,a),r.makeTensorInfo([c.length],"int32",c)]}const vOe={kernelName:uG,backendName:"webgl",kernelFunc:yOe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function xOe(t){const{inputs:e,backend:n,attrs:r}=t,{value:i}=e;let{axis:s}=r;s<0&&(s+=i.shape.length);const o=i,a=o.shape.length,l=i.shape[s],c=new Array(a-1);let u=0;for(let x=0;x<a;x++)x!==s&&(c[u++]=o.shape[x]);const d=[],f=new Array(a).fill(0),h=o.shape.slice();h[s]=1;const p=new Array(l);for(let x=0;x<p.length;x++){f[s]=x;const v=Pp({inputs:{x:o},backend:n,attrs:{begin:f,size:h}}),y=qe({inputs:{x:v},backend:n,attrs:{shape:c}});p[x]=y,d.push(v)}return d.forEach(x=>n.disposeIntermediateTensorInfo(x)),p}const bOe={kernelName:dG,backendName:"webgl",kernelFunc:xOe};/**
 * @license
 * Copyright 2018 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */class SOe{constructor(e,n){this.variableNames=["x","segmentIds"];const r=e.windowSize,i=e.batchSize,s=e.inSize,o=e.numSegments,a=o*Math.ceil(s/r);this.outputShape=[i,a];const l="0.0",c="sumValue",u=Math.floor(r/4)*4,d=r%4,f=`
        sumValue += dot(values, segFilter);
    `;let h="";s%r>0&&(h=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return initializationValue;
        }
      `);let p="";s%r>0&&(p=`
        if (inIdx < 0 || inIdx >= ${s}) {
          return -1.0;
        }
      `),this.userCode=`
      const float initializationValue = ${l};

      float getValue(int batch, int inIdx) {
        ${h}
        return getX(batch, inIdx);
      }

      float getSegmentIdAtIndex(int inIdx) {
        ${p}
        return getSegmentIds(inIdx);
      }

      void main() {
        ivec2 coords = getOutputCoords();
        int batch = coords[0];
        int outIdx = coords[1];
        int inOffset = int(floor(float(outIdx) / float(
          ${o})) * float(${r}));
        int currentSeg = int(mod(float(outIdx), float(${o})));

        float sumValue = 0.0;

        for (int i = 0; i < ${u}; i += 4) {
          int inIdx = inOffset + i;
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            getValue(batch, inIdx + 3)
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0
          );

          ${f}
        }

        int inIdx = inOffset + ${u};
        if (${d===1}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            initializationValue,
            initializationValue,
            initializationValue
          );

          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            0,
            0,
            0
          );

          ${f}
        } else if (${d===2}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            initializationValue,
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
              0,
              0
          );

          ${f}
        } else if (${d===3}) {
          vec4 values = vec4(
            getValue(batch, inIdx),
            getValue(batch, inIdx + 1),
            getValue(batch, inIdx + 2),
            initializationValue
          );

          vec4 segFilter = vec4(
            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,
            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,
            0
          );

          ${f}
        }
        setOutput(${c});
      }
    `}}/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */function _Oe(t){const{inputs:e,backend:n,attrs:r}=t,{x:i,segmentIds:s}=e,{numSegments:o}=r,a=i.shape.length,l=[];let c=0;const u=_o([c],a);let d=i;u!=null&&(d=bi({inputs:{x:i},backend:n,attrs:{perm:u}}),l.push(d),c=wo(1,a)[0]);const f=LV(d.shape,c,o),h=Ve([d.shape[c]]),p=qe({inputs:{x:d},backend:n,attrs:{shape:[-1,h]}});l.push(p);const x=gI(i.dtype),v=(w,E,A,T,I)=>{const N=w.shape[0],M=w.shape[1],P=OV(M,I),B={windowSize:P,inSize:M,batchSize:N,numSegments:I},F=new SOe(B,E),U=n.compileAndRun(F,[w,A],T);if(l.push(U),U.shape[1]===I)return U;const j=D7({backend:n,attrs:{start:0,stop:I,step:1,dtype:"float32"}}),Z=L7({inputs:{x:j},backend:n,attrs:{reps:[M/P]}});return l.push(j),l.push(Z),v(U,E,Z,T,I)},y=v(p,"unsortedSegmentSum",s,x,o),b=qe({inputs:{x:y},backend:n,attrs:{shape:f}});let S=b;if(u!=null){l.push(b);const w=NI(u);S=bi({inputs:{x:S},backend:n,attrs:{perm:w}})}return l.forEach(w=>n.disposeIntermediateTensorInfo(w)),S}const wOe={kernelName:fG,backendName:"webgl",kernelFunc:_Oe};/**
 * @license
 * Copyright 2020 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */const COe=[SMe,wMe,AMe,RMe,NMe,DMe,LMe,FMe,GMe,VMe,XMe,JMe,ZMe,rRe,oRe,lRe,uRe,pRe,gRe,vRe,_Re,RRe,NRe,kRe,$Re,zRe,WRe,iMe,KRe,ZRe,rIe,cIe,dIe,hIe,mIe,yIe,bIe,wIe,AIe,MIe,IIe,PIe,OIe,BIe,zIe,HIe,jIe,qIe,YIe,tNe,sNe,cNe,fNe,mNe,gNe,vNe,bNe,_Ne,CNe,ANe,INe,kNe,LNe,FNe,zNe,VNe,KNe,QNe,rMe,e3e,YRe,r3e,o3e,c3e,oMe,h3e,y3e,x3e,w3e,A3e,I3e,k3e,B3e,z3e,V3e,j3e,J3e,Q3e,ePe,iPe,oPe,lPe,uPe,fPe,gPe,bPe,CPe,PPe,cMe,LPe,$Pe,GPe,WPe,ORe,KPe,JPe,QPe,tke,ske,lMe,ake,cke,dke,fke,LRe,MPe,mke,xke,wke,dMe,Tke,Ike,Dke,Bke,zke,Hke,jke,qke,Yke,eDe,rDe,oDe,uDe,hDe,gDe,xDe,TRe,IPe,_De,CDe,ADe,MDe,IDe,PDe,DDe,LDe,FDe,zDe,HDe,WDe,KDe,JDe,QDe,eOe,RPe,vMe,rOe,oOe,cOe,hOe,gOe,xMe,vOe,bOe,wOe,qPe];for(const t of COe)ege(t);/**
    * @license
    * Copyright 2021 Google LLC. All Rights Reserved.
    * Licensed under the Apache License, Version 2.0 (the "License");
    * you may not use this file except in compliance with the License.
    * You may obtain a copy of the License at
    *
    * http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing, software
    * distributed under the License is distributed on an "AS IS" BASIS,
    * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    * See the License for the specific language governing permissions and
    * limitations under the License.
    * =============================================================================
    */var kT=function(){return(kT=Object.assign||function(t){for(var e,n=1,r=arguments.length;n<r;n++)for(var i in e=arguments[n])Object.prototype.hasOwnProperty.call(e,i)&&(t[i]=e[i]);return t}).apply(this,arguments)};function fl(t,e,n,r){return new(n||(n=Promise))(function(i,s){function o(c){try{l(r.next(c))}catch(u){s(u)}}function a(c){try{l(r.throw(c))}catch(u){s(u)}}function l(c){var u;c.done?i(c.value):(u=c.value,u instanceof n?u:new n(function(d){d(u)})).then(o,a)}l((r=r.apply(t,e||[])).next())})}function hl(t,e){var n,r,i,s,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function a(l){return function(c){return function(u){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(i=2&u[0]?r.return:u[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,u[1])).done)return i;switch(r=0,i&&(u=[2&u[0],i.value]),u[0]){case 0:case 1:i=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,r=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(i=o.trys,!((i=i.length>0&&i[i.length-1])||u[0]!==6&&u[0]!==2)){o=0;continue}if(u[0]===3&&(!i||u[1]>i[0]&&u[1]<i[3])){o.label=u[1];break}if(u[0]===6&&o.label<i[1]){o.label=i[1],i=u;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(u);break}i[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(t,o)}catch(d){u=[6,d],r=0}finally{n=i=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([l,c])}}}function Gf(t,e,n,r){return new(n||(n=Promise))(function(i,s){function o(c){try{l(r.next(c))}catch(u){s(u)}}function a(c){try{l(r.throw(c))}catch(u){s(u)}}function l(c){var u;c.done?i(c.value):(u=c.value,u instanceof n?u:new n(function(d){d(u)})).then(o,a)}l((r=r.apply(t,e||[])).next())})}function Hf(t,e){var n,r,i,s,o={label:0,sent:function(){if(1&i[0])throw i[1];return i[1]},trys:[],ops:[]};return s={next:a(0),throw:a(1),return:a(2)},typeof Symbol=="function"&&(s[Symbol.iterator]=function(){return this}),s;function a(l){return function(c){return function(u){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,r&&(i=2&u[0]?r.return:u[0]?r.throw||((i=r.return)&&i.call(r),0):r.next)&&!(i=i.call(r,u[1])).done)return i;switch(r=0,i&&(u=[2&u[0],i.value]),u[0]){case 0:case 1:i=u;break;case 4:return o.label++,{value:u[1],done:!1};case 5:o.label++,r=u[1],u=[0];continue;case 7:u=o.ops.pop(),o.trys.pop();continue;default:if(!(i=(i=o.trys).length>0&&i[i.length-1])&&(u[0]===6||u[0]===2)){o=0;continue}if(u[0]===3&&(!i||u[1]>i[0]&&u[1]<i[3])){o.label=u[1];break}if(u[0]===6&&o.label<i[1]){o.label=i[1],i=u;break}if(i&&o.label<i[2]){o.label=i[2],o.ops.push(u);break}i[2]&&o.ops.pop(),o.trys.pop();continue}u=e.call(t,o)}catch(d){u=[6,d],r=0}finally{n=i=0}if(5&u[0])throw u[1];return{value:u[0]?u[1]:void 0,done:!0}}([l,c])}}}var B7=function(t){return{startEndTensor:t,startPoint:Rt(t,[0,0],[-1,2]),endPoint:Rt(t,[0,2],[-1,2])}},EOe={strides:[8,16],anchors:[2,6]};function yB(t,e){var n,r,i;if(t.topLeft instanceof Mn&&t.bottomRight instanceof Mn){var s=qn(function(){return[pr([Rt(zt(e-1,t.topLeft),0,1),Rt(t.topLeft,1,1)]),pr([zt(e-1,Rt(t.bottomRight,0,1)),Rt(t.bottomRight,1,1)])]});n=s[0],r=s[1],t.landmarks!=null&&(i=qn(function(){var h=zt(zr([e-1,0]),t.landmarks),p=zr([1,-1]);return Et(h,p)}))}else{var o=t.topLeft,a=o[0],l=o[1],c=t.bottomRight,u=c[0],d=c[1];n=[e-1-a,l],r=[e-1-u,d],t.landmarks!=null&&(i=t.landmarks.map(function(h){return[e-1-h[0],h[1]]}))}var f={topLeft:n,bottomRight:r};return i!=null&&(f.landmarks=i),t.probability!=null&&(f.probability=t.probability instanceof Mn?t.probability.clone():t.probability),f}function vB(t,e){return qn(function(){var n;return n=t.hasOwnProperty("box")?t.box:t,Ra(function(r,i){var s=Et(r.startPoint,i),o=Et(r.endPoint,i),a=TI([s,o],1);return B7(a)}(n,e).startEndTensor)})}var AOe=function(){function t(e,n,r,i,s,o){this.blazeFaceModel=e,this.width=n,this.height=r,this.maxFaces=i,this.anchorsData=function(a,l,c){for(var u=[],d=0;d<c.strides.length;d++)for(var f=c.strides[d],h=Math.floor((l+f-1)/f),p=Math.floor((a+f-1)/f),x=c.anchors[d],v=0;v<h;v++)for(var y=f*(v+.5),b=0;b<p;b++)for(var S=f*(b+.5),w=0;w<x;w++)u.push([S,y]);return u}(n,r,EOe),this.anchors=dl(this.anchorsData),this.inputSizeData=[n,r],this.inputSize=zr([n,r]),this.iouThreshold=s,this.scoreThreshold=o}return t.prototype.getBoundingBoxes=function(e,n,r){return r===void 0&&(r=!0),Gf(this,void 0,void 0,function(){var i,s,o,a,l,c,u,d,f,h,p,x,v,y,b=this;return Hf(this,function(S){switch(S.label){case 0:return i=qn(function(){var w=Gu.resizeBilinear(e,[b.width,b.height]),E=Et(zt(ar(w,255),.5),2),A=b.blazeFaceModel.predict(E),T=Ra(A),I=function(M,P,B){var F=Rt(M,[0,1],[-1,2]),U=cr(F,P),j=Rt(M,[0,3],[-1,2]),Z=ar(j,B),ne=ar(U,B),O=ar(Z,2),G=zt(ne,O),q=cr(ne,O),se=Et(G,B),he=Et(q,B);return TI([se,he],1)}(T,b.anchors,b.inputSize),N=Rt(T,[0,0],[-1,1]);return[T,I,Ra(nd(N))]}),s=i[0],o=i[1],a=i[2],l=console.warn,console.warn=function(){},c=Gu.nonMaxSuppression(o,a,this.maxFaces,this.iouThreshold,this.scoreThreshold),console.warn=l,[4,c.array()];case 1:return u=S.sent(),c.dispose(),d=u.map(function(w){return Rt(o,[w,0],[1,-1])}),n?[3,3]:[4,Promise.all(d.map(function(w){return Gf(b,void 0,void 0,function(){var E;return Hf(this,function(A){switch(A.label){case 0:return[4,w.array()];case 1:return E=A.sent(),w.dispose(),[2,E]}})})}))];case 2:d=S.sent(),S.label=3;case 3:for(f=e.shape[1],h=e.shape[2],p=n?ar([h,f],this.inputSize):[h/this.inputSizeData[0],f/this.inputSizeData[1]],x=[],v=function(w){var E=d[w],A=qn(function(){var T=B7(E instanceof Mn?E:dl(E));if(!r)return T;var I,N=u[w];return I=n?Rt(b.anchors,[N,0],[1,2]):b.anchorsData[N],{box:T,landmarks:Pe(Ra(Rt(s,[N,5],[1,-1])),[6,-1]),probability:Rt(a,[N],[1]),anchor:I}});x.push(A)},y=0;y<d.length;y++)v(y);return o.dispose(),a.dispose(),s.dispose(),[2,{boxes:x,scaleFactor:p}]}})})},t.prototype.estimateFaces=function(e,n,r,i){return n===void 0&&(n=!1),r===void 0&&(r=!1),i===void 0&&(i=!0),Gf(this,void 0,void 0,function(){var s,o,a,l,c,u,d=this;return Hf(this,function(f){switch(f.label){case 0:return s=function(h){return h instanceof Mn?[h.shape[0],h.shape[1]]:[h.height,h.width]}(e),o=s[1],a=qn(function(){return e instanceof Mn||(e=ZG(e)),Qa(hr(e,"float32"),0)}),[4,this.getBoundingBoxes(a,n,i)];case 1:return l=f.sent(),c=l.boxes,u=l.scaleFactor,a.dispose(),n?[2,c.map(function(h){var p=vB(h,u),x={topLeft:Rt(p,[0],[2]),bottomRight:Rt(p,[2],[2])};if(i){var v=h,y=v.landmarks,b=v.probability,S=v.anchor,w=Et(cr(y,S),u);x.landmarks=w,x.probability=b}return r&&(x=yB(x,o)),x})]:[2,Promise.all(c.map(function(h){return Gf(d,void 0,void 0,function(){var p,x,v,y,b,S,w,E,A,T,I,N=this;return Hf(this,function(M){switch(M.label){case 0:return p=vB(h,u),i?[3,2]:[4,p.array()];case 1:return b=M.sent(),x={topLeft:b.slice(0,2),bottomRight:b.slice(2)},[3,4];case 2:return[4,Promise.all([h.landmarks,p,h.probability].map(function(P){return Gf(N,void 0,void 0,function(){return Hf(this,function(B){return[2,P.array()]})})}))];case 3:v=M.sent(),y=v[0],b=v[1],S=v[2],w=h.anchor,A=(E=u)[0],T=E[1],I=y.map(function(P){return[(P[0]+w[0])*A,(P[1]+w[1])*T]}),x={topLeft:b.slice(0,2),bottomRight:b.slice(2),landmarks:I,probability:S},function(P){P.startEndTensor.dispose(),P.startPoint.dispose(),P.endPoint.dispose()}(h.box),h.landmarks.dispose(),h.probability.dispose(),M.label=4;case 4:return p.dispose(),r&&(x=yB(x,o)),[2,x]}})})}))]}})})},t}();function TOe(t){var e=t===void 0?{}:t,n=e.maxFaces,r=n===void 0?10:n,i=e.inputWidth,s=i===void 0?128:i,o=e.inputHeight,a=o===void 0?128:o,l=e.iouThreshold,c=l===void 0?.3:l,u=e.scoreThreshold,d=u===void 0?.75:u,f=e.modelUrl;return Gf(this,void 0,void 0,function(){var h;return Hf(this,function(p){switch(p.label){case 0:return f==null?[3,2]:[4,tp(f)];case 1:return h=p.sent(),[3,4];case 2:return[4,tp("https://tfhub.dev/tensorflow/tfjs-model/blazeface/1/default/1",{fromTFHub:!0})];case 3:h=p.sent(),p.label=4;case 4:return[2,new AOe(h,s,a,r,c,d)]}})})}var pl={silhouette:[10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109],lipsUpperOuter:[61,185,40,39,37,0,267,269,270,409,291],lipsLowerOuter:[146,91,181,84,17,314,405,321,375,291],lipsUpperInner:[78,191,80,81,82,13,312,311,310,415,308],lipsLowerInner:[78,95,88,178,87,14,317,402,318,324,308],rightEyeUpper0:[246,161,160,159,158,157,173],rightEyeLower0:[33,7,163,144,145,153,154,155,133],rightEyeUpper1:[247,30,29,27,28,56,190],rightEyeLower1:[130,25,110,24,23,22,26,112,243],rightEyeUpper2:[113,225,224,223,222,221,189],rightEyeLower2:[226,31,228,229,230,231,232,233,244],rightEyeLower3:[143,111,117,118,119,120,121,128,245],rightEyebrowUpper:[156,70,63,105,66,107,55,193],rightEyebrowLower:[35,124,46,53,52,65],rightEyeIris:[473,474,475,476,477],leftEyeUpper0:[466,388,387,386,385,384,398],leftEyeLower0:[263,249,390,373,374,380,381,382,362],leftEyeUpper1:[467,260,259,257,258,286,414],leftEyeLower1:[359,255,339,254,253,252,256,341,463],leftEyeUpper2:[342,445,444,443,442,441,413],leftEyeLower2:[446,261,448,449,450,451,452,453,464],leftEyeLower3:[372,340,346,347,348,349,350,357,465],leftEyebrowUpper:[383,300,293,334,296,336,285,417],leftEyebrowLower:[265,353,276,283,282,295],leftEyeIris:[468,469,470,471,472],midwayBetweenEyes:[168],noseTip:[1],noseBottom:[2],noseRightCorner:[98],noseLeftCorner:[327],rightCheek:[205],leftCheek:[425]};function ob(t){return[Math.abs(t.endPoint[0]-t.startPoint[0]),Math.abs(t.endPoint[1]-t.startPoint[1])]}function ab(t){return[t.startPoint[0]+(t.endPoint[0]-t.startPoint[0])/2,t.startPoint[1]+(t.endPoint[1]-t.startPoint[1])/2]}function CE(t,e){e===void 0&&(e=1.5);var n=ab(t),r=ob(t),i=[e*r[0]/2,e*r[1]/2];return{startPoint:[n[0]-i[0],n[1]-i[1]],endPoint:[n[0]+i[0],n[1]+i[1]],landmarks:t.landmarks}}function EE(t){var e=ab(t),n=ob(t),r=Math.max.apply(Math,n)/2;return{startPoint:[e[0]-r,e[1]-r],endPoint:[e[0]+r,e[1]+r],landmarks:t.landmarks}}var MOe=[[1,0,0],[0,1,0],[0,0,1]];function ROe(t,e){var n,r=Math.PI/2-Math.atan2(-(e[1]-t[1]),e[0]-t[0]);return(n=r)-2*Math.PI*Math.floor((n+Math.PI)/(2*Math.PI))}function xB(t,e){return[[1,0,t],[0,1,e],[0,0,1]]}function Eu(t,e){for(var n=0,r=0;r<t.length;r++)n+=t[r]*e[r];return n}function IOe(t,e){for(var n=[],r=0;r<t.length;r++)n.push(t[r][e]);return n}function bB(t,e){for(var n=[],r=t.length,i=0;i<r;i++){n.push([]);for(var s=0;s<r;s++)n[i].push(Eu(t[i],IOe(e,s)))}return n}function SB(t,e){var n=Math.cos(t),r=Math.sin(t),i=[[n,-r,0],[r,n,0],[0,0,1]],s=bB(xB(e[0],e[1]),i);return bB(s,xB(-e[0],-e[1]))}var _B=[13,pl.midwayBetweenEyes[0]],wB=[3,2],AE=pl.leftEyeLower0,TE=[AE[0],AE[AE.length-1]],ME=pl.rightEyeLower0,RE=[ME[0],ME[ME.length-1]],CB=[{key:"EyeUpper0",indices:[9,10,11,12,13,14,15]},{key:"EyeUpper1",indices:[25,26,27,28,29,30,31]},{key:"EyeUpper2",indices:[41,42,43,44,45,46,47]},{key:"EyeLower0",indices:[0,1,2,3,4,5,6,7,8]},{key:"EyeLower1",indices:[16,17,18,19,20,21,22,23,24]},{key:"EyeLower2",indices:[32,33,34,35,36,37,38,39,40]},{key:"EyeLower3",indices:[54,55,56,57,58,59,60,61,62]},{key:"EyebrowUpper",indices:[63,64,65,66,67,68,69,70]},{key:"EyebrowLower",indices:[48,49,50,51,52,53]}];function _x(t,e,n,r){for(var i=0;i<CB.length;i++){var s=CB[i],o=s.key,a=s.indices,l=pl[""+n+o];if(r==null||r.includes(o))for(var c=0;c<a.length;c++){var u=a[c];t[l[c]]=[e[u][0],e[u][1],(e[u][2]+t[l[c]][2])/2]}}}var NOe=function(){function t(e,n,r,i,s,o,a){this.regionsOfInterest=[],this.runsWithoutFaceDetector=0,this.boundingBoxDetector=e,this.meshDetector=n,this.irisModel=a,this.meshWidth=r,this.meshHeight=i,this.maxContinuousChecks=s,this.maxFaces=o}return t.prototype.transformRawCoords=function(e,n,r,i){var s,o,a,l,c=this,u=ob({startPoint:n.startPoint,endPoint:n.endPoint}),d=[u[0]/this.meshWidth,u[1]/this.meshHeight],f=e.map(function(b){return[d[0]*(b[0]-c.meshWidth/2),d[1]*(b[1]-c.meshHeight/2),b[2]]}),h=SB(r,[0,0]),p=f.map(function(b){return function(S,w){return[Eu(S,w[0]),Eu(S,w[1])]}(b,h).concat([b[2]])}),x=(o=[[(s=i)[0][0],s[1][0]],[s[0][1],s[1][1]]],a=[s[0][2],s[1][2]],l=[-Eu(o[0],a),-Eu(o[1],a)],[o[0].concat(l[0]),o[1].concat(l[1]),[0,0,1]]),v=ab({startPoint:n.startPoint,endPoint:n.endPoint}).concat([1]),y=[Eu(v,x[0]),Eu(v,x[1])];return p.map(function(b){return[b[0]+y[0],b[1]+y[1],b[2]]})},t.prototype.getLeftToRightEyeDepthDifference=function(e){return e[TE[0]][2]-e[RE[0]][2]},t.prototype.getEyeBox=function(e,n,r,i,s){s===void 0&&(s=!1);var o=EE(CE(this.calculateLandmarksBoundingBox([e[r],e[i]]),2.3)),a=ob(o),l=Gu.cropAndResize(n,[[o.startPoint[1]/this.meshHeight,o.startPoint[0]/this.meshWidth,o.endPoint[1]/this.meshHeight,o.endPoint[0]/this.meshWidth]],[0],[64,64]);return s&&(l=Gu.flipLeftRight(l)),{box:o,boxSize:a,crop:l}},t.prototype.getEyeCoords=function(e,n,r,i){i===void 0&&(i=!1);for(var s=[],o=0;o<76;o++){var a=e[3*o],l=e[3*o+1],c=e[3*o+2];s.push([(i?1-a/64:a/64)*r[0]+n.startPoint[0],l/64*r[1]+n.startPoint[1],c])}return{rawCoords:s,iris:s.slice(71)}},t.prototype.getAdjustedIrisCoords=function(e,n,r){var i=e[pl[r+"EyeUpper0"][3]][2],s=e[pl[r+"EyeLower0"][4]][2],o=(i+s)/2;return n.map(function(a,l){var c=o;return l===2?c=i:l===4&&(c=s),[a[0],a[1],c]})},t.prototype.predict=function(e,n){return fl(this,void 0,void 0,function(){var r,i,s,o,a=this;return hl(this,function(l){switch(l.label){case 0:return this.shouldUpdateRegionsOfInterest()?[4,this.boundingBoxDetector.getBoundingBoxes(e,!1,!0)]:[3,2];case 1:return r=l.sent(),i=r.boxes,s=r.scaleFactor,i.length===0?(this.regionsOfInterest=[],[2,null]):(o=i.map(function(c){var u,d,f={startPoint:Ra(c.box.startPoint).arraySync(),endPoint:Ra(c.box.endPoint).arraySync()},h=EE(CE((d=s,{startPoint:[(u=f).startPoint[0]*d[0],u.startPoint[1]*d[1]],endPoint:[u.endPoint[0]*d[0],u.endPoint[1]*d[1]]})));return kT({},h,{landmarks:c.landmarks.arraySync()})}),i.forEach(function(c){c!=null&&c.startPoint!=null&&(c.startEndTensor.dispose(),c.startPoint.dispose(),c.endPoint.dispose())}),this.updateRegionsOfInterest(o),this.runsWithoutFaceDetector=0,[3,3]);case 2:this.runsWithoutFaceDetector++,l.label=3;case 3:return[2,qn(function(){return a.regionsOfInterest.map(function(c,u){var d,f=c.landmarks.length>=468,h=_B[0],p=_B[1];f===!1&&(h=wB[0],p=wB[1]),d=ROe(c.landmarks[h],c.landmarks[p]);var x=ab({startPoint:c.startPoint,endPoint:c.endPoint}),v=[x[0]/e.shape[2],x[1]/e.shape[1]],y=e,b=MOe;d!==0&&(y=Gu.rotateWithOffset(e,d,0,v),b=SB(-d,x));var S={startPoint:c.startPoint,endPoint:c.endPoint},w=ar(function(ce,Me,Ie){var Oe=Me.shape[1],V=Me.shape[2],$=[[ce.startPoint[1]/Oe,ce.startPoint[0]/V,ce.endPoint[1]/Oe,ce.endPoint[0]/V]];return Gu.cropAndResize(Me,$,[0],Ie,"bilinear",0)}(S,y,[a.meshHeight,a.meshWidth]),255),E=a.meshDetector.predict(w),A=E[1],T=E[2],I=Pe(T,[-1,3]).arraySync();if(n){var N=a.getEyeBox(I,w,TE[0],TE[1],!0),M=N.box,P=N.boxSize,B=N.crop,F=a.getEyeBox(I,w,RE[0],RE[1]),U=F.box,j=F.boxSize,Z=F.crop,ne=a.irisModel.predict(pr([B,Z])).dataSync(),O=ne.slice(0,228),G=a.getEyeCoords(O,M,P,!0),q=G.rawCoords,se=G.iris,he=ne.slice(228),ke=a.getEyeCoords(he,U,j),re=ke.rawCoords,pe=ke.iris,fe=a.getLeftToRightEyeDepthDifference(I);Math.abs(fe)<30?(_x(I,q,"left"),_x(I,re,"right")):fe<1?_x(I,q,"left",["EyeUpper0","EyeLower0"]):_x(I,re,"right",["EyeUpper0","EyeLower0"]);var Ee=a.getAdjustedIrisCoords(I,se,"left"),We=a.getAdjustedIrisCoords(I,pe,"right");I=I.concat(Ee).concat(We)}var je=a.transformRawCoords(I,c,d,b),Je=dl(je),te=CE(a.calculateLandmarksBoundingBox(je)),be=EE(te);return a.regionsOfInterest[u]=kT({},be,{landmarks:Je.arraySync()}),{coords:dl(I,[I.length,3]),scaledCoords:Je,box:te,flag:Ra(A)}})})]}})})},t.prototype.updateRegionsOfInterest=function(e){for(var n=0;n<e.length;n++){var r=e[n],i=this.regionsOfInterest[n],s=0;if(i&&i.startPoint){var o=r.startPoint,a=o[0],l=o[1],c=r.endPoint,u=c[0],d=c[1],f=i.startPoint,h=f[0],p=f[1],x=i.endPoint,v=x[0],y=x[1],b=Math.max(a,h),S=Math.max(l,p),w=(Math.min(u,v)-b)*(Math.min(d,y)-S);s=w/((u-a)*(d-l)+(v-h)*(y-l)-w)}s<.25&&(this.regionsOfInterest[n]=r)}this.regionsOfInterest=this.regionsOfInterest.slice(0,e.length)},t.prototype.clearRegionOfInterest=function(e){this.regionsOfInterest[e]!=null&&(this.regionsOfInterest=this.regionsOfInterest.slice(0,e).concat(this.regionsOfInterest.slice(e+1)))},t.prototype.shouldUpdateRegionsOfInterest=function(){var e=this.regionsOfInterest.length,n=e===0;return this.maxFaces===1||n?n:e!==this.maxFaces&&this.runsWithoutFaceDetector>=this.maxContinuousChecks},t.prototype.calculateLandmarksBoundingBox=function(e){var n=e.map(function(i){return i[0]}),r=e.map(function(i){return i[1]});return{startPoint:[Math.min.apply(Math,n),Math.min.apply(Math,r)],endPoint:[Math.max.apply(Math,n),Math.max.apply(Math,r)]}},t}(),POe=[[.499976992607117,.652534008026123],[.500025987625122,.547487020492554],[.499974012374878,.602371990680695],[.482113003730774,.471979022026062],[.500150978565216,.527155995368958],[.499909996986389,.498252987861633],[.499523013830185,.40106201171875],[.289712011814117,.380764007568359],[.499954998493195,.312398016452789],[.499987006187439,.269918978214264],[.500023007392883,.107050001621246],[.500023007392883,.666234016418457],[.5000159740448,.679224014282227],[.500023007392883,.692348003387451],[.499976992607117,.695277988910675],[.499976992607117,.70593398809433],[.499976992607117,.719385027885437],[.499976992607117,.737019002437592],[.499967992305756,.781370997428894],[.499816000461578,.562981009483337],[.473773002624512,.573909997940063],[.104906998574734,.254140973091125],[.365929991006851,.409575998783112],[.338757991790771,.41302502155304],[.311120003461838,.409460008144379],[.274657994508743,.389131009578705],[.393361985683441,.403706014156342],[.345234006643295,.344011008739471],[.370094001293182,.346076011657715],[.319321990013123,.347265005111694],[.297903001308441,.353591024875641],[.24779200553894,.410809993743896],[.396889001131058,.842755019664764],[.280097991228104,.375599980354309],[.106310002505779,.399955987930298],[.2099249958992,.391353011131287],[.355807989835739,.534406006336212],[.471751004457474,.65040397644043],[.474155008792877,.680191993713379],[.439785003662109,.657229006290436],[.414617002010345,.66654098033905],[.450374007225037,.680860996246338],[.428770989179611,.682690978050232],[.374971002340317,.727805018424988],[.486716985702515,.547628998756409],[.485300987958908,.527395009994507],[.257764995098114,.314490020275116],[.401223003864288,.455172002315521],[.429818987846375,.548614978790283],[.421351999044418,.533740997314453],[.276895999908447,.532056987285614],[.483370006084442,.499586999416351],[.33721199631691,.282882988452911],[.296391993761063,.293242990970612],[.169294998049736,.193813979625702],[.447580009698868,.302609980106354],[.392390012741089,.353887975215912],[.354490011930466,.696784019470215],[.067304998636246,.730105042457581],[.442739009857178,.572826027870178],[.457098007202148,.584792017936707],[.381974011659622,.694710969924927],[.392388999462128,.694203019142151],[.277076005935669,.271932005882263],[.422551989555359,.563233017921448],[.385919004678726,.281364023685455],[.383103013038635,.255840003490448],[.331431001424789,.119714021682739],[.229923993349075,.232002973556519],[.364500999450684,.189113974571228],[.229622006416321,.299540996551514],[.173287004232407,.278747975826263],[.472878992557526,.666198015213013],[.446828007698059,.668527007102966],[.422762006521225,.673889994621277],[.445307999849319,.580065965652466],[.388103008270264,.693961024284363],[.403039008378983,.706539988517761],[.403629004955292,.693953037261963],[.460041999816895,.557139039039612],[.431158006191254,.692366003990173],[.452181994915009,.692366003990173],[.475387006998062,.692366003990173],[.465828001499176,.779190003871918],[.472328990697861,.736225962638855],[.473087012767792,.717857003211975],[.473122000694275,.704625964164734],[.473033010959625,.695277988910675],[.427942007780075,.695277988910675],[.426479011774063,.703539967536926],[.423162013292313,.711845993995667],[.4183090031147,.720062971115112],[.390094995498657,.639572978019714],[.013953999616206,.560034036636353],[.499913990497589,.58014702796936],[.413199990987778,.69539999961853],[.409626007080078,.701822996139526],[.468080013990402,.601534962654114],[.422728985548019,.585985004901886],[.463079988956451,.593783974647522],[.37211999297142,.47341400384903],[.334562003612518,.496073007583618],[.411671012639999,.546965003013611],[.242175996303558,.14767599105835],[.290776997804642,.201445996761322],[.327338010072708,.256527006626129],[.399509996175766,.748921036720276],[.441727995872498,.261676013469696],[.429764986038208,.187834024429321],[.412198007106781,.108901023864746],[.288955003023148,.398952007293701],[.218936994671822,.435410976409912],[.41278201341629,.398970007896423],[.257135003805161,.355440020561218],[.427684992551804,.437960982322693],[.448339998722076,.536936044692993],[.178560003638268,.45755398273468],[.247308000922203,.457193970680237],[.286267012357712,.467674970626831],[.332827985286713,.460712015628815],[.368755996227264,.447206974029541],[.398963987827301,.432654976844788],[.476410001516342,.405806005001068],[.189241006970406,.523923993110657],[.228962004184723,.348950982093811],[.490725994110107,.562400996685028],[.404670000076294,.485132992267609],[.019469000399113,.401564002037048],[.426243007183075,.420431017875671],[.396993011236191,.548797011375427],[.266469985246658,.376977026462555],[.439121007919312,.51895797252655],[.032313998788595,.644356966018677],[.419054001569748,.387154996395111],[.462783008813858,.505746960639954],[.238978996872902,.779744982719421],[.198220998048782,.831938028335571],[.107550002634525,.540755033493042],[.183610007166862,.740257024765015],[.134409993886948,.333683013916016],[.385764002799988,.883153975009918],[.490967005491257,.579378008842468],[.382384985685349,.508572995662689],[.174399003386497,.397670984268188],[.318785011768341,.39623498916626],[.343364000320435,.400596976280212],[.396100014448166,.710216999053955],[.187885001301765,.588537991046906],[.430987000465393,.944064974784851],[.318993002176285,.898285031318665],[.266247987747192,.869701027870178],[.500023007392883,.190576016902924],[.499976992607117,.954452991485596],[.366169989109039,.398822009563446],[.393207013607025,.39553701877594],[.410373002290726,.391080021858215],[.194993004202843,.342101991176605],[.388664990663528,.362284004688263],[.365961998701096,.355970978736877],[.343364000320435,.355356991291046],[.318785011768341,.35834002494812],[.301414996385574,.363156020641327],[.058132998645306,.319076001644135],[.301414996385574,.387449026107788],[.499987989664078,.618434011936188],[.415838003158569,.624195992946625],[.445681989192963,.566076993942261],[.465844005346298,.620640993118286],[.49992299079895,.351523995399475],[.288718998432159,.819945991039276],[.335278987884521,.852819979190826],[.440512001514435,.902418971061707],[.128294005990028,.791940987110138],[.408771991729736,.373893976211548],[.455606997013092,.451801002025604],[.499877005815506,.908990025520325],[.375436991453171,.924192011356354],[.11421000212431,.615022003650665],[.448662012815475,.695277988910675],[.4480200111866,.704632043838501],[.447111994028091,.715808033943176],[.444831997156143,.730794012546539],[.430011987686157,.766808986663818],[.406787008047104,.685672998428345],[.400738000869751,.681069016456604],[.392399996519089,.677703022956848],[.367855995893478,.663918972015381],[.247923001646996,.601333022117615],[.452769994735718,.420849978923798],[.43639200925827,.359887003898621],[.416164010763168,.368713974952698],[.413385987281799,.692366003990173],[.228018000721931,.683571994304657],[.468268007040024,.352671027183533],[.411361992359161,.804327011108398],[.499989002943039,.469825029373169],[.479153990745544,.442654013633728],[.499974012374878,.439637005329132],[.432112008333206,.493588984012604],[.499886006116867,.866917014122009],[.49991300702095,.821729004383087],[.456548988819122,.819200992584229],[.344549000263214,.745438992977142],[.37890899181366,.574010014533997],[.374292999505997,.780184984207153],[.319687992334366,.570737957954407],[.357154995203018,.604269981384277],[.295284003019333,.621580958366394],[.447750002145767,.862477004528046],[.410986006259918,.508723020553589],[.31395098567009,.775308012962341],[.354128003120422,.812552988529205],[.324548006057739,.703992962837219],[.189096003770828,.646299958229065],[.279776990413666,.71465802192688],[.1338230073452,.682700991630554],[.336768001317978,.644733011722565],[.429883986711502,.466521978378296],[.455527991056442,.548622965812683],[.437114000320435,.558896005153656],[.467287987470627,.529924988746643],[.414712011814117,.335219979286194],[.37704598903656,.322777986526489],[.344107985496521,.320150971412659],[.312875986099243,.32233202457428],[.283526003360748,.333190023899078],[.241245999932289,.382785975933075],[.102986000478268,.468762993812561],[.267612010240555,.424560010433197],[.297879010438919,.433175981044769],[.333433985710144,.433878004550934],[.366427004337311,.426115989685059],[.396012008190155,.416696012020111],[.420121014118195,.41022801399231],[.007561000064015,.480777025222778],[.432949006557465,.569517970085144],[.458638995885849,.479089021682739],[.473466008901596,.545744001865387],[.476087987422943,.563830018043518],[.468472003936768,.555056989192963],[.433990985155106,.582361996173859],[.483518004417419,.562983989715576],[.482482999563217,.57784903049469],[.42645001411438,.389798998832703],[.438998997211456,.39649498462677],[.450067013502121,.400434017181396],[.289712011814117,.368252992630005],[.276670008897781,.363372981548309],[.517862021923065,.471948027610779],[.710287988185883,.380764007568359],[.526226997375488,.573909997940063],[.895093023777008,.254140973091125],[.634069979190826,.409575998783112],[.661242008209229,.41302502155304],[.688880026340485,.409460008144379],[.725341975688934,.389131009578705],[.606630027294159,.40370500087738],[.654766023159027,.344011008739471],[.629905998706818,.346076011657715],[.680678009986877,.347265005111694],[.702096998691559,.353591024875641],[.75221198797226,.410804986953735],[.602918028831482,.842862963676453],[.719901978969574,.375599980354309],[.893692970275879,.399959981441498],[.790081977844238,.391354024410248],[.643998026847839,.534487962722778],[.528249025344849,.65040397644043],[.525849997997284,.680191040039062],[.560214996337891,.657229006290436],[.585384011268616,.66654098033905],[.549625992774963,.680860996246338],[.57122802734375,.682691991329193],[.624852001667023,.72809898853302],[.513050019741058,.547281980514526],[.51509702205658,.527251958847046],[.742246985435486,.314507007598877],[.598631024360657,.454979002475739],[.570338010787964,.548575043678284],[.578631997108459,.533622980117798],[.723087012767792,.532054007053375],[.516445994377136,.499638974666595],[.662801027297974,.282917976379395],[.70362401008606,.293271005153656],[.830704987049103,.193813979625702],[.552385985851288,.302568018436432],[.607609987258911,.353887975215912],[.645429015159607,.696707010269165],[.932694971561432,.730105042457581],[.557260990142822,.572826027870178],[.542901992797852,.584792017936707],[.6180260181427,.694710969924927],[.607590973377228,.694203019142151],[.722943007946014,.271963000297546],[.577413976192474,.563166975975037],[.614082992076874,.281386971473694],[.616907000541687,.255886018276215],[.668509006500244,.119913995265961],[.770092010498047,.232020974159241],[.635536015033722,.189248979091644],[.77039098739624,.299556016921997],[.826722025871277,.278755009174347],[.527121007442474,.666198015213013],[.553171992301941,.668527007102966],[.577238023281097,.673889994621277],[.554691970348358,.580065965652466],[.611896991729736,.693961024284363],[.59696102142334,.706539988517761],[.596370995044708,.693953037261963],[.539958000183105,.557139039039612],[.568841993808746,.692366003990173],[.547818005084991,.692366003990173],[.52461302280426,.692366003990173],[.534089982509613,.779141008853912],[.527670979499817,.736225962638855],[.526912987232208,.717857003211975],[.526877999305725,.704625964164734],[.526966989040375,.695277988910675],[.572058022022247,.695277988910675],[.573521018028259,.703539967536926],[.57683801651001,.711845993995667],[.581691026687622,.720062971115112],[.609944999217987,.639909982681274],[.986046016216278,.560034036636353],[.5867999792099,.69539999961853],[.590372025966644,.701822996139526],[.531915009021759,.601536989212036],[.577268004417419,.585934996604919],[.536915004253387,.593786001205444],[.627542972564697,.473352015018463],[.665585994720459,.495950996875763],[.588353991508484,.546862006187439],[.757824003696442,.14767599105835],[.709249973297119,.201507985591888],[.672684013843536,.256581008434296],[.600408971309662,.74900496006012],[.55826598405838,.261672019958496],[.570303976535797,.187870979309082],[.588165998458862,.109044015407562],[.711045026779175,.398952007293701],[.781069993972778,.435405015945435],[.587247014045715,.398931980133057],[.742869973182678,.355445981025696],[.572156012058258,.437651991844177],[.55186802148819,.536570012569427],[.821442008018494,.457556009292603],[.752701997756958,.457181990146637],[.71375697851181,.467626988887787],[.66711300611496,.460672974586487],[.631101012229919,.447153985500336],[.6008620262146,.432473003864288],[.523481011390686,.405627012252808],[.810747981071472,.523926019668579],[.771045982837677,.348959028720856],[.509127020835876,.562718033790588],[.595292985439301,.485023975372314],[.980530977249146,.401564002037048],[.573499977588654,.420000016689301],[.602994978427887,.548687994480133],[.733529984951019,.376977026462555],[.560611009597778,.519016981124878],[.967685997486115,.644356966018677],[.580985009670258,.387160003185272],[.537728011608124,.505385041236877],[.760966002941132,.779752969741821],[.801778972148895,.831938028335571],[.892440974712372,.54076099395752],[.816350996494293,.740260004997253],[.865594983100891,.333687007427216],[.614073991775513,.883246004581451],[.508952975273132,.579437971115112],[.617941975593567,.508316040039062],[.825608015060425,.397674977779388],[.681214988231659,.39623498916626],[.656635999679565,.400596976280212],[.603900015354156,.710216999053955],[.81208598613739,.588539004325867],[.56801301240921,.944564998149872],[.681007981300354,.898285031318665],[.733752012252808,.869701027870178],[.633830010890961,.398822009563446],[.606792986392975,.39553701877594],[.589659988880157,.391062021255493],[.805015981197357,.342108011245728],[.611334979534149,.362284004688263],[.634037971496582,.355970978736877],[.656635999679565,.355356991291046],[.681214988231659,.35834002494812],[.698584973812103,.363156020641327],[.941866993904114,.319076001644135],[.698584973812103,.387449026107788],[.584177017211914,.624107003211975],[.554318010807037,.566076993942261],[.534153997898102,.62064003944397],[.711217999458313,.819975018501282],[.664629995822906,.852871000766754],[.559099972248077,.902631998062134],[.871706008911133,.791940987110138],[.591234028339386,.373893976211548],[.544341027736664,.451583981513977],[.624562978744507,.924192011356354],[.88577002286911,.615028977394104],[.551338016986847,.695277988910675],[.551980018615723,.704632043838501],[.552887976169586,.715808033943176],[.555167973041534,.730794012546539],[.569944024085999,.767035007476807],[.593203008174896,.685675978660583],[.599261999130249,.681069016456604],[.607599973678589,.677703022956848],[.631937980651855,.663500010967255],[.752032995223999,.601315021514893],[.547226011753082,.420395016670227],[.563543975353241,.359827995300293],[.583841025829315,.368713974952698],[.586614012718201,.692366003990173],[.771915018558502,.683578014373779],[.531597018241882,.352482974529266],[.588370978832245,.804440975189209],[.52079701423645,.442565023899078],[.567984998226166,.493479013442993],[.543282985687256,.819254994392395],[.655317008495331,.745514988899231],[.621008992195129,.574018001556396],[.625559985637665,.78031200170517],[.680198013782501,.570719003677368],[.64276397228241,.604337990283966],[.704662978649139,.621529996395111],[.552012026309967,.862591981887817],[.589071989059448,.508637011051178],[.685944974422455,.775357007980347],[.645735025405884,.812640011310577],[.675342977046967,.703978002071381],[.810858011245728,.646304965019226],[.72012197971344,.714666962623596],[.866151988506317,.682704985141754],[.663187026977539,.644596993923187],[.570082008838654,.466325998306274],[.544561982154846,.548375964164734],[.562758982181549,.558784961700439],[.531987011432648,.530140042304993],[.585271000862122,.335177004337311],[.622952997684479,.32277899980545],[.655896008014679,.320163011550903],[.687132000923157,.322345972061157],[.716481983661652,.333200991153717],[.758756995201111,.382786989212036],[.897013008594513,.468769013881683],[.732392013072968,.424547016620636],[.70211398601532,.433162987232208],[.66652500629425,.433866024017334],[.633504986763,.426087975502014],[.603875994682312,.416586995124817],[.579657971858978,.409945011138916],[.992439985275269,.480777025222778],[.567192018032074,.569419980049133],[.54136598110199,.478899002075195],[.526564002037048,.546118021011353],[.523913025856018,.563830018043518],[.531529009342194,.555056989192963],[.566035985946655,.582329034805298],[.51631098985672,.563053965568542],[.5174720287323,.577877044677734],[.573594987392426,.389806985855103],[.560697972774506,.395331978797913],[.549755990505219,.399751007556915],[.710287988185883,.368252992630005],[.723330020904541,.363372981548309]];function kOe(t){return fl(this,void 0,void 0,function(){var e,n,r,i,s,o,a,l,c,u,d,f,h,p,x,v;return hl(this,function(y){switch(y.label){case 0:return e=t.maxContinuousChecks,n=e===void 0?5:e,r=t.detectionConfidence,i=r===void 0?.9:r,s=t.maxFaces,o=s===void 0?10:s,a=t.iouThreshold,l=a===void 0?.3:a,c=t.scoreThreshold,u=c===void 0?.75:c,d=t.shouldLoadIrisModel,f=d===void 0||d,h=t.modelUrl,p=t.detectorModelUrl,x=t.irisModelUrl,f?[4,Promise.all([EB(p,o,l,u),AB(h),DOe(x)])]:[3,2];case 1:return v=y.sent(),[3,4];case 2:return[4,Promise.all([EB(p,o,l,u),AB(h)])];case 3:v=y.sent(),y.label=4;case 4:return[2,new OOe(v[0],v[1],n,i,o,f?v[2]:null)]}})})}function EB(t,e,n,r){return fl(this,void 0,void 0,function(){return hl(this,function(i){return[2,TOe({modelUrl:t,maxFaces:e,iouThreshold:n,scoreThreshold:r})]})})}function AB(t){return fl(this,void 0,void 0,function(){return hl(this,function(e){return t!=null?[2,tp(t)]:[2,tp("https://tfhub.dev/mediapipe/tfjs-model/facemesh/1/default/1",{fromTFHub:!0})]})})}function DOe(t){return fl(this,void 0,void 0,function(){return hl(this,function(e){return t!=null?[2,tp(t)]:[2,tp("https://tfhub.dev/mediapipe/tfjs-model/iris/1/default/2",{fromTFHub:!0})]})})}function TB(t,e){if(t.mesh instanceof Mn){var n=qn(function(){var a=zr([e-1,0,0]),l=zr([1,-1,1]);return qn(function(){return[pr([zt(e-1,Rt(t.boundingBox.topLeft,0,1)),Rt(t.boundingBox.topLeft,1,1)]),pr([zt(e-1,Rt(t.boundingBox.bottomRight,0,1)),Rt(t.boundingBox.bottomRight,1,1)]),Et(zt(a,t.mesh),l),Et(zt(a,t.scaledMesh),l)]})}),r=n[0],i=n[1],s=n[2],o=n[3];return Object.assign({},t,{boundingBox:{topLeft:r,bottomRight:i},mesh:s,scaledMesh:o})}return Object.assign({},t,{boundingBox:{topLeft:[e-1-t.boundingBox.topLeft[0],t.boundingBox.topLeft[1]],bottomRight:[e-1-t.boundingBox.bottomRight[0],t.boundingBox.bottomRight[1]]},mesh:t.mesh.map(function(a){var l=a.slice(0);return l[0]=e-1-a[0],l}),scaledMesh:t.scaledMesh.map(function(a){var l=a.slice(0);return l[0]=e-1-a[0],l})})}var l0,OOe=function(){function t(e,n,r,i,s,o){this.kind="MediaPipeFaceMesh",this.pipeline=new NOe(e,n,192,192,r,s,o),this.detectionConfidence=i}return t.getAnnotations=function(){return pl},t.getUVCoords=function(){return POe},t.prototype.estimateFaces=function(e){return fl(this,void 0,void 0,function(){var n,r,i,s,o,a,l,c,u,d,f,h,p=this;return hl(this,function(x){switch(x.label){case 0:if(n=e.returnTensors,r=n!==void 0&&n,i=e.flipHorizontal,s=i!==void 0&&i,o=e.predictIrises,a=o===void 0||o,l=e.input,a&&this.pipeline.irisModel==null)throw new Error("The iris model was not loaded as part of facemesh. Please initialize the model with facemesh.load({shouldLoadIrisModel: true}).");return c=function(v){return v instanceof Mn?[v.shape[0],v.shape[1]]:[v.height,v.width]}(l),u=c[1],d=qn(function(){return l instanceof Mn||(l=ZG(l)),Qa(hr(l,"float32"),0)}),M0e()!=="webgl"?[3,2]:(h=ge().get("WEBGL_PACK_DEPTHWISECONV"),ge().set("WEBGL_PACK_DEPTHWISECONV",!0),[4,this.pipeline.predict(d,a)]);case 1:return f=x.sent(),ge().set("WEBGL_PACK_DEPTHWISECONV",h),[3,4];case 2:return[4,this.pipeline.predict(d,a)];case 3:f=x.sent(),x.label=4;case 4:return d.dispose(),f!=null&&f.length>0?[2,Promise.all(f.map(function(v,y){return fl(p,void 0,void 0,function(){var b,S,w,E,A,T,I,N,M,P,B,F,U,j,Z=this;return hl(this,function(ne){switch(ne.label){case 0:return b=v.coords,S=v.scaledCoords,w=v.box,E=v.flag,A=[E],r||(A=A.concat([b,S])),[4,Promise.all(A.map(function(O){return fl(Z,void 0,void 0,function(){return hl(this,function(G){return[2,O.array()]})})}))];case 1:if(T=ne.sent(),I=T[0],E.dispose(),I<this.detectionConfidence&&this.pipeline.clearRegionOfInterest(y),r)return N={kind:"MediaPipePredictionTensors",faceInViewConfidence:I,mesh:b,scaledMesh:S,boundingBox:{topLeft:zr(w.startPoint),bottomRight:zr(w.endPoint)}},s?[2,TB(N,u)]:[2,N];for(j in M=T.slice(1),P=M[0],B=M[1],S.dispose(),b.dispose(),F={kind:"MediaPipePredictionValues",faceInViewConfidence:I,boundingBox:{topLeft:w.startPoint,bottomRight:w.endPoint},mesh:P,scaledMesh:B},s&&(F=TB(F,u)),U={},pl)(a||j.includes("Iris")===!1)&&(U[j]=pl[j].map(function(O){return F.scaledMesh[O]}));return F.annotations=U,[2,F]}})})}))]:[2,[]]}})})},t}();function LOe(t,e){return t===void 0&&(t=l0.mediapipeFacemesh),e===void 0&&(e={}),fl(this,void 0,void 0,function(){return hl(this,function(n){if(t===l0.mediapipeFacemesh)return[2,kOe(e)];throw new Error(t+" is not a valid package name.")})})}(function(t){t.mediapipeFacemesh="mediapipe-facemesh"})(l0||(l0={}));const BOe=()=>{const[t,e]=L.useState({width:void 0,height:void 0});return L.useEffect(()=>{const n=()=>{e({width:window.innerWidth,height:window.innerHeight})};return window.addEventListener("resize",n),n(),()=>window.removeEventListener("resize",n)},[]),t},FOe="800px",$Oe="800px",ha={GLASSES:"glasses",DESK:"desk",GUITAR:"guitar",HEADPHONES:"headphones"},UOe=t=>{const{image:e}=t,n=new URL(e,import.meta.url).href,r=L.useRef(null),i=L.useRef(null),[s,o]=L.useState(null),[a,l]=L.useState(null),[c,u]=L.useState(!0),d=BOe(),h=d.height<=d.width?d.width/d.height:d.height/d.width,x=window.innerWidth<768||screen.width<768?{width:d.width,height:d.height}:{width:$Oe,height:FOe};return L.useEffect(()=>{(async()=>{try{const y=await navigator.mediaDevices.getUserMedia({video:!0});r.current&&(r.current.srcObject=y),await T0e("webgl");const b=await LOe(l0.mediapipeFacemesh,{shouldLoadIrisModel:!0,maxFaces:1});o(b);const S=i.current.clientWidth,w=i.current.clientHeight,E=new Wg,A=new Hn(75,S/w,.1,1e3);A.position.z=5;const T=new LR({canvas:i.current,alpha:!0});T.setSize(S,w),T.setAnimationLoop(()=>T.render(E,A)),new QR().load(n,N=>{N.colorSpace=xs;const M=new kd(2,1),P=new Qi({map:N,transparent:!0}),B=new lr(M,P);E.add(B),l(B)})}catch(y){console.error("Initialization error:",y),u(!1)}})()},[n]),L.useEffect(()=>{const v=async()=>{if(!r.current||!s||!a)return;const{video:b}=r.current;if(b.readyState!==4)return;const S=await s.estimateFaces({input:b});if(S.length>0){u(!1);const w=S[0].scaledMesh,E=w[130],A=w[359],T=w[168],N=Math.sqrt((A[0]-E[0])**2+(A[1]-E[1])**2)/140,M=-.01,P=-.01,B=0,F=-.01;a.position.x=(T[0]-b.videoWidth/2)*M+B,a.position.y=(T[1]-b.videoHeight/2)*P+F,a.scale.set(N,N,N),a.position.z=1;const U=new Re(A[0]-E[0],A[1]-E[1]),j=Math.atan2(U.y,U.x);a.rotation.z=j}},y=setInterval(()=>{v()},120);return()=>clearInterval(y)},[s,a]),H.jsxs("div",{style:{position:"relative",margin:"0 auto"},children:[c&&H.jsx("div",{style:{position:"absolute",top:0,left:0,width:"100%",height:"100%",backgroundColor:"rgba(255, 255, 255, 0.5)",display:"flex",justifyContent:"center",alignItems:"center",zIndex:2},children:H.jsx("h3",{children:"Loading..."})}),H.jsx(Lae,{ref:r,autoPlay:!0,playsInline:!0,mirrored:!0,videoConstraints:{facingMode:"user",aspectRatio:h},style:{...x}}),H.jsx("canvas",{ref:i,style:{position:"absolute",top:0,left:0,...x}})]})};var F7={exports:{}},Hd={};/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */Hd.ConcurrentRoot=1;Hd.ContinuousEventPriority=4;Hd.DefaultEventPriority=16;Hd.DiscreteEventPriority=1;Hd.IdleEventPriority=536870912;Hd.LegacyRoot=0;F7.exports=Hd;var uh=F7.exports;function zOe(t){let e;const n=new Set,r=(c,u)=>{const d=typeof c=="function"?c(e):c;if(d!==e){const f=e;e=u?d:Object.assign({},e,d),n.forEach(h=>h(e,f))}},i=()=>e,s=(c,u=i,d=Object.is)=>{console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");let f=u(e);function h(){const p=u(e);if(!d(f,p)){const x=f;c(f=p,x)}}return n.add(h),()=>n.delete(h)},l={setState:r,getState:i,subscribe:(c,u,d)=>u||d?s(c,u,d):(n.add(c),()=>n.delete(c)),destroy:()=>n.clear()};return e=t(r,i,l),l}const GOe=typeof window>"u"||!window.navigator||/ServerSideRendering|^Deno\//.test(window.navigator.userAgent),MB=GOe?L.useEffect:L.useLayoutEffect;function oN(t){const e=typeof t=="function"?zOe(t):t,n=(r=e.getState,i=Object.is)=>{const[,s]=L.useReducer(v=>v+1,0),o=e.getState(),a=L.useRef(o),l=L.useRef(r),c=L.useRef(i),u=L.useRef(!1),d=L.useRef();d.current===void 0&&(d.current=r(o));let f,h=!1;(a.current!==o||l.current!==r||c.current!==i||u.current)&&(f=r(o),h=!i(d.current,f)),MB(()=>{h&&(d.current=f),a.current=o,l.current=r,c.current=i,u.current=!1});const p=L.useRef(o);MB(()=>{const v=()=>{try{const b=e.getState(),S=l.current(b);c.current(d.current,S)||(a.current=b,d.current=S,s())}catch{u.current=!0,s()}},y=e.subscribe(v);return e.getState()!==p.current&&v(),y},[]);const x=h?f:d.current;return L.useDebugValue(x),x};return Object.assign(n,e),n[Symbol.iterator]=function(){console.warn("[useStore, api] = create() is deprecated and will be removed in v4");const r=[n,e];return{next(){const i=r.length<=0;return{value:r.shift(),done:i}}}},n}var $7={exports:{}},IE={exports:{}},NE={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var RB;function HOe(){return RB||(RB=1,function(t){function e(O,G){var q=O.length;O.push(G);e:for(;0<q;){var se=q-1>>>1,he=O[se];if(0<i(he,G))O[se]=G,O[q]=he,q=se;else break e}}function n(O){return O.length===0?null:O[0]}function r(O){if(O.length===0)return null;var G=O[0],q=O.pop();if(q!==G){O[0]=q;e:for(var se=0,he=O.length,ke=he>>>1;se<ke;){var re=2*(se+1)-1,pe=O[re],fe=re+1,Ee=O[fe];if(0>i(pe,q))fe<he&&0>i(Ee,pe)?(O[se]=Ee,O[fe]=q,se=fe):(O[se]=pe,O[re]=q,se=re);else if(fe<he&&0>i(Ee,q))O[se]=Ee,O[fe]=q,se=fe;else break e}}return G}function i(O,G){var q=O.sortIndex-G.sortIndex;return q!==0?q:O.id-G.id}if(typeof performance=="object"&&typeof performance.now=="function"){var s=performance;t.unstable_now=function(){return s.now()}}else{var o=Date,a=o.now();t.unstable_now=function(){return o.now()-a}}var l=[],c=[],u=1,d=null,f=3,h=!1,p=!1,x=!1,v=typeof setTimeout=="function"?setTimeout:null,y=typeof clearTimeout=="function"?clearTimeout:null,b=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function S(O){for(var G=n(c);G!==null;){if(G.callback===null)r(c);else if(G.startTime<=O)r(c),G.sortIndex=G.expirationTime,e(l,G);else break;G=n(c)}}function w(O){if(x=!1,S(O),!p)if(n(l)!==null)p=!0,Z(E);else{var G=n(c);G!==null&&ne(w,G.startTime-O)}}function E(O,G){p=!1,x&&(x=!1,y(I),I=-1),h=!0;var q=f;try{for(S(G),d=n(l);d!==null&&(!(d.expirationTime>G)||O&&!P());){var se=d.callback;if(typeof se=="function"){d.callback=null,f=d.priorityLevel;var he=se(d.expirationTime<=G);G=t.unstable_now(),typeof he=="function"?d.callback=he:d===n(l)&&r(l),S(G)}else r(l);d=n(l)}if(d!==null)var ke=!0;else{var re=n(c);re!==null&&ne(w,re.startTime-G),ke=!1}return ke}finally{d=null,f=q,h=!1}}var A=!1,T=null,I=-1,N=5,M=-1;function P(){return!(t.unstable_now()-M<N)}function B(){if(T!==null){var O=t.unstable_now();M=O;var G=!0;try{G=T(!0,O)}finally{G?F():(A=!1,T=null)}}else A=!1}var F;if(typeof b=="function")F=function(){b(B)};else if(typeof MessageChannel<"u"){var U=new MessageChannel,j=U.port2;U.port1.onmessage=B,F=function(){j.postMessage(null)}}else F=function(){v(B,0)};function Z(O){T=O,A||(A=!0,F())}function ne(O,G){I=v(function(){O(t.unstable_now())},G)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(O){O.callback=null},t.unstable_continueExecution=function(){p||h||(p=!0,Z(E))},t.unstable_forceFrameRate=function(O){0>O||125<O?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):N=0<O?Math.floor(1e3/O):5},t.unstable_getCurrentPriorityLevel=function(){return f},t.unstable_getFirstCallbackNode=function(){return n(l)},t.unstable_next=function(O){switch(f){case 1:case 2:case 3:var G=3;break;default:G=f}var q=f;f=G;try{return O()}finally{f=q}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(O,G){switch(O){case 1:case 2:case 3:case 4:case 5:break;default:O=3}var q=f;f=O;try{return G()}finally{f=q}},t.unstable_scheduleCallback=function(O,G,q){var se=t.unstable_now();switch(typeof q=="object"&&q!==null?(q=q.delay,q=typeof q=="number"&&0<q?se+q:se):q=se,O){case 1:var he=-1;break;case 2:he=250;break;case 5:he=1073741823;break;case 4:he=1e4;break;default:he=5e3}return he=q+he,O={id:u++,callback:G,priorityLevel:O,startTime:q,expirationTime:he,sortIndex:-1},q>se?(O.sortIndex=q,e(c,O),n(l)===null&&O===n(c)&&(x?(y(I),I=-1):x=!0,ne(w,q-se))):(O.sortIndex=he,e(l,O),p||h||(p=!0,Z(E))),O},t.unstable_shouldYield=P,t.unstable_wrapCallback=function(O){var G=f;return function(){var q=f;f=G;try{return O.apply(this,arguments)}finally{f=q}}}}(NE)),NE}var IB;function VOe(){return IB||(IB=1,IE.exports=HOe()),IE.exports}/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var WOe=function(e){var n={},r=L,i=VOe(),s=Object.assign;function o(m){for(var g="https://reactjs.org/docs/error-decoder.html?invariant="+m,_=1;_<arguments.length;_++)g+="&args[]="+encodeURIComponent(arguments[_]);return"Minified React error #"+m+"; visit "+g+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var a=r.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,l=Symbol.for("react.element"),c=Symbol.for("react.portal"),u=Symbol.for("react.fragment"),d=Symbol.for("react.strict_mode"),f=Symbol.for("react.profiler"),h=Symbol.for("react.provider"),p=Symbol.for("react.context"),x=Symbol.for("react.forward_ref"),v=Symbol.for("react.suspense"),y=Symbol.for("react.suspense_list"),b=Symbol.for("react.memo"),S=Symbol.for("react.lazy"),w=Symbol.for("react.offscreen"),E=Symbol.iterator;function A(m){return m===null||typeof m!="object"?null:(m=E&&m[E]||m["@@iterator"],typeof m=="function"?m:null)}function T(m){if(m==null)return null;if(typeof m=="function")return m.displayName||m.name||null;if(typeof m=="string")return m;switch(m){case u:return"Fragment";case c:return"Portal";case f:return"Profiler";case d:return"StrictMode";case v:return"Suspense";case y:return"SuspenseList"}if(typeof m=="object")switch(m.$$typeof){case p:return(m.displayName||"Context")+".Consumer";case h:return(m._context.displayName||"Context")+".Provider";case x:var g=m.render;return m=m.displayName,m||(m=g.displayName||g.name||"",m=m!==""?"ForwardRef("+m+")":"ForwardRef"),m;case b:return g=m.displayName||null,g!==null?g:T(m.type)||"Memo";case S:g=m._payload,m=m._init;try{return T(m(g))}catch{}}return null}function I(m){var g=m.type;switch(m.tag){case 24:return"Cache";case 9:return(g.displayName||"Context")+".Consumer";case 10:return(g._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return m=g.render,m=m.displayName||m.name||"",g.displayName||(m!==""?"ForwardRef("+m+")":"ForwardRef");case 7:return"Fragment";case 5:return g;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return T(g);case 8:return g===d?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof g=="function")return g.displayName||g.name||null;if(typeof g=="string")return g}return null}function N(m){var g=m,_=m;if(m.alternate)for(;g.return;)g=g.return;else{m=g;do g=m,g.flags&4098&&(_=g.return),m=g.return;while(m)}return g.tag===3?_:null}function M(m){if(N(m)!==m)throw Error(o(188))}function P(m){var g=m.alternate;if(!g){if(g=N(m),g===null)throw Error(o(188));return g!==m?null:m}for(var _=m,C=g;;){var R=_.return;if(R===null)break;var D=R.alternate;if(D===null){if(C=R.return,C!==null){_=C;continue}break}if(R.child===D.child){for(D=R.child;D;){if(D===_)return M(R),m;if(D===C)return M(R),g;D=D.sibling}throw Error(o(188))}if(_.return!==C.return)_=R,C=D;else{for(var Q=!1,ae=R.child;ae;){if(ae===_){Q=!0,_=R,C=D;break}if(ae===C){Q=!0,C=R,_=D;break}ae=ae.sibling}if(!Q){for(ae=D.child;ae;){if(ae===_){Q=!0,_=D,C=R;break}if(ae===C){Q=!0,C=D,_=R;break}ae=ae.sibling}if(!Q)throw Error(o(189))}}if(_.alternate!==C)throw Error(o(190))}if(_.tag!==3)throw Error(o(188));return _.stateNode.current===_?m:g}function B(m){return m=P(m),m!==null?F(m):null}function F(m){if(m.tag===5||m.tag===6)return m;for(m=m.child;m!==null;){var g=F(m);if(g!==null)return g;m=m.sibling}return null}function U(m){if(m.tag===5||m.tag===6)return m;for(m=m.child;m!==null;){if(m.tag!==4){var g=U(m);if(g!==null)return g}m=m.sibling}return null}var j=Array.isArray,Z=e.getPublicInstance,ne=e.getRootHostContext,O=e.getChildHostContext,G=e.prepareForCommit,q=e.resetAfterCommit,se=e.createInstance,he=e.appendInitialChild,ke=e.finalizeInitialChildren,re=e.prepareUpdate,pe=e.shouldSetTextContent,fe=e.createTextInstance,Ee=e.scheduleTimeout,We=e.cancelTimeout,je=e.noTimeout,Je=e.isPrimaryRenderer,te=e.supportsMutation,be=e.supportsPersistence,ce=e.supportsHydration,Me=e.getInstanceFromNode,Ie=e.preparePortalMount,Oe=e.getCurrentEventPriority,V=e.detachDeletedInstance,$=e.supportsMicrotasks,ue=e.scheduleMicrotask,ye=e.supportsTestSelectors,ve=e.findFiberRoot,Ne=e.getBoundingRect,nt=e.getTextContent,Ae=e.isHiddenSubtree,st=e.matchAccessibilityRole,ht=e.setFocusIfFocusable,Ue=e.setupIntersectionObserver,Fe=e.appendChild,$e=e.appendChildToContainer,Ze=e.commitTextUpdate,ot=e.commitMount,Pt=e.commitUpdate,Ge=e.insertBefore,yt=e.insertInContainerBefore,_t=e.removeChild,ie=e.removeChildFromContainer,_e=e.resetTextContent,J=e.hideInstance,De=e.hideTextInstance,Be=e.unhideInstance,ut=e.unhideTextInstance,pt=e.clearContainer,mn=e.cloneInstance,hn=e.createContainerChildSet,jt=e.appendChildToContainerChildSet,_n=e.finalizeContainerChildren,Jt=e.replaceContainerChildren,Cr=e.cloneHiddenInstance,Er=e.cloneHiddenTextInstance,zi=e.canHydrateInstance,q0=e.canHydrateTextInstance,J0=e.canHydrateSuspenseInstance,Y0=e.isSuspenseInstancePending,Pl=e.isSuspenseInstanceFallback,Q0=e.registerSuspenseInstanceRetry,na=e.getNextHydratableSibling,Z0=e.getFirstHydratableChild,ey=e.getFirstHydratableChildWithinContainer,b_=e.getFirstHydratableChildWithinSuspenseInstance,S_=e.hydrateInstance,__=e.hydrateTextInstance,W=e.hydrateSuspenseInstance,de=e.getNextHydratableInstanceAfterSuspenseInstance,Se=e.commitHydratedContainer,we=e.commitHydratedSuspenseInstance,xe=e.clearSuspenseBoundary,tt=e.clearSuspenseBoundaryFromContainer,xt=e.shouldDeleteUnhydratedTailInstances,Ct=e.didNotMatchHydratedContainerTextInstance,Tt=e.didNotMatchHydratedTextInstance,It;function At(m){if(It===void 0)try{throw Error()}catch(_){var g=_.stack.trim().match(/\n( *(at )?)/);It=g&&g[1]||""}return`
`+It+m}var Nt=!1;function kn(m,g){if(!m||Nt)return"";Nt=!0;var _=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(g)if(g=function(){throw Error()},Object.defineProperty(g.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(g,[])}catch(He){var C=He}Reflect.construct(m,[],g)}else{try{g.call()}catch(He){C=He}m.call(g.prototype)}else{try{throw Error()}catch(He){C=He}m()}}catch(He){if(He&&C&&typeof He.stack=="string"){for(var R=He.stack.split(`
`),D=C.stack.split(`
`),Q=R.length-1,ae=D.length-1;1<=Q&&0<=ae&&R[Q]!==D[ae];)ae--;for(;1<=Q&&0<=ae;Q--,ae--)if(R[Q]!==D[ae]){if(Q!==1||ae!==1)do if(Q--,ae--,0>ae||R[Q]!==D[ae]){var Te=`
`+R[Q].replace(" at new "," at ");return m.displayName&&Te.includes("<anonymous>")&&(Te=Te.replace("<anonymous>",m.displayName)),Te}while(1<=Q&&0<=ae);break}}}finally{Nt=!1,Error.prepareStackTrace=_}return(m=m?m.displayName||m.name:"")?At(m):""}var Ei=Object.prototype.hasOwnProperty,Zn=[],ni=-1;function rn(m){return{current:m}}function at(m){0>ni||(m.current=Zn[ni],Zn[ni]=null,ni--)}function pn(m,g){ni++,Zn[ni]=m.current,m.current=g}var tn={},Fn=rn(tn),Kr=rn(!1),cs=tn;function ra(m,g){var _=m.type.contextTypes;if(!_)return tn;var C=m.stateNode;if(C&&C.__reactInternalMemoizedUnmaskedChildContext===g)return C.__reactInternalMemoizedMaskedChildContext;var R={},D;for(D in _)R[D]=g[D];return C&&(m=m.stateNode,m.__reactInternalMemoizedUnmaskedChildContext=g,m.__reactInternalMemoizedMaskedChildContext=R),R}function cn(m){return m=m.childContextTypes,m!=null}function us(){at(Kr),at(Fn)}function Vd(m,g,_){if(Fn.current!==tn)throw Error(o(168));pn(Fn,g),pn(Kr,_)}function Ai(m,g,_){var C=m.stateNode;if(g=g.childContextTypes,typeof C.getChildContext!="function")return _;C=C.getChildContext();for(var R in C)if(!(R in g))throw Error(o(108,I(m)||"Unknown",R));return s({},_,C)}function kl(m){return m=(m=m.stateNode)&&m.__reactInternalMemoizedMergedChildContext||tn,cs=Fn.current,pn(Fn,m),pn(Kr,Kr.current),!0}function ty(m,g,_){var C=m.stateNode;if(!C)throw Error(o(169));_?(m=Ai(m,g,cs),C.__reactInternalMemoizedMergedChildContext=m,at(Kr),at(Fn),pn(Fn,m)):at(Kr),pn(Kr,_)}var Gi=Math.clz32?Math.clz32:yW,mW=Math.log,gW=Math.LN2;function yW(m){return m>>>=0,m===0?32:31-(mW(m)/gW|0)|0}var ny=64,ry=4194304;function kp(m){switch(m&-m){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return m&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return m&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return m}}function iy(m,g){var _=m.pendingLanes;if(_===0)return 0;var C=0,R=m.suspendedLanes,D=m.pingedLanes,Q=_&268435455;if(Q!==0){var ae=Q&~R;ae!==0?C=kp(ae):(D&=Q,D!==0&&(C=kp(D)))}else Q=_&~R,Q!==0?C=kp(Q):D!==0&&(C=kp(D));if(C===0)return 0;if(g!==0&&g!==C&&!(g&R)&&(R=C&-C,D=g&-g,R>=D||R===16&&(D&4194240)!==0))return g;if(C&4&&(C|=_&16),g=m.entangledLanes,g!==0)for(m=m.entanglements,g&=C;0<g;)_=31-Gi(g),R=1<<_,C|=m[_],g&=~R;return C}function vW(m,g){switch(m){case 1:case 2:case 4:return g+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return g+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function xW(m,g){for(var _=m.suspendedLanes,C=m.pingedLanes,R=m.expirationTimes,D=m.pendingLanes;0<D;){var Q=31-Gi(D),ae=1<<Q,Te=R[Q];Te===-1?(!(ae&_)||ae&C)&&(R[Q]=vW(ae,g)):Te<=g&&(m.expiredLanes|=ae),D&=~ae}}function w_(m){return m=m.pendingLanes&-1073741825,m!==0?m:m&1073741824?1073741824:0}function C_(m){for(var g=[],_=0;31>_;_++)g.push(m);return g}function Dp(m,g,_){m.pendingLanes|=g,g!==536870912&&(m.suspendedLanes=0,m.pingedLanes=0),m=m.eventTimes,g=31-Gi(g),m[g]=_}function bW(m,g){var _=m.pendingLanes&~g;m.pendingLanes=g,m.suspendedLanes=0,m.pingedLanes=0,m.expiredLanes&=g,m.mutableReadLanes&=g,m.entangledLanes&=g,g=m.entanglements;var C=m.eventTimes;for(m=m.expirationTimes;0<_;){var R=31-Gi(_),D=1<<R;g[R]=0,C[R]=-1,m[R]=-1,_&=~D}}function E_(m,g){var _=m.entangledLanes|=g;for(m=m.entanglements;_;){var C=31-Gi(_),R=1<<C;R&g|m[C]&g&&(m[C]|=g),_&=~R}}var sn=0;function uN(m){return m&=-m,1<m?4<m?m&268435455?16:536870912:4:1}var A_=i.unstable_scheduleCallback,dN=i.unstable_cancelCallback,SW=i.unstable_shouldYield,_W=i.unstable_requestPaint,Or=i.unstable_now,T_=i.unstable_ImmediatePriority,wW=i.unstable_UserBlockingPriority,M_=i.unstable_NormalPriority,CW=i.unstable_IdlePriority,sy=null,ia=null;function EW(m){if(ia&&typeof ia.onCommitFiberRoot=="function")try{ia.onCommitFiberRoot(sy,m,void 0,(m.current.flags&128)===128)}catch{}}function AW(m,g){return m===g&&(m!==0||1/m===1/g)||m!==m&&g!==g}var sa=typeof Object.is=="function"?Object.is:AW,La=null,oy=!1,R_=!1;function fN(m){La===null?La=[m]:La.push(m)}function TW(m){oy=!0,fN(m)}function oa(){if(!R_&&La!==null){R_=!0;var m=0,g=sn;try{var _=La;for(sn=1;m<_.length;m++){var C=_[m];do C=C(!0);while(C!==null)}La=null,oy=!1}catch(R){throw La!==null&&(La=La.slice(m+1)),A_(T_,oa),R}finally{sn=g,R_=!1}}return null}var MW=a.ReactCurrentBatchConfig;function ay(m,g){if(sa(m,g))return!0;if(typeof m!="object"||m===null||typeof g!="object"||g===null)return!1;var _=Object.keys(m),C=Object.keys(g);if(_.length!==C.length)return!1;for(C=0;C<_.length;C++){var R=_[C];if(!Ei.call(g,R)||!sa(m[R],g[R]))return!1}return!0}function RW(m){switch(m.tag){case 5:return At(m.type);case 16:return At("Lazy");case 13:return At("Suspense");case 19:return At("SuspenseList");case 0:case 2:case 15:return m=kn(m.type,!1),m;case 11:return m=kn(m.type.render,!1),m;case 1:return m=kn(m.type,!0),m;default:return""}}function Eo(m,g){if(m&&m.defaultProps){g=s({},g),m=m.defaultProps;for(var _ in m)g[_]===void 0&&(g[_]=m[_]);return g}return g}var ly=rn(null),cy=null,Wd=null,I_=null;function N_(){I_=Wd=cy=null}function hN(m,g,_){Je?(pn(ly,g._currentValue),g._currentValue=_):(pn(ly,g._currentValue2),g._currentValue2=_)}function P_(m){var g=ly.current;at(ly),Je?m._currentValue=g:m._currentValue2=g}function k_(m,g,_){for(;m!==null;){var C=m.alternate;if((m.childLanes&g)!==g?(m.childLanes|=g,C!==null&&(C.childLanes|=g)):C!==null&&(C.childLanes&g)!==g&&(C.childLanes|=g),m===_)break;m=m.return}}function jd(m,g){cy=m,I_=Wd=null,m=m.dependencies,m!==null&&m.firstContext!==null&&(m.lanes&g&&(hs=!0),m.firstContext=null)}function Us(m){var g=Je?m._currentValue:m._currentValue2;if(I_!==m)if(m={context:m,memoizedValue:g,next:null},Wd===null){if(cy===null)throw Error(o(308));Wd=m,cy.dependencies={lanes:0,firstContext:m}}else Wd=Wd.next=m;return g}var aa=null,Dl=!1;function D_(m){m.updateQueue={baseState:m.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function pN(m,g){m=m.updateQueue,g.updateQueue===m&&(g.updateQueue={baseState:m.baseState,firstBaseUpdate:m.firstBaseUpdate,lastBaseUpdate:m.lastBaseUpdate,shared:m.shared,effects:m.effects})}function Ba(m,g){return{eventTime:m,lane:g,tag:0,payload:null,callback:null,next:null}}function Ol(m,g){var _=m.updateQueue;_!==null&&(_=_.shared,yr!==null&&m.mode&1&&!(Wt&2)?(m=_.interleaved,m===null?(g.next=g,aa===null?aa=[_]:aa.push(_)):(g.next=m.next,m.next=g),_.interleaved=g):(m=_.pending,m===null?g.next=g:(g.next=m.next,m.next=g),_.pending=g))}function uy(m,g,_){if(g=g.updateQueue,g!==null&&(g=g.shared,(_&4194240)!==0)){var C=g.lanes;C&=m.pendingLanes,_|=C,g.lanes=_,E_(m,_)}}function mN(m,g){var _=m.updateQueue,C=m.alternate;if(C!==null&&(C=C.updateQueue,_===C)){var R=null,D=null;if(_=_.firstBaseUpdate,_!==null){do{var Q={eventTime:_.eventTime,lane:_.lane,tag:_.tag,payload:_.payload,callback:_.callback,next:null};D===null?R=D=Q:D=D.next=Q,_=_.next}while(_!==null);D===null?R=D=g:D=D.next=g}else R=D=g;_={baseState:C.baseState,firstBaseUpdate:R,lastBaseUpdate:D,shared:C.shared,effects:C.effects},m.updateQueue=_;return}m=_.lastBaseUpdate,m===null?_.firstBaseUpdate=g:m.next=g,_.lastBaseUpdate=g}function dy(m,g,_,C){var R=m.updateQueue;Dl=!1;var D=R.firstBaseUpdate,Q=R.lastBaseUpdate,ae=R.shared.pending;if(ae!==null){R.shared.pending=null;var Te=ae,He=Te.next;Te.next=null,Q===null?D=He:Q.next=He,Q=Te;var dt=m.alternate;dt!==null&&(dt=dt.updateQueue,ae=dt.lastBaseUpdate,ae!==Q&&(ae===null?dt.firstBaseUpdate=He:ae.next=He,dt.lastBaseUpdate=Te))}if(D!==null){var Dt=R.baseState;Q=0,dt=He=Te=null,ae=D;do{var wt=ae.lane,Cn=ae.eventTime;if((C&wt)===wt){dt!==null&&(dt=dt.next={eventTime:Cn,lane:0,tag:ae.tag,payload:ae.payload,callback:ae.callback,next:null});e:{var bt=m,oi=ae;switch(wt=g,Cn=_,oi.tag){case 1:if(bt=oi.payload,typeof bt=="function"){Dt=bt.call(Cn,Dt,wt);break e}Dt=bt;break e;case 3:bt.flags=bt.flags&-65537|128;case 0:if(bt=oi.payload,wt=typeof bt=="function"?bt.call(Cn,Dt,wt):bt,wt==null)break e;Dt=s({},Dt,wt);break e;case 2:Dl=!0}}ae.callback!==null&&ae.lane!==0&&(m.flags|=64,wt=R.effects,wt===null?R.effects=[ae]:wt.push(ae))}else Cn={eventTime:Cn,lane:wt,tag:ae.tag,payload:ae.payload,callback:ae.callback,next:null},dt===null?(He=dt=Cn,Te=Dt):dt=dt.next=Cn,Q|=wt;if(ae=ae.next,ae===null){if(ae=R.shared.pending,ae===null)break;wt=ae,ae=wt.next,wt.next=null,R.lastBaseUpdate=wt,R.shared.pending=null}}while(!0);if(dt===null&&(Te=Dt),R.baseState=Te,R.firstBaseUpdate=He,R.lastBaseUpdate=dt,g=R.shared.interleaved,g!==null){R=g;do Q|=R.lane,R=R.next;while(R!==g)}else D===null&&(R.shared.lanes=0);tf|=Q,m.lanes=Q,m.memoizedState=Dt}}function gN(m,g,_){if(m=g.effects,g.effects=null,m!==null)for(g=0;g<m.length;g++){var C=m[g],R=C.callback;if(R!==null){if(C.callback=null,C=_,typeof R!="function")throw Error(o(191,R));R.call(C)}}}var yN=new r.Component().refs;function O_(m,g,_,C){g=m.memoizedState,_=_(C,g),_=_==null?g:s({},g,_),m.memoizedState=_,m.lanes===0&&(m.updateQueue.baseState=_)}var fy={isMounted:function(m){return(m=m._reactInternals)?N(m)===m:!1},enqueueSetState:function(m,g,_){m=m._reactInternals;var C=Mi(),R=Fl(m),D=Ba(C,R);D.payload=g,_!=null&&(D.callback=_),Ol(m,D),g=Ws(m,R,C),g!==null&&uy(g,m,R)},enqueueReplaceState:function(m,g,_){m=m._reactInternals;var C=Mi(),R=Fl(m),D=Ba(C,R);D.tag=1,D.payload=g,_!=null&&(D.callback=_),Ol(m,D),g=Ws(m,R,C),g!==null&&uy(g,m,R)},enqueueForceUpdate:function(m,g){m=m._reactInternals;var _=Mi(),C=Fl(m),R=Ba(_,C);R.tag=2,g!=null&&(R.callback=g),Ol(m,R),g=Ws(m,C,_),g!==null&&uy(g,m,C)}};function vN(m,g,_,C,R,D,Q){return m=m.stateNode,typeof m.shouldComponentUpdate=="function"?m.shouldComponentUpdate(C,D,Q):g.prototype&&g.prototype.isPureReactComponent?!ay(_,C)||!ay(R,D):!0}function xN(m,g,_){var C=!1,R=tn,D=g.contextType;return typeof D=="object"&&D!==null?D=Us(D):(R=cn(g)?cs:Fn.current,C=g.contextTypes,D=(C=C!=null)?ra(m,R):tn),g=new g(_,D),m.memoizedState=g.state!==null&&g.state!==void 0?g.state:null,g.updater=fy,m.stateNode=g,g._reactInternals=m,C&&(m=m.stateNode,m.__reactInternalMemoizedUnmaskedChildContext=R,m.__reactInternalMemoizedMaskedChildContext=D),g}function bN(m,g,_,C){m=g.state,typeof g.componentWillReceiveProps=="function"&&g.componentWillReceiveProps(_,C),typeof g.UNSAFE_componentWillReceiveProps=="function"&&g.UNSAFE_componentWillReceiveProps(_,C),g.state!==m&&fy.enqueueReplaceState(g,g.state,null)}function L_(m,g,_,C){var R=m.stateNode;R.props=_,R.state=m.memoizedState,R.refs=yN,D_(m);var D=g.contextType;typeof D=="object"&&D!==null?R.context=Us(D):(D=cn(g)?cs:Fn.current,R.context=ra(m,D)),R.state=m.memoizedState,D=g.getDerivedStateFromProps,typeof D=="function"&&(O_(m,g,D,_),R.state=m.memoizedState),typeof g.getDerivedStateFromProps=="function"||typeof R.getSnapshotBeforeUpdate=="function"||typeof R.UNSAFE_componentWillMount!="function"&&typeof R.componentWillMount!="function"||(g=R.state,typeof R.componentWillMount=="function"&&R.componentWillMount(),typeof R.UNSAFE_componentWillMount=="function"&&R.UNSAFE_componentWillMount(),g!==R.state&&fy.enqueueReplaceState(R,R.state,null),dy(m,_,R,C),R.state=m.memoizedState),typeof R.componentDidMount=="function"&&(m.flags|=4194308)}var Xd=[],Kd=0,hy=null,py=0,zs=[],Gs=0,Wc=null,Fa=1,$a="";function jc(m,g){Xd[Kd++]=py,Xd[Kd++]=hy,hy=m,py=g}function SN(m,g,_){zs[Gs++]=Fa,zs[Gs++]=$a,zs[Gs++]=Wc,Wc=m;var C=Fa;m=$a;var R=32-Gi(C)-1;C&=~(1<<R),_+=1;var D=32-Gi(g)+R;if(30<D){var Q=R-R%5;D=(C&(1<<Q)-1).toString(32),C>>=Q,R-=Q,Fa=1<<32-Gi(g)+R|_<<R|C,$a=D+m}else Fa=1<<D|_<<R|C,$a=m}function B_(m){m.return!==null&&(jc(m,1),SN(m,1,0))}function F_(m){for(;m===hy;)hy=Xd[--Kd],Xd[Kd]=null,py=Xd[--Kd],Xd[Kd]=null;for(;m===Wc;)Wc=zs[--Gs],zs[Gs]=null,$a=zs[--Gs],zs[Gs]=null,Fa=zs[--Gs],zs[Gs]=null}var ds=null,fs=null,$n=!1,Op=!1,Ao=null;function _N(m,g){var _=js(5,null,null,0);_.elementType="DELETED",_.stateNode=g,_.return=m,g=m.deletions,g===null?(m.deletions=[_],m.flags|=16):g.push(_)}function wN(m,g){switch(m.tag){case 5:return g=zi(g,m.type,m.pendingProps),g!==null?(m.stateNode=g,ds=m,fs=Z0(g),!0):!1;case 6:return g=q0(g,m.pendingProps),g!==null?(m.stateNode=g,ds=m,fs=null,!0):!1;case 13:if(g=J0(g),g!==null){var _=Wc!==null?{id:Fa,overflow:$a}:null;return m.memoizedState={dehydrated:g,treeContext:_,retryLane:1073741824},_=js(18,null,null,0),_.stateNode=g,_.return=m,m.child=_,ds=m,fs=null,!0}return!1;default:return!1}}function $_(m){return(m.mode&1)!==0&&(m.flags&128)===0}function U_(m){if($n){var g=fs;if(g){var _=g;if(!wN(m,g)){if($_(m))throw Error(o(418));g=na(_);var C=ds;g&&wN(m,g)?_N(C,_):(m.flags=m.flags&-4097|2,$n=!1,ds=m)}}else{if($_(m))throw Error(o(418));m.flags=m.flags&-4097|2,$n=!1,ds=m}}}function CN(m){for(m=m.return;m!==null&&m.tag!==5&&m.tag!==3&&m.tag!==13;)m=m.return;ds=m}function Lp(m){if(!ce||m!==ds)return!1;if(!$n)return CN(m),$n=!0,!1;if(m.tag!==3&&(m.tag!==5||xt(m.type)&&!pe(m.type,m.memoizedProps))){var g=fs;if(g){if($_(m)){for(m=fs;m;)m=na(m);throw Error(o(418))}for(;g;)_N(m,g),g=na(g)}}if(CN(m),m.tag===13){if(!ce)throw Error(o(316));if(m=m.memoizedState,m=m!==null?m.dehydrated:null,!m)throw Error(o(317));fs=de(m)}else fs=ds?na(m.stateNode):null;return!0}function qd(){ce&&(fs=ds=null,Op=$n=!1)}function z_(m){Ao===null?Ao=[m]:Ao.push(m)}function Bp(m,g,_){if(m=_.ref,m!==null&&typeof m!="function"&&typeof m!="object"){if(_._owner){if(_=_._owner,_){if(_.tag!==1)throw Error(o(309));var C=_.stateNode}if(!C)throw Error(o(147,m));var R=C,D=""+m;return g!==null&&g.ref!==null&&typeof g.ref=="function"&&g.ref._stringRef===D?g.ref:(g=function(Q){var ae=R.refs;ae===yN&&(ae=R.refs={}),Q===null?delete ae[D]:ae[D]=Q},g._stringRef=D,g)}if(typeof m!="string")throw Error(o(284));if(!_._owner)throw Error(o(290,m))}return m}function my(m,g){throw m=Object.prototype.toString.call(g),Error(o(31,m==="[object Object]"?"object with keys {"+Object.keys(g).join(", ")+"}":m))}function EN(m){var g=m._init;return g(m._payload)}function AN(m){function g(me,le){if(m){var Ce=me.deletions;Ce===null?(me.deletions=[le],me.flags|=16):Ce.push(le)}}function _(me,le){if(!m)return null;for(;le!==null;)g(me,le),le=le.sibling;return null}function C(me,le){for(me=new Map;le!==null;)le.key!==null?me.set(le.key,le):me.set(le.index,le),le=le.sibling;return me}function R(me,le){return me=Ul(me,le),me.index=0,me.sibling=null,me}function D(me,le,Ce){return me.index=Ce,m?(Ce=me.alternate,Ce!==null?(Ce=Ce.index,Ce<le?(me.flags|=2,le):Ce):(me.flags|=2,le)):(me.flags|=1048576,le)}function Q(me){return m&&me.alternate===null&&(me.flags|=2),me}function ae(me,le,Ce,rt){return le===null||le.tag!==6?(le=Cw(Ce,me.mode,rt),le.return=me,le):(le=R(le,Ce),le.return=me,le)}function Te(me,le,Ce,rt){var vt=Ce.type;return vt===u?dt(me,le,Ce.props.children,rt,Ce.key):le!==null&&(le.elementType===vt||typeof vt=="object"&&vt!==null&&vt.$$typeof===S&&EN(vt)===le.type)?(rt=R(le,Ce.props),rt.ref=Bp(me,le,Ce),rt.return=me,rt):(rt=jy(Ce.type,Ce.key,Ce.props,null,me.mode,rt),rt.ref=Bp(me,le,Ce),rt.return=me,rt)}function He(me,le,Ce,rt){return le===null||le.tag!==4||le.stateNode.containerInfo!==Ce.containerInfo||le.stateNode.implementation!==Ce.implementation?(le=Ew(Ce,me.mode,rt),le.return=me,le):(le=R(le,Ce.children||[]),le.return=me,le)}function dt(me,le,Ce,rt,vt){return le===null||le.tag!==7?(le=Zc(Ce,me.mode,rt,vt),le.return=me,le):(le=R(le,Ce),le.return=me,le)}function Dt(me,le,Ce){if(typeof le=="string"&&le!==""||typeof le=="number")return le=Cw(""+le,me.mode,Ce),le.return=me,le;if(typeof le=="object"&&le!==null){switch(le.$$typeof){case l:return Ce=jy(le.type,le.key,le.props,null,me.mode,Ce),Ce.ref=Bp(me,null,le),Ce.return=me,Ce;case c:return le=Ew(le,me.mode,Ce),le.return=me,le;case S:var rt=le._init;return Dt(me,rt(le._payload),Ce)}if(j(le)||A(le))return le=Zc(le,me.mode,Ce,null),le.return=me,le;my(me,le)}return null}function wt(me,le,Ce,rt){var vt=le!==null?le.key:null;if(typeof Ce=="string"&&Ce!==""||typeof Ce=="number")return vt!==null?null:ae(me,le,""+Ce,rt);if(typeof Ce=="object"&&Ce!==null){switch(Ce.$$typeof){case l:return Ce.key===vt?Te(me,le,Ce,rt):null;case c:return Ce.key===vt?He(me,le,Ce,rt):null;case S:return vt=Ce._init,wt(me,le,vt(Ce._payload),rt)}if(j(Ce)||A(Ce))return vt!==null?null:dt(me,le,Ce,rt,null);my(me,Ce)}return null}function Cn(me,le,Ce,rt,vt){if(typeof rt=="string"&&rt!==""||typeof rt=="number")return me=me.get(Ce)||null,ae(le,me,""+rt,vt);if(typeof rt=="object"&&rt!==null){switch(rt.$$typeof){case l:return me=me.get(rt.key===null?Ce:rt.key)||null,Te(le,me,rt,vt);case c:return me=me.get(rt.key===null?Ce:rt.key)||null,He(le,me,rt,vt);case S:var Ht=rt._init;return Cn(me,le,Ce,Ht(rt._payload),vt)}if(j(rt)||A(rt))return me=me.get(Ce)||null,dt(le,me,rt,vt,null);my(le,rt)}return null}function bt(me,le,Ce,rt){for(var vt=null,Ht=null,Ot=le,on=le=0,Br=null;Ot!==null&&on<Ce.length;on++){Ot.index>on?(Br=Ot,Ot=null):Br=Ot.sibling;var an=wt(me,Ot,Ce[on],rt);if(an===null){Ot===null&&(Ot=Br);break}m&&Ot&&an.alternate===null&&g(me,Ot),le=D(an,le,on),Ht===null?vt=an:Ht.sibling=an,Ht=an,Ot=Br}if(on===Ce.length)return _(me,Ot),$n&&jc(me,on),vt;if(Ot===null){for(;on<Ce.length;on++)Ot=Dt(me,Ce[on],rt),Ot!==null&&(le=D(Ot,le,on),Ht===null?vt=Ot:Ht.sibling=Ot,Ht=Ot);return $n&&jc(me,on),vt}for(Ot=C(me,Ot);on<Ce.length;on++)Br=Cn(Ot,me,on,Ce[on],rt),Br!==null&&(m&&Br.alternate!==null&&Ot.delete(Br.key===null?on:Br.key),le=D(Br,le,on),Ht===null?vt=Br:Ht.sibling=Br,Ht=Br);return m&&Ot.forEach(function(zl){return g(me,zl)}),$n&&jc(me,on),vt}function oi(me,le,Ce,rt){var vt=A(Ce);if(typeof vt!="function")throw Error(o(150));if(Ce=vt.call(Ce),Ce==null)throw Error(o(151));for(var Ht=vt=null,Ot=le,on=le=0,Br=null,an=Ce.next();Ot!==null&&!an.done;on++,an=Ce.next()){Ot.index>on?(Br=Ot,Ot=null):Br=Ot.sibling;var zl=wt(me,Ot,an.value,rt);if(zl===null){Ot===null&&(Ot=Br);break}m&&Ot&&zl.alternate===null&&g(me,Ot),le=D(zl,le,on),Ht===null?vt=zl:Ht.sibling=zl,Ht=zl,Ot=Br}if(an.done)return _(me,Ot),$n&&jc(me,on),vt;if(Ot===null){for(;!an.done;on++,an=Ce.next())an=Dt(me,an.value,rt),an!==null&&(le=D(an,le,on),Ht===null?vt=an:Ht.sibling=an,Ht=an);return $n&&jc(me,on),vt}for(Ot=C(me,Ot);!an.done;on++,an=Ce.next())an=Cn(Ot,me,on,an.value,rt),an!==null&&(m&&an.alternate!==null&&Ot.delete(an.key===null?on:an.key),le=D(an,le,on),Ht===null?vt=an:Ht.sibling=an,Ht=an);return m&&Ot.forEach(function(sj){return g(me,sj)}),$n&&jc(me,on),vt}function Xs(me,le,Ce,rt){if(typeof Ce=="object"&&Ce!==null&&Ce.type===u&&Ce.key===null&&(Ce=Ce.props.children),typeof Ce=="object"&&Ce!==null){switch(Ce.$$typeof){case l:e:{for(var vt=Ce.key,Ht=le;Ht!==null;){if(Ht.key===vt){if(vt=Ce.type,vt===u){if(Ht.tag===7){_(me,Ht.sibling),le=R(Ht,Ce.props.children),le.return=me,me=le;break e}}else if(Ht.elementType===vt||typeof vt=="object"&&vt!==null&&vt.$$typeof===S&&EN(vt)===Ht.type){_(me,Ht.sibling),le=R(Ht,Ce.props),le.ref=Bp(me,Ht,Ce),le.return=me,me=le;break e}_(me,Ht);break}else g(me,Ht);Ht=Ht.sibling}Ce.type===u?(le=Zc(Ce.props.children,me.mode,rt,Ce.key),le.return=me,me=le):(rt=jy(Ce.type,Ce.key,Ce.props,null,me.mode,rt),rt.ref=Bp(me,le,Ce),rt.return=me,me=rt)}return Q(me);case c:e:{for(Ht=Ce.key;le!==null;){if(le.key===Ht)if(le.tag===4&&le.stateNode.containerInfo===Ce.containerInfo&&le.stateNode.implementation===Ce.implementation){_(me,le.sibling),le=R(le,Ce.children||[]),le.return=me,me=le;break e}else{_(me,le);break}else g(me,le);le=le.sibling}le=Ew(Ce,me.mode,rt),le.return=me,me=le}return Q(me);case S:return Ht=Ce._init,Xs(me,le,Ht(Ce._payload),rt)}if(j(Ce))return bt(me,le,Ce,rt);if(A(Ce))return oi(me,le,Ce,rt);my(me,Ce)}return typeof Ce=="string"&&Ce!==""||typeof Ce=="number"?(Ce=""+Ce,le!==null&&le.tag===6?(_(me,le.sibling),le=R(le,Ce),le.return=me,me=le):(_(me,le),le=Cw(Ce,me.mode,rt),le.return=me,me=le),Q(me)):_(me,le)}return Xs}var Jd=AN(!0),TN=AN(!1),Fp={},Hs=rn(Fp),$p=rn(Fp),Yd=rn(Fp);function la(m){if(m===Fp)throw Error(o(174));return m}function G_(m,g){pn(Yd,g),pn($p,m),pn(Hs,Fp),m=ne(g),at(Hs),pn(Hs,m)}function Qd(){at(Hs),at($p),at(Yd)}function MN(m){var g=la(Yd.current),_=la(Hs.current);g=O(_,m.type,g),_!==g&&(pn($p,m),pn(Hs,g))}function H_(m){$p.current===m&&(at(Hs),at($p))}var Wn=rn(0);function gy(m){for(var g=m;g!==null;){if(g.tag===13){var _=g.memoizedState;if(_!==null&&(_=_.dehydrated,_===null||Y0(_)||Pl(_)))return g}else if(g.tag===19&&g.memoizedProps.revealOrder!==void 0){if(g.flags&128)return g}else if(g.child!==null){g.child.return=g,g=g.child;continue}if(g===m)break;for(;g.sibling===null;){if(g.return===null||g.return===m)return null;g=g.return}g.sibling.return=g.return,g=g.sibling}return null}var V_=[];function W_(){for(var m=0;m<V_.length;m++){var g=V_[m];Je?g._workInProgressVersionPrimary=null:g._workInProgressVersionSecondary=null}V_.length=0}var yy=a.ReactCurrentDispatcher,Vs=a.ReactCurrentBatchConfig,Zd=0,er=null,ri=null,Lr=null,vy=!1,Up=!1,zp=0,IW=0;function ii(){throw Error(o(321))}function j_(m,g){if(g===null)return!1;for(var _=0;_<g.length&&_<m.length;_++)if(!sa(m[_],g[_]))return!1;return!0}function X_(m,g,_,C,R,D){if(Zd=D,er=g,g.memoizedState=null,g.updateQueue=null,g.lanes=0,yy.current=m===null||m.memoizedState===null?DW:OW,m=_(C,R),Up){D=0;do{if(Up=!1,zp=0,25<=D)throw Error(o(301));D+=1,Lr=ri=null,g.updateQueue=null,yy.current=LW,m=_(C,R)}while(Up)}if(yy.current=wy,g=ri!==null&&ri.next!==null,Zd=0,Lr=ri=er=null,vy=!1,g)throw Error(o(300));return m}function K_(){var m=zp!==0;return zp=0,m}function Ua(){var m={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return Lr===null?er.memoizedState=Lr=m:Lr=Lr.next=m,Lr}function ca(){if(ri===null){var m=er.alternate;m=m!==null?m.memoizedState:null}else m=ri.next;var g=Lr===null?er.memoizedState:Lr.next;if(g!==null)Lr=g,ri=m;else{if(m===null)throw Error(o(310));ri=m,m={memoizedState:ri.memoizedState,baseState:ri.baseState,baseQueue:ri.baseQueue,queue:ri.queue,next:null},Lr===null?er.memoizedState=Lr=m:Lr=Lr.next=m}return Lr}function Xc(m,g){return typeof g=="function"?g(m):g}function xy(m){var g=ca(),_=g.queue;if(_===null)throw Error(o(311));_.lastRenderedReducer=m;var C=ri,R=C.baseQueue,D=_.pending;if(D!==null){if(R!==null){var Q=R.next;R.next=D.next,D.next=Q}C.baseQueue=R=D,_.pending=null}if(R!==null){D=R.next,C=C.baseState;var ae=Q=null,Te=null,He=D;do{var dt=He.lane;if((Zd&dt)===dt)Te!==null&&(Te=Te.next={lane:0,action:He.action,hasEagerState:He.hasEagerState,eagerState:He.eagerState,next:null}),C=He.hasEagerState?He.eagerState:m(C,He.action);else{var Dt={lane:dt,action:He.action,hasEagerState:He.hasEagerState,eagerState:He.eagerState,next:null};Te===null?(ae=Te=Dt,Q=C):Te=Te.next=Dt,er.lanes|=dt,tf|=dt}He=He.next}while(He!==null&&He!==D);Te===null?Q=C:Te.next=ae,sa(C,g.memoizedState)||(hs=!0),g.memoizedState=C,g.baseState=Q,g.baseQueue=Te,_.lastRenderedState=C}if(m=_.interleaved,m!==null){R=m;do D=R.lane,er.lanes|=D,tf|=D,R=R.next;while(R!==m)}else R===null&&(_.lanes=0);return[g.memoizedState,_.dispatch]}function by(m){var g=ca(),_=g.queue;if(_===null)throw Error(o(311));_.lastRenderedReducer=m;var C=_.dispatch,R=_.pending,D=g.memoizedState;if(R!==null){_.pending=null;var Q=R=R.next;do D=m(D,Q.action),Q=Q.next;while(Q!==R);sa(D,g.memoizedState)||(hs=!0),g.memoizedState=D,g.baseQueue===null&&(g.baseState=D),_.lastRenderedState=D}return[D,C]}function RN(){}function IN(m,g){var _=er,C=ca(),R=g(),D=!sa(C.memoizedState,R);if(D&&(C.memoizedState=R,hs=!0),C=C.queue,Hp(kN.bind(null,_,C,m),[m]),C.getSnapshot!==g||D||Lr!==null&&Lr.memoizedState.tag&1){if(_.flags|=2048,Gp(9,PN.bind(null,_,C,R,g),void 0,null),yr===null)throw Error(o(349));Zd&30||NN(_,g,R)}return R}function NN(m,g,_){m.flags|=16384,m={getSnapshot:g,value:_},g=er.updateQueue,g===null?(g={lastEffect:null,stores:null},er.updateQueue=g,g.stores=[m]):(_=g.stores,_===null?g.stores=[m]:_.push(m))}function PN(m,g,_,C){g.value=_,g.getSnapshot=C,DN(g)&&Ws(m,1,-1)}function kN(m,g,_){return _(function(){DN(g)&&Ws(m,1,-1)})}function DN(m){var g=m.getSnapshot;m=m.value;try{var _=g();return!sa(m,_)}catch{return!0}}function q_(m){var g=Ua();return typeof m=="function"&&(m=m()),g.memoizedState=g.baseState=m,m={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:Xc,lastRenderedState:m},g.queue=m,m=m.dispatch=kW.bind(null,er,m),[g.memoizedState,m]}function Gp(m,g,_,C){return m={tag:m,create:g,destroy:_,deps:C,next:null},g=er.updateQueue,g===null?(g={lastEffect:null,stores:null},er.updateQueue=g,g.lastEffect=m.next=m):(_=g.lastEffect,_===null?g.lastEffect=m.next=m:(C=_.next,_.next=m,m.next=C,g.lastEffect=m)),m}function ON(){return ca().memoizedState}function Sy(m,g,_,C){var R=Ua();er.flags|=m,R.memoizedState=Gp(1|g,_,void 0,C===void 0?null:C)}function _y(m,g,_,C){var R=ca();C=C===void 0?null:C;var D=void 0;if(ri!==null){var Q=ri.memoizedState;if(D=Q.destroy,C!==null&&j_(C,Q.deps)){R.memoizedState=Gp(g,_,D,C);return}}er.flags|=m,R.memoizedState=Gp(1|g,_,D,C)}function J_(m,g){return Sy(8390656,8,m,g)}function Hp(m,g){return _y(2048,8,m,g)}function LN(m,g){return _y(4,2,m,g)}function BN(m,g){return _y(4,4,m,g)}function FN(m,g){if(typeof g=="function")return m=m(),g(m),function(){g(null)};if(g!=null)return m=m(),g.current=m,function(){g.current=null}}function $N(m,g,_){return _=_!=null?_.concat([m]):null,_y(4,4,FN.bind(null,g,m),_)}function Y_(){}function UN(m,g){var _=ca();g=g===void 0?null:g;var C=_.memoizedState;return C!==null&&g!==null&&j_(g,C[1])?C[0]:(_.memoizedState=[m,g],m)}function zN(m,g){var _=ca();g=g===void 0?null:g;var C=_.memoizedState;return C!==null&&g!==null&&j_(g,C[1])?C[0]:(m=m(),_.memoizedState=[m,g],m)}function NW(m,g){var _=sn;sn=_!==0&&4>_?_:4,m(!0);var C=Vs.transition;Vs.transition={};try{m(!1),g()}finally{sn=_,Vs.transition=C}}function GN(){return ca().memoizedState}function PW(m,g,_){var C=Fl(m);_={lane:C,action:_,hasEagerState:!1,eagerState:null,next:null},HN(m)?VN(g,_):(WN(m,g,_),_=Mi(),m=Ws(m,C,_),m!==null&&jN(m,g,C))}function kW(m,g,_){var C=Fl(m),R={lane:C,action:_,hasEagerState:!1,eagerState:null,next:null};if(HN(m))VN(g,R);else{WN(m,g,R);var D=m.alternate;if(m.lanes===0&&(D===null||D.lanes===0)&&(D=g.lastRenderedReducer,D!==null))try{var Q=g.lastRenderedState,ae=D(Q,_);if(R.hasEagerState=!0,R.eagerState=ae,sa(ae,Q))return}catch{}finally{}_=Mi(),m=Ws(m,C,_),m!==null&&jN(m,g,C)}}function HN(m){var g=m.alternate;return m===er||g!==null&&g===er}function VN(m,g){Up=vy=!0;var _=m.pending;_===null?g.next=g:(g.next=_.next,_.next=g),m.pending=g}function WN(m,g,_){yr!==null&&m.mode&1&&!(Wt&2)?(m=g.interleaved,m===null?(_.next=_,aa===null?aa=[g]:aa.push(g)):(_.next=m.next,m.next=_),g.interleaved=_):(m=g.pending,m===null?_.next=_:(_.next=m.next,m.next=_),g.pending=_)}function jN(m,g,_){if(_&4194240){var C=g.lanes;C&=m.pendingLanes,_|=C,g.lanes=_,E_(m,_)}}var wy={readContext:Us,useCallback:ii,useContext:ii,useEffect:ii,useImperativeHandle:ii,useInsertionEffect:ii,useLayoutEffect:ii,useMemo:ii,useReducer:ii,useRef:ii,useState:ii,useDebugValue:ii,useDeferredValue:ii,useTransition:ii,useMutableSource:ii,useSyncExternalStore:ii,useId:ii,unstable_isNewReconciler:!1},DW={readContext:Us,useCallback:function(m,g){return Ua().memoizedState=[m,g===void 0?null:g],m},useContext:Us,useEffect:J_,useImperativeHandle:function(m,g,_){return _=_!=null?_.concat([m]):null,Sy(4194308,4,FN.bind(null,g,m),_)},useLayoutEffect:function(m,g){return Sy(4194308,4,m,g)},useInsertionEffect:function(m,g){return Sy(4,2,m,g)},useMemo:function(m,g){var _=Ua();return g=g===void 0?null:g,m=m(),_.memoizedState=[m,g],m},useReducer:function(m,g,_){var C=Ua();return g=_!==void 0?_(g):g,C.memoizedState=C.baseState=g,m={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:m,lastRenderedState:g},C.queue=m,m=m.dispatch=PW.bind(null,er,m),[C.memoizedState,m]},useRef:function(m){var g=Ua();return m={current:m},g.memoizedState=m},useState:q_,useDebugValue:Y_,useDeferredValue:function(m){var g=q_(m),_=g[0],C=g[1];return J_(function(){var R=Vs.transition;Vs.transition={};try{C(m)}finally{Vs.transition=R}},[m]),_},useTransition:function(){var m=q_(!1),g=m[0];return m=NW.bind(null,m[1]),Ua().memoizedState=m,[g,m]},useMutableSource:function(){},useSyncExternalStore:function(m,g,_){var C=er,R=Ua();if($n){if(_===void 0)throw Error(o(407));_=_()}else{if(_=g(),yr===null)throw Error(o(349));Zd&30||NN(C,g,_)}R.memoizedState=_;var D={value:_,getSnapshot:g};return R.queue=D,J_(kN.bind(null,C,D,m),[m]),C.flags|=2048,Gp(9,PN.bind(null,C,D,_,g),void 0,null),_},useId:function(){var m=Ua(),g=yr.identifierPrefix;if($n){var _=$a,C=Fa;_=(C&~(1<<32-Gi(C)-1)).toString(32)+_,g=":"+g+"R"+_,_=zp++,0<_&&(g+="H"+_.toString(32)),g+=":"}else _=IW++,g=":"+g+"r"+_.toString(32)+":";return m.memoizedState=g},unstable_isNewReconciler:!1},OW={readContext:Us,useCallback:UN,useContext:Us,useEffect:Hp,useImperativeHandle:$N,useInsertionEffect:LN,useLayoutEffect:BN,useMemo:zN,useReducer:xy,useRef:ON,useState:function(){return xy(Xc)},useDebugValue:Y_,useDeferredValue:function(m){var g=xy(Xc),_=g[0],C=g[1];return Hp(function(){var R=Vs.transition;Vs.transition={};try{C(m)}finally{Vs.transition=R}},[m]),_},useTransition:function(){var m=xy(Xc)[0],g=ca().memoizedState;return[m,g]},useMutableSource:RN,useSyncExternalStore:IN,useId:GN,unstable_isNewReconciler:!1},LW={readContext:Us,useCallback:UN,useContext:Us,useEffect:Hp,useImperativeHandle:$N,useInsertionEffect:LN,useLayoutEffect:BN,useMemo:zN,useReducer:by,useRef:ON,useState:function(){return by(Xc)},useDebugValue:Y_,useDeferredValue:function(m){var g=by(Xc),_=g[0],C=g[1];return Hp(function(){var R=Vs.transition;Vs.transition={};try{C(m)}finally{Vs.transition=R}},[m]),_},useTransition:function(){var m=by(Xc)[0],g=ca().memoizedState;return[m,g]},useMutableSource:RN,useSyncExternalStore:IN,useId:GN,unstable_isNewReconciler:!1};function Q_(m,g){try{var _="",C=g;do _+=RW(C),C=C.return;while(C);var R=_}catch(D){R=`
Error generating stack: `+D.message+`
`+D.stack}return{value:m,source:g,stack:R}}function Z_(m,g){try{console.error(g.value)}catch(_){setTimeout(function(){throw _})}}var BW=typeof WeakMap=="function"?WeakMap:Map;function XN(m,g,_){_=Ba(-1,_),_.tag=3,_.payload={element:null};var C=g.value;return _.callback=function(){$y||($y=!0,yw=C),Z_(m,g)},_}function KN(m,g,_){_=Ba(-1,_),_.tag=3;var C=m.type.getDerivedStateFromError;if(typeof C=="function"){var R=g.value;_.payload=function(){return C(R)},_.callback=function(){Z_(m,g)}}var D=m.stateNode;return D!==null&&typeof D.componentDidCatch=="function"&&(_.callback=function(){Z_(m,g),typeof C!="function"&&(Ll===null?Ll=new Set([this]):Ll.add(this));var Q=g.stack;this.componentDidCatch(g.value,{componentStack:Q!==null?Q:""})}),_}function qN(m,g,_){var C=m.pingCache;if(C===null){C=m.pingCache=new BW;var R=new Set;C.set(g,R)}else R=C.get(g),R===void 0&&(R=new Set,C.set(g,R));R.has(_)||(R.add(_),m=YW.bind(null,m,g,_),g.then(m,m))}function JN(m){do{var g;if((g=m.tag===13)&&(g=m.memoizedState,g=g!==null?g.dehydrated!==null:!0),g)return m;m=m.return}while(m!==null);return null}function YN(m,g,_,C,R){return m.mode&1?(m.flags|=65536,m.lanes=R,m):(m===g?m.flags|=65536:(m.flags|=128,_.flags|=131072,_.flags&=-52805,_.tag===1&&(_.alternate===null?_.tag=17:(g=Ba(-1,1),g.tag=2,Ol(_,g))),_.lanes|=1),m)}function ua(m){m.flags|=4}function QN(m,g){if(m!==null&&m.child===g.child)return!0;if(g.flags&16)return!1;for(m=g.child;m!==null;){if(m.flags&12854||m.subtreeFlags&12854)return!1;m=m.sibling}return!0}var Vp,Wp,Cy,Ey;if(te)Vp=function(m,g){for(var _=g.child;_!==null;){if(_.tag===5||_.tag===6)he(m,_.stateNode);else if(_.tag!==4&&_.child!==null){_.child.return=_,_=_.child;continue}if(_===g)break;for(;_.sibling===null;){if(_.return===null||_.return===g)return;_=_.return}_.sibling.return=_.return,_=_.sibling}},Wp=function(){},Cy=function(m,g,_,C,R){if(m=m.memoizedProps,m!==C){var D=g.stateNode,Q=la(Hs.current);_=re(D,_,m,C,R,Q),(g.updateQueue=_)&&ua(g)}},Ey=function(m,g,_,C){_!==C&&ua(g)};else if(be){Vp=function(m,g,_,C){for(var R=g.child;R!==null;){if(R.tag===5){var D=R.stateNode;_&&C&&(D=Cr(D,R.type,R.memoizedProps,R)),he(m,D)}else if(R.tag===6)D=R.stateNode,_&&C&&(D=Er(D,R.memoizedProps,R)),he(m,D);else if(R.tag!==4){if(R.tag===22&&R.memoizedState!==null)D=R.child,D!==null&&(D.return=R),Vp(m,R,!0,!0);else if(R.child!==null){R.child.return=R,R=R.child;continue}}if(R===g)break;for(;R.sibling===null;){if(R.return===null||R.return===g)return;R=R.return}R.sibling.return=R.return,R=R.sibling}};var ZN=function(m,g,_,C){for(var R=g.child;R!==null;){if(R.tag===5){var D=R.stateNode;_&&C&&(D=Cr(D,R.type,R.memoizedProps,R)),jt(m,D)}else if(R.tag===6)D=R.stateNode,_&&C&&(D=Er(D,R.memoizedProps,R)),jt(m,D);else if(R.tag!==4){if(R.tag===22&&R.memoizedState!==null)D=R.child,D!==null&&(D.return=R),ZN(m,R,!0,!0);else if(R.child!==null){R.child.return=R,R=R.child;continue}}if(R===g)break;for(;R.sibling===null;){if(R.return===null||R.return===g)return;R=R.return}R.sibling.return=R.return,R=R.sibling}};Wp=function(m,g){var _=g.stateNode;if(!QN(m,g)){m=_.containerInfo;var C=hn(m);ZN(C,g,!1,!1),_.pendingChildren=C,ua(g),_n(m,C)}},Cy=function(m,g,_,C,R){var D=m.stateNode,Q=m.memoizedProps;if((m=QN(m,g))&&Q===C)g.stateNode=D;else{var ae=g.stateNode,Te=la(Hs.current),He=null;Q!==C&&(He=re(ae,_,Q,C,R,Te)),m&&He===null?g.stateNode=D:(D=mn(D,He,_,Q,C,g,m,ae),ke(D,_,C,R,Te)&&ua(g),g.stateNode=D,m?ua(g):Vp(D,g,!1,!1))}},Ey=function(m,g,_,C){_!==C?(m=la(Yd.current),_=la(Hs.current),g.stateNode=fe(C,m,_,g),ua(g)):g.stateNode=m.stateNode}}else Wp=function(){},Cy=function(){},Ey=function(){};function jp(m,g){if(!$n)switch(m.tailMode){case"hidden":g=m.tail;for(var _=null;g!==null;)g.alternate!==null&&(_=g),g=g.sibling;_===null?m.tail=null:_.sibling=null;break;case"collapsed":_=m.tail;for(var C=null;_!==null;)_.alternate!==null&&(C=_),_=_.sibling;C===null?g||m.tail===null?m.tail=null:m.tail.sibling=null:C.sibling=null}}function si(m){var g=m.alternate!==null&&m.alternate.child===m.child,_=0,C=0;if(g)for(var R=m.child;R!==null;)_|=R.lanes|R.childLanes,C|=R.subtreeFlags&14680064,C|=R.flags&14680064,R.return=m,R=R.sibling;else for(R=m.child;R!==null;)_|=R.lanes|R.childLanes,C|=R.subtreeFlags,C|=R.flags,R.return=m,R=R.sibling;return m.subtreeFlags|=C,m.childLanes=_,g}function FW(m,g,_){var C=g.pendingProps;switch(F_(g),g.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return si(g),null;case 1:return cn(g.type)&&us(),si(g),null;case 3:return C=g.stateNode,Qd(),at(Kr),at(Fn),W_(),C.pendingContext&&(C.context=C.pendingContext,C.pendingContext=null),(m===null||m.child===null)&&(Lp(g)?ua(g):m===null||m.memoizedState.isDehydrated&&!(g.flags&256)||(g.flags|=1024,Ao!==null&&(bw(Ao),Ao=null))),Wp(m,g),si(g),null;case 5:H_(g),_=la(Yd.current);var R=g.type;if(m!==null&&g.stateNode!=null)Cy(m,g,R,C,_),m.ref!==g.ref&&(g.flags|=512,g.flags|=2097152);else{if(!C){if(g.stateNode===null)throw Error(o(166));return si(g),null}if(m=la(Hs.current),Lp(g)){if(!ce)throw Error(o(175));m=S_(g.stateNode,g.type,g.memoizedProps,_,m,g,!Op),g.updateQueue=m,m!==null&&ua(g)}else{var D=se(R,C,_,m,g);Vp(D,g,!1,!1),g.stateNode=D,ke(D,R,C,_,m)&&ua(g)}g.ref!==null&&(g.flags|=512,g.flags|=2097152)}return si(g),null;case 6:if(m&&g.stateNode!=null)Ey(m,g,m.memoizedProps,C);else{if(typeof C!="string"&&g.stateNode===null)throw Error(o(166));if(m=la(Yd.current),_=la(Hs.current),Lp(g)){if(!ce)throw Error(o(176));if(m=g.stateNode,C=g.memoizedProps,(_=__(m,C,g,!Op))&&(R=ds,R!==null))switch(D=(R.mode&1)!==0,R.tag){case 3:Ct(R.stateNode.containerInfo,m,C,D);break;case 5:Tt(R.type,R.memoizedProps,R.stateNode,m,C,D)}_&&ua(g)}else g.stateNode=fe(C,m,_,g)}return si(g),null;case 13:if(at(Wn),C=g.memoizedState,$n&&fs!==null&&g.mode&1&&!(g.flags&128)){for(m=fs;m;)m=na(m);return qd(),g.flags|=98560,g}if(C!==null&&C.dehydrated!==null){if(C=Lp(g),m===null){if(!C)throw Error(o(318));if(!ce)throw Error(o(344));if(m=g.memoizedState,m=m!==null?m.dehydrated:null,!m)throw Error(o(317));W(m,g)}else qd(),!(g.flags&128)&&(g.memoizedState=null),g.flags|=4;return si(g),null}return Ao!==null&&(bw(Ao),Ao=null),g.flags&128?(g.lanes=_,g):(C=C!==null,_=!1,m===null?Lp(g):_=m.memoizedState!==null,C&&!_&&(g.child.flags|=8192,g.mode&1&&(m===null||Wn.current&1?Ar===0&&(Ar=3):_w())),g.updateQueue!==null&&(g.flags|=4),si(g),null);case 4:return Qd(),Wp(m,g),m===null&&Ie(g.stateNode.containerInfo),si(g),null;case 10:return P_(g.type._context),si(g),null;case 17:return cn(g.type)&&us(),si(g),null;case 19:if(at(Wn),R=g.memoizedState,R===null)return si(g),null;if(C=(g.flags&128)!==0,D=R.rendering,D===null)if(C)jp(R,!1);else{if(Ar!==0||m!==null&&m.flags&128)for(m=g.child;m!==null;){if(D=gy(m),D!==null){for(g.flags|=128,jp(R,!1),m=D.updateQueue,m!==null&&(g.updateQueue=m,g.flags|=4),g.subtreeFlags=0,m=_,C=g.child;C!==null;)_=C,R=m,_.flags&=14680066,D=_.alternate,D===null?(_.childLanes=0,_.lanes=R,_.child=null,_.subtreeFlags=0,_.memoizedProps=null,_.memoizedState=null,_.updateQueue=null,_.dependencies=null,_.stateNode=null):(_.childLanes=D.childLanes,_.lanes=D.lanes,_.child=D.child,_.subtreeFlags=0,_.deletions=null,_.memoizedProps=D.memoizedProps,_.memoizedState=D.memoizedState,_.updateQueue=D.updateQueue,_.type=D.type,R=D.dependencies,_.dependencies=R===null?null:{lanes:R.lanes,firstContext:R.firstContext}),C=C.sibling;return pn(Wn,Wn.current&1|2),g.child}m=m.sibling}R.tail!==null&&Or()>gw&&(g.flags|=128,C=!0,jp(R,!1),g.lanes=4194304)}else{if(!C)if(m=gy(D),m!==null){if(g.flags|=128,C=!0,m=m.updateQueue,m!==null&&(g.updateQueue=m,g.flags|=4),jp(R,!0),R.tail===null&&R.tailMode==="hidden"&&!D.alternate&&!$n)return si(g),null}else 2*Or()-R.renderingStartTime>gw&&_!==1073741824&&(g.flags|=128,C=!0,jp(R,!1),g.lanes=4194304);R.isBackwards?(D.sibling=g.child,g.child=D):(m=R.last,m!==null?m.sibling=D:g.child=D,R.last=D)}return R.tail!==null?(g=R.tail,R.rendering=g,R.tail=g.sibling,R.renderingStartTime=Or(),g.sibling=null,m=Wn.current,pn(Wn,C?m&1|2:m&1),g):(si(g),null);case 22:case 23:return Sw(),C=g.memoizedState!==null,m!==null&&m.memoizedState!==null!==C&&(g.flags|=8192),C&&g.mode&1?ps&1073741824&&(si(g),te&&g.subtreeFlags&6&&(g.flags|=8192)):si(g),null;case 24:return null;case 25:return null}throw Error(o(156,g.tag))}var $W=a.ReactCurrentOwner,hs=!1;function Ti(m,g,_,C){g.child=m===null?TN(g,null,_,C):Jd(g,m.child,_,C)}function e3(m,g,_,C,R){_=_.render;var D=g.ref;return jd(g,R),C=X_(m,g,_,C,D,R),_=K_(),m!==null&&!hs?(g.updateQueue=m.updateQueue,g.flags&=-2053,m.lanes&=~R,za(m,g,R)):($n&&_&&B_(g),g.flags|=1,Ti(m,g,C,R),g.child)}function t3(m,g,_,C,R){if(m===null){var D=_.type;return typeof D=="function"&&!ww(D)&&D.defaultProps===void 0&&_.compare===null&&_.defaultProps===void 0?(g.tag=15,g.type=D,n3(m,g,D,C,R)):(m=jy(_.type,null,C,g,g.mode,R),m.ref=g.ref,m.return=g,g.child=m)}if(D=m.child,!(m.lanes&R)){var Q=D.memoizedProps;if(_=_.compare,_=_!==null?_:ay,_(Q,C)&&m.ref===g.ref)return za(m,g,R)}return g.flags|=1,m=Ul(D,C),m.ref=g.ref,m.return=g,g.child=m}function n3(m,g,_,C,R){if(m!==null&&ay(m.memoizedProps,C)&&m.ref===g.ref)if(hs=!1,(m.lanes&R)!==0)m.flags&131072&&(hs=!0);else return g.lanes=m.lanes,za(m,g,R);return ew(m,g,_,C,R)}function r3(m,g,_){var C=g.pendingProps,R=C.children,D=m!==null?m.memoizedState:null;if(C.mode==="hidden")if(!(g.mode&1))g.memoizedState={baseLanes:0,cachePool:null},pn(ef,ps),ps|=_;else if(_&1073741824)g.memoizedState={baseLanes:0,cachePool:null},C=D!==null?D.baseLanes:_,pn(ef,ps),ps|=C;else return m=D!==null?D.baseLanes|_:_,g.lanes=g.childLanes=1073741824,g.memoizedState={baseLanes:m,cachePool:null},g.updateQueue=null,pn(ef,ps),ps|=m,null;else D!==null?(C=D.baseLanes|_,g.memoizedState=null):C=_,pn(ef,ps),ps|=C;return Ti(m,g,R,_),g.child}function i3(m,g){var _=g.ref;(m===null&&_!==null||m!==null&&m.ref!==_)&&(g.flags|=512,g.flags|=2097152)}function ew(m,g,_,C,R){var D=cn(_)?cs:Fn.current;return D=ra(g,D),jd(g,R),_=X_(m,g,_,C,D,R),C=K_(),m!==null&&!hs?(g.updateQueue=m.updateQueue,g.flags&=-2053,m.lanes&=~R,za(m,g,R)):($n&&C&&B_(g),g.flags|=1,Ti(m,g,_,R),g.child)}function s3(m,g,_,C,R){if(cn(_)){var D=!0;kl(g)}else D=!1;if(jd(g,R),g.stateNode===null)m!==null&&(m.alternate=null,g.alternate=null,g.flags|=2),xN(g,_,C),L_(g,_,C,R),C=!0;else if(m===null){var Q=g.stateNode,ae=g.memoizedProps;Q.props=ae;var Te=Q.context,He=_.contextType;typeof He=="object"&&He!==null?He=Us(He):(He=cn(_)?cs:Fn.current,He=ra(g,He));var dt=_.getDerivedStateFromProps,Dt=typeof dt=="function"||typeof Q.getSnapshotBeforeUpdate=="function";Dt||typeof Q.UNSAFE_componentWillReceiveProps!="function"&&typeof Q.componentWillReceiveProps!="function"||(ae!==C||Te!==He)&&bN(g,Q,C,He),Dl=!1;var wt=g.memoizedState;Q.state=wt,dy(g,C,Q,R),Te=g.memoizedState,ae!==C||wt!==Te||Kr.current||Dl?(typeof dt=="function"&&(O_(g,_,dt,C),Te=g.memoizedState),(ae=Dl||vN(g,_,ae,C,wt,Te,He))?(Dt||typeof Q.UNSAFE_componentWillMount!="function"&&typeof Q.componentWillMount!="function"||(typeof Q.componentWillMount=="function"&&Q.componentWillMount(),typeof Q.UNSAFE_componentWillMount=="function"&&Q.UNSAFE_componentWillMount()),typeof Q.componentDidMount=="function"&&(g.flags|=4194308)):(typeof Q.componentDidMount=="function"&&(g.flags|=4194308),g.memoizedProps=C,g.memoizedState=Te),Q.props=C,Q.state=Te,Q.context=He,C=ae):(typeof Q.componentDidMount=="function"&&(g.flags|=4194308),C=!1)}else{Q=g.stateNode,pN(m,g),ae=g.memoizedProps,He=g.type===g.elementType?ae:Eo(g.type,ae),Q.props=He,Dt=g.pendingProps,wt=Q.context,Te=_.contextType,typeof Te=="object"&&Te!==null?Te=Us(Te):(Te=cn(_)?cs:Fn.current,Te=ra(g,Te));var Cn=_.getDerivedStateFromProps;(dt=typeof Cn=="function"||typeof Q.getSnapshotBeforeUpdate=="function")||typeof Q.UNSAFE_componentWillReceiveProps!="function"&&typeof Q.componentWillReceiveProps!="function"||(ae!==Dt||wt!==Te)&&bN(g,Q,C,Te),Dl=!1,wt=g.memoizedState,Q.state=wt,dy(g,C,Q,R);var bt=g.memoizedState;ae!==Dt||wt!==bt||Kr.current||Dl?(typeof Cn=="function"&&(O_(g,_,Cn,C),bt=g.memoizedState),(He=Dl||vN(g,_,He,C,wt,bt,Te)||!1)?(dt||typeof Q.UNSAFE_componentWillUpdate!="function"&&typeof Q.componentWillUpdate!="function"||(typeof Q.componentWillUpdate=="function"&&Q.componentWillUpdate(C,bt,Te),typeof Q.UNSAFE_componentWillUpdate=="function"&&Q.UNSAFE_componentWillUpdate(C,bt,Te)),typeof Q.componentDidUpdate=="function"&&(g.flags|=4),typeof Q.getSnapshotBeforeUpdate=="function"&&(g.flags|=1024)):(typeof Q.componentDidUpdate!="function"||ae===m.memoizedProps&&wt===m.memoizedState||(g.flags|=4),typeof Q.getSnapshotBeforeUpdate!="function"||ae===m.memoizedProps&&wt===m.memoizedState||(g.flags|=1024),g.memoizedProps=C,g.memoizedState=bt),Q.props=C,Q.state=bt,Q.context=Te,C=He):(typeof Q.componentDidUpdate!="function"||ae===m.memoizedProps&&wt===m.memoizedState||(g.flags|=4),typeof Q.getSnapshotBeforeUpdate!="function"||ae===m.memoizedProps&&wt===m.memoizedState||(g.flags|=1024),C=!1)}return tw(m,g,_,C,D,R)}function tw(m,g,_,C,R,D){i3(m,g);var Q=(g.flags&128)!==0;if(!C&&!Q)return R&&ty(g,_,!1),za(m,g,D);C=g.stateNode,$W.current=g;var ae=Q&&typeof _.getDerivedStateFromError!="function"?null:C.render();return g.flags|=1,m!==null&&Q?(g.child=Jd(g,m.child,null,D),g.child=Jd(g,null,ae,D)):Ti(m,g,ae,D),g.memoizedState=C.state,R&&ty(g,_,!0),g.child}function o3(m){var g=m.stateNode;g.pendingContext?Vd(m,g.pendingContext,g.pendingContext!==g.context):g.context&&Vd(m,g.context,!1),G_(m,g.containerInfo)}function a3(m,g,_,C,R){return qd(),z_(R),g.flags|=256,Ti(m,g,_,C),g.child}var Ay={dehydrated:null,treeContext:null,retryLane:0};function Ty(m){return{baseLanes:m,cachePool:null}}function l3(m,g,_){var C=g.pendingProps,R=Wn.current,D=!1,Q=(g.flags&128)!==0,ae;if((ae=Q)||(ae=m!==null&&m.memoizedState===null?!1:(R&2)!==0),ae?(D=!0,g.flags&=-129):(m===null||m.memoizedState!==null)&&(R|=1),pn(Wn,R&1),m===null)return U_(g),m=g.memoizedState,m!==null&&(m=m.dehydrated,m!==null)?(g.mode&1?Pl(m)?g.lanes=8:g.lanes=1073741824:g.lanes=1,null):(R=C.children,m=C.fallback,D?(C=g.mode,D=g.child,R={mode:"hidden",children:R},!(C&1)&&D!==null?(D.childLanes=0,D.pendingProps=R):D=Xy(R,C,0,null),m=Zc(m,C,_,null),D.return=g,m.return=g,D.sibling=m,g.child=D,g.child.memoizedState=Ty(_),g.memoizedState=Ay,m):nw(g,R));if(R=m.memoizedState,R!==null){if(ae=R.dehydrated,ae!==null){if(Q)return g.flags&256?(g.flags&=-257,My(m,g,_,Error(o(422)))):g.memoizedState!==null?(g.child=m.child,g.flags|=128,null):(D=C.fallback,R=g.mode,C=Xy({mode:"visible",children:C.children},R,0,null),D=Zc(D,R,_,null),D.flags|=2,C.return=g,D.return=g,C.sibling=D,g.child=C,g.mode&1&&Jd(g,m.child,null,_),g.child.memoizedState=Ty(_),g.memoizedState=Ay,D);if(!(g.mode&1))g=My(m,g,_,null);else if(Pl(ae))g=My(m,g,_,Error(o(419)));else if(C=(_&m.childLanes)!==0,hs||C){if(C=yr,C!==null){switch(_&-_){case 4:D=2;break;case 16:D=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:D=32;break;case 536870912:D=268435456;break;default:D=0}C=D&(C.suspendedLanes|_)?0:D,C!==0&&C!==R.retryLane&&(R.retryLane=C,Ws(m,C,-1))}_w(),g=My(m,g,_,Error(o(421)))}else Y0(ae)?(g.flags|=128,g.child=m.child,g=QW.bind(null,m),Q0(ae,g),g=null):(_=R.treeContext,ce&&(fs=b_(ae),ds=g,$n=!0,Ao=null,Op=!1,_!==null&&(zs[Gs++]=Fa,zs[Gs++]=$a,zs[Gs++]=Wc,Fa=_.id,$a=_.overflow,Wc=g)),g=nw(g,g.pendingProps.children),g.flags|=4096);return g}return D?(C=u3(m,g,C.children,C.fallback,_),D=g.child,R=m.child.memoizedState,D.memoizedState=R===null?Ty(_):{baseLanes:R.baseLanes|_,cachePool:null},D.childLanes=m.childLanes&~_,g.memoizedState=Ay,C):(_=c3(m,g,C.children,_),g.memoizedState=null,_)}return D?(C=u3(m,g,C.children,C.fallback,_),D=g.child,R=m.child.memoizedState,D.memoizedState=R===null?Ty(_):{baseLanes:R.baseLanes|_,cachePool:null},D.childLanes=m.childLanes&~_,g.memoizedState=Ay,C):(_=c3(m,g,C.children,_),g.memoizedState=null,_)}function nw(m,g){return g=Xy({mode:"visible",children:g},m.mode,0,null),g.return=m,m.child=g}function c3(m,g,_,C){var R=m.child;return m=R.sibling,_=Ul(R,{mode:"visible",children:_}),!(g.mode&1)&&(_.lanes=C),_.return=g,_.sibling=null,m!==null&&(C=g.deletions,C===null?(g.deletions=[m],g.flags|=16):C.push(m)),g.child=_}function u3(m,g,_,C,R){var D=g.mode;m=m.child;var Q=m.sibling,ae={mode:"hidden",children:_};return!(D&1)&&g.child!==m?(_=g.child,_.childLanes=0,_.pendingProps=ae,g.deletions=null):(_=Ul(m,ae),_.subtreeFlags=m.subtreeFlags&14680064),Q!==null?C=Ul(Q,C):(C=Zc(C,D,R,null),C.flags|=2),C.return=g,_.return=g,_.sibling=C,g.child=_,C}function My(m,g,_,C){return C!==null&&z_(C),Jd(g,m.child,null,_),m=nw(g,g.pendingProps.children),m.flags|=2,g.memoizedState=null,m}function d3(m,g,_){m.lanes|=g;var C=m.alternate;C!==null&&(C.lanes|=g),k_(m.return,g,_)}function rw(m,g,_,C,R){var D=m.memoizedState;D===null?m.memoizedState={isBackwards:g,rendering:null,renderingStartTime:0,last:C,tail:_,tailMode:R}:(D.isBackwards=g,D.rendering=null,D.renderingStartTime=0,D.last=C,D.tail=_,D.tailMode=R)}function f3(m,g,_){var C=g.pendingProps,R=C.revealOrder,D=C.tail;if(Ti(m,g,C.children,_),C=Wn.current,C&2)C=C&1|2,g.flags|=128;else{if(m!==null&&m.flags&128)e:for(m=g.child;m!==null;){if(m.tag===13)m.memoizedState!==null&&d3(m,_,g);else if(m.tag===19)d3(m,_,g);else if(m.child!==null){m.child.return=m,m=m.child;continue}if(m===g)break e;for(;m.sibling===null;){if(m.return===null||m.return===g)break e;m=m.return}m.sibling.return=m.return,m=m.sibling}C&=1}if(pn(Wn,C),!(g.mode&1))g.memoizedState=null;else switch(R){case"forwards":for(_=g.child,R=null;_!==null;)m=_.alternate,m!==null&&gy(m)===null&&(R=_),_=_.sibling;_=R,_===null?(R=g.child,g.child=null):(R=_.sibling,_.sibling=null),rw(g,!1,R,_,D);break;case"backwards":for(_=null,R=g.child,g.child=null;R!==null;){if(m=R.alternate,m!==null&&gy(m)===null){g.child=R;break}m=R.sibling,R.sibling=_,_=R,R=m}rw(g,!0,_,null,D);break;case"together":rw(g,!1,null,null,void 0);break;default:g.memoizedState=null}return g.child}function za(m,g,_){if(m!==null&&(g.dependencies=m.dependencies),tf|=g.lanes,!(_&g.childLanes))return null;if(m!==null&&g.child!==m.child)throw Error(o(153));if(g.child!==null){for(m=g.child,_=Ul(m,m.pendingProps),g.child=_,_.return=g;m.sibling!==null;)m=m.sibling,_=_.sibling=Ul(m,m.pendingProps),_.return=g;_.sibling=null}return g.child}function UW(m,g,_){switch(g.tag){case 3:o3(g),qd();break;case 5:MN(g);break;case 1:cn(g.type)&&kl(g);break;case 4:G_(g,g.stateNode.containerInfo);break;case 10:hN(g,g.type._context,g.memoizedProps.value);break;case 13:var C=g.memoizedState;if(C!==null)return C.dehydrated!==null?(pn(Wn,Wn.current&1),g.flags|=128,null):_&g.child.childLanes?l3(m,g,_):(pn(Wn,Wn.current&1),m=za(m,g,_),m!==null?m.sibling:null);pn(Wn,Wn.current&1);break;case 19:if(C=(_&g.childLanes)!==0,m.flags&128){if(C)return f3(m,g,_);g.flags|=128}var R=g.memoizedState;if(R!==null&&(R.rendering=null,R.tail=null,R.lastEffect=null),pn(Wn,Wn.current),C)break;return null;case 22:case 23:return g.lanes=0,r3(m,g,_)}return za(m,g,_)}function zW(m,g){switch(F_(g),g.tag){case 1:return cn(g.type)&&us(),m=g.flags,m&65536?(g.flags=m&-65537|128,g):null;case 3:return Qd(),at(Kr),at(Fn),W_(),m=g.flags,m&65536&&!(m&128)?(g.flags=m&-65537|128,g):null;case 5:return H_(g),null;case 13:if(at(Wn),m=g.memoizedState,m!==null&&m.dehydrated!==null){if(g.alternate===null)throw Error(o(340));qd()}return m=g.flags,m&65536?(g.flags=m&-65537|128,g):null;case 19:return at(Wn),null;case 4:return Qd(),null;case 10:return P_(g.type._context),null;case 22:case 23:return Sw(),null;case 24:return null;default:return null}}var Ry=!1,Kc=!1,GW=typeof WeakSet=="function"?WeakSet:Set,et=null;function Iy(m,g){var _=m.ref;if(_!==null)if(typeof _=="function")try{_(null)}catch(C){Wi(m,g,C)}else _.current=null}function iw(m,g,_){try{_()}catch(C){Wi(m,g,C)}}var h3=!1;function HW(m,g){for(G(m.containerInfo),et=g;et!==null;)if(m=et,g=m.child,(m.subtreeFlags&1028)!==0&&g!==null)g.return=m,et=g;else for(;et!==null;){m=et;try{var _=m.alternate;if(m.flags&1024)switch(m.tag){case 0:case 11:case 15:break;case 1:if(_!==null){var C=_.memoizedProps,R=_.memoizedState,D=m.stateNode,Q=D.getSnapshotBeforeUpdate(m.elementType===m.type?C:Eo(m.type,C),R);D.__reactInternalSnapshotBeforeUpdate=Q}break;case 3:te&&pt(m.stateNode.containerInfo);break;case 5:case 6:case 4:case 17:break;default:throw Error(o(163))}}catch(ae){Wi(m,m.return,ae)}if(g=m.sibling,g!==null){g.return=m.return,et=g;break}et=m.return}return _=h3,h3=!1,_}function qc(m,g,_){var C=g.updateQueue;if(C=C!==null?C.lastEffect:null,C!==null){var R=C=C.next;do{if((R.tag&m)===m){var D=R.destroy;R.destroy=void 0,D!==void 0&&iw(g,_,D)}R=R.next}while(R!==C)}}function Xp(m,g){if(g=g.updateQueue,g=g!==null?g.lastEffect:null,g!==null){var _=g=g.next;do{if((_.tag&m)===m){var C=_.create;_.destroy=C()}_=_.next}while(_!==g)}}function sw(m){var g=m.ref;if(g!==null){var _=m.stateNode;switch(m.tag){case 5:m=Z(_);break;default:m=_}typeof g=="function"?g(m):g.current=m}}function p3(m,g,_){if(ia&&typeof ia.onCommitFiberUnmount=="function")try{ia.onCommitFiberUnmount(sy,g)}catch{}switch(g.tag){case 0:case 11:case 14:case 15:if(m=g.updateQueue,m!==null&&(m=m.lastEffect,m!==null)){var C=m=m.next;do{var R=C,D=R.destroy;R=R.tag,D!==void 0&&(R&2||R&4)&&iw(g,_,D),C=C.next}while(C!==m)}break;case 1:if(Iy(g,_),m=g.stateNode,typeof m.componentWillUnmount=="function")try{m.props=g.memoizedProps,m.state=g.memoizedState,m.componentWillUnmount()}catch(Q){Wi(g,_,Q)}break;case 5:Iy(g,_);break;case 4:te?b3(m,g,_):be&&be&&(g=g.stateNode.containerInfo,_=hn(g),Jt(g,_))}}function m3(m,g,_){for(var C=g;;)if(p3(m,C,_),C.child===null||te&&C.tag===4){if(C===g)break;for(;C.sibling===null;){if(C.return===null||C.return===g)return;C=C.return}C.sibling.return=C.return,C=C.sibling}else C.child.return=C,C=C.child}function g3(m){var g=m.alternate;g!==null&&(m.alternate=null,g3(g)),m.child=null,m.deletions=null,m.sibling=null,m.tag===5&&(g=m.stateNode,g!==null&&V(g)),m.stateNode=null,m.return=null,m.dependencies=null,m.memoizedProps=null,m.memoizedState=null,m.pendingProps=null,m.stateNode=null,m.updateQueue=null}function y3(m){return m.tag===5||m.tag===3||m.tag===4}function v3(m){e:for(;;){for(;m.sibling===null;){if(m.return===null||y3(m.return))return null;m=m.return}for(m.sibling.return=m.return,m=m.sibling;m.tag!==5&&m.tag!==6&&m.tag!==18;){if(m.flags&2||m.child===null||m.tag===4)continue e;m.child.return=m,m=m.child}if(!(m.flags&2))return m.stateNode}}function x3(m){if(te){e:{for(var g=m.return;g!==null;){if(y3(g))break e;g=g.return}throw Error(o(160))}var _=g;switch(_.tag){case 5:g=_.stateNode,_.flags&32&&(_e(g),_.flags&=-33),_=v3(m),aw(m,_,g);break;case 3:case 4:g=_.stateNode.containerInfo,_=v3(m),ow(m,_,g);break;default:throw Error(o(161))}}}function ow(m,g,_){var C=m.tag;if(C===5||C===6)m=m.stateNode,g?yt(_,m,g):$e(_,m);else if(C!==4&&(m=m.child,m!==null))for(ow(m,g,_),m=m.sibling;m!==null;)ow(m,g,_),m=m.sibling}function aw(m,g,_){var C=m.tag;if(C===5||C===6)m=m.stateNode,g?Ge(_,m,g):Fe(_,m);else if(C!==4&&(m=m.child,m!==null))for(aw(m,g,_),m=m.sibling;m!==null;)aw(m,g,_),m=m.sibling}function b3(m,g,_){for(var C=g,R=!1,D,Q;;){if(!R){R=C.return;e:for(;;){if(R===null)throw Error(o(160));switch(D=R.stateNode,R.tag){case 5:Q=!1;break e;case 3:D=D.containerInfo,Q=!0;break e;case 4:D=D.containerInfo,Q=!0;break e}R=R.return}R=!0}if(C.tag===5||C.tag===6)m3(m,C,_),Q?ie(D,C.stateNode):_t(D,C.stateNode);else if(C.tag===18)Q?tt(D,C.stateNode):xe(D,C.stateNode);else if(C.tag===4){if(C.child!==null){D=C.stateNode.containerInfo,Q=!0,C.child.return=C,C=C.child;continue}}else if(p3(m,C,_),C.child!==null){C.child.return=C,C=C.child;continue}if(C===g)break;for(;C.sibling===null;){if(C.return===null||C.return===g)return;C=C.return,C.tag===4&&(R=!1)}C.sibling.return=C.return,C=C.sibling}}function lw(m,g){if(te){switch(g.tag){case 0:case 11:case 14:case 15:qc(3,g,g.return),Xp(3,g),qc(5,g,g.return);return;case 1:return;case 5:var _=g.stateNode;if(_!=null){var C=g.memoizedProps;m=m!==null?m.memoizedProps:C;var R=g.type,D=g.updateQueue;g.updateQueue=null,D!==null&&Pt(_,D,R,m,C,g)}return;case 6:if(g.stateNode===null)throw Error(o(162));_=g.memoizedProps,Ze(g.stateNode,m!==null?m.memoizedProps:_,_);return;case 3:ce&&m!==null&&m.memoizedState.isDehydrated&&Se(g.stateNode.containerInfo);return;case 12:return;case 13:Ny(g);return;case 19:Ny(g);return;case 17:return}throw Error(o(163))}switch(g.tag){case 0:case 11:case 14:case 15:qc(3,g,g.return),Xp(3,g),qc(5,g,g.return);return;case 12:return;case 13:Ny(g);return;case 19:Ny(g);return;case 3:ce&&m!==null&&m.memoizedState.isDehydrated&&Se(g.stateNode.containerInfo);break;case 22:case 23:return}e:if(be){switch(g.tag){case 1:case 5:case 6:break e;case 3:case 4:g=g.stateNode,Jt(g.containerInfo,g.pendingChildren);break e}throw Error(o(163))}}function Ny(m){var g=m.updateQueue;if(g!==null){m.updateQueue=null;var _=m.stateNode;_===null&&(_=m.stateNode=new GW),g.forEach(function(C){var R=ZW.bind(null,m,C);_.has(C)||(_.add(C),C.then(R,R))})}}function VW(m,g){for(et=g;et!==null;){g=et;var _=g.deletions;if(_!==null)for(var C=0;C<_.length;C++){var R=_[C];try{var D=m;te?b3(D,R,g):m3(D,R,g);var Q=R.alternate;Q!==null&&(Q.return=null),R.return=null}catch(vt){Wi(R,g,vt)}}if(_=g.child,g.subtreeFlags&12854&&_!==null)_.return=g,et=_;else for(;et!==null;){g=et;try{var ae=g.flags;if(ae&32&&te&&_e(g.stateNode),ae&512){var Te=g.alternate;if(Te!==null){var He=Te.ref;He!==null&&(typeof He=="function"?He(null):He.current=null)}}if(ae&8192)switch(g.tag){case 13:if(g.memoizedState!==null){var dt=g.alternate;(dt===null||dt.memoizedState===null)&&(mw=Or())}break;case 22:var Dt=g.memoizedState!==null,wt=g.alternate,Cn=wt!==null&&wt.memoizedState!==null;if(_=g,te){e:if(C=_,R=Dt,D=null,te)for(var bt=C;;){if(bt.tag===5){if(D===null){D=bt;var oi=bt.stateNode;R?J(oi):Be(bt.stateNode,bt.memoizedProps)}}else if(bt.tag===6){if(D===null){var Xs=bt.stateNode;R?De(Xs):ut(Xs,bt.memoizedProps)}}else if((bt.tag!==22&&bt.tag!==23||bt.memoizedState===null||bt===C)&&bt.child!==null){bt.child.return=bt,bt=bt.child;continue}if(bt===C)break;for(;bt.sibling===null;){if(bt.return===null||bt.return===C)break e;D===bt&&(D=null),bt=bt.return}D===bt&&(D=null),bt.sibling.return=bt.return,bt=bt.sibling}}if(Dt&&!Cn&&_.mode&1){et=_;for(var me=_.child;me!==null;){for(_=et=me;et!==null;){C=et;var le=C.child;switch(C.tag){case 0:case 11:case 14:case 15:qc(4,C,C.return);break;case 1:Iy(C,C.return);var Ce=C.stateNode;if(typeof Ce.componentWillUnmount=="function"){var rt=C.return;try{Ce.props=C.memoizedProps,Ce.state=C.memoizedState,Ce.componentWillUnmount()}catch(vt){Wi(C,rt,vt)}}break;case 5:Iy(C,C.return);break;case 22:if(C.memoizedState!==null){w3(_);continue}}le!==null?(le.return=C,et=le):w3(_)}me=me.sibling}}}switch(ae&4102){case 2:x3(g),g.flags&=-3;break;case 6:x3(g),g.flags&=-3,lw(g.alternate,g);break;case 4096:g.flags&=-4097;break;case 4100:g.flags&=-4097,lw(g.alternate,g);break;case 4:lw(g.alternate,g)}}catch(vt){Wi(g,g.return,vt)}if(_=g.sibling,_!==null){_.return=g.return,et=_;break}et=g.return}}}function WW(m,g,_){et=m,S3(m)}function S3(m,g,_){for(var C=(m.mode&1)!==0;et!==null;){var R=et,D=R.child;if(R.tag===22&&C){var Q=R.memoizedState!==null||Ry;if(!Q){var ae=R.alternate,Te=ae!==null&&ae.memoizedState!==null||Kc;ae=Ry;var He=Kc;if(Ry=Q,(Kc=Te)&&!He)for(et=R;et!==null;)Q=et,Te=Q.child,Q.tag===22&&Q.memoizedState!==null?C3(R):Te!==null?(Te.return=Q,et=Te):C3(R);for(;D!==null;)et=D,S3(D),D=D.sibling;et=R,Ry=ae,Kc=He}_3(m)}else R.subtreeFlags&8772&&D!==null?(D.return=R,et=D):_3(m)}}function _3(m){for(;et!==null;){var g=et;if(g.flags&8772){var _=g.alternate;try{if(g.flags&8772)switch(g.tag){case 0:case 11:case 15:Kc||Xp(5,g);break;case 1:var C=g.stateNode;if(g.flags&4&&!Kc)if(_===null)C.componentDidMount();else{var R=g.elementType===g.type?_.memoizedProps:Eo(g.type,_.memoizedProps);C.componentDidUpdate(R,_.memoizedState,C.__reactInternalSnapshotBeforeUpdate)}var D=g.updateQueue;D!==null&&gN(g,D,C);break;case 3:var Q=g.updateQueue;if(Q!==null){if(_=null,g.child!==null)switch(g.child.tag){case 5:_=Z(g.child.stateNode);break;case 1:_=g.child.stateNode}gN(g,Q,_)}break;case 5:var ae=g.stateNode;_===null&&g.flags&4&&ot(ae,g.type,g.memoizedProps,g);break;case 6:break;case 4:break;case 12:break;case 13:if(ce&&g.memoizedState===null){var Te=g.alternate;if(Te!==null){var He=Te.memoizedState;if(He!==null){var dt=He.dehydrated;dt!==null&&we(dt)}}}break;case 19:case 17:case 21:case 22:case 23:break;default:throw Error(o(163))}Kc||g.flags&512&&sw(g)}catch(Dt){Wi(g,g.return,Dt)}}if(g===m){et=null;break}if(_=g.sibling,_!==null){_.return=g.return,et=_;break}et=g.return}}function w3(m){for(;et!==null;){var g=et;if(g===m){et=null;break}var _=g.sibling;if(_!==null){_.return=g.return,et=_;break}et=g.return}}function C3(m){for(;et!==null;){var g=et;try{switch(g.tag){case 0:case 11:case 15:var _=g.return;try{Xp(4,g)}catch(Te){Wi(g,_,Te)}break;case 1:var C=g.stateNode;if(typeof C.componentDidMount=="function"){var R=g.return;try{C.componentDidMount()}catch(Te){Wi(g,R,Te)}}var D=g.return;try{sw(g)}catch(Te){Wi(g,D,Te)}break;case 5:var Q=g.return;try{sw(g)}catch(Te){Wi(g,Q,Te)}}}catch(Te){Wi(g,g.return,Te)}if(g===m){et=null;break}var ae=g.sibling;if(ae!==null){ae.return=g.return,et=ae;break}et=g.return}}var Py=0,ky=1,Dy=2,Oy=3,Ly=4;if(typeof Symbol=="function"&&Symbol.for){var Kp=Symbol.for;Py=Kp("selector.component"),ky=Kp("selector.has_pseudo_class"),Dy=Kp("selector.role"),Oy=Kp("selector.test_id"),Ly=Kp("selector.text")}function cw(m){var g=Me(m);if(g!=null){if(typeof g.memoizedProps["data-testname"]!="string")throw Error(o(364));return g}if(m=ve(m),m===null)throw Error(o(362));return m.stateNode.current}function uw(m,g){switch(g.$$typeof){case Py:if(m.type===g.value)return!0;break;case ky:e:{g=g.value,m=[m,0];for(var _=0;_<m.length;){var C=m[_++],R=m[_++],D=g[R];if(C.tag!==5||!Ae(C)){for(;D!=null&&uw(C,D);)R++,D=g[R];if(R===g.length){g=!0;break e}else for(C=C.child;C!==null;)m.push(C,R),C=C.sibling}}g=!1}return g;case Dy:if(m.tag===5&&st(m.stateNode,g.value))return!0;break;case Ly:if((m.tag===5||m.tag===6)&&(m=nt(m),m!==null&&0<=m.indexOf(g.value)))return!0;break;case Oy:if(m.tag===5&&(m=m.memoizedProps["data-testname"],typeof m=="string"&&m.toLowerCase()===g.value.toLowerCase()))return!0;break;default:throw Error(o(365))}return!1}function dw(m){switch(m.$$typeof){case Py:return"<"+(T(m.value)||"Unknown")+">";case ky:return":has("+(dw(m)||"")+")";case Dy:return'[role="'+m.value+'"]';case Ly:return'"'+m.value+'"';case Oy:return'[data-testname="'+m.value+'"]';default:throw Error(o(365))}}function E3(m,g){var _=[];m=[m,0];for(var C=0;C<m.length;){var R=m[C++],D=m[C++],Q=g[D];if(R.tag!==5||!Ae(R)){for(;Q!=null&&uw(R,Q);)D++,Q=g[D];if(D===g.length)_.push(R);else for(R=R.child;R!==null;)m.push(R,D),R=R.sibling}}return _}function fw(m,g){if(!ye)throw Error(o(363));m=cw(m),m=E3(m,g),g=[],m=Array.from(m);for(var _=0;_<m.length;){var C=m[_++];if(C.tag===5)Ae(C)||g.push(C.stateNode);else for(C=C.child;C!==null;)m.push(C),C=C.sibling}return g}var jW=Math.ceil,By=a.ReactCurrentDispatcher,hw=a.ReactCurrentOwner,ur=a.ReactCurrentBatchConfig,Wt=0,yr=null,vr=null,qr=0,ps=0,ef=rn(0),Ar=0,qp=null,tf=0,Fy=0,pw=0,Jp=null,Hi=null,mw=0,gw=1/0;function nf(){gw=Or()+500}var $y=!1,yw=null,Ll=null,Uy=!1,Bl=null,zy=0,Yp=0,vw=null,Gy=-1,Hy=0;function Mi(){return Wt&6?Or():Gy!==-1?Gy:Gy=Or()}function Fl(m){return m.mode&1?Wt&2&&qr!==0?qr&-qr:MW.transition!==null?(Hy===0&&(m=ny,ny<<=1,!(ny&4194240)&&(ny=64),Hy=m),Hy):(m=sn,m!==0?m:Oe()):1}function Ws(m,g,_){if(50<Yp)throw Yp=0,vw=null,Error(o(185));var C=Vy(m,g);return C===null?null:(Dp(C,g,_),(!(Wt&2)||C!==yr)&&(C===yr&&(!(Wt&2)&&(Fy|=g),Ar===4&&$l(C,qr)),Vi(C,_),g===1&&Wt===0&&!(m.mode&1)&&(nf(),oy&&oa())),C)}function Vy(m,g){m.lanes|=g;var _=m.alternate;for(_!==null&&(_.lanes|=g),_=m,m=m.return;m!==null;)m.childLanes|=g,_=m.alternate,_!==null&&(_.childLanes|=g),_=m,m=m.return;return _.tag===3?_.stateNode:null}function Vi(m,g){var _=m.callbackNode;xW(m,g);var C=iy(m,m===yr?qr:0);if(C===0)_!==null&&dN(_),m.callbackNode=null,m.callbackPriority=0;else if(g=C&-C,m.callbackPriority!==g){if(_!=null&&dN(_),g===1)m.tag===0?TW(T3.bind(null,m)):fN(T3.bind(null,m)),$?ue(function(){Wt===0&&oa()}):A_(T_,oa),_=null;else{switch(uN(C)){case 1:_=T_;break;case 4:_=wW;break;case 16:_=M_;break;case 536870912:_=CW;break;default:_=M_}_=L3(_,A3.bind(null,m))}m.callbackPriority=g,m.callbackNode=_}}function A3(m,g){if(Gy=-1,Hy=0,Wt&6)throw Error(o(327));var _=m.callbackNode;if(Qc()&&m.callbackNode!==_)return null;var C=iy(m,m===yr?qr:0);if(C===0)return null;if(C&30||C&m.expiredLanes||g)g=Wy(m,C);else{g=C;var R=Wt;Wt|=2;var D=I3();(yr!==m||qr!==g)&&(nf(),Jc(m,g));do try{qW();break}catch(ae){R3(m,ae)}while(!0);N_(),By.current=D,Wt=R,vr!==null?g=0:(yr=null,qr=0,g=Ar)}if(g!==0){if(g===2&&(R=w_(m),R!==0&&(C=R,g=xw(m,R))),g===1)throw _=qp,Jc(m,0),$l(m,C),Vi(m,Or()),_;if(g===6)$l(m,C);else{if(R=m.current.alternate,!(C&30)&&!XW(R)&&(g=Wy(m,C),g===2&&(D=w_(m),D!==0&&(C=D,g=xw(m,D))),g===1))throw _=qp,Jc(m,0),$l(m,C),Vi(m,Or()),_;switch(m.finishedWork=R,m.finishedLanes=C,g){case 0:case 1:throw Error(o(345));case 2:Yc(m,Hi);break;case 3:if($l(m,C),(C&130023424)===C&&(g=mw+500-Or(),10<g)){if(iy(m,0)!==0)break;if(R=m.suspendedLanes,(R&C)!==C){Mi(),m.pingedLanes|=m.suspendedLanes&R;break}m.timeoutHandle=Ee(Yc.bind(null,m,Hi),g);break}Yc(m,Hi);break;case 4:if($l(m,C),(C&4194240)===C)break;for(g=m.eventTimes,R=-1;0<C;){var Q=31-Gi(C);D=1<<Q,Q=g[Q],Q>R&&(R=Q),C&=~D}if(C=R,C=Or()-C,C=(120>C?120:480>C?480:1080>C?1080:1920>C?1920:3e3>C?3e3:4320>C?4320:1960*jW(C/1960))-C,10<C){m.timeoutHandle=Ee(Yc.bind(null,m,Hi),C);break}Yc(m,Hi);break;case 5:Yc(m,Hi);break;default:throw Error(o(329))}}}return Vi(m,Or()),m.callbackNode===_?A3.bind(null,m):null}function xw(m,g){var _=Jp;return m.current.memoizedState.isDehydrated&&(Jc(m,g).flags|=256),m=Wy(m,g),m!==2&&(g=Hi,Hi=_,g!==null&&bw(g)),m}function bw(m){Hi===null?Hi=m:Hi.push.apply(Hi,m)}function XW(m){for(var g=m;;){if(g.flags&16384){var _=g.updateQueue;if(_!==null&&(_=_.stores,_!==null))for(var C=0;C<_.length;C++){var R=_[C],D=R.getSnapshot;R=R.value;try{if(!sa(D(),R))return!1}catch{return!1}}}if(_=g.child,g.subtreeFlags&16384&&_!==null)_.return=g,g=_;else{if(g===m)break;for(;g.sibling===null;){if(g.return===null||g.return===m)return!0;g=g.return}g.sibling.return=g.return,g=g.sibling}}return!0}function $l(m,g){for(g&=~pw,g&=~Fy,m.suspendedLanes|=g,m.pingedLanes&=~g,m=m.expirationTimes;0<g;){var _=31-Gi(g),C=1<<_;m[_]=-1,g&=~C}}function T3(m){if(Wt&6)throw Error(o(327));Qc();var g=iy(m,0);if(!(g&1))return Vi(m,Or()),null;var _=Wy(m,g);if(m.tag!==0&&_===2){var C=w_(m);C!==0&&(g=C,_=xw(m,C))}if(_===1)throw _=qp,Jc(m,0),$l(m,g),Vi(m,Or()),_;if(_===6)throw Error(o(345));return m.finishedWork=m.current.alternate,m.finishedLanes=g,Yc(m,Hi),Vi(m,Or()),null}function M3(m){Bl!==null&&Bl.tag===0&&!(Wt&6)&&Qc();var g=Wt;Wt|=1;var _=ur.transition,C=sn;try{if(ur.transition=null,sn=1,m)return m()}finally{sn=C,ur.transition=_,Wt=g,!(Wt&6)&&oa()}}function Sw(){ps=ef.current,at(ef)}function Jc(m,g){m.finishedWork=null,m.finishedLanes=0;var _=m.timeoutHandle;if(_!==je&&(m.timeoutHandle=je,We(_)),vr!==null)for(_=vr.return;_!==null;){var C=_;switch(F_(C),C.tag){case 1:C=C.type.childContextTypes,C!=null&&us();break;case 3:Qd(),at(Kr),at(Fn),W_();break;case 5:H_(C);break;case 4:Qd();break;case 13:at(Wn);break;case 19:at(Wn);break;case 10:P_(C.type._context);break;case 22:case 23:Sw()}_=_.return}if(yr=m,vr=m=Ul(m.current,null),qr=ps=g,Ar=0,qp=null,pw=Fy=tf=0,Hi=Jp=null,aa!==null){for(g=0;g<aa.length;g++)if(_=aa[g],C=_.interleaved,C!==null){_.interleaved=null;var R=C.next,D=_.pending;if(D!==null){var Q=D.next;D.next=R,C.next=Q}_.pending=C}aa=null}return m}function R3(m,g){do{var _=vr;try{if(N_(),yy.current=wy,vy){for(var C=er.memoizedState;C!==null;){var R=C.queue;R!==null&&(R.pending=null),C=C.next}vy=!1}if(Zd=0,Lr=ri=er=null,Up=!1,zp=0,hw.current=null,_===null||_.return===null){Ar=1,qp=g,vr=null;break}e:{var D=m,Q=_.return,ae=_,Te=g;if(g=qr,ae.flags|=32768,Te!==null&&typeof Te=="object"&&typeof Te.then=="function"){var He=Te,dt=ae,Dt=dt.tag;if(!(dt.mode&1)&&(Dt===0||Dt===11||Dt===15)){var wt=dt.alternate;wt?(dt.updateQueue=wt.updateQueue,dt.memoizedState=wt.memoizedState,dt.lanes=wt.lanes):(dt.updateQueue=null,dt.memoizedState=null)}var Cn=JN(Q);if(Cn!==null){Cn.flags&=-257,YN(Cn,Q,ae,D,g),Cn.mode&1&&qN(D,He,g),g=Cn,Te=He;var bt=g.updateQueue;if(bt===null){var oi=new Set;oi.add(Te),g.updateQueue=oi}else bt.add(Te);break e}else{if(!(g&1)){qN(D,He,g),_w();break e}Te=Error(o(426))}}else if($n&&ae.mode&1){var Xs=JN(Q);if(Xs!==null){!(Xs.flags&65536)&&(Xs.flags|=256),YN(Xs,Q,ae,D,g),z_(Te);break e}}D=Te,Ar!==4&&(Ar=2),Jp===null?Jp=[D]:Jp.push(D),Te=Q_(Te,ae),ae=Q;do{switch(ae.tag){case 3:ae.flags|=65536,g&=-g,ae.lanes|=g;var me=XN(ae,Te,g);mN(ae,me);break e;case 1:D=Te;var le=ae.type,Ce=ae.stateNode;if(!(ae.flags&128)&&(typeof le.getDerivedStateFromError=="function"||Ce!==null&&typeof Ce.componentDidCatch=="function"&&(Ll===null||!Ll.has(Ce)))){ae.flags|=65536,g&=-g,ae.lanes|=g;var rt=KN(ae,D,g);mN(ae,rt);break e}}ae=ae.return}while(ae!==null)}P3(_)}catch(vt){g=vt,vr===_&&_!==null&&(vr=_=_.return);continue}break}while(!0)}function I3(){var m=By.current;return By.current=wy,m===null?wy:m}function _w(){(Ar===0||Ar===3||Ar===2)&&(Ar=4),yr===null||!(tf&268435455)&&!(Fy&268435455)||$l(yr,qr)}function Wy(m,g){var _=Wt;Wt|=2;var C=I3();yr===m&&qr===g||Jc(m,g);do try{KW();break}catch(R){R3(m,R)}while(!0);if(N_(),Wt=_,By.current=C,vr!==null)throw Error(o(261));return yr=null,qr=0,Ar}function KW(){for(;vr!==null;)N3(vr)}function qW(){for(;vr!==null&&!SW();)N3(vr)}function N3(m){var g=O3(m.alternate,m,ps);m.memoizedProps=m.pendingProps,g===null?P3(m):vr=g,hw.current=null}function P3(m){var g=m;do{var _=g.alternate;if(m=g.return,g.flags&32768){if(_=zW(_,g),_!==null){_.flags&=32767,vr=_;return}if(m!==null)m.flags|=32768,m.subtreeFlags=0,m.deletions=null;else{Ar=6,vr=null;return}}else if(_=FW(_,g,ps),_!==null){vr=_;return}if(g=g.sibling,g!==null){vr=g;return}vr=g=m}while(g!==null);Ar===0&&(Ar=5)}function Yc(m,g){var _=sn,C=ur.transition;try{ur.transition=null,sn=1,JW(m,g,_)}finally{ur.transition=C,sn=_}return null}function JW(m,g,_){do Qc();while(Bl!==null);if(Wt&6)throw Error(o(327));var C=m.finishedWork,R=m.finishedLanes;if(C===null)return null;if(m.finishedWork=null,m.finishedLanes=0,C===m.current)throw Error(o(177));m.callbackNode=null,m.callbackPriority=0;var D=C.lanes|C.childLanes;if(bW(m,D),m===yr&&(vr=yr=null,qr=0),!(C.subtreeFlags&2064)&&!(C.flags&2064)||Uy||(Uy=!0,L3(M_,function(){return Qc(),null})),D=(C.flags&15990)!==0,C.subtreeFlags&15990||D){D=ur.transition,ur.transition=null;var Q=sn;sn=1;var ae=Wt;Wt|=4,hw.current=null,HW(m,C),VW(m,C),q(m.containerInfo),m.current=C,WW(C),_W(),Wt=ae,sn=Q,ur.transition=D}else m.current=C;if(Uy&&(Uy=!1,Bl=m,zy=R),D=m.pendingLanes,D===0&&(Ll=null),EW(C.stateNode),Vi(m,Or()),g!==null)for(_=m.onRecoverableError,C=0;C<g.length;C++)_(g[C]);if($y)throw $y=!1,m=yw,yw=null,m;return zy&1&&m.tag!==0&&Qc(),D=m.pendingLanes,D&1?m===vw?Yp++:(Yp=0,vw=m):Yp=0,oa(),null}function Qc(){if(Bl!==null){var m=uN(zy),g=ur.transition,_=sn;try{if(ur.transition=null,sn=16>m?16:m,Bl===null)var C=!1;else{if(m=Bl,Bl=null,zy=0,Wt&6)throw Error(o(331));var R=Wt;for(Wt|=4,et=m.current;et!==null;){var D=et,Q=D.child;if(et.flags&16){var ae=D.deletions;if(ae!==null){for(var Te=0;Te<ae.length;Te++){var He=ae[Te];for(et=He;et!==null;){var dt=et;switch(dt.tag){case 0:case 11:case 15:qc(8,dt,D)}var Dt=dt.child;if(Dt!==null)Dt.return=dt,et=Dt;else for(;et!==null;){dt=et;var wt=dt.sibling,Cn=dt.return;if(g3(dt),dt===He){et=null;break}if(wt!==null){wt.return=Cn,et=wt;break}et=Cn}}}var bt=D.alternate;if(bt!==null){var oi=bt.child;if(oi!==null){bt.child=null;do{var Xs=oi.sibling;oi.sibling=null,oi=Xs}while(oi!==null)}}et=D}}if(D.subtreeFlags&2064&&Q!==null)Q.return=D,et=Q;else e:for(;et!==null;){if(D=et,D.flags&2048)switch(D.tag){case 0:case 11:case 15:qc(9,D,D.return)}var me=D.sibling;if(me!==null){me.return=D.return,et=me;break e}et=D.return}}var le=m.current;for(et=le;et!==null;){Q=et;var Ce=Q.child;if(Q.subtreeFlags&2064&&Ce!==null)Ce.return=Q,et=Ce;else e:for(Q=le;et!==null;){if(ae=et,ae.flags&2048)try{switch(ae.tag){case 0:case 11:case 15:Xp(9,ae)}}catch(vt){Wi(ae,ae.return,vt)}if(ae===Q){et=null;break e}var rt=ae.sibling;if(rt!==null){rt.return=ae.return,et=rt;break e}et=ae.return}}if(Wt=R,oa(),ia&&typeof ia.onPostCommitFiberRoot=="function")try{ia.onPostCommitFiberRoot(sy,m)}catch{}C=!0}return C}finally{sn=_,ur.transition=g}}return!1}function k3(m,g,_){g=Q_(_,g),g=XN(m,g,1),Ol(m,g),g=Mi(),m=Vy(m,1),m!==null&&(Dp(m,1,g),Vi(m,g))}function Wi(m,g,_){if(m.tag===3)k3(m,m,_);else for(;g!==null;){if(g.tag===3){k3(g,m,_);break}else if(g.tag===1){var C=g.stateNode;if(typeof g.type.getDerivedStateFromError=="function"||typeof C.componentDidCatch=="function"&&(Ll===null||!Ll.has(C))){m=Q_(_,m),m=KN(g,m,1),Ol(g,m),m=Mi(),g=Vy(g,1),g!==null&&(Dp(g,1,m),Vi(g,m));break}}g=g.return}}function YW(m,g,_){var C=m.pingCache;C!==null&&C.delete(g),g=Mi(),m.pingedLanes|=m.suspendedLanes&_,yr===m&&(qr&_)===_&&(Ar===4||Ar===3&&(qr&130023424)===qr&&500>Or()-mw?Jc(m,0):pw|=_),Vi(m,g)}function D3(m,g){g===0&&(m.mode&1?(g=ry,ry<<=1,!(ry&130023424)&&(ry=4194304)):g=1);var _=Mi();m=Vy(m,g),m!==null&&(Dp(m,g,_),Vi(m,_))}function QW(m){var g=m.memoizedState,_=0;g!==null&&(_=g.retryLane),D3(m,_)}function ZW(m,g){var _=0;switch(m.tag){case 13:var C=m.stateNode,R=m.memoizedState;R!==null&&(_=R.retryLane);break;case 19:C=m.stateNode;break;default:throw Error(o(314))}C!==null&&C.delete(g),D3(m,_)}var O3;O3=function(m,g,_){if(m!==null)if(m.memoizedProps!==g.pendingProps||Kr.current)hs=!0;else{if(!(m.lanes&_)&&!(g.flags&128))return hs=!1,UW(m,g,_);hs=!!(m.flags&131072)}else hs=!1,$n&&g.flags&1048576&&SN(g,py,g.index);switch(g.lanes=0,g.tag){case 2:var C=g.type;m!==null&&(m.alternate=null,g.alternate=null,g.flags|=2),m=g.pendingProps;var R=ra(g,Fn.current);jd(g,_),R=X_(null,g,C,m,R,_);var D=K_();return g.flags|=1,typeof R=="object"&&R!==null&&typeof R.render=="function"&&R.$$typeof===void 0?(g.tag=1,g.memoizedState=null,g.updateQueue=null,cn(C)?(D=!0,kl(g)):D=!1,g.memoizedState=R.state!==null&&R.state!==void 0?R.state:null,D_(g),R.updater=fy,g.stateNode=R,R._reactInternals=g,L_(g,C,m,_),g=tw(null,g,C,!0,D,_)):(g.tag=0,$n&&D&&B_(g),Ti(null,g,R,_),g=g.child),g;case 16:C=g.elementType;e:{switch(m!==null&&(m.alternate=null,g.alternate=null,g.flags|=2),m=g.pendingProps,R=C._init,C=R(C._payload),g.type=C,R=g.tag=tj(C),m=Eo(C,m),R){case 0:g=ew(null,g,C,m,_);break e;case 1:g=s3(null,g,C,m,_);break e;case 11:g=e3(null,g,C,m,_);break e;case 14:g=t3(null,g,C,Eo(C.type,m),_);break e}throw Error(o(306,C,""))}return g;case 0:return C=g.type,R=g.pendingProps,R=g.elementType===C?R:Eo(C,R),ew(m,g,C,R,_);case 1:return C=g.type,R=g.pendingProps,R=g.elementType===C?R:Eo(C,R),s3(m,g,C,R,_);case 3:e:{if(o3(g),m===null)throw Error(o(387));C=g.pendingProps,D=g.memoizedState,R=D.element,pN(m,g),dy(g,C,null,_);var Q=g.memoizedState;if(C=Q.element,ce&&D.isDehydrated)if(D={element:C,isDehydrated:!1,cache:Q.cache,transitions:Q.transitions},g.updateQueue.baseState=D,g.memoizedState=D,g.flags&256){R=Error(o(423)),g=a3(m,g,C,_,R);break e}else if(C!==R){R=Error(o(424)),g=a3(m,g,C,_,R);break e}else for(ce&&(fs=ey(g.stateNode.containerInfo),ds=g,$n=!0,Ao=null,Op=!1),_=TN(g,null,C,_),g.child=_;_;)_.flags=_.flags&-3|4096,_=_.sibling;else{if(qd(),C===R){g=za(m,g,_);break e}Ti(m,g,C,_)}g=g.child}return g;case 5:return MN(g),m===null&&U_(g),C=g.type,R=g.pendingProps,D=m!==null?m.memoizedProps:null,Q=R.children,pe(C,R)?Q=null:D!==null&&pe(C,D)&&(g.flags|=32),i3(m,g),Ti(m,g,Q,_),g.child;case 6:return m===null&&U_(g),null;case 13:return l3(m,g,_);case 4:return G_(g,g.stateNode.containerInfo),C=g.pendingProps,m===null?g.child=Jd(g,null,C,_):Ti(m,g,C,_),g.child;case 11:return C=g.type,R=g.pendingProps,R=g.elementType===C?R:Eo(C,R),e3(m,g,C,R,_);case 7:return Ti(m,g,g.pendingProps,_),g.child;case 8:return Ti(m,g,g.pendingProps.children,_),g.child;case 12:return Ti(m,g,g.pendingProps.children,_),g.child;case 10:e:{if(C=g.type._context,R=g.pendingProps,D=g.memoizedProps,Q=R.value,hN(g,C,Q),D!==null)if(sa(D.value,Q)){if(D.children===R.children&&!Kr.current){g=za(m,g,_);break e}}else for(D=g.child,D!==null&&(D.return=g);D!==null;){var ae=D.dependencies;if(ae!==null){Q=D.child;for(var Te=ae.firstContext;Te!==null;){if(Te.context===C){if(D.tag===1){Te=Ba(-1,_&-_),Te.tag=2;var He=D.updateQueue;if(He!==null){He=He.shared;var dt=He.pending;dt===null?Te.next=Te:(Te.next=dt.next,dt.next=Te),He.pending=Te}}D.lanes|=_,Te=D.alternate,Te!==null&&(Te.lanes|=_),k_(D.return,_,g),ae.lanes|=_;break}Te=Te.next}}else if(D.tag===10)Q=D.type===g.type?null:D.child;else if(D.tag===18){if(Q=D.return,Q===null)throw Error(o(341));Q.lanes|=_,ae=Q.alternate,ae!==null&&(ae.lanes|=_),k_(Q,_,g),Q=D.sibling}else Q=D.child;if(Q!==null)Q.return=D;else for(Q=D;Q!==null;){if(Q===g){Q=null;break}if(D=Q.sibling,D!==null){D.return=Q.return,Q=D;break}Q=Q.return}D=Q}Ti(m,g,R.children,_),g=g.child}return g;case 9:return R=g.type,C=g.pendingProps.children,jd(g,_),R=Us(R),C=C(R),g.flags|=1,Ti(m,g,C,_),g.child;case 14:return C=g.type,R=Eo(C,g.pendingProps),R=Eo(C.type,R),t3(m,g,C,R,_);case 15:return n3(m,g,g.type,g.pendingProps,_);case 17:return C=g.type,R=g.pendingProps,R=g.elementType===C?R:Eo(C,R),m!==null&&(m.alternate=null,g.alternate=null,g.flags|=2),g.tag=1,cn(C)?(m=!0,kl(g)):m=!1,jd(g,_),xN(g,C,R),L_(g,C,R,_),tw(null,g,C,!0,m,_);case 19:return f3(m,g,_);case 22:return r3(m,g,_)}throw Error(o(156,g.tag))};function L3(m,g){return A_(m,g)}function ej(m,g,_,C){this.tag=m,this.key=_,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=g,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=C,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function js(m,g,_,C){return new ej(m,g,_,C)}function ww(m){return m=m.prototype,!(!m||!m.isReactComponent)}function tj(m){if(typeof m=="function")return ww(m)?1:0;if(m!=null){if(m=m.$$typeof,m===x)return 11;if(m===b)return 14}return 2}function Ul(m,g){var _=m.alternate;return _===null?(_=js(m.tag,g,m.key,m.mode),_.elementType=m.elementType,_.type=m.type,_.stateNode=m.stateNode,_.alternate=m,m.alternate=_):(_.pendingProps=g,_.type=m.type,_.flags=0,_.subtreeFlags=0,_.deletions=null),_.flags=m.flags&14680064,_.childLanes=m.childLanes,_.lanes=m.lanes,_.child=m.child,_.memoizedProps=m.memoizedProps,_.memoizedState=m.memoizedState,_.updateQueue=m.updateQueue,g=m.dependencies,_.dependencies=g===null?null:{lanes:g.lanes,firstContext:g.firstContext},_.sibling=m.sibling,_.index=m.index,_.ref=m.ref,_}function jy(m,g,_,C,R,D){var Q=2;if(C=m,typeof m=="function")ww(m)&&(Q=1);else if(typeof m=="string")Q=5;else e:switch(m){case u:return Zc(_.children,R,D,g);case d:Q=8,R|=8;break;case f:return m=js(12,_,g,R|2),m.elementType=f,m.lanes=D,m;case v:return m=js(13,_,g,R),m.elementType=v,m.lanes=D,m;case y:return m=js(19,_,g,R),m.elementType=y,m.lanes=D,m;case w:return Xy(_,R,D,g);default:if(typeof m=="object"&&m!==null)switch(m.$$typeof){case h:Q=10;break e;case p:Q=9;break e;case x:Q=11;break e;case b:Q=14;break e;case S:Q=16,C=null;break e}throw Error(o(130,m==null?m:typeof m,""))}return g=js(Q,_,g,R),g.elementType=m,g.type=C,g.lanes=D,g}function Zc(m,g,_,C){return m=js(7,m,C,g),m.lanes=_,m}function Xy(m,g,_,C){return m=js(22,m,C,g),m.elementType=w,m.lanes=_,m.stateNode={},m}function Cw(m,g,_){return m=js(6,m,null,g),m.lanes=_,m}function Ew(m,g,_){return g=js(4,m.children!==null?m.children:[],m.key,g),g.lanes=_,g.stateNode={containerInfo:m.containerInfo,pendingChildren:null,implementation:m.implementation},g}function nj(m,g,_,C,R){this.tag=g,this.containerInfo=m,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=je,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=C_(0),this.expirationTimes=C_(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=C_(0),this.identifierPrefix=C,this.onRecoverableError=R,ce&&(this.mutableSourceEagerHydrationData=null)}function B3(m,g,_,C,R,D,Q,ae,Te){return m=new nj(m,g,_,ae,Te),g===1?(g=1,D===!0&&(g|=8)):g=0,D=js(3,null,null,g),m.current=D,D.stateNode=m,D.memoizedState={element:C,isDehydrated:_,cache:null,transitions:null},D_(D),m}function F3(m){if(!m)return tn;m=m._reactInternals;e:{if(N(m)!==m||m.tag!==1)throw Error(o(170));var g=m;do{switch(g.tag){case 3:g=g.stateNode.context;break e;case 1:if(cn(g.type)){g=g.stateNode.__reactInternalMemoizedMergedChildContext;break e}}g=g.return}while(g!==null);throw Error(o(171))}if(m.tag===1){var _=m.type;if(cn(_))return Ai(m,_,g)}return g}function $3(m){var g=m._reactInternals;if(g===void 0)throw typeof m.render=="function"?Error(o(188)):(m=Object.keys(m).join(","),Error(o(268,m)));return m=B(g),m===null?null:m.stateNode}function U3(m,g){if(m=m.memoizedState,m!==null&&m.dehydrated!==null){var _=m.retryLane;m.retryLane=_!==0&&_<g?_:g}}function Aw(m,g){U3(m,g),(m=m.alternate)&&U3(m,g)}function rj(m){return m=B(m),m===null?null:m.stateNode}function ij(){return null}return n.attemptContinuousHydration=function(m){if(m.tag===13){var g=Mi();Ws(m,134217728,g),Aw(m,134217728)}},n.attemptHydrationAtCurrentPriority=function(m){if(m.tag===13){var g=Mi(),_=Fl(m);Ws(m,_,g),Aw(m,_)}},n.attemptSynchronousHydration=function(m){switch(m.tag){case 3:var g=m.stateNode;if(g.current.memoizedState.isDehydrated){var _=kp(g.pendingLanes);_!==0&&(E_(g,_|1),Vi(g,Or()),!(Wt&6)&&(nf(),oa()))}break;case 13:var C=Mi();M3(function(){return Ws(m,1,C)}),Aw(m,1)}},n.batchedUpdates=function(m,g){var _=Wt;Wt|=1;try{return m(g)}finally{Wt=_,Wt===0&&(nf(),oy&&oa())}},n.createComponentSelector=function(m){return{$$typeof:Py,value:m}},n.createContainer=function(m,g,_,C,R,D,Q){return B3(m,g,!1,null,_,C,R,D,Q)},n.createHasPseudoClassSelector=function(m){return{$$typeof:ky,value:m}},n.createHydrationContainer=function(m,g,_,C,R,D,Q,ae,Te){return m=B3(_,C,!0,m,R,D,Q,ae,Te),m.context=F3(null),_=m.current,C=Mi(),R=Fl(_),D=Ba(C,R),D.callback=g??null,Ol(_,D),m.current.lanes=R,Dp(m,R,C),Vi(m,C),m},n.createPortal=function(m,g,_){var C=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:c,key:C==null?null:""+C,children:m,containerInfo:g,implementation:_}},n.createRoleSelector=function(m){return{$$typeof:Dy,value:m}},n.createTestNameSelector=function(m){return{$$typeof:Oy,value:m}},n.createTextSelector=function(m){return{$$typeof:Ly,value:m}},n.deferredUpdates=function(m){var g=sn,_=ur.transition;try{return ur.transition=null,sn=16,m()}finally{sn=g,ur.transition=_}},n.discreteUpdates=function(m,g,_,C,R){var D=sn,Q=ur.transition;try{return ur.transition=null,sn=1,m(g,_,C,R)}finally{sn=D,ur.transition=Q,Wt===0&&nf()}},n.findAllNodes=fw,n.findBoundingRects=function(m,g){if(!ye)throw Error(o(363));g=fw(m,g),m=[];for(var _=0;_<g.length;_++)m.push(Ne(g[_]));for(g=m.length-1;0<g;g--){_=m[g];for(var C=_.x,R=C+_.width,D=_.y,Q=D+_.height,ae=g-1;0<=ae;ae--)if(g!==ae){var Te=m[ae],He=Te.x,dt=He+Te.width,Dt=Te.y,wt=Dt+Te.height;if(C>=He&&D>=Dt&&R<=dt&&Q<=wt){m.splice(g,1);break}else if(C!==He||_.width!==Te.width||wt<D||Dt>Q){if(!(D!==Dt||_.height!==Te.height||dt<C||He>R)){He>C&&(Te.width+=He-C,Te.x=C),dt<R&&(Te.width=R-He),m.splice(g,1);break}}else{Dt>D&&(Te.height+=Dt-D,Te.y=D),wt<Q&&(Te.height=Q-Dt),m.splice(g,1);break}}}return m},n.findHostInstance=$3,n.findHostInstanceWithNoPortals=function(m){return m=P(m),m=m!==null?U(m):null,m===null?null:m.stateNode},n.findHostInstanceWithWarning=function(m){return $3(m)},n.flushControlled=function(m){var g=Wt;Wt|=1;var _=ur.transition,C=sn;try{ur.transition=null,sn=1,m()}finally{sn=C,ur.transition=_,Wt=g,Wt===0&&(nf(),oa())}},n.flushPassiveEffects=Qc,n.flushSync=M3,n.focusWithin=function(m,g){if(!ye)throw Error(o(363));for(m=cw(m),g=E3(m,g),g=Array.from(g),m=0;m<g.length;){var _=g[m++];if(!Ae(_)){if(_.tag===5&&ht(_.stateNode))return!0;for(_=_.child;_!==null;)g.push(_),_=_.sibling}}return!1},n.getCurrentUpdatePriority=function(){return sn},n.getFindAllNodesFailureDescription=function(m,g){if(!ye)throw Error(o(363));var _=0,C=[];m=[cw(m),0];for(var R=0;R<m.length;){var D=m[R++],Q=m[R++],ae=g[Q];if((D.tag!==5||!Ae(D))&&(uw(D,ae)&&(C.push(dw(ae)),Q++,Q>_&&(_=Q)),Q<g.length))for(D=D.child;D!==null;)m.push(D,Q),D=D.sibling}if(_<g.length){for(m=[];_<g.length;_++)m.push(dw(g[_]));return`findAllNodes was able to match part of the selector:
  `+(C.join(" > ")+`

No matching component was found for:
  `)+m.join(" > ")}return null},n.getPublicRootInstance=function(m){if(m=m.current,!m.child)return null;switch(m.child.tag){case 5:return Z(m.child.stateNode);default:return m.child.stateNode}},n.injectIntoDevTools=function(m){if(m={bundleType:m.bundleType,version:m.version,rendererPackageName:m.rendererPackageName,rendererConfig:m.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:a.ReactCurrentDispatcher,findHostInstanceByFiber:rj,findFiberByHostInstance:m.findFiberByHostInstance||ij,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.0.0-fc46dba67-20220329"},typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u")m=!1;else{var g=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(g.isDisabled||!g.supportsFiber)m=!0;else{try{sy=g.inject(m),ia=g}catch{}m=!!g.checkDCE}}return m},n.isAlreadyRendering=function(){return!1},n.observeVisibleRects=function(m,g,_,C){if(!ye)throw Error(o(363));m=fw(m,g);var R=Ue(m,_,C).disconnect;return{disconnect:function(){R()}}},n.registerMutableSourceForHydration=function(m,g){var _=g._getVersion;_=_(g._source),m.mutableSourceEagerHydrationData==null?m.mutableSourceEagerHydrationData=[g,_]:m.mutableSourceEagerHydrationData.push(g,_)},n.runWithPriority=function(m,g){var _=sn;try{return sn=m,g()}finally{sn=_}},n.shouldError=function(){return null},n.shouldSuspend=function(){return!1},n.updateContainer=function(m,g,_,C){var R=g.current,D=Mi(),Q=Fl(R);return _=F3(_),g.context===null?g.context=_:g.pendingContext=_,g=Ba(D,Q),g.payload={element:m},C=C===void 0?null:C,C!==null&&(g.callback=C),Ol(R,g),m=Ws(R,Q,D),m!==null&&uy(m,R,Q),Q},n};$7.exports=WOe;var jOe=$7.exports;const XOe=Ed(jOe);var U7={exports:{}},z7={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function(t){function e(O,G){var q=O.length;O.push(G);e:for(;0<q;){var se=q-1>>>1,he=O[se];if(0<i(he,G))O[se]=G,O[q]=he,q=se;else break e}}function n(O){return O.length===0?null:O[0]}function r(O){if(O.length===0)return null;var G=O[0],q=O.pop();if(q!==G){O[0]=q;e:for(var se=0,he=O.length,ke=he>>>1;se<ke;){var re=2*(se+1)-1,pe=O[re],fe=re+1,Ee=O[fe];if(0>i(pe,q))fe<he&&0>i(Ee,pe)?(O[se]=Ee,O[fe]=q,se=fe):(O[se]=pe,O[re]=q,se=re);else if(fe<he&&0>i(Ee,q))O[se]=Ee,O[fe]=q,se=fe;else break e}}return G}function i(O,G){var q=O.sortIndex-G.sortIndex;return q!==0?q:O.id-G.id}if(typeof performance=="object"&&typeof performance.now=="function"){var s=performance;t.unstable_now=function(){return s.now()}}else{var o=Date,a=o.now();t.unstable_now=function(){return o.now()-a}}var l=[],c=[],u=1,d=null,f=3,h=!1,p=!1,x=!1,v=typeof setTimeout=="function"?setTimeout:null,y=typeof clearTimeout=="function"?clearTimeout:null,b=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function S(O){for(var G=n(c);G!==null;){if(G.callback===null)r(c);else if(G.startTime<=O)r(c),G.sortIndex=G.expirationTime,e(l,G);else break;G=n(c)}}function w(O){if(x=!1,S(O),!p)if(n(l)!==null)p=!0,Z(E);else{var G=n(c);G!==null&&ne(w,G.startTime-O)}}function E(O,G){p=!1,x&&(x=!1,y(I),I=-1),h=!0;var q=f;try{for(S(G),d=n(l);d!==null&&(!(d.expirationTime>G)||O&&!P());){var se=d.callback;if(typeof se=="function"){d.callback=null,f=d.priorityLevel;var he=se(d.expirationTime<=G);G=t.unstable_now(),typeof he=="function"?d.callback=he:d===n(l)&&r(l),S(G)}else r(l);d=n(l)}if(d!==null)var ke=!0;else{var re=n(c);re!==null&&ne(w,re.startTime-G),ke=!1}return ke}finally{d=null,f=q,h=!1}}var A=!1,T=null,I=-1,N=5,M=-1;function P(){return!(t.unstable_now()-M<N)}function B(){if(T!==null){var O=t.unstable_now();M=O;var G=!0;try{G=T(!0,O)}finally{G?F():(A=!1,T=null)}}else A=!1}var F;if(typeof b=="function")F=function(){b(B)};else if(typeof MessageChannel<"u"){var U=new MessageChannel,j=U.port2;U.port1.onmessage=B,F=function(){j.postMessage(null)}}else F=function(){v(B,0)};function Z(O){T=O,A||(A=!0,F())}function ne(O,G){I=v(function(){O(t.unstable_now())},G)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(O){O.callback=null},t.unstable_continueExecution=function(){p||h||(p=!0,Z(E))},t.unstable_forceFrameRate=function(O){0>O||125<O?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):N=0<O?Math.floor(1e3/O):5},t.unstable_getCurrentPriorityLevel=function(){return f},t.unstable_getFirstCallbackNode=function(){return n(l)},t.unstable_next=function(O){switch(f){case 1:case 2:case 3:var G=3;break;default:G=f}var q=f;f=G;try{return O()}finally{f=q}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(O,G){switch(O){case 1:case 2:case 3:case 4:case 5:break;default:O=3}var q=f;f=O;try{return G()}finally{f=q}},t.unstable_scheduleCallback=function(O,G,q){var se=t.unstable_now();switch(typeof q=="object"&&q!==null?(q=q.delay,q=typeof q=="number"&&0<q?se+q:se):q=se,O){case 1:var he=-1;break;case 2:he=250;break;case 5:he=1073741823;break;case 4:he=1e4;break;default:he=5e3}return he=q+he,O={id:u++,callback:G,priorityLevel:O,startTime:q,expirationTime:he,sortIndex:-1},q>se?(O.sortIndex=q,e(c,O),n(l)===null&&O===n(c)&&(x?(y(I),I=-1):x=!0,ne(w,q-se))):(O.sortIndex=he,e(l,O),p||h||(p=!0,Z(E))),O},t.unstable_shouldYield=P,t.unstable_wrapCallback=function(O){var G=f;return function(){var q=f;f=G;try{return O.apply(this,arguments)}finally{f=q}}}})(z7);U7.exports=z7;var NB=U7.exports;const KOe=t=>typeof t=="object"&&typeof t.then=="function",Vu=[];function G7(t,e,n=(r,i)=>r===i){if(t===e)return!0;if(!t||!e)return!1;const r=t.length;if(e.length!==r)return!1;for(let i=0;i<r;i++)if(!n(t[i],e[i]))return!1;return!0}function H7(t,e=null,n=!1,r={}){e===null&&(e=[t]);for(const s of Vu)if(G7(e,s.keys,s.equal)){if(n)return;if(Object.prototype.hasOwnProperty.call(s,"error"))throw s.error;if(Object.prototype.hasOwnProperty.call(s,"response"))return r.lifespan&&r.lifespan>0&&(s.timeout&&clearTimeout(s.timeout),s.timeout=setTimeout(s.remove,r.lifespan)),s.response;if(!n)throw s.promise}const i={keys:e,equal:r.equal,remove:()=>{const s=Vu.indexOf(i);s!==-1&&Vu.splice(s,1)},promise:(KOe(t)?t:t(...e)).then(s=>{i.response=s,r.lifespan&&r.lifespan>0&&(i.timeout=setTimeout(i.remove,r.lifespan))}).catch(s=>i.error=s)};if(Vu.push(i),!n)throw i.promise}const qOe=(t,e,n)=>H7(t,e,!1,n),JOe=(t,e,n)=>void H7(t,e,!0,n),YOe=t=>{if(t===void 0||t.length===0)Vu.splice(0,Vu.length);else{const e=Vu.find(n=>G7(t,n.keys,n.equal));e&&e.remove()}},aN={},QOe=t=>void Object.assign(aN,t);function ZOe(t,e){function n(u,{args:d=[],attach:f,...h},p){let x=`${u[0].toUpperCase()}${u.slice(1)}`,v;if(u==="primitive"){if(h.object===void 0)throw new Error("R3F: Primitives without 'object' are invalid!");const y=h.object;v=Vf(y,{type:u,root:p,attach:f,primitive:!0})}else{const y=aN[x];if(!y)throw new Error(`R3F: ${x} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);if(!Array.isArray(d))throw new Error("R3F: The args prop must be an array!");v=Vf(new y(...d),{type:u,root:p,attach:f,memoizedProps:{args:d}})}return v.__r3f.attach===void 0&&(v instanceof Lt?v.__r3f.attach="geometry":v instanceof wr&&(v.__r3f.attach="material")),x!=="inject"&&DE(v,h),v}function r(u,d){let f=!1;if(d){var h,p;(h=d.__r3f)!=null&&h.attach?kE(u,d,d.__r3f.attach):d.isObject3D&&u.isObject3D&&(u.add(d),f=!0),f||(p=u.__r3f)==null||p.objects.push(d),d.__r3f||Vf(d,{}),d.__r3f.parent=u,OT(d),Wf(d)}}function i(u,d,f){let h=!1;if(d){var p,x;if((p=d.__r3f)!=null&&p.attach)kE(u,d,d.__r3f.attach);else if(d.isObject3D&&u.isObject3D){d.parent=u,d.dispatchEvent({type:"added"}),u.dispatchEvent({type:"childadded",child:d});const v=u.children.filter(b=>b!==d),y=v.indexOf(f);u.children=[...v.slice(0,y),d,...v.slice(y)],h=!0}h||(x=u.__r3f)==null||x.objects.push(d),d.__r3f||Vf(d,{}),d.__r3f.parent=u,OT(d),Wf(d)}}function s(u,d,f=!1){u&&[...u].forEach(h=>o(d,h,f))}function o(u,d,f){if(d){var h,p,x;if(d.__r3f&&(d.__r3f.parent=null),(h=u.__r3f)!=null&&h.objects&&(u.__r3f.objects=u.__r3f.objects.filter(w=>w!==d)),(p=d.__r3f)!=null&&p.attach)LB(u,d,d.__r3f.attach);else if(d.isObject3D&&u.isObject3D){var v;u.remove(d),(v=d.__r3f)!=null&&v.root&&lLe(s1(d),d)}const b=(x=d.__r3f)==null?void 0:x.primitive,S=!b&&(f===void 0?d.dispose!==null:f);if(!b){var y;s((y=d.__r3f)==null?void 0:y.objects,d,S),s(d.children,d,S)}if(delete d.__r3f,S&&d.dispose&&d.type!=="Scene"){const w=()=>{try{d.dispose()}catch{}};typeof IS_REACT_ACT_ENVIRONMENT>"u"?NB.unstable_scheduleCallback(NB.unstable_IdlePriority,w):w()}Wf(u)}}function a(u,d,f,h){var p;const x=(p=u.__r3f)==null?void 0:p.parent;if(!x)return;const v=n(d,f,u.__r3f.root);if(u.children){for(const y of u.children)y.__r3f&&r(v,y);u.children=u.children.filter(y=>!y.__r3f)}u.__r3f.objects.forEach(y=>r(v,y)),u.__r3f.objects=[],u.__r3f.autoRemovedBeforeAppend||o(x,u),v.parent&&(v.__r3f.autoRemovedBeforeAppend=!0),r(x,v),v.raycast&&v.__r3f.eventCount&&s1(v).getState().internal.interaction.push(v),[h,h.alternate].forEach(y=>{y!==null&&(y.stateNode=v,y.ref&&(typeof y.ref=="function"?y.ref(v):y.ref.current=v))})}const l=()=>console.warn("Text is not allowed in the R3F tree! This could be stray whitespace or characters.");return{reconciler:XOe({createInstance:n,removeChild:o,appendChild:r,appendInitialChild:r,insertBefore:i,supportsMutation:!0,isPrimaryRenderer:!1,supportsPersistence:!1,supportsHydration:!1,noTimeout:-1,appendChildToContainer:(u,d)=>{if(!d)return;const f=u.getState().scene;f.__r3f&&(f.__r3f.root=u,r(f,d))},removeChildFromContainer:(u,d)=>{d&&o(u.getState().scene,d)},insertInContainerBefore:(u,d,f)=>{if(!d||!f)return;const h=u.getState().scene;h.__r3f&&i(h,d,f)},getRootHostContext:()=>null,getChildHostContext:u=>u,finalizeInitialChildren(u){var d;return!!((d=u==null?void 0:u.__r3f)!=null?d:{}).handlers},prepareUpdate(u,d,f,h){var p;if(((p=u==null?void 0:u.__r3f)!=null?p:{}).primitive&&h.object&&h.object!==u)return[!0];{const{args:v=[],children:y,...b}=h,{args:S=[],children:w,...E}=f;if(!Array.isArray(v))throw new Error("R3F: the args prop must be an array!");if(v.some((T,I)=>T!==S[I]))return[!0];const A=J7(u,b,E,!0);return A.changes.length?[!1,A]:null}},commitUpdate(u,[d,f],h,p,x,v){d?a(u,h,x,v):DE(u,f)},commitMount(u,d,f,h){var p;const x=(p=u.__r3f)!=null?p:{};u.raycast&&x.handlers&&x.eventCount&&s1(u).getState().internal.interaction.push(u)},getPublicInstance:u=>u,prepareForCommit:()=>null,preparePortalMount:u=>Vf(u.getState().scene),resetAfterCommit:()=>{},shouldSetTextContent:()=>!1,clearContainer:()=>!1,hideInstance(u){var d;const{attach:f,parent:h}=(d=u.__r3f)!=null?d:{};f&&h&&LB(h,u,f),u.isObject3D&&(u.visible=!1),Wf(u)},unhideInstance(u,d){var f;const{attach:h,parent:p}=(f=u.__r3f)!=null?f:{};h&&p&&kE(p,u,h),(u.isObject3D&&d.visible==null||d.visible)&&(u.visible=!0),Wf(u)},createTextInstance:l,hideTextInstance:l,unhideTextInstance:l,getCurrentEventPriority:()=>e?e():uh.DefaultEventPriority,beforeActiveInstanceBlur:()=>{},afterActiveInstanceBlur:()=>{},detachDeletedInstance:()=>{},now:typeof performance<"u"&&On.fun(performance.now)?performance.now:On.fun(Date.now)?Date.now:()=>0,scheduleTimeout:On.fun(setTimeout)?setTimeout:void 0,cancelTimeout:On.fun(clearTimeout)?clearTimeout:void 0}),applyProps:DE}}var PB,kB;const PE=t=>"colorSpace"in t||"outputColorSpace"in t,V7=()=>{var t;return(t=aN.ColorManagement)!=null?t:null},W7=t=>t&&t.isOrthographicCamera,eLe=t=>t&&t.hasOwnProperty("current"),X0=typeof window<"u"&&((PB=window.document)!=null&&PB.createElement||((kB=window.navigator)==null?void 0:kB.product)==="ReactNative")?L.useLayoutEffect:L.useEffect;function j7(t){const e=L.useRef(t);return X0(()=>void(e.current=t),[t]),e}function tLe({set:t}){return X0(()=>(t(new Promise(()=>null)),()=>t(!1)),[t]),null}class X7 extends L.Component{constructor(...e){super(...e),this.state={error:!1}}componentDidCatch(e){this.props.set(e)}render(){return this.state.error?null:this.props.children}}X7.getDerivedStateFromError=()=>({error:!0});const K7="__default",DB=new Map,nLe=t=>t&&!!t.memoized&&!!t.changes;function q7(t){var e;const n=typeof window<"u"?(e=window.devicePixelRatio)!=null?e:2:1;return Array.isArray(t)?Math.min(Math.max(t[0],n),t[1]):t}const Nm=t=>{var e;return(e=t.__r3f)==null?void 0:e.root.getState()};function s1(t){let e=t.__r3f.root;for(;e.getState().previousRoot;)e=e.getState().previousRoot;return e}const On={obj:t=>t===Object(t)&&!On.arr(t)&&typeof t!="function",fun:t=>typeof t=="function",str:t=>typeof t=="string",num:t=>typeof t=="number",boo:t=>typeof t=="boolean",und:t=>t===void 0,arr:t=>Array.isArray(t),equ(t,e,{arrays:n="shallow",objects:r="reference",strict:i=!0}={}){if(typeof t!=typeof e||!!t!=!!e)return!1;if(On.str(t)||On.num(t))return t===e;const s=On.obj(t);if(s&&r==="reference")return t===e;const o=On.arr(t);if(o&&n==="reference")return t===e;if((o||s)&&t===e)return!0;let a;for(a in t)if(!(a in e))return!1;if(s&&n==="shallow"&&r==="shallow"){for(a in i?e:t)if(!On.equ(t[a],e[a],{strict:i,objects:"reference"}))return!1}else for(a in i?e:t)if(t[a]!==e[a])return!1;if(On.und(a)){if(o&&t.length===0&&e.length===0||s&&Object.keys(t).length===0&&Object.keys(e).length===0)return!0;if(t!==e)return!1}return!0}};function rLe(t){const e={nodes:{},materials:{}};return t&&t.traverse(n=>{n.name&&(e.nodes[n.name]=n),n.material&&!e.materials[n.material.name]&&(e.materials[n.material.name]=n.material)}),e}function iLe(t){t.dispose&&t.type!=="Scene"&&t.dispose();for(const e in t)e.dispose==null||e.dispose(),delete t[e]}function Vf(t,e){const n=t;return n.__r3f={type:"",root:null,previousAttach:null,memoizedProps:{},eventCount:0,handlers:{},objects:[],parent:null,...e},t}function DT(t,e){let n=t;if(e.includes("-")){const r=e.split("-"),i=r.pop();return n=r.reduce((s,o)=>s[o],t),{target:n,key:i}}else return{target:n,key:e}}const OB=/-\d+$/;function kE(t,e,n){if(On.str(n)){if(OB.test(n)){const s=n.replace(OB,""),{target:o,key:a}=DT(t,s);Array.isArray(o[a])||(o[a]=[])}const{target:r,key:i}=DT(t,n);e.__r3f.previousAttach=r[i],r[i]=e}else e.__r3f.previousAttach=n(t,e)}function LB(t,e,n){var r,i;if(On.str(n)){const{target:s,key:o}=DT(t,n),a=e.__r3f.previousAttach;a===void 0?delete s[o]:s[o]=a}else(r=e.__r3f)==null||r.previousAttach==null||r.previousAttach(t,e);(i=e.__r3f)==null||delete i.previousAttach}function J7(t,{children:e,key:n,ref:r,...i},{children:s,key:o,ref:a,...l}={},c=!1){var u;const d=(u=t==null?void 0:t.__r3f)!=null?u:{},f=Object.entries(i),h=[];if(c){const x=Object.keys(l);for(let v=0;v<x.length;v++)i.hasOwnProperty(x[v])||f.unshift([x[v],K7+"remove"])}f.forEach(([x,v])=>{var y;if((y=t.__r3f)!=null&&y.primitive&&x==="object"||On.equ(v,l[x]))return;if(/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(x))return h.push([x,v,!0,[]]);let b=[];x.includes("-")&&(b=x.split("-")),h.push([x,v,!1,b]);for(const S in i){const w=i[S];S.startsWith(`${x}-`)&&h.push([S,w,!1,S.split("-")])}});const p={...i};return d.memoizedProps&&d.memoizedProps.args&&(p.args=d.memoizedProps.args),d.memoizedProps&&d.memoizedProps.attach&&(p.attach=d.memoizedProps.attach),{memoized:p,changes:h}}const sLe=typeof process<"u"&&!1;function DE(t,e){var n,r,i;const s=(n=t.__r3f)!=null?n:{},o=s.root,a=(r=o==null||o.getState==null?void 0:o.getState())!=null?r:{},{memoized:l,changes:c}=nLe(e)?e:J7(t,e),u=s.eventCount;t.__r3f&&(t.__r3f.memoizedProps=l);for(let f=0;f<c.length;f++){let[h,p,x,v]=c[f];if(PE(t)){const w="srgb",E="srgb-linear";h==="encoding"?(h="colorSpace",p=p===3001?w:E):h==="outputEncoding"&&(h="outputColorSpace",p=p===3001?w:E)}let y=t,b=y[h];if(v.length&&(b=v.reduce((S,w)=>S[w],t),!(b&&b.set))){const[S,...w]=v.reverse();y=w.reverse().reduce((E,A)=>E[A],t),h=S}if(p===K7+"remove")if(y.constructor){let S=DB.get(y.constructor);S||(S=new y.constructor,DB.set(y.constructor,S)),p=S[h]}else p=0;if(x)p?s.handlers[h]=p:delete s.handlers[h],s.eventCount=Object.keys(s.handlers).length;else if(b&&b.set&&(b.copy||b instanceof Qu)){if(Array.isArray(p))b.fromArray?b.fromArray(p):b.set(...p);else if(b.copy&&p&&p.constructor&&(sLe?b.constructor.name===p.constructor.name:b.constructor===p.constructor))b.copy(p);else if(p!==void 0){const S=b instanceof Qe;!S&&b.setScalar?b.setScalar(p):b instanceof Qu&&p instanceof Qu?b.mask=p.mask:b.set(p),!V7()&&!a.linear&&S&&b.convertSRGBToLinear()}}else if(y[h]=p,y[h]instanceof Bn&&y[h].format===Yi&&y[h].type===Ea){const S=y[h];PE(S)&&PE(a.gl)?S.colorSpace=a.gl.outputColorSpace:S.encoding=a.gl.outputEncoding}Wf(t)}if(s.parent&&t.raycast&&u!==s.eventCount){const f=s1(t).getState().internal,h=f.interaction.indexOf(t);h>-1&&f.interaction.splice(h,1),s.eventCount&&f.interaction.push(t)}return!(c.length===1&&c[0][0]==="onUpdate")&&c.length&&(i=t.__r3f)!=null&&i.parent&&OT(t),t}function Wf(t){var e,n;const r=(e=t.__r3f)==null||(n=e.root)==null||n.getState==null?void 0:n.getState();r&&r.internal.frames===0&&r.invalidate()}function OT(t){t.onUpdate==null||t.onUpdate(t)}function oLe(t,e){t.manual||(W7(t)?(t.left=e.width/-2,t.right=e.width/2,t.top=e.height/2,t.bottom=e.height/-2):t.aspect=e.width/e.height,t.updateProjectionMatrix(),t.updateMatrixWorld())}function wx(t){return(t.eventObject||t.object).uuid+"/"+t.index+t.instanceId}function aLe(){var t;const e=typeof self<"u"&&self||typeof window<"u"&&window;if(!e)return uh.DefaultEventPriority;switch((t=e.event)==null?void 0:t.type){case"click":case"contextmenu":case"dblclick":case"pointercancel":case"pointerdown":case"pointerup":return uh.DiscreteEventPriority;case"pointermove":case"pointerout":case"pointerover":case"pointerenter":case"pointerleave":case"wheel":return uh.ContinuousEventPriority;default:return uh.DefaultEventPriority}}function Y7(t,e,n,r){const i=n.get(e);i&&(n.delete(e),n.size===0&&(t.delete(r),i.target.releasePointerCapture(r)))}function lLe(t,e){const{internal:n}=t.getState();n.interaction=n.interaction.filter(r=>r!==e),n.initialHits=n.initialHits.filter(r=>r!==e),n.hovered.forEach((r,i)=>{(r.eventObject===e||r.object===e)&&n.hovered.delete(i)}),n.capturedMap.forEach((r,i)=>{Y7(n.capturedMap,e,r,i)})}function cLe(t){function e(l){const{internal:c}=t.getState(),u=l.offsetX-c.initialClick[0],d=l.offsetY-c.initialClick[1];return Math.round(Math.sqrt(u*u+d*d))}function n(l){return l.filter(c=>["Move","Over","Enter","Out","Leave"].some(u=>{var d;return(d=c.__r3f)==null?void 0:d.handlers["onPointer"+u]}))}function r(l,c){const u=t.getState(),d=new Set,f=[],h=c?c(u.internal.interaction):u.internal.interaction;for(let y=0;y<h.length;y++){const b=Nm(h[y]);b&&(b.raycaster.camera=void 0)}u.previousRoot||u.events.compute==null||u.events.compute(l,u);function p(y){const b=Nm(y);if(!b||!b.events.enabled||b.raycaster.camera===null)return[];if(b.raycaster.camera===void 0){var S;b.events.compute==null||b.events.compute(l,b,(S=b.previousRoot)==null?void 0:S.getState()),b.raycaster.camera===void 0&&(b.raycaster.camera=null)}return b.raycaster.camera?b.raycaster.intersectObject(y,!0):[]}let x=h.flatMap(p).sort((y,b)=>{const S=Nm(y.object),w=Nm(b.object);return!S||!w?y.distance-b.distance:w.events.priority-S.events.priority||y.distance-b.distance}).filter(y=>{const b=wx(y);return d.has(b)?!1:(d.add(b),!0)});u.events.filter&&(x=u.events.filter(x,u));for(const y of x){let b=y.object;for(;b;){var v;(v=b.__r3f)!=null&&v.eventCount&&f.push({...y,eventObject:b}),b=b.parent}}if("pointerId"in l&&u.internal.capturedMap.has(l.pointerId))for(let y of u.internal.capturedMap.get(l.pointerId).values())d.has(wx(y.intersection))||f.push(y.intersection);return f}function i(l,c,u,d){const f=t.getState();if(l.length){const h={stopped:!1};for(const p of l){const x=Nm(p.object)||f,{raycaster:v,pointer:y,camera:b,internal:S}=x,w=new K(y.x,y.y,0).unproject(b),E=M=>{var P,B;return(P=(B=S.capturedMap.get(M))==null?void 0:B.has(p.eventObject))!=null?P:!1},A=M=>{const P={intersection:p,target:c.target};S.capturedMap.has(M)?S.capturedMap.get(M).set(p.eventObject,P):S.capturedMap.set(M,new Map([[p.eventObject,P]])),c.target.setPointerCapture(M)},T=M=>{const P=S.capturedMap.get(M);P&&Y7(S.capturedMap,p.eventObject,P,M)};let I={};for(let M in c){let P=c[M];typeof P!="function"&&(I[M]=P)}let N={...p,...I,pointer:y,intersections:l,stopped:h.stopped,delta:u,unprojectedPoint:w,ray:v.ray,camera:b,stopPropagation(){const M="pointerId"in c&&S.capturedMap.get(c.pointerId);if((!M||M.has(p.eventObject))&&(N.stopped=h.stopped=!0,S.hovered.size&&Array.from(S.hovered.values()).find(P=>P.eventObject===p.eventObject))){const P=l.slice(0,l.indexOf(p));s([...P,p])}},target:{hasPointerCapture:E,setPointerCapture:A,releasePointerCapture:T},currentTarget:{hasPointerCapture:E,setPointerCapture:A,releasePointerCapture:T},nativeEvent:c};if(d(N),h.stopped===!0)break}}return l}function s(l){const{internal:c}=t.getState();for(const u of c.hovered.values())if(!l.length||!l.find(d=>d.object===u.object&&d.index===u.index&&d.instanceId===u.instanceId)){const f=u.eventObject.__r3f,h=f==null?void 0:f.handlers;if(c.hovered.delete(wx(u)),f!=null&&f.eventCount){const p={...u,intersections:l};h.onPointerOut==null||h.onPointerOut(p),h.onPointerLeave==null||h.onPointerLeave(p)}}}function o(l,c){for(let u=0;u<c.length;u++){const d=c[u].__r3f;d==null||d.handlers.onPointerMissed==null||d.handlers.onPointerMissed(l)}}function a(l){switch(l){case"onPointerLeave":case"onPointerCancel":return()=>s([]);case"onLostPointerCapture":return c=>{const{internal:u}=t.getState();"pointerId"in c&&u.capturedMap.has(c.pointerId)&&requestAnimationFrame(()=>{u.capturedMap.has(c.pointerId)&&(u.capturedMap.delete(c.pointerId),s([]))})}}return function(u){const{onPointerMissed:d,internal:f}=t.getState();f.lastEvent.current=u;const h=l==="onPointerMove",p=l==="onClick"||l==="onContextMenu"||l==="onDoubleClick",v=r(u,h?n:void 0),y=p?e(u):0;l==="onPointerDown"&&(f.initialClick=[u.offsetX,u.offsetY],f.initialHits=v.map(S=>S.eventObject)),p&&!v.length&&y<=2&&(o(u,f.interaction),d&&d(u)),h&&s(v);function b(S){const w=S.eventObject,E=w.__r3f,A=E==null?void 0:E.handlers;if(E!=null&&E.eventCount)if(h){if(A.onPointerOver||A.onPointerEnter||A.onPointerOut||A.onPointerLeave){const T=wx(S),I=f.hovered.get(T);I?I.stopped&&S.stopPropagation():(f.hovered.set(T,S),A.onPointerOver==null||A.onPointerOver(S),A.onPointerEnter==null||A.onPointerEnter(S))}A.onPointerMove==null||A.onPointerMove(S)}else{const T=A[l];T?(!p||f.initialHits.includes(w))&&(o(u,f.interaction.filter(I=>!f.initialHits.includes(I))),T(S)):p&&f.initialHits.includes(w)&&o(u,f.interaction.filter(I=>!f.initialHits.includes(I)))}}i(v,u,y,b)}}return{handlePointer:a}}const Q7=t=>!!(t!=null&&t.render),Z7=L.createContext(null),uLe=(t,e)=>{const n=oN((a,l)=>{const c=new K,u=new K,d=new K;function f(y=l().camera,b=u,S=l().size){const{width:w,height:E,top:A,left:T}=S,I=w/E;b instanceof K?d.copy(b):d.set(...b);const N=y.getWorldPosition(c).distanceTo(d);if(W7(y))return{width:w/y.zoom,height:E/y.zoom,top:A,left:T,factor:1,distance:N,aspect:I};{const M=y.fov*Math.PI/180,P=2*Math.tan(M/2)*N,B=P*(w/E);return{width:B,height:P,top:A,left:T,factor:w/B,distance:N,aspect:I}}}let h;const p=y=>a(b=>({performance:{...b.performance,current:y}})),x=new Re;return{set:a,get:l,gl:null,camera:null,raycaster:null,events:{priority:1,enabled:!0,connected:!1},xr:null,scene:null,invalidate:(y=1)=>t(l(),y),advance:(y,b)=>e(y,b,l()),legacy:!1,linear:!1,flat:!1,controls:null,clock:new iI,pointer:x,mouse:x,frameloop:"always",onPointerMissed:void 0,performance:{current:1,min:.5,max:1,debounce:200,regress:()=>{const y=l();h&&clearTimeout(h),y.performance.current!==y.performance.min&&p(y.performance.min),h=setTimeout(()=>p(l().performance.max),y.performance.debounce)}},size:{width:0,height:0,top:0,left:0,updateStyle:!1},viewport:{initialDpr:0,dpr:0,width:0,height:0,top:0,left:0,aspect:0,distance:0,factor:0,getCurrentViewport:f},setEvents:y=>a(b=>({...b,events:{...b.events,...y}})),setSize:(y,b,S,w,E)=>{const A=l().camera,T={width:y,height:b,top:w||0,left:E||0,updateStyle:S};a(I=>({size:T,viewport:{...I.viewport,...f(A,u,T)}}))},setDpr:y=>a(b=>{const S=q7(y);return{viewport:{...b.viewport,dpr:S,initialDpr:b.viewport.initialDpr||S}}}),setFrameloop:(y="always")=>{const b=l().clock;b.stop(),b.elapsedTime=0,y!=="never"&&(b.start(),b.elapsedTime=0),a(()=>({frameloop:y}))},previousRoot:void 0,internal:{active:!1,priority:0,frames:0,lastEvent:L.createRef(),interaction:[],hovered:new Map,subscribers:[],initialClick:[0,0],initialHits:[],capturedMap:new Map,subscribe:(y,b,S)=>{const w=l().internal;return w.priority=w.priority+(b>0?1:0),w.subscribers.push({ref:y,priority:b,store:S}),w.subscribers=w.subscribers.sort((E,A)=>E.priority-A.priority),()=>{const E=l().internal;E!=null&&E.subscribers&&(E.priority=E.priority-(b>0?1:0),E.subscribers=E.subscribers.filter(A=>A.ref!==y))}}}}}),r=n.getState();let i=r.size,s=r.viewport.dpr,o=r.camera;return n.subscribe(()=>{const{camera:a,size:l,viewport:c,gl:u,set:d}=n.getState();if(l.width!==i.width||l.height!==i.height||c.dpr!==s){var f;i=l,s=c.dpr,oLe(a,l),u.setPixelRatio(c.dpr);const h=(f=l.updateStyle)!=null?f:typeof HTMLCanvasElement<"u"&&u.domElement instanceof HTMLCanvasElement;u.setSize(l.width,l.height,h)}a!==o&&(o=a,d(h=>({viewport:{...h.viewport,...h.viewport.getCurrentViewport(a)}})))}),n.subscribe(a=>t(a)),n};let Cx,dLe=new Set,fLe=new Set,hLe=new Set;function OE(t,e){if(t.size)for(const{callback:n}of t.values())n(e)}function Pm(t,e){switch(t){case"before":return OE(dLe,e);case"after":return OE(fLe,e);case"tail":return OE(hLe,e)}}let LE,BE;function FE(t,e,n){let r=e.clock.getDelta();for(e.frameloop==="never"&&typeof t=="number"&&(r=t-e.clock.elapsedTime,e.clock.oldTime=e.clock.elapsedTime,e.clock.elapsedTime=t),LE=e.internal.subscribers,Cx=0;Cx<LE.length;Cx++)BE=LE[Cx],BE.ref.current(BE.store.getState(),r,n);return!e.internal.priority&&e.gl.render&&e.gl.render(e.scene,e.camera),e.internal.frames=Math.max(0,e.internal.frames-1),e.frameloop==="always"?1:e.internal.frames}function pLe(t){let e=!1,n=!1,r,i,s;function o(c){i=requestAnimationFrame(o),e=!0,r=0,Pm("before",c),n=!0;for(const d of t.values()){var u;s=d.store.getState(),s.internal.active&&(s.frameloop==="always"||s.internal.frames>0)&&!((u=s.gl.xr)!=null&&u.isPresenting)&&(r+=FE(c,s))}if(n=!1,Pm("after",c),r===0)return Pm("tail",c),e=!1,cancelAnimationFrame(i)}function a(c,u=1){var d;if(!c)return t.forEach(f=>a(f.store.getState(),u));(d=c.gl.xr)!=null&&d.isPresenting||!c.internal.active||c.frameloop==="never"||(u>1?c.internal.frames=Math.min(60,c.internal.frames+u):n?c.internal.frames=2:c.internal.frames=1,e||(e=!0,requestAnimationFrame(o)))}function l(c,u=!0,d,f){if(u&&Pm("before",c),d)FE(c,d,f);else for(const h of t.values())FE(c,h.store.getState());u&&Pm("after",c)}return{loop:o,invalidate:a,advance:l}}function eW(){const t=L.useContext(Z7);if(!t)throw new Error("R3F: Hooks can only be used within the Canvas component!");return t}function Ki(t=n=>n,e){return eW()(t,e)}function x_(t,e=0){const n=eW(),r=n.getState().internal.subscribe,i=j7(t);return X0(()=>r(i,e,n),[e,r,n]),null}const BB=new WeakMap;function tW(t,e){return function(n,...r){let i=BB.get(n);return i||(i=new n,BB.set(n,i)),t&&t(i),Promise.all(r.map(s=>new Promise((o,a)=>i.load(s,l=>{l.scene&&Object.assign(l,rLe(l.scene)),o(l)},e,l=>a(new Error(`Could not load ${s}: ${l==null?void 0:l.message}`))))))}}function K0(t,e,n,r){const i=Array.isArray(e)?e:[e],s=qOe(tW(n,r),[t,...i],{equal:On.equ});return Array.isArray(e)?s:s[0]}K0.preload=function(t,e,n){const r=Array.isArray(e)?e:[e];return JOe(tW(n),[t,...r])};K0.clear=function(t,e){const n=Array.isArray(e)?e:[e];return YOe([t,...n])};const sp=new Map,{invalidate:FB,advance:$B}=pLe(sp),{reconciler:lb,applyProps:Lf}=ZOe(sp,aLe),Bf={objects:"shallow",strict:!1},mLe=(t,e)=>{const n=typeof t=="function"?t(e):t;return Q7(n)?n:new LR({powerPreference:"high-performance",canvas:e,antialias:!0,alpha:!0,...t})};function gLe(t,e){const n=typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement;if(e){const{width:r,height:i,top:s,left:o,updateStyle:a=n}=e;return{width:r,height:i,top:s,left:o,updateStyle:a}}else if(typeof HTMLCanvasElement<"u"&&t instanceof HTMLCanvasElement&&t.parentElement){const{width:r,height:i,top:s,left:o}=t.parentElement.getBoundingClientRect();return{width:r,height:i,top:s,left:o,updateStyle:n}}else if(typeof OffscreenCanvas<"u"&&t instanceof OffscreenCanvas)return{width:t.width,height:t.height,top:0,left:0,updateStyle:n};return{width:0,height:0,top:0,left:0}}function yLe(t){const e=sp.get(t),n=e==null?void 0:e.fiber,r=e==null?void 0:e.store;e&&console.warn("R3F.createRoot should only be called once!");const i=typeof reportError=="function"?reportError:console.error,s=r||uLe(FB,$B),o=n||lb.createContainer(s,uh.ConcurrentRoot,null,!1,null,"",i,null);e||sp.set(t,{fiber:o,store:s});let a,l=!1,c;return{configure(u={}){let{gl:d,size:f,scene:h,events:p,onCreated:x,shadows:v=!1,linear:y=!1,flat:b=!1,legacy:S=!1,orthographic:w=!1,frameloop:E="always",dpr:A=[1,2],performance:T,raycaster:I,camera:N,onPointerMissed:M}=u,P=s.getState(),B=P.gl;P.gl||P.set({gl:B=mLe(d,t)});let F=P.raycaster;F||P.set({raycaster:F=new w6});const{params:U,...j}=I||{};if(On.equ(j,F,Bf)||Lf(F,{...j}),On.equ(U,F.params,Bf)||Lf(F,{params:{...F.params,...U}}),!P.camera||P.camera===c&&!On.equ(c,N,Bf)){c=N;const q=N instanceof T0,se=q?N:w?new ba(0,0,0,0,.1,1e3):new Hn(75,0,.1,1e3);q||(se.position.z=5,N&&Lf(se,N),!P.camera&&!(N!=null&&N.rotation)&&se.lookAt(0,0,0)),P.set({camera:se}),F.camera=se}if(!P.scene){let q;h instanceof Wg?q=h:(q=new Wg,h&&Lf(q,h)),P.set({scene:Vf(q)})}if(!P.xr){var Z;const q=(ke,re)=>{const pe=s.getState();pe.frameloop!=="never"&&$B(ke,!0,pe,re)},se=()=>{const ke=s.getState();ke.gl.xr.enabled=ke.gl.xr.isPresenting,ke.gl.xr.setAnimationLoop(ke.gl.xr.isPresenting?q:null),ke.gl.xr.isPresenting||FB(ke)},he={connect(){const ke=s.getState().gl;ke.xr.addEventListener("sessionstart",se),ke.xr.addEventListener("sessionend",se)},disconnect(){const ke=s.getState().gl;ke.xr.removeEventListener("sessionstart",se),ke.xr.removeEventListener("sessionend",se)}};typeof((Z=B.xr)==null?void 0:Z.addEventListener)=="function"&&he.connect(),P.set({xr:he})}if(B.shadowMap){const q=B.shadowMap.enabled,se=B.shadowMap.type;if(B.shadowMap.enabled=!!v,On.boo(v))B.shadowMap.type=ig;else if(On.str(v)){var ne;const he={basic:m9,percentage:CS,soft:ig,variance:ko};B.shadowMap.type=(ne=he[v])!=null?ne:ig}else On.obj(v)&&Object.assign(B.shadowMap,v);(q!==B.shadowMap.enabled||se!==B.shadowMap.type)&&(B.shadowMap.needsUpdate=!0)}const O=V7();O&&("enabled"in O?O.enabled=!S:"legacyMode"in O&&(O.legacyMode=S)),l||Lf(B,{outputEncoding:y?3e3:3001,toneMapping:b?Ca:mR}),P.legacy!==S&&P.set(()=>({legacy:S})),P.linear!==y&&P.set(()=>({linear:y})),P.flat!==b&&P.set(()=>({flat:b})),d&&!On.fun(d)&&!Q7(d)&&!On.equ(d,B,Bf)&&Lf(B,d),p&&!P.events.handlers&&P.set({events:p(s)});const G=gLe(t,f);return On.equ(G,P.size,Bf)||P.setSize(G.width,G.height,G.updateStyle,G.top,G.left),A&&P.viewport.dpr!==q7(A)&&P.setDpr(A),P.frameloop!==E&&P.setFrameloop(E),P.onPointerMissed||P.set({onPointerMissed:M}),T&&!On.equ(T,P.performance,Bf)&&P.set(q=>({performance:{...q.performance,...T}})),a=x,l=!0,this},render(u){return l||this.configure(),lb.updateContainer(L.createElement(vLe,{store:s,children:u,onCreated:a,rootElement:t}),o,null,()=>{}),s},unmount(){nW(t)}}}function vLe({store:t,children:e,onCreated:n,rootElement:r}){return X0(()=>{const i=t.getState();i.set(s=>({internal:{...s.internal,active:!0}})),n&&n(i),t.getState().events.connected||i.events.connect==null||i.events.connect(r)},[]),L.createElement(Z7.Provider,{value:t},e)}function nW(t,e){const n=sp.get(t),r=n==null?void 0:n.fiber;if(r){const i=n==null?void 0:n.store.getState();i&&(i.internal.active=!1),lb.updateContainer(null,r,null,()=>{i&&setTimeout(()=>{try{var s,o,a,l;i.events.disconnect==null||i.events.disconnect(),(s=i.gl)==null||(o=s.renderLists)==null||o.dispose==null||o.dispose(),(a=i.gl)==null||a.forceContextLoss==null||a.forceContextLoss(),(l=i.gl)!=null&&l.xr&&i.xr.disconnect(),iLe(i),sp.delete(t),e&&e(t)}catch{}},500)})}}lb.injectIntoDevTools({bundleType:0,rendererPackageName:"@react-three/fiber",version:L.version});function LT(t,e,n){var r,i,s,o,a;e==null&&(e=100);function l(){var u=Date.now()-o;u<e&&u>=0?r=setTimeout(l,e-u):(r=null,n||(a=t.apply(s,i),s=i=null))}var c=function(){s=this,i=arguments,o=Date.now();var u=n&&!r;return r||(r=setTimeout(l,e)),u&&(a=t.apply(s,i),s=i=null),a};return c.clear=function(){r&&(clearTimeout(r),r=null)},c.flush=function(){r&&(a=t.apply(s,i),s=i=null,clearTimeout(r),r=null)},c}LT.debounce=LT;var xLe=LT;const UB=Ed(xLe);function bLe(t){let{debounce:e,scroll:n,polyfill:r,offsetSize:i}=t===void 0?{debounce:0,scroll:!1,offsetSize:!1}:t;const s=r||(typeof window>"u"?class{}:window.ResizeObserver);if(!s)throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");const[o,a]=L.useState({left:0,top:0,width:0,height:0,bottom:0,right:0,x:0,y:0}),l=L.useRef({element:null,scrollContainers:null,resizeObserver:null,lastBounds:o}),c=e?typeof e=="number"?e:e.scroll:null,u=e?typeof e=="number"?e:e.resize:null,d=L.useRef(!1);L.useEffect(()=>(d.current=!0,()=>void(d.current=!1)));const[f,h,p]=L.useMemo(()=>{const b=()=>{if(!l.current.element)return;const{left:S,top:w,width:E,height:A,bottom:T,right:I,x:N,y:M}=l.current.element.getBoundingClientRect(),P={left:S,top:w,width:E,height:A,bottom:T,right:I,x:N,y:M};l.current.element instanceof HTMLElement&&i&&(P.height=l.current.element.offsetHeight,P.width=l.current.element.offsetWidth),Object.freeze(P),d.current&&!CLe(l.current.lastBounds,P)&&a(l.current.lastBounds=P)};return[b,u?UB(b,u):b,c?UB(b,c):b]},[a,i,c,u]);function x(){l.current.scrollContainers&&(l.current.scrollContainers.forEach(b=>b.removeEventListener("scroll",p,!0)),l.current.scrollContainers=null),l.current.resizeObserver&&(l.current.resizeObserver.disconnect(),l.current.resizeObserver=null)}function v(){l.current.element&&(l.current.resizeObserver=new s(p),l.current.resizeObserver.observe(l.current.element),n&&l.current.scrollContainers&&l.current.scrollContainers.forEach(b=>b.addEventListener("scroll",p,{capture:!0,passive:!0})))}const y=b=>{!b||b===l.current.element||(x(),l.current.element=b,l.current.scrollContainers=rW(b),v())};return _Le(p,!!n),SLe(h),L.useEffect(()=>{x(),v()},[n,p,h]),L.useEffect(()=>x,[]),[y,o,f]}function SLe(t){L.useEffect(()=>{const e=t;return window.addEventListener("resize",e),()=>void window.removeEventListener("resize",e)},[t])}function _Le(t,e){L.useEffect(()=>{if(e){const n=t;return window.addEventListener("scroll",n,{capture:!0,passive:!0}),()=>void window.removeEventListener("scroll",n,!0)}},[t,e])}function rW(t){const e=[];if(!t||t===document.body)return e;const{overflow:n,overflowX:r,overflowY:i}=window.getComputedStyle(t);return[n,r,i].some(s=>s==="auto"||s==="scroll")&&e.push(t),[...e,...rW(t.parentElement)]}const wLe=["x","y","top","bottom","left","right","width","height"],CLe=(t,e)=>wLe.every(n=>t[n]===e[n]);var ELe=Object.defineProperty,ALe=Object.defineProperties,TLe=Object.getOwnPropertyDescriptors,zB=Object.getOwnPropertySymbols,MLe=Object.prototype.hasOwnProperty,RLe=Object.prototype.propertyIsEnumerable,GB=(t,e,n)=>e in t?ELe(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,HB=(t,e)=>{for(var n in e||(e={}))MLe.call(e,n)&&GB(t,n,e[n]);if(zB)for(var n of zB(e))RLe.call(e,n)&&GB(t,n,e[n]);return t},ILe=(t,e)=>ALe(t,TLe(e)),VB,WB;typeof window<"u"&&((VB=window.document)!=null&&VB.createElement||((WB=window.navigator)==null?void 0:WB.product)==="ReactNative")?L.useLayoutEffect:L.useEffect;function iW(t,e,n){if(!t)return;if(n(t)===!0)return t;let r=e?t.return:t.child;for(;r;){const i=iW(r,e,n);if(i)return i;r=e?null:r.sibling}}function sW(t){try{return Object.defineProperties(t,{_currentRenderer:{get(){return null},set(){}},_currentRenderer2:{get(){return null},set(){}}})}catch{return t}}const jB=console.error;console.error=function(){const t=[...arguments].join("");if(t!=null&&t.startsWith("Warning:")&&t.includes("useContext")){console.error=jB;return}return jB.apply(this,arguments)};const lN=sW(L.createContext(null));class oW extends L.Component{render(){return L.createElement(lN.Provider,{value:this._reactInternals},this.props.children)}}function NLe(){const t=L.useContext(lN);if(t===null)throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");const e=L.useId();return L.useMemo(()=>{for(const r of[t,t==null?void 0:t.alternate]){if(!r)continue;const i=iW(r,!1,s=>{let o=s.memoizedState;for(;o;){if(o.memoizedState===e)return!0;o=o.next}});if(i)return i}},[t,e])}function PLe(){const t=NLe(),[e]=L.useState(()=>new Map);e.clear();let n=t;for(;n;){if(n.type&&typeof n.type=="object"){const i=n.type._context===void 0&&n.type.Provider===n.type?n.type:n.type._context;i&&i!==lN&&!e.has(i)&&e.set(i,L.useContext(sW(i)))}n=n.return}return e}function kLe(){const t=PLe();return L.useMemo(()=>Array.from(t.keys()).reduce((e,n)=>r=>L.createElement(e,null,L.createElement(n.Provider,ILe(HB({},r),{value:t.get(n)}))),e=>L.createElement(oW,HB({},e))),[t])}const $E={onClick:["click",!1],onContextMenu:["contextmenu",!1],onDoubleClick:["dblclick",!1],onWheel:["wheel",!0],onPointerDown:["pointerdown",!0],onPointerUp:["pointerup",!0],onPointerLeave:["pointerleave",!0],onPointerMove:["pointermove",!0],onPointerCancel:["pointercancel",!0],onLostPointerCapture:["lostpointercapture",!0]};function DLe(t){const{handlePointer:e}=cLe(t);return{priority:1,enabled:!0,compute(n,r,i){r.pointer.set(n.offsetX/r.size.width*2-1,-(n.offsetY/r.size.height)*2+1),r.raycaster.setFromCamera(r.pointer,r.camera)},connected:void 0,handlers:Object.keys($E).reduce((n,r)=>({...n,[r]:e(r)}),{}),update:()=>{var n;const{events:r,internal:i}=t.getState();(n=i.lastEvent)!=null&&n.current&&r.handlers&&r.handlers.onPointerMove(i.lastEvent.current)},connect:n=>{var r;const{set:i,events:s}=t.getState();s.disconnect==null||s.disconnect(),i(o=>({events:{...o.events,connected:n}})),Object.entries((r=s.handlers)!=null?r:[]).forEach(([o,a])=>{const[l,c]=$E[o];n.addEventListener(l,a,{passive:c})})},disconnect:()=>{const{set:n,events:r}=t.getState();if(r.connected){var i;Object.entries((i=r.handlers)!=null?i:[]).forEach(([s,o])=>{if(r&&r.connected instanceof HTMLElement){const[a]=$E[s];r.connected.removeEventListener(a,o)}}),n(s=>({events:{...s.events,connected:void 0}}))}}}}const OLe=L.forwardRef(function({children:e,fallback:n,resize:r,style:i,gl:s,events:o=DLe,eventSource:a,eventPrefix:l,shadows:c,linear:u,flat:d,legacy:f,orthographic:h,frameloop:p,dpr:x,performance:v,raycaster:y,camera:b,scene:S,onPointerMissed:w,onCreated:E,...A},T){L.useMemo(()=>QOe(Cme),[]);const I=kLe(),[N,M]=bLe({scroll:!0,debounce:{scroll:50,resize:0},...r}),P=L.useRef(null),B=L.useRef(null);L.useImperativeHandle(T,()=>P.current);const F=j7(w),[U,j]=L.useState(!1),[Z,ne]=L.useState(!1);if(U)throw U;if(Z)throw Z;const O=L.useRef(null);X0(()=>{const q=P.current;M.width>0&&M.height>0&&q&&(O.current||(O.current=yLe(q)),O.current.configure({gl:s,events:o,shadows:c,linear:u,flat:d,legacy:f,orthographic:h,frameloop:p,dpr:x,performance:v,raycaster:y,camera:b,scene:S,size:M,onPointerMissed:(...se)=>F.current==null?void 0:F.current(...se),onCreated:se=>{se.events.connect==null||se.events.connect(a?eLe(a)?a.current:a:B.current),l&&se.setEvents({compute:(he,ke)=>{const re=he[l+"X"],pe=he[l+"Y"];ke.pointer.set(re/ke.size.width*2-1,-(pe/ke.size.height)*2+1),ke.raycaster.setFromCamera(ke.pointer,ke.camera)}}),E==null||E(se)}}),O.current.render(L.createElement(I,null,L.createElement(X7,{set:ne},L.createElement(L.Suspense,{fallback:L.createElement(tLe,{set:j})},e)))))}),L.useEffect(()=>{const q=P.current;if(q)return()=>nW(q)},[]);const G=a?"none":"auto";return L.createElement("div",X({ref:B,style:{position:"relative",width:"100%",height:"100%",overflow:"hidden",pointerEvents:G,...i}},A),L.createElement("div",{ref:N,style:{width:"100%",height:"100%"}},L.createElement("canvas",{ref:P,style:{display:"block"}},n)))}),LLe=L.forwardRef(function(e,n){return L.createElement(oW,null,L.createElement(OLe,X({},e,{ref:n})))});class BLe extends Ho{constructor(e,n){super(),this.inputSource=null,this.xrControllerModel=null,this.index=e,this.controller=n.xr.getController(e),this.grip=n.xr.getControllerGrip(e),this.hand=n.xr.getHand(e),this.grip.userData.name="grip",this.controller.userData.name="controller",this.hand.userData.name="hand",this.visible=!1,this.add(this.controller,this.grip,this.hand),this._onConnected=this._onConnected.bind(this),this._onDisconnected=this._onDisconnected.bind(this),this.controller.addEventListener("connected",this._onConnected),this.controller.addEventListener("disconnected",this._onDisconnected)}_onConnected(e){e.fake||e.data&&(this.visible=!0,this.inputSource=e.data,this.dispatchEvent(e))}_onDisconnected(e){e.fake||(this.visible=!1,this.inputSource=null,this.dispatchEvent(e))}dispose(){this.controller.removeEventListener("connected",this._onConnected),this.controller.removeEventListener("disconnected",this._onDisconnected)}}var XB,KB;const FLe=t=>Array.from(new Set(t)),so=typeof window<"u"&&((XB=window.document)!=null&&XB.createElement||((KB=window.navigator)==null?void 0:KB.product)==="ReactNative")?L.useLayoutEffect:L.useEffect;function Wu(t){const e=L.useRef(t);return so(()=>void(e.current=t),[t]),e}function Ff(t,e,{handedness:n}={}){const r=Wu(e),i=Di(s=>s.controllers);so(()=>{const s=i.map(o=>{if(n&&o.inputSource&&o.inputSource.handedness!==n)return;const a=l=>r.current({nativeEvent:l,target:o});return o.controller.addEventListener(t,a),()=>o.controller.removeEventListener(t,a)});return()=>s.forEach(o=>o==null?void 0:o())},[i,n,t])}const qB=new St;function $Le({children:t}){const e=Ki(d=>d.events),n=Ki(d=>d.get),r=Ki(d=>d.raycaster),i=Di(d=>d.controllers),s=Di(d=>d.interactions),o=Di(d=>d.hoverState),a=Di(d=>d.hasInteraction),l=Di(d=>d.getInteraction),c=L.useCallback(d=>{const f=Array.from(s.keys());return qB.identity().extractRotation(d.matrixWorld),r.ray.origin.setFromMatrixPosition(d.matrixWorld),r.ray.direction.set(0,0,-1).applyMatrix4(qB),r.intersectObjects(f,!0)},[s,r]);x_(()=>{var d;if(s.size!==0)for(const f of i){if(!((d=f.inputSource)!=null&&d.handedness))return;const h=o[f.inputSource.handedness],p=new Set;let x=c(f.controller);if(e.filter)x=e.filter(x,n());else{const v=x.find(y=>y==null?void 0:y.object);v&&(x=[v])}for(const v of x){let y=v.object;for(;y;){if(a(y,"onHover")&&!h.has(y)){const S=l(y,"onHover");for(const w of S)w({target:f,intersection:v,intersections:x})}const b=l(y,"onMove");b==null||b.forEach(S=>S({target:f,intersection:v,intersections:x})),h.set(y,v),p.add(y.id),y=y.parent}}for(const v of h.keys())if(!p.has(v.id)){h.delete(v);const y=l(v,"onBlur");if(!y)continue;for(const b of y)b({target:f,intersections:x})}}});const u=L.useCallback(d=>f=>{var h;if(!((h=f.target.inputSource)!=null&&h.handedness))return;const p=o[f.target.inputSource.handedness],x=Array.from(new Set(p.values()));s.forEach((v,y)=>{var b,S,w;if(p.has(y)){if(!v[d])return;for(const E of v[d])(b=E.current)==null||b.call(E,{target:f.target,intersection:p.get(y),intersections:x})}else if(d==="onSelect"&&v.onSelectMissed)for(const E of v.onSelectMissed)(S=E.current)==null||S.call(E,{target:f.target,intersections:x});else if(d==="onSqueeze"&&v.onSqueezeMissed)for(const E of v.onSqueezeMissed)(w=E.current)==null||w.call(E,{target:f.target,intersections:x})})},[o,s]);return Ff("select",u("onSelect")),Ff("selectstart",u("onSelectStart")),Ff("selectend",u("onSelectEnd")),Ff("squeeze",u("onSqueeze")),Ff("squeezeend",u("onSqueezeEnd")),Ff("squeezestart",u("onSqueezeStart")),L.createElement(L.Fragment,null,t)}function No(t,e,n){const r=Di(o=>o.addInteraction),i=Di(o=>o.removeInteraction),s=Wu(n);so(()=>{const o=t.current;if(!(!o||!s.current))return r(o,e,s),()=>i(o,e,s)},[t,e,r,i])}const aW=L.forwardRef(function({onHover:e,onBlur:n,onSelectStart:r,onSelectEnd:i,onSelectMissed:s,onSelect:o,onSqueezeStart:a,onSqueezeEnd:l,onSqueezeMissed:c,onSqueeze:u,onMove:d,children:f},h){const p=L.useRef(null);return L.useImperativeHandle(h,()=>p.current),No(p,"onHover",e),No(p,"onBlur",n),No(p,"onSelectStart",r),No(p,"onSelectEnd",i),No(p,"onSelectMissed",s),No(p,"onSelect",o),No(p,"onSqueezeStart",a),No(p,"onSqueezeEnd",l),No(p,"onSqueezeMissed",c),No(p,"onSqueeze",u),No(p,"onMove",d),L.createElement("group",{ref:p},f)});L.forwardRef(function({onSelectStart:e,onSelectEnd:n,children:r,...i},s){const o=L.useRef(),a=L.useRef(null),l=L.useMemo(()=>new St,[]);return L.useImperativeHandle(s,()=>a.current),x_(()=>{const c=o.current,u=a.current;c&&(u.applyMatrix4(l),u.applyMatrix4(c.matrixWorld),u.updateMatrixWorld(),l.copy(c.matrixWorld).invert())}),L.createElement(aW,{ref:a,onSelectStart:c=>{o.current=c.target.controller,l.copy(c.target.controller.matrixWorld).invert(),e==null||e(c)},onSelectEnd:c=>{c.target.controller===o.current&&(o.current=void 0),n==null||n(c)},...i},r)});function ULe(t){const e=Di(i=>i.session),n=L.useRef(),r=L.useMemo(()=>new St,[]);so(()=>{if(!e)return void(n.current=void 0);e.requestReferenceSpace("viewer").then(async i=>{var s;n.current=await((s=e==null?void 0:e.requestHitTestSource)==null?void 0:s.call(e,{space:i}))})},[e]),x_((i,s,o)=>{if(!o||!n.current)return;const[a]=o.getHitTestResults(n.current);if(a){const l=i.gl.xr.getReferenceSpace(),c=a.getPose(l);c&&(r.fromArray(c.transform.matrix),t(r,a))}})}const lW=L.createContext(null),rd=oN((t,e)=>({set:t,get:e,session:null,referenceSpaceType:null}));function zLe({foveation:t=0,frameRate:e=void 0,referenceSpace:n="local-floor",onSessionStart:r,onSessionEnd:i,onVisibilityChange:s,onInputSourcesChange:o,children:a}){const l=Ki(S=>S.gl),c=Ki(S=>S.camera),u=Di(S=>S.player),d=Di(S=>S.get),f=Di(S=>S.set),h=Di(S=>S.session),p=Di(S=>S.controllers),x=Wu(r),v=Wu(i),y=Wu(s),b=Wu(o);return so(()=>{const S=[0,1].map(w=>{const E=new BLe(w,l),A=()=>f(I=>({controllers:[...I.controllers,E]})),T=()=>f(I=>({controllers:I.controllers.filter(N=>N!==E)}));return E.addEventListener("connected",A),E.addEventListener("disconnected",T),()=>{E.removeEventListener("connected",A),E.removeEventListener("disconnected",T)}});return()=>S.forEach(w=>w())},[l,f]),so(()=>rd.subscribe(({session:S})=>f(()=>({session:S}))),[l.xr,f]),so(()=>{l.xr.setFoveation(t),f(()=>({foveation:t}))},[l.xr,t,f]),so(()=>{var S;try{e&&((S=h==null?void 0:h.updateTargetFrameRate)==null||S.call(h,e))}catch{}f(()=>({frameRate:e}))},[h,e,f]),so(()=>{const S=rd.getState();l.xr.setReferenceSpaceType(n),f(()=>({referenceSpace:n})),S.set({referenceSpaceType:n})},[l.xr,n,f]),so(()=>{if(!h)return void l.xr.setSession(null);const S=T=>{var I;f(()=>({isPresenting:!0})),(I=x.current)==null||I.call(x,{nativeEvent:{...T,target:h},target:h})},w=T=>{var I;f(()=>({isPresenting:!1,session:null})),rd.setState(()=>({session:null})),(I=v.current)==null||I.call(v,{nativeEvent:{...T,target:h},target:h})},E=T=>{var I;(I=y.current)==null||I.call(y,{nativeEvent:T,target:h})},A=T=>{var I;const N=Object.values(h.inputSources).some(M=>M.hand);f(()=>({isHandTracking:N})),(I=b.current)==null||I.call(b,{nativeEvent:T,target:h})};return l.xr.addEventListener("sessionstart",S),l.xr.addEventListener("sessionend",w),h.addEventListener("visibilitychange",E),h.addEventListener("inputsourceschange",A),l.xr.setSession(h).then(()=>{l.xr.setFoveation(d().foveation)}),()=>{l.xr.removeEventListener("sessionstart",S),l.xr.removeEventListener("sessionend",w),h.removeEventListener("visibilitychange",E),h.removeEventListener("inputsourceschange",A)}},[h,l.xr,f,d]),L.createElement($Le,null,L.createElement("primitive",{object:u},L.createElement("primitive",{object:c}),p.map(S=>L.createElement("primitive",{key:S.index,object:S}))),a)}function GLe(t){const e=L.useMemo(()=>oN((n,r)=>({set:n,get:r,controllers:[],isPresenting:!1,isHandTracking:!1,player:new Ho,session:null,foveation:0,referenceSpace:"local-floor",hoverState:{left:new Map,right:new Map,none:new Map},interactions:new Map,hasInteraction(i,s){var o;return!!((o=r().interactions.get(i))!=null&&o[s].some(a=>a.current))},getInteraction(i,s){var o;return(o=r().interactions.get(i))==null?void 0:o[s].reduce((a,l)=>(l.current&&a.push(l.current),a),[])},addInteraction(i,s,o){const a=r().interactions;a.has(i)||a.set(i,{onHover:[],onBlur:[],onSelect:[],onSelectEnd:[],onSelectStart:[],onSelectMissed:[],onSqueeze:[],onSqueezeEnd:[],onSqueezeStart:[],onSqueezeMissed:[],onMove:[]}),a.get(i)[s].push(o)},removeInteraction(i,s,o){const a=r().interactions.get(i);if(a){const l=a[s].indexOf(o);l!==-1&&a[s].splice(l,1)}}})),[]);return L.createElement(lW.Provider,{value:e},L.createElement(zLe,{...t}))}const HLe=(t,e)=>{var n;if(!(!t&&!e))return t&&!e?{optionalFeatures:[t]}:t&&e?{...e,optionalFeatures:FLe([...(n=e.optionalFeatures)!=null?n:[],t])}:e},VLe=async(t,e)=>{const n=rd.getState();if(n.session){console.warn("@react-three/xr: session already started, please stop it first");return}const r=HLe(n.referenceSpaceType,e),i=await navigator.xr.requestSession(t,r);return n.set(()=>({session:i})),i},WLe=async()=>{const t=rd.getState();if(!t.session){console.warn("@react-three/xr: no session to stop, please start it first");return}await t.session.end(),t.set({session:null})},jLe=async(t,{sessionInit:e,enterOnly:n,exitOnly:r}={})=>{const i=rd.getState();if(!(i.session&&n)&&!(!i.session&&r))return i.session?await WLe():await VLe(t,e)},XLe=(t,e,n)=>{switch(t){case"entered":return`Exit ${e}`;case"exited":return`Enter ${e}`;case"unsupported":default:switch(n){case"https":return"HTTPS needed";case"security":return`${e} blocked`;case"unknown":default:return`${e} unsupported`}}},cW=L.forwardRef(function({mode:e,sessionInit:n,enterOnly:r=!1,exitOnly:i=!1,onClick:s,onError:o,children:a,...l},c){var u;const[d,f]=L.useState("exited"),[h,p]=L.useState("unknown"),x=XLe(d,e,h),v=e==="inline"?e:`immersive-${e.toLowerCase()}`,y=Wu(o);so(()=>{if(!(navigator!=null&&navigator.xr))return void f("unsupported");navigator.xr.isSessionSupported(v).then(S=>{if(S)f("exited");else{const w=location.protocol==="https:";f("unsupported"),p(w?"unknown":"https")}}).catch(S=>{f("unsupported"),"name"in S&&S.name==="SecurityError"?p("security"):p("unknown")})},[v]),so(()=>rd.subscribe(S=>{S.session?f("entered"):d!=="unsupported"&&f("exited")}),[d]);const b=L.useCallback(async S=>{s==null||s(S);try{jLe(v,{sessionInit:n,enterOnly:r,exitOnly:i})}catch(w){const E=y.current;if(E&&w instanceof Error)E(w);else throw w}},[s,v,n,r,i,y]);return L.createElement("button",{...l,ref:c,onClick:d==="unsupported"?s:b},(u=typeof a=="function"?a(d):a)!=null?u:x)}),uW={position:"absolute",bottom:"24px",left:"50%",transform:"translateX(-50%)",padding:"12px 24px",border:"1px solid white",borderRadius:"4px",background:"rgba(0, 0, 0, 0.1)",color:"white",font:"normal 0.8125rem sans-serif",outline:"none",zIndex:99999,cursor:"pointer"},KLe=L.forwardRef(({style:t=uW,sessionInit:e={domOverlay:typeof document<"u"?{root:document.body}:void 0,optionalFeatures:["hit-test","dom-overlay","dom-overlay-for-handheld-ar"]},children:n,...r},i)=>L.createElement(cW,{...r,ref:i,mode:"AR",style:t,sessionInit:e},n));L.forwardRef(({style:t=uW,sessionInit:e={optionalFeatures:["local-floor","bounded-floor","hand-tracking","layers"]},children:n,...r},i)=>L.createElement(cW,{...r,ref:i,mode:"VR",style:t,sessionInit:e},n));function Di(t=n=>n,e){const n=L.useContext(lW);if(!n)throw new Error("useXR must be used within an <XR /> component!");return n(t,e)}function JB(t,e){if(e===l5)return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),t;if(e===z1||e===AR){let n=t.getIndex();if(n===null){const o=[],a=t.getAttribute("position");if(a!==void 0){for(let l=0;l<a.count;l++)o.push(l);t.setIndex(o),n=t.getIndex()}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),t}const r=n.count-2,i=[];if(n)if(e===z1)for(let o=1;o<=r;o++)i.push(n.getX(0)),i.push(n.getX(o)),i.push(n.getX(o+1));else for(let o=0;o<r;o++)o%2===0?(i.push(n.getX(o)),i.push(n.getX(o+1)),i.push(n.getX(o+2))):(i.push(n.getX(o+2)),i.push(n.getX(o+1)),i.push(n.getX(o)));i.length/3!==r&&console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");const s=t.clone();return s.setIndex(i),s.clearGroups(),s}else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",e),t}const qLe=parseInt(C0.replace(/\D+/g,""));var JLe=Object.defineProperty,YLe=(t,e,n)=>e in t?JLe(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n,Mt=(t,e,n)=>(YLe(t,typeof e!="symbol"?e+"":e,n),n);const Ex=new Nd,YB=new Ya,QLe=Math.cos(70*(Math.PI/180)),QB=(t,e)=>(t%e+e)%e;let ZLe=class extends ka{constructor(e,n){super(),Mt(this,"object"),Mt(this,"domElement"),Mt(this,"enabled",!0),Mt(this,"target",new K),Mt(this,"minDistance",0),Mt(this,"maxDistance",1/0),Mt(this,"minZoom",0),Mt(this,"maxZoom",1/0),Mt(this,"minPolarAngle",0),Mt(this,"maxPolarAngle",Math.PI),Mt(this,"minAzimuthAngle",-1/0),Mt(this,"maxAzimuthAngle",1/0),Mt(this,"enableDamping",!1),Mt(this,"dampingFactor",.05),Mt(this,"enableZoom",!0),Mt(this,"zoomSpeed",1),Mt(this,"enableRotate",!0),Mt(this,"rotateSpeed",1),Mt(this,"enablePan",!0),Mt(this,"panSpeed",1),Mt(this,"screenSpacePanning",!0),Mt(this,"keyPanSpeed",7),Mt(this,"zoomToCursor",!1),Mt(this,"autoRotate",!1),Mt(this,"autoRotateSpeed",2),Mt(this,"reverseOrbit",!1),Mt(this,"reverseHorizontalOrbit",!1),Mt(this,"reverseVerticalOrbit",!1),Mt(this,"keys",{LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"}),Mt(this,"mouseButtons",{LEFT:bu.ROTATE,MIDDLE:bu.DOLLY,RIGHT:bu.PAN}),Mt(this,"touches",{ONE:Su.ROTATE,TWO:Su.DOLLY_PAN}),Mt(this,"target0"),Mt(this,"position0"),Mt(this,"zoom0"),Mt(this,"_domElementKeyEvents",null),Mt(this,"getPolarAngle"),Mt(this,"getAzimuthalAngle"),Mt(this,"setPolarAngle"),Mt(this,"setAzimuthalAngle"),Mt(this,"getDistance"),Mt(this,"listenToKeyEvents"),Mt(this,"stopListenToKeyEvents"),Mt(this,"saveState"),Mt(this,"reset"),Mt(this,"update"),Mt(this,"connect"),Mt(this,"dispose"),this.object=e,this.domElement=n,this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=()=>u.phi,this.getAzimuthalAngle=()=>u.theta,this.setPolarAngle=ie=>{let _e=QB(ie,2*Math.PI),J=u.phi;J<0&&(J+=2*Math.PI),_e<0&&(_e+=2*Math.PI);let De=Math.abs(_e-J);2*Math.PI-De<De&&(_e<J?_e+=2*Math.PI:J+=2*Math.PI),d.phi=_e-J,r.update()},this.setAzimuthalAngle=ie=>{let _e=QB(ie,2*Math.PI),J=u.theta;J<0&&(J+=2*Math.PI),_e<0&&(_e+=2*Math.PI);let De=Math.abs(_e-J);2*Math.PI-De<De&&(_e<J?_e+=2*Math.PI:J+=2*Math.PI),d.theta=_e-J,r.update()},this.getDistance=()=>r.object.position.distanceTo(r.target),this.listenToKeyEvents=ie=>{ie.addEventListener("keydown",Fe),this._domElementKeyEvents=ie},this.stopListenToKeyEvents=()=>{this._domElementKeyEvents.removeEventListener("keydown",Fe),this._domElementKeyEvents=null},this.saveState=()=>{r.target0.copy(r.target),r.position0.copy(r.object.position),r.zoom0=r.object.zoom},this.reset=()=>{r.target.copy(r.target0),r.object.position.copy(r.position0),r.object.zoom=r.zoom0,r.object.updateProjectionMatrix(),r.dispatchEvent(i),r.update(),l=a.NONE},this.update=(()=>{const ie=new K,_e=new K(0,1,0),J=new Hr().setFromUnitVectors(e.up,_e),De=J.clone().invert(),Be=new K,ut=new Hr,pt=2*Math.PI;return function(){const hn=r.object.position;J.setFromUnitVectors(e.up,_e),De.copy(J).invert(),ie.copy(hn).sub(r.target),ie.applyQuaternion(J),u.setFromVector3(ie),r.autoRotate&&l===a.NONE&&U(B()),r.enableDamping?(u.theta+=d.theta*r.dampingFactor,u.phi+=d.phi*r.dampingFactor):(u.theta+=d.theta,u.phi+=d.phi);let jt=r.minAzimuthAngle,_n=r.maxAzimuthAngle;isFinite(jt)&&isFinite(_n)&&(jt<-Math.PI?jt+=pt:jt>Math.PI&&(jt-=pt),_n<-Math.PI?_n+=pt:_n>Math.PI&&(_n-=pt),jt<=_n?u.theta=Math.max(jt,Math.min(_n,u.theta)):u.theta=u.theta>(jt+_n)/2?Math.max(jt,u.theta):Math.min(_n,u.theta)),u.phi=Math.max(r.minPolarAngle,Math.min(r.maxPolarAngle,u.phi)),u.makeSafe(),r.enableDamping===!0?r.target.addScaledVector(h,r.dampingFactor):r.target.add(h),r.zoomToCursor&&N||r.object.isOrthographicCamera?u.radius=he(u.radius):u.radius=he(u.radius*f),ie.setFromSpherical(u),ie.applyQuaternion(De),hn.copy(r.target).add(ie),r.object.matrixAutoUpdate||r.object.updateMatrix(),r.object.lookAt(r.target),r.enableDamping===!0?(d.theta*=1-r.dampingFactor,d.phi*=1-r.dampingFactor,h.multiplyScalar(1-r.dampingFactor)):(d.set(0,0,0),h.set(0,0,0));let Jt=!1;if(r.zoomToCursor&&N){let Cr=null;if(r.object instanceof Hn&&r.object.isPerspectiveCamera){const Er=ie.length();Cr=he(Er*f);const zi=Er-Cr;r.object.position.addScaledVector(T,zi),r.object.updateMatrixWorld()}else if(r.object.isOrthographicCamera){const Er=new K(I.x,I.y,0);Er.unproject(r.object),r.object.zoom=Math.max(r.minZoom,Math.min(r.maxZoom,r.object.zoom/f)),r.object.updateProjectionMatrix(),Jt=!0;const zi=new K(I.x,I.y,0);zi.unproject(r.object),r.object.position.sub(zi).add(Er),r.object.updateMatrixWorld(),Cr=ie.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),r.zoomToCursor=!1;Cr!==null&&(r.screenSpacePanning?r.target.set(0,0,-1).transformDirection(r.object.matrix).multiplyScalar(Cr).add(r.object.position):(Ex.origin.copy(r.object.position),Ex.direction.set(0,0,-1).transformDirection(r.object.matrix),Math.abs(r.object.up.dot(Ex.direction))<QLe?e.lookAt(r.target):(YB.setFromNormalAndCoplanarPoint(r.object.up,r.target),Ex.intersectPlane(YB,r.target))))}else r.object instanceof ba&&r.object.isOrthographicCamera&&(Jt=f!==1,Jt&&(r.object.zoom=Math.max(r.minZoom,Math.min(r.maxZoom,r.object.zoom/f)),r.object.updateProjectionMatrix()));return f=1,N=!1,Jt||Be.distanceToSquared(r.object.position)>c||8*(1-ut.dot(r.object.quaternion))>c?(r.dispatchEvent(i),Be.copy(r.object.position),ut.copy(r.object.quaternion),Jt=!1,!0):!1}})(),this.connect=ie=>{ie===document&&console.error('THREE.OrbitControls: "document" should not be used as the target "domElement". Please use "renderer.domElement" instead.'),r.domElement=ie,r.domElement.style.touchAction="none",r.domElement.addEventListener("contextmenu",ot),r.domElement.addEventListener("pointerdown",ve),r.domElement.addEventListener("pointercancel",Ae),r.domElement.addEventListener("wheel",Ue)},this.dispose=()=>{var ie,_e,J,De,Be,ut;(ie=r.domElement)==null||ie.removeEventListener("contextmenu",ot),(_e=r.domElement)==null||_e.removeEventListener("pointerdown",ve),(J=r.domElement)==null||J.removeEventListener("pointercancel",Ae),(De=r.domElement)==null||De.removeEventListener("wheel",Ue),(Be=r.domElement)==null||Be.ownerDocument.removeEventListener("pointermove",Ne),(ut=r.domElement)==null||ut.ownerDocument.removeEventListener("pointerup",nt),r._domElementKeyEvents!==null&&r._domElementKeyEvents.removeEventListener("keydown",Fe)};const r=this,i={type:"change"},s={type:"start"},o={type:"end"},a={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_PAN:4,TOUCH_DOLLY_PAN:5,TOUCH_DOLLY_ROTATE:6};let l=a.NONE;const c=1e-6,u=new z2,d=new z2;let f=1;const h=new K,p=new Re,x=new Re,v=new Re,y=new Re,b=new Re,S=new Re,w=new Re,E=new Re,A=new Re,T=new K,I=new Re;let N=!1;const M=[],P={};function B(){return 2*Math.PI/60/60*r.autoRotateSpeed}function F(){return Math.pow(.95,r.zoomSpeed)}function U(ie){r.reverseOrbit||r.reverseHorizontalOrbit?d.theta+=ie:d.theta-=ie}function j(ie){r.reverseOrbit||r.reverseVerticalOrbit?d.phi+=ie:d.phi-=ie}const Z=(()=>{const ie=new K;return function(J,De){ie.setFromMatrixColumn(De,0),ie.multiplyScalar(-J),h.add(ie)}})(),ne=(()=>{const ie=new K;return function(J,De){r.screenSpacePanning===!0?ie.setFromMatrixColumn(De,1):(ie.setFromMatrixColumn(De,0),ie.crossVectors(r.object.up,ie)),ie.multiplyScalar(J),h.add(ie)}})(),O=(()=>{const ie=new K;return function(J,De){const Be=r.domElement;if(Be&&r.object instanceof Hn&&r.object.isPerspectiveCamera){const ut=r.object.position;ie.copy(ut).sub(r.target);let pt=ie.length();pt*=Math.tan(r.object.fov/2*Math.PI/180),Z(2*J*pt/Be.clientHeight,r.object.matrix),ne(2*De*pt/Be.clientHeight,r.object.matrix)}else Be&&r.object instanceof ba&&r.object.isOrthographicCamera?(Z(J*(r.object.right-r.object.left)/r.object.zoom/Be.clientWidth,r.object.matrix),ne(De*(r.object.top-r.object.bottom)/r.object.zoom/Be.clientHeight,r.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),r.enablePan=!1)}})();function G(ie){r.object instanceof Hn&&r.object.isPerspectiveCamera||r.object instanceof ba&&r.object.isOrthographicCamera?f/=ie:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),r.enableZoom=!1)}function q(ie){r.object instanceof Hn&&r.object.isPerspectiveCamera||r.object instanceof ba&&r.object.isOrthographicCamera?f*=ie:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),r.enableZoom=!1)}function se(ie){if(!r.zoomToCursor||!r.domElement)return;N=!0;const _e=r.domElement.getBoundingClientRect(),J=ie.clientX-_e.left,De=ie.clientY-_e.top,Be=_e.width,ut=_e.height;I.x=J/Be*2-1,I.y=-(De/ut)*2+1,T.set(I.x,I.y,1).unproject(r.object).sub(r.object.position).normalize()}function he(ie){return Math.max(r.minDistance,Math.min(r.maxDistance,ie))}function ke(ie){p.set(ie.clientX,ie.clientY)}function re(ie){se(ie),w.set(ie.clientX,ie.clientY)}function pe(ie){y.set(ie.clientX,ie.clientY)}function fe(ie){x.set(ie.clientX,ie.clientY),v.subVectors(x,p).multiplyScalar(r.rotateSpeed);const _e=r.domElement;_e&&(U(2*Math.PI*v.x/_e.clientHeight),j(2*Math.PI*v.y/_e.clientHeight)),p.copy(x),r.update()}function Ee(ie){E.set(ie.clientX,ie.clientY),A.subVectors(E,w),A.y>0?G(F()):A.y<0&&q(F()),w.copy(E),r.update()}function We(ie){b.set(ie.clientX,ie.clientY),S.subVectors(b,y).multiplyScalar(r.panSpeed),O(S.x,S.y),y.copy(b),r.update()}function je(ie){se(ie),ie.deltaY<0?q(F()):ie.deltaY>0&&G(F()),r.update()}function Je(ie){let _e=!1;switch(ie.code){case r.keys.UP:O(0,r.keyPanSpeed),_e=!0;break;case r.keys.BOTTOM:O(0,-r.keyPanSpeed),_e=!0;break;case r.keys.LEFT:O(r.keyPanSpeed,0),_e=!0;break;case r.keys.RIGHT:O(-r.keyPanSpeed,0),_e=!0;break}_e&&(ie.preventDefault(),r.update())}function te(){if(M.length==1)p.set(M[0].pageX,M[0].pageY);else{const ie=.5*(M[0].pageX+M[1].pageX),_e=.5*(M[0].pageY+M[1].pageY);p.set(ie,_e)}}function be(){if(M.length==1)y.set(M[0].pageX,M[0].pageY);else{const ie=.5*(M[0].pageX+M[1].pageX),_e=.5*(M[0].pageY+M[1].pageY);y.set(ie,_e)}}function ce(){const ie=M[0].pageX-M[1].pageX,_e=M[0].pageY-M[1].pageY,J=Math.sqrt(ie*ie+_e*_e);w.set(0,J)}function Me(){r.enableZoom&&ce(),r.enablePan&&be()}function Ie(){r.enableZoom&&ce(),r.enableRotate&&te()}function Oe(ie){if(M.length==1)x.set(ie.pageX,ie.pageY);else{const J=_t(ie),De=.5*(ie.pageX+J.x),Be=.5*(ie.pageY+J.y);x.set(De,Be)}v.subVectors(x,p).multiplyScalar(r.rotateSpeed);const _e=r.domElement;_e&&(U(2*Math.PI*v.x/_e.clientHeight),j(2*Math.PI*v.y/_e.clientHeight)),p.copy(x)}function V(ie){if(M.length==1)b.set(ie.pageX,ie.pageY);else{const _e=_t(ie),J=.5*(ie.pageX+_e.x),De=.5*(ie.pageY+_e.y);b.set(J,De)}S.subVectors(b,y).multiplyScalar(r.panSpeed),O(S.x,S.y),y.copy(b)}function $(ie){const _e=_t(ie),J=ie.pageX-_e.x,De=ie.pageY-_e.y,Be=Math.sqrt(J*J+De*De);E.set(0,Be),A.set(0,Math.pow(E.y/w.y,r.zoomSpeed)),G(A.y),w.copy(E)}function ue(ie){r.enableZoom&&$(ie),r.enablePan&&V(ie)}function ye(ie){r.enableZoom&&$(ie),r.enableRotate&&Oe(ie)}function ve(ie){var _e,J;r.enabled!==!1&&(M.length===0&&((_e=r.domElement)==null||_e.ownerDocument.addEventListener("pointermove",Ne),(J=r.domElement)==null||J.ownerDocument.addEventListener("pointerup",nt)),Pt(ie),ie.pointerType==="touch"?$e(ie):st(ie))}function Ne(ie){r.enabled!==!1&&(ie.pointerType==="touch"?Ze(ie):ht(ie))}function nt(ie){var _e,J,De;Ge(ie),M.length===0&&((_e=r.domElement)==null||_e.releasePointerCapture(ie.pointerId),(J=r.domElement)==null||J.ownerDocument.removeEventListener("pointermove",Ne),(De=r.domElement)==null||De.ownerDocument.removeEventListener("pointerup",nt)),r.dispatchEvent(o),l=a.NONE}function Ae(ie){Ge(ie)}function st(ie){let _e;switch(ie.button){case 0:_e=r.mouseButtons.LEFT;break;case 1:_e=r.mouseButtons.MIDDLE;break;case 2:_e=r.mouseButtons.RIGHT;break;default:_e=-1}switch(_e){case bu.DOLLY:if(r.enableZoom===!1)return;re(ie),l=a.DOLLY;break;case bu.ROTATE:if(ie.ctrlKey||ie.metaKey||ie.shiftKey){if(r.enablePan===!1)return;pe(ie),l=a.PAN}else{if(r.enableRotate===!1)return;ke(ie),l=a.ROTATE}break;case bu.PAN:if(ie.ctrlKey||ie.metaKey||ie.shiftKey){if(r.enableRotate===!1)return;ke(ie),l=a.ROTATE}else{if(r.enablePan===!1)return;pe(ie),l=a.PAN}break;default:l=a.NONE}l!==a.NONE&&r.dispatchEvent(s)}function ht(ie){if(r.enabled!==!1)switch(l){case a.ROTATE:if(r.enableRotate===!1)return;fe(ie);break;case a.DOLLY:if(r.enableZoom===!1)return;Ee(ie);break;case a.PAN:if(r.enablePan===!1)return;We(ie);break}}function Ue(ie){r.enabled===!1||r.enableZoom===!1||l!==a.NONE&&l!==a.ROTATE||(ie.preventDefault(),r.dispatchEvent(s),je(ie),r.dispatchEvent(o))}function Fe(ie){r.enabled===!1||r.enablePan===!1||Je(ie)}function $e(ie){switch(yt(ie),M.length){case 1:switch(r.touches.ONE){case Su.ROTATE:if(r.enableRotate===!1)return;te(),l=a.TOUCH_ROTATE;break;case Su.PAN:if(r.enablePan===!1)return;be(),l=a.TOUCH_PAN;break;default:l=a.NONE}break;case 2:switch(r.touches.TWO){case Su.DOLLY_PAN:if(r.enableZoom===!1&&r.enablePan===!1)return;Me(),l=a.TOUCH_DOLLY_PAN;break;case Su.DOLLY_ROTATE:if(r.enableZoom===!1&&r.enableRotate===!1)return;Ie(),l=a.TOUCH_DOLLY_ROTATE;break;default:l=a.NONE}break;default:l=a.NONE}l!==a.NONE&&r.dispatchEvent(s)}function Ze(ie){switch(yt(ie),l){case a.TOUCH_ROTATE:if(r.enableRotate===!1)return;Oe(ie),r.update();break;case a.TOUCH_PAN:if(r.enablePan===!1)return;V(ie),r.update();break;case a.TOUCH_DOLLY_PAN:if(r.enableZoom===!1&&r.enablePan===!1)return;ue(ie),r.update();break;case a.TOUCH_DOLLY_ROTATE:if(r.enableZoom===!1&&r.enableRotate===!1)return;ye(ie),r.update();break;default:l=a.NONE}}function ot(ie){r.enabled!==!1&&ie.preventDefault()}function Pt(ie){M.push(ie)}function Ge(ie){delete P[ie.pointerId];for(let _e=0;_e<M.length;_e++)if(M[_e].pointerId==ie.pointerId){M.splice(_e,1);return}}function yt(ie){let _e=P[ie.pointerId];_e===void 0&&(_e=new Re,P[ie.pointerId]=_e),_e.set(ie.pageX,ie.pageY)}function _t(ie){const _e=ie.pointerId===M[0].pointerId?M[1]:M[0];return P[_e.pointerId]}n!==void 0&&this.connect(n),this.update()}};class cN extends _i{constructor(e){super(e),this.dracoLoader=null,this.ktx2Loader=null,this.meshoptDecoder=null,this.pluginCallbacks=[],this.register(function(n){return new iBe(n)}),this.register(function(n){return new fBe(n)}),this.register(function(n){return new hBe(n)}),this.register(function(n){return new pBe(n)}),this.register(function(n){return new oBe(n)}),this.register(function(n){return new aBe(n)}),this.register(function(n){return new lBe(n)}),this.register(function(n){return new cBe(n)}),this.register(function(n){return new rBe(n)}),this.register(function(n){return new uBe(n)}),this.register(function(n){return new sBe(n)}),this.register(function(n){return new dBe(n)}),this.register(function(n){return new tBe(n)}),this.register(function(n){return new mBe(n)}),this.register(function(n){return new gBe(n)})}load(e,n,r,i){const s=this;let o;this.resourcePath!==""?o=this.resourcePath:this.path!==""?o=this.path:o=Ta.extractUrlBase(e),this.manager.itemStart(e);const a=function(c){i?i(c):console.error(c),s.manager.itemError(e),s.manager.itemEnd(e)},l=new Ns(this.manager);l.setPath(this.path),l.setResponseType("arraybuffer"),l.setRequestHeader(this.requestHeader),l.setWithCredentials(this.withCredentials),l.load(e,function(c){try{s.parse(c,o,function(u){n(u),s.manager.itemEnd(e)},a)}catch(u){a(u)}},r,a)}setDRACOLoader(e){return this.dracoLoader=e,this}setDDSLoader(){throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')}setKTX2Loader(e){return this.ktx2Loader=e,this}setMeshoptDecoder(e){return this.meshoptDecoder=e,this}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}parse(e,n,r,i){let s;const o={},a={};if(typeof e=="string")s=JSON.parse(e);else if(e instanceof ArrayBuffer)if(Ta.decodeText(new Uint8Array(e.slice(0,4)))===dW){try{o[Kt.KHR_BINARY_GLTF]=new yBe(e)}catch(u){i&&i(u);return}s=JSON.parse(o[Kt.KHR_BINARY_GLTF].content)}else s=JSON.parse(Ta.decodeText(new Uint8Array(e)));else s=e;if(s.asset===void 0||s.asset.version[0]<2){i&&i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));return}const l=new IBe(s,{path:n||this.resourcePath||"",crossOrigin:this.crossOrigin,requestHeader:this.requestHeader,manager:this.manager,ktx2Loader:this.ktx2Loader,meshoptDecoder:this.meshoptDecoder});l.fileLoader.setRequestHeader(this.requestHeader);for(let c=0;c<this.pluginCallbacks.length;c++){const u=this.pluginCallbacks[c](l);a[u.name]=u,o[u.name]=!0}if(s.extensionsUsed)for(let c=0;c<s.extensionsUsed.length;++c){const u=s.extensionsUsed[c],d=s.extensionsRequired||[];switch(u){case Kt.KHR_MATERIALS_UNLIT:o[u]=new nBe;break;case Kt.KHR_DRACO_MESH_COMPRESSION:o[u]=new vBe(s,this.dracoLoader);break;case Kt.KHR_TEXTURE_TRANSFORM:o[u]=new xBe;break;case Kt.KHR_MESH_QUANTIZATION:o[u]=new bBe;break;default:d.indexOf(u)>=0&&a[u]===void 0&&console.warn('THREE.GLTFLoader: Unknown extension "'+u+'".')}}l.setExtensions(o),l.setPlugins(a),l.parse(r,i)}parseAsync(e,n){const r=this;return new Promise(function(i,s){r.parse(e,n,i,s)})}}function eBe(){let t={};return{get:function(e){return t[e]},add:function(e,n){t[e]=n},remove:function(e){delete t[e]},removeAll:function(){t={}}}}const Kt={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_IRIDESCENCE:"KHR_materials_iridescence",KHR_MATERIALS_ANISOTROPY:"KHR_materials_anisotropy",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",KHR_MATERIALS_EMISSIVE_STRENGTH:"KHR_materials_emissive_strength",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_TEXTURE_AVIF:"EXT_texture_avif",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression",EXT_MESH_GPU_INSTANCING:"EXT_mesh_gpu_instancing"};class tBe{constructor(e){this.parser=e,this.name=Kt.KHR_LIGHTS_PUNCTUAL,this.cache={refs:{},uses:{}}}_markDefs(){const e=this.parser,n=this.parser.json.nodes||[];for(let r=0,i=n.length;r<i;r++){const s=n[r];s.extensions&&s.extensions[this.name]&&s.extensions[this.name].light!==void 0&&e._addNodeRef(this.cache,s.extensions[this.name].light)}}_loadLight(e){const n=this.parser,r="light:"+e;let i=n.cache.get(r);if(i)return i;const s=n.json,l=((s.extensions&&s.extensions[this.name]||{}).lights||[])[e];let c;const u=new Qe(16777215);l.color!==void 0&&u.fromArray(l.color);const d=l.range!==void 0?l.range:0;switch(l.type){case"directional":c=new nI(u),c.target.position.set(0,0,-1),c.add(c.target);break;case"point":c=new tI(u),c.distance=d;break;case"spot":c=new eI(u),c.distance=d,l.spot=l.spot||{},l.spot.innerConeAngle=l.spot.innerConeAngle!==void 0?l.spot.innerConeAngle:0,l.spot.outerConeAngle=l.spot.outerConeAngle!==void 0?l.spot.outerConeAngle:Math.PI/4,c.angle=l.spot.outerConeAngle,c.penumbra=1-l.spot.innerConeAngle/l.spot.outerConeAngle,c.target.position.set(0,0,-1),c.add(c.target);break;default:throw new Error("THREE.GLTFLoader: Unexpected light type: "+l.type)}return c.position.set(0,0,0),c.decay=2,nc(c,l),l.intensity!==void 0&&(c.intensity=l.intensity),c.name=n.createUniqueName(l.name||"light_"+e),i=Promise.resolve(c),n.cache.add(r,i),i}getDependency(e,n){if(e==="light")return this._loadLight(n)}createNodeAttachment(e){const n=this,r=this.parser,s=r.json.nodes[e],a=(s.extensions&&s.extensions[this.name]||{}).light;return a===void 0?null:this._loadLight(a).then(function(l){return r._getNodeRef(n.cache,a,l)})}}class nBe{constructor(){this.name=Kt.KHR_MATERIALS_UNLIT}getMaterialType(){return Qi}extendParams(e,n,r){const i=[];e.color=new Qe(1,1,1),e.opacity=1;const s=n.pbrMetallicRoughness;if(s){if(Array.isArray(s.baseColorFactor)){const o=s.baseColorFactor;e.color.fromArray(o),e.opacity=o[3]}s.baseColorTexture!==void 0&&i.push(r.assignTexture(e,"map",s.baseColorTexture,3001))}return Promise.all(i)}}class rBe{constructor(e){this.parser=e,this.name=Kt.KHR_MATERIALS_EMISSIVE_STRENGTH}extendMaterialParams(e,n){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name].emissiveStrength;return s!==void 0&&(n.emissiveIntensity=s),Promise.resolve()}}class iBe{constructor(e){this.parser=e,this.name=Kt.KHR_MATERIALS_CLEARCOAT}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Da}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];if(o.clearcoatFactor!==void 0&&(n.clearcoat=o.clearcoatFactor),o.clearcoatTexture!==void 0&&s.push(r.assignTexture(n,"clearcoatMap",o.clearcoatTexture)),o.clearcoatRoughnessFactor!==void 0&&(n.clearcoatRoughness=o.clearcoatRoughnessFactor),o.clearcoatRoughnessTexture!==void 0&&s.push(r.assignTexture(n,"clearcoatRoughnessMap",o.clearcoatRoughnessTexture)),o.clearcoatNormalTexture!==void 0&&(s.push(r.assignTexture(n,"clearcoatNormalMap",o.clearcoatNormalTexture)),o.clearcoatNormalTexture.scale!==void 0)){const a=o.clearcoatNormalTexture.scale;n.clearcoatNormalScale=new Re(a,a)}return Promise.all(s)}}class sBe{constructor(e){this.parser=e,this.name=Kt.KHR_MATERIALS_IRIDESCENCE}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Da}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];return o.iridescenceFactor!==void 0&&(n.iridescence=o.iridescenceFactor),o.iridescenceTexture!==void 0&&s.push(r.assignTexture(n,"iridescenceMap",o.iridescenceTexture)),o.iridescenceIor!==void 0&&(n.iridescenceIOR=o.iridescenceIor),n.iridescenceThicknessRange===void 0&&(n.iridescenceThicknessRange=[100,400]),o.iridescenceThicknessMinimum!==void 0&&(n.iridescenceThicknessRange[0]=o.iridescenceThicknessMinimum),o.iridescenceThicknessMaximum!==void 0&&(n.iridescenceThicknessRange[1]=o.iridescenceThicknessMaximum),o.iridescenceThicknessTexture!==void 0&&s.push(r.assignTexture(n,"iridescenceThicknessMap",o.iridescenceThicknessTexture)),Promise.all(s)}}class oBe{constructor(e){this.parser=e,this.name=Kt.KHR_MATERIALS_SHEEN}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Da}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[];n.sheenColor=new Qe(0,0,0),n.sheenRoughness=0,n.sheen=1;const o=i.extensions[this.name];return o.sheenColorFactor!==void 0&&n.sheenColor.fromArray(o.sheenColorFactor),o.sheenRoughnessFactor!==void 0&&(n.sheenRoughness=o.sheenRoughnessFactor),o.sheenColorTexture!==void 0&&s.push(r.assignTexture(n,"sheenColorMap",o.sheenColorTexture,3001)),o.sheenRoughnessTexture!==void 0&&s.push(r.assignTexture(n,"sheenRoughnessMap",o.sheenRoughnessTexture)),Promise.all(s)}}class aBe{constructor(e){this.parser=e,this.name=Kt.KHR_MATERIALS_TRANSMISSION}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Da}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];return o.transmissionFactor!==void 0&&(n.transmission=o.transmissionFactor),o.transmissionTexture!==void 0&&s.push(r.assignTexture(n,"transmissionMap",o.transmissionTexture)),Promise.all(s)}}class lBe{constructor(e){this.parser=e,this.name=Kt.KHR_MATERIALS_VOLUME}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Da}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];n.thickness=o.thicknessFactor!==void 0?o.thicknessFactor:0,o.thicknessTexture!==void 0&&s.push(r.assignTexture(n,"thicknessMap",o.thicknessTexture)),n.attenuationDistance=o.attenuationDistance||1/0;const a=o.attenuationColor||[1,1,1];return n.attenuationColor=new Qe(a[0],a[1],a[2]),Promise.all(s)}}class cBe{constructor(e){this.parser=e,this.name=Kt.KHR_MATERIALS_IOR}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Da}extendMaterialParams(e,n){const i=this.parser.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=i.extensions[this.name];return n.ior=s.ior!==void 0?s.ior:1.5,Promise.resolve()}}class uBe{constructor(e){this.parser=e,this.name=Kt.KHR_MATERIALS_SPECULAR}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Da}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];n.specularIntensity=o.specularFactor!==void 0?o.specularFactor:1,o.specularTexture!==void 0&&s.push(r.assignTexture(n,"specularIntensityMap",o.specularTexture));const a=o.specularColorFactor||[1,1,1];return n.specularColor=new Qe(a[0],a[1],a[2]),o.specularColorTexture!==void 0&&s.push(r.assignTexture(n,"specularColorMap",o.specularColorTexture,3001)),Promise.all(s)}}class dBe{constructor(e){this.parser=e,this.name=Kt.KHR_MATERIALS_ANISOTROPY}getMaterialType(e){const r=this.parser.json.materials[e];return!r.extensions||!r.extensions[this.name]?null:Da}extendMaterialParams(e,n){const r=this.parser,i=r.json.materials[e];if(!i.extensions||!i.extensions[this.name])return Promise.resolve();const s=[],o=i.extensions[this.name];return o.anisotropyStrength!==void 0&&(n.anisotropy=o.anisotropyStrength),o.anisotropyRotation!==void 0&&(n.anisotropyRotation=o.anisotropyRotation),o.anisotropyTexture!==void 0&&s.push(r.assignTexture(n,"anisotropyMap",o.anisotropyTexture)),Promise.all(s)}}class fBe{constructor(e){this.parser=e,this.name=Kt.KHR_TEXTURE_BASISU}loadTexture(e){const n=this.parser,r=n.json,i=r.textures[e];if(!i.extensions||!i.extensions[this.name])return null;const s=i.extensions[this.name],o=n.options.ktx2Loader;if(!o){if(r.extensionsRequired&&r.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");return null}return n.loadTextureImage(e,s.source,o)}}class hBe{constructor(e){this.parser=e,this.name=Kt.EXT_TEXTURE_WEBP,this.isSupported=null}loadTexture(e){const n=this.name,r=this.parser,i=r.json,s=i.textures[e];if(!s.extensions||!s.extensions[n])return null;const o=s.extensions[n],a=i.images[o.source];let l=r.textureLoader;if(a.uri){const c=r.options.manager.getHandler(a.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return r.loadTextureImage(e,o.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(n)>=0)throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");return r.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const n=new Image;n.src="data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",n.onload=n.onerror=function(){e(n.height===1)}})),this.isSupported}}class pBe{constructor(e){this.parser=e,this.name=Kt.EXT_TEXTURE_AVIF,this.isSupported=null}loadTexture(e){const n=this.name,r=this.parser,i=r.json,s=i.textures[e];if(!s.extensions||!s.extensions[n])return null;const o=s.extensions[n],a=i.images[o.source];let l=r.textureLoader;if(a.uri){const c=r.options.manager.getHandler(a.uri);c!==null&&(l=c)}return this.detectSupport().then(function(c){if(c)return r.loadTextureImage(e,o.source,l);if(i.extensionsRequired&&i.extensionsRequired.indexOf(n)>=0)throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");return r.loadTexture(e)})}detectSupport(){return this.isSupported||(this.isSupported=new Promise(function(e){const n=new Image;n.src="data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",n.onload=n.onerror=function(){e(n.height===1)}})),this.isSupported}}class mBe{constructor(e){this.name=Kt.EXT_MESHOPT_COMPRESSION,this.parser=e}loadBufferView(e){const n=this.parser.json,r=n.bufferViews[e];if(r.extensions&&r.extensions[this.name]){const i=r.extensions[this.name],s=this.parser.getDependency("buffer",i.buffer),o=this.parser.options.meshoptDecoder;if(!o||!o.supported){if(n.extensionsRequired&&n.extensionsRequired.indexOf(this.name)>=0)throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");return null}return s.then(function(a){const l=i.byteOffset||0,c=i.byteLength||0,u=i.count,d=i.byteStride,f=new Uint8Array(a,l,c);return o.decodeGltfBufferAsync?o.decodeGltfBufferAsync(u,d,f,i.mode,i.filter).then(function(h){return h.buffer}):o.ready.then(function(){const h=new ArrayBuffer(u*d);return o.decodeGltfBuffer(new Uint8Array(h),u,d,f,i.mode,i.filter),h})})}else return null}}class gBe{constructor(e){this.name=Kt.EXT_MESH_GPU_INSTANCING,this.parser=e}createNodeMesh(e){const n=this.parser.json,r=n.nodes[e];if(!r.extensions||!r.extensions[this.name]||r.mesh===void 0)return null;const i=n.meshes[r.mesh];for(const c of i.primitives)if(c.mode!==Ys.TRIANGLES&&c.mode!==Ys.TRIANGLE_STRIP&&c.mode!==Ys.TRIANGLE_FAN&&c.mode!==void 0)return null;const o=r.extensions[this.name].attributes,a=[],l={};for(const c in o)a.push(this.parser.getDependency("accessor",o[c]).then(u=>(l[c]=u,l[c])));return a.length<1?null:(a.push(this.parser.createNodeMesh(e)),Promise.all(a).then(c=>{const u=c.pop(),d=u.isGroup?u.children:[u],f=c[0].count,h=[];for(const p of d){const x=new St,v=new K,y=new Hr,b=new K(1,1,1),S=new $R(p.geometry,p.material,f);for(let w=0;w<f;w++)l.TRANSLATION&&v.fromBufferAttribute(l.TRANSLATION,w),l.ROTATION&&y.fromBufferAttribute(l.ROTATION,w),l.SCALE&&b.fromBufferAttribute(l.SCALE,w),S.setMatrixAt(w,x.compose(v,y,b));for(const w in l)w!=="TRANSLATION"&&w!=="ROTATION"&&w!=="SCALE"&&p.geometry.setAttribute(w,l[w]);Zt.prototype.copy.call(S,p),this.parser.assignFinalMaterial(S),h.push(S)}return u.isGroup?(u.clear(),u.add(...h),u):h[0]}))}}const dW="glTF",km=12,ZB={JSON:1313821514,BIN:5130562};class yBe{constructor(e){this.name=Kt.KHR_BINARY_GLTF,this.content=null,this.body=null;const n=new DataView(e,0,km);if(this.header={magic:Ta.decodeText(new Uint8Array(e.slice(0,4))),version:n.getUint32(4,!0),length:n.getUint32(8,!0)},this.header.magic!==dW)throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("THREE.GLTFLoader: Legacy binary file detected.");const r=this.header.length-km,i=new DataView(e,km);let s=0;for(;s<r;){const o=i.getUint32(s,!0);s+=4;const a=i.getUint32(s,!0);if(s+=4,a===ZB.JSON){const l=new Uint8Array(e,km+s,o);this.content=Ta.decodeText(l)}else if(a===ZB.BIN){const l=km+s;this.body=e.slice(l,l+o)}s+=o}if(this.content===null)throw new Error("THREE.GLTFLoader: JSON content not found.")}}class vBe{constructor(e,n){if(!n)throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");this.name=Kt.KHR_DRACO_MESH_COMPRESSION,this.json=e,this.dracoLoader=n,this.dracoLoader.preload()}decodePrimitive(e,n){const r=this.json,i=this.dracoLoader,s=e.extensions[this.name].bufferView,o=e.extensions[this.name].attributes,a={},l={},c={};for(const u in o){const d=BT[u]||u.toLowerCase();a[d]=o[u]}for(const u in e.attributes){const d=BT[u]||u.toLowerCase();if(o[u]!==void 0){const f=r.accessors[e.attributes[u]],h=Th[f.componentType];c[d]=h.name,l[d]=f.normalized===!0}}return n.getDependency("bufferView",s).then(function(u){return new Promise(function(d){i.decodeDracoFile(u,function(f){for(const h in f.attributes){const p=f.attributes[h],x=l[h];x!==void 0&&(p.normalized=x)}d(f)},a,c)})})}}class xBe{constructor(){this.name=Kt.KHR_TEXTURE_TRANSFORM}extendTexture(e,n){return(n.texCoord===void 0||n.texCoord===e.channel)&&n.offset===void 0&&n.rotation===void 0&&n.scale===void 0||(e=e.clone(),n.texCoord!==void 0&&(e.channel=n.texCoord),n.offset!==void 0&&e.offset.fromArray(n.offset),n.rotation!==void 0&&(e.rotation=n.rotation),n.scale!==void 0&&e.repeat.fromArray(n.scale),e.needsUpdate=!0),e}}class bBe{constructor(){this.name=Kt.KHR_MESH_QUANTIZATION}}class fW extends Sp{constructor(e,n,r,i){super(e,n,r,i)}copySampleValue_(e){const n=this.resultBuffer,r=this.sampleValues,i=this.valueSize,s=e*i*3+i;for(let o=0;o!==i;o++)n[o]=r[s+o];return n}interpolate_(e,n,r,i){const s=this.resultBuffer,o=this.sampleValues,a=this.valueSize,l=a*2,c=a*3,u=i-n,d=(r-n)/u,f=d*d,h=f*d,p=e*c,x=p-c,v=-2*h+3*f,y=h-f,b=1-v,S=y-f+d;for(let w=0;w!==a;w++){const E=o[x+w+a],A=o[x+w+l]*u,T=o[p+w+a],I=o[p+w]*u;s[w]=b*E+S*A+v*T+y*I}return s}}const SBe=new Hr;class _Be extends fW{interpolate_(e,n,r,i){const s=super.interpolate_(e,n,r,i);return SBe.fromArray(s).normalize().toArray(s),s}}const Ys={FLOAT:5126,FLOAT_MAT3:35675,FLOAT_MAT4:35676,FLOAT_VEC2:35664,FLOAT_VEC3:35665,FLOAT_VEC4:35666,LINEAR:9729,REPEAT:10497,SAMPLER_2D:35678,POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,TRIANGLE_STRIP:5,TRIANGLE_FAN:6,UNSIGNED_BYTE:5121,UNSIGNED_SHORT:5123},Th={5120:Int8Array,5121:Uint8Array,5122:Int16Array,5123:Uint16Array,5125:Uint32Array,5126:Float32Array},eF={9728:Nr,9729:or,9984:AS,9985:Sh,9986:Du,9987:ao},tF={33071:ws,33648:$h,10497:Tc},UE={SCALAR:1,VEC2:2,VEC3:3,VEC4:4,MAT2:4,MAT3:9,MAT4:16},BT={POSITION:"position",NORMAL:"normal",TANGENT:"tangent",...qLe>=152?{TEXCOORD_0:"uv",TEXCOORD_1:"uv1",TEXCOORD_2:"uv2",TEXCOORD_3:"uv3"}:{TEXCOORD_0:"uv",TEXCOORD_1:"uv2"},COLOR_0:"color",WEIGHTS_0:"skinWeight",JOINTS_0:"skinIndex"},Zl={scale:"scale",translation:"position",rotation:"quaternion",weights:"morphTargetInfluences"},wBe={CUBICSPLINE:void 0,LINEAR:md,STEP:zh},zE={OPAQUE:"OPAQUE",MASK:"MASK",BLEND:"BLEND"};function CBe(t){return t.DefaultMaterial===void 0&&(t.DefaultMaterial=new O0({color:16777215,emissive:0,metalness:1,roughness:1,transparent:!1,depthTest:!0,side:Ia})),t.DefaultMaterial}function mu(t,e,n){for(const r in n.extensions)t[r]===void 0&&(e.userData.gltfExtensions=e.userData.gltfExtensions||{},e.userData.gltfExtensions[r]=n.extensions[r])}function nc(t,e){e.extras!==void 0&&(typeof e.extras=="object"?Object.assign(t.userData,e.extras):console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, "+e.extras))}function EBe(t,e,n){let r=!1,i=!1,s=!1;for(let c=0,u=e.length;c<u;c++){const d=e[c];if(d.POSITION!==void 0&&(r=!0),d.NORMAL!==void 0&&(i=!0),d.COLOR_0!==void 0&&(s=!0),r&&i&&s)break}if(!r&&!i&&!s)return Promise.resolve(t);const o=[],a=[],l=[];for(let c=0,u=e.length;c<u;c++){const d=e[c];if(r){const f=d.POSITION!==void 0?n.getDependency("accessor",d.POSITION):t.attributes.position;o.push(f)}if(i){const f=d.NORMAL!==void 0?n.getDependency("accessor",d.NORMAL):t.attributes.normal;a.push(f)}if(s){const f=d.COLOR_0!==void 0?n.getDependency("accessor",d.COLOR_0):t.attributes.color;l.push(f)}}return Promise.all([Promise.all(o),Promise.all(a),Promise.all(l)]).then(function(c){const u=c[0],d=c[1],f=c[2];return r&&(t.morphAttributes.position=u),i&&(t.morphAttributes.normal=d),s&&(t.morphAttributes.color=f),t.morphTargetsRelative=!0,t})}function ABe(t,e){if(t.updateMorphTargets(),e.weights!==void 0)for(let n=0,r=e.weights.length;n<r;n++)t.morphTargetInfluences[n]=e.weights[n];if(e.extras&&Array.isArray(e.extras.targetNames)){const n=e.extras.targetNames;if(t.morphTargetInfluences.length===n.length){t.morphTargetDictionary={};for(let r=0,i=n.length;r<i;r++)t.morphTargetDictionary[n[r]]=r}else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")}}function TBe(t){let e;const n=t.extensions&&t.extensions[Kt.KHR_DRACO_MESH_COMPRESSION];if(n?e="draco:"+n.bufferView+":"+n.indices+":"+GE(n.attributes):e=t.indices+":"+GE(t.attributes)+":"+t.mode,t.targets!==void 0)for(let r=0,i=t.targets.length;r<i;r++)e+=":"+GE(t.targets[r]);return e}function GE(t){let e="";const n=Object.keys(t).sort();for(let r=0,i=n.length;r<i;r++)e+=n[r]+":"+t[n[r]]+";";return e}function FT(t){switch(t){case Int8Array:return 1/127;case Uint8Array:return 1/255;case Int16Array:return 1/32767;case Uint16Array:return 1/65535;default:throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")}}function MBe(t){return t.search(/\.jpe?g($|\?)/i)>0||t.search(/^data\:image\/jpeg/)===0?"image/jpeg":t.search(/\.webp($|\?)/i)>0||t.search(/^data\:image\/webp/)===0?"image/webp":"image/png"}const RBe=new St;class IBe{constructor(e={},n={}){this.json=e,this.extensions={},this.plugins={},this.options=n,this.cache=new eBe,this.associations=new Map,this.primitiveCache={},this.nodeCache={},this.meshCache={refs:{},uses:{}},this.cameraCache={refs:{},uses:{}},this.lightCache={refs:{},uses:{}},this.sourceCache={},this.textureCache={},this.nodeNamesUsed={};let r=!1,i=!1,s=-1;typeof navigator<"u"&&typeof navigator.userAgent<"u"&&(r=/^((?!chrome|android).)*safari/i.test(navigator.userAgent)===!0,i=navigator.userAgent.indexOf("Firefox")>-1,s=i?navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1]:-1),typeof createImageBitmap>"u"||r||i&&s<98?this.textureLoader=new QR(this.options.manager):this.textureLoader=new x6(this.options.manager),this.textureLoader.setCrossOrigin(this.options.crossOrigin),this.textureLoader.setRequestHeader(this.options.requestHeader),this.fileLoader=new Ns(this.options.manager),this.fileLoader.setResponseType("arraybuffer"),this.options.crossOrigin==="use-credentials"&&this.fileLoader.setWithCredentials(!0)}setExtensions(e){this.extensions=e}setPlugins(e){this.plugins=e}parse(e,n){const r=this,i=this.json,s=this.extensions;this.cache.removeAll(),this.nodeCache={},this._invokeAll(function(o){return o._markDefs&&o._markDefs()}),Promise.all(this._invokeAll(function(o){return o.beforeRoot&&o.beforeRoot()})).then(function(){return Promise.all([r.getDependencies("scene"),r.getDependencies("animation"),r.getDependencies("camera")])}).then(function(o){const a={scene:o[0][i.scene||0],scenes:o[0],animations:o[1],cameras:o[2],asset:i.asset,parser:r,userData:{}};mu(s,a,i),nc(a,i),Promise.all(r._invokeAll(function(l){return l.afterRoot&&l.afterRoot(a)})).then(function(){e(a)})}).catch(n)}_markDefs(){const e=this.json.nodes||[],n=this.json.skins||[],r=this.json.meshes||[];for(let i=0,s=n.length;i<s;i++){const o=n[i].joints;for(let a=0,l=o.length;a<l;a++)e[o[a]].isBone=!0}for(let i=0,s=e.length;i<s;i++){const o=e[i];o.mesh!==void 0&&(this._addNodeRef(this.meshCache,o.mesh),o.skin!==void 0&&(r[o.mesh].isSkinnedMesh=!0)),o.camera!==void 0&&this._addNodeRef(this.cameraCache,o.camera)}}_addNodeRef(e,n){n!==void 0&&(e.refs[n]===void 0&&(e.refs[n]=e.uses[n]=0),e.refs[n]++)}_getNodeRef(e,n,r){if(e.refs[n]<=1)return r;const i=r.clone(),s=(o,a)=>{const l=this.associations.get(o);l!=null&&this.associations.set(a,l);for(const[c,u]of o.children.entries())s(u,a.children[c])};return s(r,i),i.name+="_instance_"+e.uses[n]++,i}_invokeOne(e){const n=Object.values(this.plugins);n.push(this);for(let r=0;r<n.length;r++){const i=e(n[r]);if(i)return i}return null}_invokeAll(e){const n=Object.values(this.plugins);n.unshift(this);const r=[];for(let i=0;i<n.length;i++){const s=e(n[i]);s&&r.push(s)}return r}getDependency(e,n){const r=e+":"+n;let i=this.cache.get(r);if(!i){switch(e){case"scene":i=this.loadScene(n);break;case"node":i=this._invokeOne(function(s){return s.loadNode&&s.loadNode(n)});break;case"mesh":i=this._invokeOne(function(s){return s.loadMesh&&s.loadMesh(n)});break;case"accessor":i=this.loadAccessor(n);break;case"bufferView":i=this._invokeOne(function(s){return s.loadBufferView&&s.loadBufferView(n)});break;case"buffer":i=this.loadBuffer(n);break;case"material":i=this._invokeOne(function(s){return s.loadMaterial&&s.loadMaterial(n)});break;case"texture":i=this._invokeOne(function(s){return s.loadTexture&&s.loadTexture(n)});break;case"skin":i=this.loadSkin(n);break;case"animation":i=this._invokeOne(function(s){return s.loadAnimation&&s.loadAnimation(n)});break;case"camera":i=this.loadCamera(n);break;default:if(i=this._invokeOne(function(s){return s!=this&&s.getDependency&&s.getDependency(e,n)}),!i)throw new Error("Unknown type: "+e);break}this.cache.add(r,i)}return i}getDependencies(e){let n=this.cache.get(e);if(!n){const r=this,i=this.json[e+(e==="mesh"?"es":"s")]||[];n=Promise.all(i.map(function(s,o){return r.getDependency(e,o)})),this.cache.add(e,n)}return n}loadBuffer(e){const n=this.json.buffers[e],r=this.fileLoader;if(n.type&&n.type!=="arraybuffer")throw new Error("THREE.GLTFLoader: "+n.type+" buffer type is not supported.");if(n.uri===void 0&&e===0)return Promise.resolve(this.extensions[Kt.KHR_BINARY_GLTF].body);const i=this.options;return new Promise(function(s,o){r.load(Ta.resolveURL(n.uri,i.path),s,void 0,function(){o(new Error('THREE.GLTFLoader: Failed to load buffer "'+n.uri+'".'))})})}loadBufferView(e){const n=this.json.bufferViews[e];return this.getDependency("buffer",n.buffer).then(function(r){const i=n.byteLength||0,s=n.byteOffset||0;return r.slice(s,s+i)})}loadAccessor(e){const n=this,r=this.json,i=this.json.accessors[e];if(i.bufferView===void 0&&i.sparse===void 0){const o=UE[i.type],a=Th[i.componentType],l=i.normalized===!0,c=new a(i.count*o);return Promise.resolve(new en(c,o,l))}const s=[];return i.bufferView!==void 0?s.push(this.getDependency("bufferView",i.bufferView)):s.push(null),i.sparse!==void 0&&(s.push(this.getDependency("bufferView",i.sparse.indices.bufferView)),s.push(this.getDependency("bufferView",i.sparse.values.bufferView))),Promise.all(s).then(function(o){const a=o[0],l=UE[i.type],c=Th[i.componentType],u=c.BYTES_PER_ELEMENT,d=u*l,f=i.byteOffset||0,h=i.bufferView!==void 0?r.bufferViews[i.bufferView].byteStride:void 0,p=i.normalized===!0;let x,v;if(h&&h!==d){const y=Math.floor(f/h),b="InterleavedBuffer:"+i.bufferView+":"+i.componentType+":"+y+":"+i.count;let S=n.cache.get(b);S||(x=new c(a,y*h,i.count*h/u),S=new I0(x,h/u),n.cache.add(b,S)),v=new Mc(S,l,f%h/u,p)}else a===null?x=new c(i.count*l):x=new c(a,f,i.count*l),v=new en(x,l,p);if(i.sparse!==void 0){const y=UE.SCALAR,b=Th[i.sparse.indices.componentType],S=i.sparse.indices.byteOffset||0,w=i.sparse.values.byteOffset||0,E=new b(o[1],S,i.sparse.count*y),A=new c(o[2],w,i.sparse.count*l);a!==null&&(v=new en(v.array.slice(),v.itemSize,v.normalized));for(let T=0,I=E.length;T<I;T++){const N=E[T];if(v.setX(N,A[T*l]),l>=2&&v.setY(N,A[T*l+1]),l>=3&&v.setZ(N,A[T*l+2]),l>=4&&v.setW(N,A[T*l+3]),l>=5)throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")}}return v})}loadTexture(e){const n=this.json,r=this.options,s=n.textures[e].source,o=n.images[s];let a=this.textureLoader;if(o.uri){const l=r.manager.getHandler(o.uri);l!==null&&(a=l)}return this.loadTextureImage(e,s,a)}loadTextureImage(e,n,r){const i=this,s=this.json,o=s.textures[e],a=s.images[n],l=(a.uri||a.bufferView)+":"+o.sampler;if(this.textureCache[l])return this.textureCache[l];const c=this.loadImageSource(n,r).then(function(u){u.flipY=!1,u.name=o.name||a.name||"",u.name===""&&typeof a.uri=="string"&&a.uri.startsWith("data:image/")===!1&&(u.name=a.uri);const f=(s.samplers||{})[o.sampler]||{};return u.magFilter=eF[f.magFilter]||or,u.minFilter=eF[f.minFilter]||ao,u.wrapS=tF[f.wrapS]||Tc,u.wrapT=tF[f.wrapT]||Tc,i.associations.set(u,{textures:e}),u}).catch(function(){return null});return this.textureCache[l]=c,c}loadImageSource(e,n){const r=this,i=this.json,s=this.options;if(this.sourceCache[e]!==void 0)return this.sourceCache[e].then(d=>d.clone());const o=i.images[e],a=self.URL||self.webkitURL;let l=o.uri||"",c=!1;if(o.bufferView!==void 0)l=r.getDependency("bufferView",o.bufferView).then(function(d){c=!0;const f=new Blob([d],{type:o.mimeType});return l=a.createObjectURL(f),l});else if(o.uri===void 0)throw new Error("THREE.GLTFLoader: Image "+e+" is missing URI and bufferView");const u=Promise.resolve(l).then(function(d){return new Promise(function(f,h){let p=f;n.isImageBitmapLoader===!0&&(p=function(x){const v=new Bn(x);v.needsUpdate=!0,f(v)}),n.load(Ta.resolveURL(d,s.path),p,void 0,h)})}).then(function(d){return c===!0&&a.revokeObjectURL(l),d.userData.mimeType=o.mimeType||MBe(o.uri),d}).catch(function(d){throw console.error("THREE.GLTFLoader: Couldn't load texture",l),d});return this.sourceCache[e]=u,u}assignTexture(e,n,r,i){const s=this;return this.getDependency("texture",r.index).then(function(o){if(!o)return null;if(r.texCoord!==void 0&&r.texCoord>0&&(o=o.clone(),o.channel=r.texCoord),s.extensions[Kt.KHR_TEXTURE_TRANSFORM]){const a=r.extensions!==void 0?r.extensions[Kt.KHR_TEXTURE_TRANSFORM]:void 0;if(a){const l=s.associations.get(o);o=s.extensions[Kt.KHR_TEXTURE_TRANSFORM].extendTexture(o,a),s.associations.set(o,l)}}return i!==void 0&&("colorSpace"in o?o.colorSpace=i===3001?"srgb":"srgb-linear":o.encoding=i),e[n]=o,o})}assignFinalMaterial(e){const n=e.geometry;let r=e.material;const i=n.attributes.tangent===void 0,s=n.attributes.color!==void 0,o=n.attributes.normal===void 0;if(e.isPoints){const a="PointsMaterial:"+r.uuid;let l=this.cache.get(a);l||(l=new DS,wr.prototype.copy.call(l,r),l.color.copy(r.color),l.map=r.map,l.sizeAttenuation=!1,this.cache.add(a,l)),r=l}else if(e.isLine){const a="LineBasicMaterial:"+r.uuid;let l=this.cache.get(a);l||(l=new Si,wr.prototype.copy.call(l,r),l.color.copy(r.color),l.map=r.map,this.cache.add(a,l)),r=l}if(i||s||o){let a="ClonedMaterial:"+r.uuid+":";i&&(a+="derivative-tangents:"),s&&(a+="vertex-colors:"),o&&(a+="flat-shading:");let l=this.cache.get(a);l||(l=r.clone(),s&&(l.vertexColors=!0),o&&(l.flatShading=!0),i&&(l.normalScale&&(l.normalScale.y*=-1),l.clearcoatNormalScale&&(l.clearcoatNormalScale.y*=-1)),this.cache.add(a,l),this.associations.set(l,this.associations.get(r))),r=l}e.material=r}getMaterialType(){return O0}loadMaterial(e){const n=this,r=this.json,i=this.extensions,s=r.materials[e];let o;const a={},l=s.extensions||{},c=[];if(l[Kt.KHR_MATERIALS_UNLIT]){const d=i[Kt.KHR_MATERIALS_UNLIT];o=d.getMaterialType(),c.push(d.extendParams(a,s,n))}else{const d=s.pbrMetallicRoughness||{};if(a.color=new Qe(1,1,1),a.opacity=1,Array.isArray(d.baseColorFactor)){const f=d.baseColorFactor;a.color.fromArray(f),a.opacity=f[3]}d.baseColorTexture!==void 0&&c.push(n.assignTexture(a,"map",d.baseColorTexture,3001)),a.metalness=d.metallicFactor!==void 0?d.metallicFactor:1,a.roughness=d.roughnessFactor!==void 0?d.roughnessFactor:1,d.metallicRoughnessTexture!==void 0&&(c.push(n.assignTexture(a,"metalnessMap",d.metallicRoughnessTexture)),c.push(n.assignTexture(a,"roughnessMap",d.metallicRoughnessTexture))),o=this._invokeOne(function(f){return f.getMaterialType&&f.getMaterialType(e)}),c.push(Promise.all(this._invokeAll(function(f){return f.extendMaterialParams&&f.extendMaterialParams(e,a)})))}s.doubleSided===!0&&(a.side=Uo);const u=s.alphaMode||zE.OPAQUE;if(u===zE.BLEND?(a.transparent=!0,a.depthWrite=!1):(a.transparent=!1,u===zE.MASK&&(a.alphaTest=s.alphaCutoff!==void 0?s.alphaCutoff:.5)),s.normalTexture!==void 0&&o!==Qi&&(c.push(n.assignTexture(a,"normalMap",s.normalTexture)),a.normalScale=new Re(1,1),s.normalTexture.scale!==void 0)){const d=s.normalTexture.scale;a.normalScale.set(d,d)}return s.occlusionTexture!==void 0&&o!==Qi&&(c.push(n.assignTexture(a,"aoMap",s.occlusionTexture)),s.occlusionTexture.strength!==void 0&&(a.aoMapIntensity=s.occlusionTexture.strength)),s.emissiveFactor!==void 0&&o!==Qi&&(a.emissive=new Qe().fromArray(s.emissiveFactor)),s.emissiveTexture!==void 0&&o!==Qi&&c.push(n.assignTexture(a,"emissiveMap",s.emissiveTexture,3001)),Promise.all(c).then(function(){const d=new o(a);return s.name&&(d.name=s.name),nc(d,s),n.associations.set(d,{materials:e}),s.extensions&&mu(i,d,s),d})}createUniqueName(e){const n=Yt.sanitizeNodeName(e||"");return n in this.nodeNamesUsed?n+"_"+ ++this.nodeNamesUsed[n]:(this.nodeNamesUsed[n]=0,n)}loadGeometries(e){const n=this,r=this.extensions,i=this.primitiveCache;function s(a){return r[Kt.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a,n).then(function(l){return nF(l,a,n)})}const o=[];for(let a=0,l=e.length;a<l;a++){const c=e[a],u=TBe(c),d=i[u];if(d)o.push(d.promise);else{let f;c.extensions&&c.extensions[Kt.KHR_DRACO_MESH_COMPRESSION]?f=s(c):f=nF(new Lt,c,n),i[u]={primitive:c,promise:f},o.push(f)}}return Promise.all(o)}loadMesh(e){const n=this,r=this.json,i=this.extensions,s=r.meshes[e],o=s.primitives,a=[];for(let l=0,c=o.length;l<c;l++){const u=o[l].material===void 0?CBe(this.cache):this.getDependency("material",o[l].material);a.push(u)}return a.push(n.loadGeometries(o)),Promise.all(a).then(function(l){const c=l.slice(0,l.length-1),u=l[l.length-1],d=[];for(let h=0,p=u.length;h<p;h++){const x=u[h],v=o[h];let y;const b=c[h];if(v.mode===Ys.TRIANGLES||v.mode===Ys.TRIANGLE_STRIP||v.mode===Ys.TRIANGLE_FAN||v.mode===void 0)y=s.isSkinnedMesh===!0?new FR(x,b):new lr(x,b),y.isSkinnedMesh===!0&&y.normalizeSkinWeights(),v.mode===Ys.TRIANGLE_STRIP?y.geometry=JB(y.geometry,AR):v.mode===Ys.TRIANGLE_FAN&&(y.geometry=JB(y.geometry,z1));else if(v.mode===Ys.LINES)y=new Yo(x,b);else if(v.mode===Ys.LINE_STRIP)y=new bl(x,b);else if(v.mode===Ys.LINE_LOOP)y=new UR(x,b);else if(v.mode===Ys.POINTS)y=new zR(x,b);else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: "+v.mode);Object.keys(y.geometry.morphAttributes).length>0&&ABe(y,s),y.name=n.createUniqueName(s.name||"mesh_"+e),nc(y,s),v.extensions&&mu(i,y,v),n.assignFinalMaterial(y),d.push(y)}for(let h=0,p=d.length;h<p;h++)n.associations.set(d[h],{meshes:e,primitives:h});if(d.length===1)return s.extensions&&mu(i,d[0],s),d[0];const f=new Ho;s.extensions&&mu(i,f,s),n.associations.set(f,{meshes:e});for(let h=0,p=d.length;h<p;h++)f.add(d[h]);return f})}loadCamera(e){let n;const r=this.json.cameras[e],i=r[r.type];if(!i){console.warn("THREE.GLTFLoader: Missing camera parameters.");return}return r.type==="perspective"?n=new Hn(x5.radToDeg(i.yfov),i.aspectRatio||1,i.znear||1,i.zfar||2e6):r.type==="orthographic"&&(n=new ba(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),r.name&&(n.name=this.createUniqueName(r.name)),nc(n,r),Promise.resolve(n)}loadSkin(e){const n=this.json.skins[e],r=[];for(let i=0,s=n.joints.length;i<s;i++)r.push(this._loadNodeShallow(n.joints[i]));return n.inverseBindMatrices!==void 0?r.push(this.getDependency("accessor",n.inverseBindMatrices)):r.push(null),Promise.all(r).then(function(i){const s=i.pop(),o=i,a=[],l=[];for(let c=0,u=o.length;c<u;c++){const d=o[c];if(d){a.push(d);const f=new St;s!==null&&f.fromArray(s.array,c*16),l.push(f)}else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.',n.joints[c])}return new N0(a,l)})}loadAnimation(e){const r=this.json.animations[e],i=r.name?r.name:"animation_"+e,s=[],o=[],a=[],l=[],c=[];for(let u=0,d=r.channels.length;u<d;u++){const f=r.channels[u],h=r.samplers[f.sampler],p=f.target,x=p.node,v=r.parameters!==void 0?r.parameters[h.input]:h.input,y=r.parameters!==void 0?r.parameters[h.output]:h.output;p.node!==void 0&&(s.push(this.getDependency("node",x)),o.push(this.getDependency("accessor",v)),a.push(this.getDependency("accessor",y)),l.push(h),c.push(p))}return Promise.all([Promise.all(s),Promise.all(o),Promise.all(a),Promise.all(l),Promise.all(c)]).then(function(u){const d=u[0],f=u[1],h=u[2],p=u[3],x=u[4],v=[];for(let y=0,b=d.length;y<b;y++){const S=d[y],w=f[y],E=h[y],A=p[y],T=x[y];if(S===void 0)continue;S.updateMatrix();let I;switch(Zl[T.path]){case Zl.weights:I=Wh;break;case Zl.rotation:I=Rc;break;case Zl.position:case Zl.scale:default:I=jh;break}const N=S.name?S.name:S.uuid,M=A.interpolation!==void 0?wBe[A.interpolation]:md,P=[];Zl[T.path]===Zl.weights?S.traverse(function(F){F.morphTargetInfluences&&P.push(F.name?F.name:F.uuid)}):P.push(N);let B=E.array;if(E.normalized){const F=FT(B.constructor),U=new Float32Array(B.length);for(let j=0,Z=B.length;j<Z;j++)U[j]=B[j]*F;B=U}for(let F=0,U=P.length;F<U;F++){const j=new I(P[F]+"."+Zl[T.path],w.array,B,M);A.interpolation==="CUBICSPLINE"&&(j.createInterpolant=function(ne){const O=this instanceof Rc?_Be:fW;return new O(this.times,this.values,this.getValueSize()/3,ne)},j.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline=!0),v.push(j)}}return new Xh(i,void 0,v)})}createNodeMesh(e){const n=this.json,r=this,i=n.nodes[e];return i.mesh===void 0?null:r.getDependency("mesh",i.mesh).then(function(s){const o=r._getNodeRef(r.meshCache,i.mesh,s);return i.weights!==void 0&&o.traverse(function(a){if(a.isMesh)for(let l=0,c=i.weights.length;l<c;l++)a.morphTargetInfluences[l]=i.weights[l]}),o})}loadNode(e){const n=this.json,r=this,i=n.nodes[e],s=r._loadNodeShallow(e),o=[],a=i.children||[];for(let c=0,u=a.length;c<u;c++)o.push(r.getDependency("node",a[c]));const l=i.skin===void 0?Promise.resolve(null):r.getDependency("skin",i.skin);return Promise.all([s,Promise.all(o),l]).then(function(c){const u=c[0],d=c[1],f=c[2];f!==null&&u.traverse(function(h){h.isSkinnedMesh&&h.bind(f,RBe)});for(let h=0,p=d.length;h<p;h++)u.add(d[h]);return u})}_loadNodeShallow(e){const n=this.json,r=this.extensions,i=this;if(this.nodeCache[e]!==void 0)return this.nodeCache[e];const s=n.nodes[e],o=s.name?i.createUniqueName(s.name):"",a=[],l=i._invokeOne(function(c){return c.createNodeMesh&&c.createNodeMesh(e)});return l&&a.push(l),s.camera!==void 0&&a.push(i.getDependency("camera",s.camera).then(function(c){return i._getNodeRef(i.cameraCache,s.camera,c)})),i._invokeAll(function(c){return c.createNodeAttachment&&c.createNodeAttachment(e)}).forEach(function(c){a.push(c)}),this.nodeCache[e]=Promise.all(a).then(function(c){let u;if(s.isBone===!0?u=new kS:c.length>1?u=new Ho:c.length===1?u=c[0]:u=new Zt,u!==c[0])for(let d=0,f=c.length;d<f;d++)u.add(c[d]);if(s.name&&(u.userData.name=s.name,u.name=o),nc(u,s),s.extensions&&mu(r,u,s),s.matrix!==void 0){const d=new St;d.fromArray(s.matrix),u.applyMatrix4(d)}else s.translation!==void 0&&u.position.fromArray(s.translation),s.rotation!==void 0&&u.quaternion.fromArray(s.rotation),s.scale!==void 0&&u.scale.fromArray(s.scale);return i.associations.has(u)||i.associations.set(u,{}),i.associations.get(u).nodes=e,u}),this.nodeCache[e]}loadScene(e){const n=this.extensions,r=this.json.scenes[e],i=this,s=new Ho;r.name&&(s.name=i.createUniqueName(r.name)),nc(s,r),r.extensions&&mu(n,s,r);const o=r.nodes||[],a=[];for(let l=0,c=o.length;l<c;l++)a.push(i.getDependency("node",o[l]));return Promise.all(a).then(function(l){for(let u=0,d=l.length;u<d;u++)s.add(l[u]);const c=u=>{const d=new Map;for(const[f,h]of i.associations)(f instanceof wr||f instanceof Bn)&&d.set(f,h);return u.traverse(f=>{const h=i.associations.get(f);h!=null&&d.set(f,h)}),d};return i.associations=c(s),s})}}function NBe(t,e,n){const r=e.attributes,i=new vi;if(r.POSITION!==void 0){const a=n.json.accessors[r.POSITION],l=a.min,c=a.max;if(l!==void 0&&c!==void 0){if(i.set(new K(l[0],l[1],l[2]),new K(c[0],c[1],c[2])),a.normalized){const u=FT(Th[a.componentType]);i.min.multiplyScalar(u),i.max.multiplyScalar(u)}}else{console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");return}}else return;const s=e.targets;if(s!==void 0){const a=new K,l=new K;for(let c=0,u=s.length;c<u;c++){const d=s[c];if(d.POSITION!==void 0){const f=n.json.accessors[d.POSITION],h=f.min,p=f.max;if(h!==void 0&&p!==void 0){if(l.setX(Math.max(Math.abs(h[0]),Math.abs(p[0]))),l.setY(Math.max(Math.abs(h[1]),Math.abs(p[1]))),l.setZ(Math.max(Math.abs(h[2]),Math.abs(p[2]))),f.normalized){const x=FT(Th[f.componentType]);l.multiplyScalar(x)}a.max(l)}else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")}}i.expandByVector(a)}t.boundingBox=i;const o=new Zr;i.getCenter(o.center),o.radius=i.min.distanceTo(i.max)/2,t.boundingSphere=o}function nF(t,e,n){const r=e.attributes,i=[];function s(o,a){return n.getDependency("accessor",o).then(function(l){t.setAttribute(a,l)})}for(const o in r){const a=BT[o]||o.toLowerCase();a in t.attributes||i.push(s(r[o],a))}if(e.indices!==void 0&&!t.index){const o=n.getDependency("accessor",e.indices).then(function(a){t.setIndex(a)});i.push(o)}return nc(t,e),NBe(t,e,n),Promise.all(i).then(function(){return e.targets!==void 0?EBe(t,e.targets,n):t})}const HE=new WeakMap;class PBe extends _i{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,n,r,i){const s=new Ns(this.manager);s.setPath(this.path),s.setResponseType("arraybuffer"),s.setRequestHeader(this.requestHeader),s.setWithCredentials(this.withCredentials),s.load(e,o=>{const a={attributeIDs:this.defaultAttributeIDs,attributeTypes:this.defaultAttributeTypes,useUniqueIDs:!1};this.decodeGeometry(o,a).then(n).catch(i)},r,i)}decodeDracoFile(e,n,r,i){const s={attributeIDs:r||this.defaultAttributeIDs,attributeTypes:i||this.defaultAttributeTypes,useUniqueIDs:!!r};this.decodeGeometry(e,s).then(n)}decodeGeometry(e,n){for(const l in n.attributeTypes){const c=n.attributeTypes[l];c.BYTES_PER_ELEMENT!==void 0&&(n.attributeTypes[l]=c.name)}const r=JSON.stringify(n);if(HE.has(e)){const l=HE.get(e);if(l.key===r)return l.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let i;const s=this.workerNextTaskID++,o=e.byteLength,a=this._getWorker(s,o).then(l=>(i=l,new Promise((c,u)=>{i._callbacks[s]={resolve:c,reject:u},i.postMessage({type:"decode",id:s,taskConfig:n,buffer:e},[e])}))).then(l=>this._createGeometry(l.geometry));return a.catch(()=>!0).then(()=>{i&&s&&this._releaseTask(i,s)}),HE.set(e,{key:r,promise:a}),a}_createGeometry(e){const n=new Lt;e.index&&n.setIndex(new en(e.index.array,1));for(let r=0;r<e.attributes.length;r++){const i=e.attributes[r],s=i.name,o=i.array,a=i.itemSize;n.setAttribute(s,new en(o,a))}return n}_loadLibrary(e,n){const r=new Ns(this.manager);return r.setPath(this.decoderPath),r.setResponseType(n),r.setWithCredentials(this.withCredentials),new Promise((i,s)=>{r.load(e,i,void 0,s)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",n=[];return e?n.push(this._loadLibrary("draco_decoder.js","text")):(n.push(this._loadLibrary("draco_wasm_wrapper.js","text")),n.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(n).then(r=>{const i=r[0];e||(this.decoderConfig.wasmBinary=r[1]);const s=kBe.toString(),o=["/* draco decoder */",i,"","/* worker */",s.substring(s.indexOf("{")+1,s.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([o]))}),this.decoderPending}_getWorker(e,n){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const i=new Worker(this.workerSourceURL);i._callbacks={},i._taskCosts={},i._taskLoad=0,i.postMessage({type:"init",decoderConfig:this.decoderConfig}),i.onmessage=function(s){const o=s.data;switch(o.type){case"decode":i._callbacks[o.id].resolve(o);break;case"error":i._callbacks[o.id].reject(o);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+o.type+'"')}},this.workerPool.push(i)}else this.workerPool.sort(function(i,s){return i._taskLoad>s._taskLoad?-1:1});const r=this.workerPool[this.workerPool.length-1];return r._taskCosts[e]=n,r._taskLoad+=n,r})}_releaseTask(e,n){e._taskLoad-=e._taskCosts[n],delete e._callbacks[n],delete e._taskCosts[n]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this}}function kBe(){let t,e;onmessage=function(o){const a=o.data;switch(a.type){case"init":t=a.decoderConfig,e=new Promise(function(u){t.onModuleLoaded=function(d){u({draco:d})},DracoDecoderModule(t)});break;case"decode":const l=a.buffer,c=a.taskConfig;e.then(u=>{const d=u.draco,f=new d.Decoder,h=new d.DecoderBuffer;h.Init(new Int8Array(l),l.byteLength);try{const p=n(d,f,h,c),x=p.attributes.map(v=>v.array.buffer);p.index&&x.push(p.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:p},x)}catch(p){console.error(p),self.postMessage({type:"error",id:a.id,error:p.message})}finally{d.destroy(h),d.destroy(f)}});break}};function n(o,a,l,c){const u=c.attributeIDs,d=c.attributeTypes;let f,h;const p=a.GetEncodedGeometryType(l);if(p===o.TRIANGULAR_MESH)f=new o.Mesh,h=a.DecodeBufferToMesh(l,f);else if(p===o.POINT_CLOUD)f=new o.PointCloud,h=a.DecodeBufferToPointCloud(l,f);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!h.ok()||f.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+h.error_msg());const x={index:null,attributes:[]};for(const v in u){const y=self[d[v]];let b,S;if(c.useUniqueIDs)S=u[v],b=a.GetAttributeByUniqueId(f,S);else{if(S=a.GetAttributeId(f,o[u[v]]),S===-1)continue;b=a.GetAttribute(f,S)}x.attributes.push(i(o,a,f,v,y,b))}return p===o.TRIANGULAR_MESH&&(x.index=r(o,a,f)),o.destroy(f),x}function r(o,a,l){const u=l.num_faces()*3,d=u*4,f=o._malloc(d);a.GetTrianglesUInt32Array(l,d,f);const h=new Uint32Array(o.HEAPF32.buffer,f,u).slice();return o._free(f),{array:h,itemSize:1}}function i(o,a,l,c,u,d){const f=d.num_components(),p=l.num_points()*f,x=p*u.BYTES_PER_ELEMENT,v=s(o,u),y=o._malloc(x);a.GetAttributeDataArrayForAllPoints(l,d,v,x,y);const b=new u(o.HEAPF32.buffer,y,p).slice();return o._free(y),{name:c,array:b,itemSize:f}}function s(o,a){switch(a){case Float32Array:return o.DT_FLOAT32;case Int8Array:return o.DT_INT8;case Int16Array:return o.DT_INT16;case Int32Array:return o.DT_INT32;case Uint8Array:return o.DT_UINT8;case Uint16Array:return o.DT_UINT16;case Uint32Array:return o.DT_UINT32}}}let Ax;const VE=()=>{if(Ax)return Ax;const t="B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",e="B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",n=new Uint8Array([0,97,115,109,1,0,0,0,1,4,1,96,0,0,3,3,2,0,0,5,3,1,0,1,12,1,0,10,22,2,12,0,65,0,65,0,65,0,252,10,0,0,11,7,0,65,0,253,15,26,11]),r=new Uint8Array([32,0,65,253,3,1,2,34,4,106,6,5,11,8,7,20,13,33,12,16,128,9,116,64,19,113,127,15,10,21,22,14,255,66,24,54,136,107,18,23,192,26,114,118,132,17,77,101,130,144,27,87,131,44,45,74,156,154,70,167]);if(typeof WebAssembly!="object")return{supported:!1};let i=t;WebAssembly.validate(n)&&(i=e);let s;const o=WebAssembly.instantiate(a(i),{}).then(d=>{s=d.instance,s.exports.__wasm_call_ctors()});function a(d){const f=new Uint8Array(d.length);for(let p=0;p<d.length;++p){const x=d.charCodeAt(p);f[p]=x>96?x-71:x>64?x-65:x>47?x+4:x>46?63:62}let h=0;for(let p=0;p<d.length;++p)f[h++]=f[p]<60?r[f[p]]:(f[p]-60)*64+f[++p];return f.buffer.slice(0,h)}function l(d,f,h,p,x,v){const y=s.exports.sbrk,b=h+3&-4,S=y(b*p),w=y(x.length),E=new Uint8Array(s.exports.memory.buffer);E.set(x,w);const A=d(S,h,p,w,x.length);if(A===0&&v&&v(S,b,p),f.set(E.subarray(S,S+h*p)),y(S-y(0)),A!==0)throw new Error(`Malformed buffer data: ${A}`)}const c={0:"",1:"meshopt_decodeFilterOct",2:"meshopt_decodeFilterQuat",3:"meshopt_decodeFilterExp",NONE:"",OCTAHEDRAL:"meshopt_decodeFilterOct",QUATERNION:"meshopt_decodeFilterQuat",EXPONENTIAL:"meshopt_decodeFilterExp"},u={0:"meshopt_decodeVertexBuffer",1:"meshopt_decodeIndexBuffer",2:"meshopt_decodeIndexSequence",ATTRIBUTES:"meshopt_decodeVertexBuffer",TRIANGLES:"meshopt_decodeIndexBuffer",INDICES:"meshopt_decodeIndexSequence"};return Ax={ready:o,supported:!0,decodeVertexBuffer(d,f,h,p,x){l(s.exports.meshopt_decodeVertexBuffer,d,f,h,p,s.exports[c[x]])},decodeIndexBuffer(d,f,h,p){l(s.exports.meshopt_decodeIndexBuffer,d,f,h,p)},decodeIndexSequence(d,f,h,p){l(s.exports.meshopt_decodeIndexSequence,d,f,h,p)},decodeGltfBuffer(d,f,h,p,x,v){l(s.exports[u[x]],d,f,h,p,s.exports[c[v]])}},Ax};let Tx=null,hW="https://www.gstatic.com/draco/versioned/decoders/1.5.5/";function pW(t,e,n){return r=>{n&&n(r),t&&(Tx||(Tx=new PBe),Tx.setDecoderPath(typeof t=="string"?t:hW),r.setDRACOLoader(Tx)),e&&r.setMeshoptDecoder(typeof VE=="function"?VE():VE)}}function Nl(t,e=!0,n=!0,r){return K0(cN,t,pW(e,n,r))}Nl.preload=(t,e=!0,n=!0,r)=>K0.preload(cN,t,pW(e,n,r));Nl.clear=t=>K0.clear(cN,t);Nl.setDecoderPath=t=>{hW=t};const DBe=L.forwardRef(({makeDefault:t,camera:e,regress:n,domElement:r,enableDamping:i=!0,keyEvents:s=!1,onChange:o,onStart:a,onEnd:l,...c},u)=>{const d=Ki(A=>A.invalidate),f=Ki(A=>A.camera),h=Ki(A=>A.gl),p=Ki(A=>A.events),x=Ki(A=>A.setEvents),v=Ki(A=>A.set),y=Ki(A=>A.get),b=Ki(A=>A.performance),S=e||f,w=r||p.connected||h.domElement,E=L.useMemo(()=>new ZLe(S),[S]);return x_(()=>{E.enabled&&E.update()},-1),L.useEffect(()=>(s&&E.connect(s===!0?w:s),E.connect(w),()=>void E.dispose()),[s,w,n,E,d]),L.useEffect(()=>{const A=N=>{d(),n&&b.regress(),o&&o(N)},T=N=>{a&&a(N)},I=N=>{l&&l(N)};return E.addEventListener("change",A),E.addEventListener("start",T),E.addEventListener("end",I),()=>{E.removeEventListener("start",T),E.removeEventListener("end",I),E.removeEventListener("change",A)}},[o,a,l,E,d,x]),L.useEffect(()=>{if(t){const A=y().controls;return v({controls:E}),()=>v({controls:A})}},[t,E]),L.createElement("primitive",X({ref:u,object:E,enableDamping:i},c))}),OBe=t=>{const e=L.useRef(),{nodes:n,materials:r}=Nl("/models/desk.gltf");return H.jsx("group",{ref:e,...t,dispose:null,children:H.jsxs("group",{scale:1.43,children:[H.jsx("mesh",{geometry:n.Cube007.geometry,material:r.MetalBlack}),H.jsx("mesh",{geometry:n.Cube007_1.geometry,material:r.DeskWood})]})})};Nl.preload("/models/desk.gltf");const LBe=t=>{const e=L.useRef(),{nodes:n,materials:r}=Nl("/models/guitar.gltf");return H.jsxs("group",{ref:e,...t,dispose:null,children:[H.jsx("mesh",{geometry:n.Generic_Les_Paul_Mesh.geometry,material:n.Generic_Les_Paul_Mesh.material}),H.jsx("mesh",{geometry:n.Generic_Les_Paul_Mesh_1.geometry,material:r["Golden Metal"]}),H.jsx("mesh",{geometry:n.Generic_Les_Paul_Mesh_2.geometry,material:r["Fretboard Wood"]}),H.jsx("mesh",{geometry:n.Generic_Les_Paul_Mesh_3.geometry,material:r.Ivory}),H.jsx("mesh",{geometry:n.Generic_Les_Paul_Mesh_4.geometry,material:r.Finish}),H.jsx("mesh",{geometry:n.Generic_Les_Paul_Mesh_5.geometry,material:r["Silver Metal"]}),H.jsx("mesh",{geometry:n.Generic_Les_Paul_Mesh_6.geometry,material:n.Generic_Les_Paul_Mesh_6.material}),H.jsx("mesh",{geometry:n.Generic_Les_Paul_Mesh_7.geometry,material:r.Knobs}),H.jsx("mesh",{geometry:n.Generic_Les_Paul_Mesh_8.geometry,material:r["Pickup Wrap Fabric"]})]})};Nl.preload("/models/guitar.gltf");const BBe=t=>{const e=L.useRef(),{nodes:n,materials:r}=Nl("/models/headphones.gltf");return H.jsx("group",{ref:e,...t,dispose:null,children:H.jsxs("group",{scale:.25,children:[H.jsx("mesh",{geometry:n.Ear_Cup.geometry,material:n.Ear_Cup.material}),H.jsx("mesh",{geometry:n.Cushion.geometry,material:r.Cushion}),H.jsx("mesh",{geometry:n["Mid-"].geometry,material:r["Black-2"]}),H.jsx("mesh",{geometry:n.Seprator001.geometry,material:n.Seprator001.material}),H.jsx("mesh",{geometry:n.Seprator.geometry,material:r.Connector}),H.jsx("mesh",{geometry:n.Cylinder025.geometry,material:n.Cylinder025.material}),H.jsx("mesh",{geometry:n.Cylinder025_1.geometry,material:r.GlowBlue})]})})};Nl.preload("/models/headphones.gltf");const rF=t=>{const{modelType:e}=t;switch(e){case ha.DESK:return H.jsx(OBe,{...t});case ha.GUITAR:return H.jsx(LBe,{...t});case ha.HEADPHONES:return H.jsx(BBe,{...t});default:return null}},FBe=({modelType:t})=>{const e=L.useRef(),[n,r]=L.useState([]),{isPresenting:i}=Di();Ki(({camera:o})=>{i||(o.position.z=3)}),ULe(o=>{o.decompose(e.current.position,e.current.quaternion,e.current.scale),e.current.rotation.set(-Math.PI/2,0,0)});const s=o=>{const a=o.intersection.object.position.clone(),l=Date.now();r([{position:a,id:l}])};return H.jsxs(H.Fragment,{children:[H.jsx(DBe,{}),H.jsx("ambientLight",{}),i&&n.map(({position:o,id:a})=>H.jsx(rF,{position:o,modelType:t},a)),i&&H.jsx(aW,{onSelect:s,children:H.jsxs("mesh",{ref:e,"rotation-x":-Math.PI/2,children:[H.jsx("ringGeometry",{args:[.1,.25,32]}),H.jsx("meshStandardMaterial",{color:"white"})]})}),!i&&H.jsx(rF,{modelType:t})]})},WE=({modelType:t})=>H.jsxs(H.Fragment,{children:[H.jsx(KLe,{sessionInit:{requiredFeatures:["hit-test"]}}),H.jsx(LLe,{children:H.jsx(GLe,{children:H.jsx(FBe,{modelType:t})})})]}),$Be=()=>{const{productId:t,type:e}=A$(),n=pR.find(r=>r.id===Number(t));return H.jsxs(H.Fragment,{children:[e===ha.GLASSES&&H.jsx(UOe,{image:n.images[0].imgPath}),e===ha.DESK&&H.jsx(WE,{modelType:ha.DESK}),e===ha.GUITAR&&H.jsx(WE,{modelType:ha.GUITAR}),e===ha.HEADPHONES&&H.jsx(WE,{modelType:ha.HEADPHONES})]})},UBe=()=>H.jsxs(xq,{children:[H.jsx(Fm,{path:"/",element:H.jsx(rae,{})}),H.jsx(Fm,{path:"products/*",element:H.jsx(mae,{})}),H.jsx(Fm,{path:"/products/:productId",element:H.jsx(Dae,{})}),H.jsx(Fm,{path:"/products/:productId/try/:type",element:H.jsx($Be,{})})]}),zBe=(t,e)=>t.find(r=>r.id===e.id)?t.map(r=>r.id===e.id?{...r,quantity:r.quantity+1}:r):[...t,{...e,quantity:1}],GBe=(t,e)=>{const n=t.find(r=>r.id===e.id);return n.quantity>1?t.map(r=>r.id===n.id?{...r,quantity:r.quantity-1}:r):t.filter(r=>r.id!==n.id)},HBe=(t,e)=>t.filter(n=>n.id!==e.id),VBe=L.createContext({isCartOpen:!1,setIsCartOpen:()=>{},cartItems:[],addItemToCart:()=>{},cartCount:0,removeItemFromCart:()=>{},totalPrice:0,clearItemFromCart:()=>{}}),WBe=({children:t})=>{const[e,n]=L.useState(!1),[r,i]=L.useState([]),[s,o]=L.useState(0),[a,l]=L.useState(0);L.useEffect(()=>{o(0)},[r]),L.useEffect(()=>{l(0)},[r]);const f={isCartOpen:e,setIsCartOpen:n,addItemToCart:h=>{i(zBe(r,h))},cartItems:r,cartCount:s,removeItemFromCart:h=>{i(GBe(r,h))},totalPrice:a,clearItemFromCart:h=>{i(HBe(r,h))}};return H.jsx(VBe.Provider,{value:f,children:t})};var jBe={};jE.createRoot(document.getElementById("root")).render(H.jsx(Go.StrictMode,{children:H.jsx(Aq,{basename:jBe.PUBLIC_URL,children:H.jsx(WBe,{children:H.jsx(UBe,{})})})}));
